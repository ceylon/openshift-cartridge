<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The Ceylon Language</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css">
  <link type='text/css' href='../shared/css/ceylon.css' rel='stylesheet'/>
  <link type='text/css' href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet'/>
  <script src='../shared/css/rainbow.min.js' type='text/javascript'></script>
  <script src='../shared/css/ceylon.js' type='text/javascript'></script>
  <script src='../shared/css/bnf.js' type='text/javascript'></script><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>The Ceylon Language</h1></div><div><h2 class="subtitle">Say more, more clearly</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Gavin</span> <span class="surname">King</span></h3></div></div><div><p class="releaseinfo">Final release draft (1.1)</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#d0e15">Welcome to Ceylon</a></span></dt><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#languageoverview">1.1. Language overview</a></span></dt><dd><dl><dt><span class="section"><a href="#runtimeandplatform">1.1.1. Runtime and platform</a></span></dt></dl></dd><dt><span class="section"><a href="#thetypesystem">1.2. Type system</a></span></dt><dd><dl><dt><span class="section"><a href="#mixininheritance">1.2.1. Mixin inheritance</a></span></dt><dt><span class="section"><a href="#algrebraictypesselftypes">1.2.2. Algebraic types, self types, and type families</a></span></dt><dt><span class="section"><a href="#simplifiedgenerics">1.2.3. Simplified generics</a></span></dt><dt><span class="section"><a href="#unionandintersectiontypes">1.2.4. Union and intersection types</a></span></dt><dt><span class="section"><a href="#typealiasesandtypeinference">1.2.5. Type aliases and type inference</a></span></dt><dt><span class="section"><a href="#metaprogramming">1.2.6. Metaprogramming</a></span></dt></dl></dd><dt><span class="section"><a href="#objectorientedprogramming">1.3. Object-oriented programming</a></span></dt><dd><dl><dt><span class="section"><a href="#initializationandinstantiation">1.3.1. Class initialization and instantiation</a></span></dt><dt><span class="section"><a href="#methodsandattributes">1.3.2. Functions, methods, values, and attributes</a></span></dt><dt><span class="section"><a href="#defaultparameters">1.3.3. Defaulted parameters and variadic parameters</a></span></dt><dt><span class="section"><a href="#firstclassfunctions">1.3.4. First-class functions and higher-order programming</a></span></dt><dt><span class="section"><a href="#namingconventionsandannotations">1.3.5. Naming conventions, annotations, and inline documentation</a></span></dt><dt><span class="section"><a href="#structureddata">1.3.6. Named arguments and tree-like structures</a></span></dt><dt><span class="section"><a href="#modularity">1.3.7. Modularity</a></span></dt></dl></dd><dt><span class="section"><a href="#thelanguagemodule">1.4. Language module</a></span></dt><dd><dl><dt><span class="section"><a href="#operatorsandoperatorpolymorphism">1.4.1. Operators and operator polymorphism</a></span></dt><dt><span class="section"><a href="#numerictypes">1.4.2. Numeric and character types</a></span></dt><dt><span class="section"><a href="#compiletimesafety">1.4.3. Compile-time safety for optional values and type narrowing</a></span></dt><dt><span class="section"><a href="#iterableobjectsandcomprehensions">1.4.4. Iterable objects and comprehensions</a></span></dt><dt><span class="section"><a href="#sequencesandtuples">1.4.5. Sequences and tuples</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#lexical">2. Lexical structure</a></span></dt><dd><dl><dt><span class="section"><a href="#whitespace">2.1. Whitespace</a></span></dt><dt><span class="section"><a href="#comments">2.2. Comments</a></span></dt><dt><span class="section"><a href="#identifiersandkeywords">2.3. Identifiers and keywords</a></span></dt><dt><span class="section"><a href="#literals">2.4. Literals</a></span></dt><dd><dl><dt><span class="section"><a href="#numericliterals">2.4.1. Numeric literals</a></span></dt><dt><span class="section"><a href="#characterliterals">2.4.2. Character literals</a></span></dt><dt><span class="section"><a href="#stringliterals">2.4.3. String literals</a></span></dt></dl></dd><dt><span class="section"><a href="#operatorsanddelimiters">2.5. Operators and delimiters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#typesystem">3. Type system</a></span></dt><dd><dl><dt><span class="section"><a href="#identifiernaming">3.1. Identifier naming</a></span></dt><dt><span class="section"><a href="#type">3.2. Types</a></span></dt><dd><dl><dt><span class="section"><a href="#memberdistinctness">3.2.1. Member distinctness</a></span></dt><dt><span class="section"><a href="#subtyping">3.2.2. Subtyping</a></span></dt><dt><span class="section"><a href="#uniontypes">3.2.3. Union types</a></span></dt><dt><span class="section"><a href="#intersectiontypes">3.2.4. Intersection types</a></span></dt><dt><span class="section"><a href="#bottomtype">3.2.5. The bottom type</a></span></dt><dt><span class="section"><a href="#principaltyping">3.2.6. Principal typing</a></span></dt><dt><span class="section"><a href="#typeexpressions">3.2.7. Type expressions</a></span></dt><dt><span class="section"><a href="#typenameabbreviations">3.2.8. Type abbreviations</a></span></dt><dt><span class="section"><a href="#typeinference">3.2.9. Type inference</a></span></dt><dt><span class="section"><a href="#typealiaselimination">3.2.10. Type alias elimination</a></span></dt></dl></dd><dt><span class="section"><a href="#inheritance">3.3. Inheritance</a></span></dt><dd><dl><dt><span class="section"><a href="#inheritanceandsubtyping">3.3.1. Inheritance and subtyping</a></span></dt><dt><span class="section"><a href="#extendedclass">3.3.2. Extension</a></span></dt><dt><span class="section"><a href="#satisfiedinterfaces">3.3.3. Satisfaction</a></span></dt></dl></dd><dt><span class="section"><a href="#casesandcoverage">3.4. Case enumeration and coverage</a></span></dt><dd><dl><dt><span class="section"><a href="#coverage">3.4.1. Coverage</a></span></dt><dt><span class="section"><a href="#cases">3.4.2. Cases</a></span></dt><dt><span class="section"><a href="#genericenumeratedtypes">3.4.3. Generic enumerated types</a></span></dt><dt><span class="section"><a href="#disjointtypes">3.4.4. Disjoint types</a></span></dt></dl></dd><dt><span class="section"><a href="#generictypeparameters">3.5. Generic type parameters</a></span></dt><dd><dl><dt><span class="section"><a href="#typeparametersandvariance">3.5.1. Type parameters and variance</a></span></dt><dt><span class="section"><a href="#variancevalidation">3.5.2. Variance validation</a></span></dt><dt><span class="section"><a href="#generictypeconstraints">3.5.3. Generic type constraints</a></span></dt></dl></dd><dt><span class="section"><a href="#generictypearguments">3.6. Generic type arguments</a></span></dt><dd><dl><dt><span class="section"><a href="#typeargumentsandconstraints">3.6.1. Type arguments and type constraints</a></span></dt><dt><span class="section"><a href="#producedtypes">3.6.2. Applied types and and variance</a></span></dt><dt><span class="section"><a href="#typeargumentinference">3.6.3. Type argument inference</a></span></dt></dl></dd><dt><span class="section"><a href="#principalinstantiations">3.7. Principal instantiations and polymorphism</a></span></dt><dd><dl><dt><span class="section"><a href="#inheritedinstantiations">3.7.1. Inherited instantiations</a></span></dt><dt><span class="section"><a href="#principalinstantiationinheritance">3.7.2. Principal instantiation inheritance</a></span></dt><dt><span class="section"><a href="#principalinstantiationofasupertype">3.7.3. Principal instantiation of a supertype</a></span></dt><dt><span class="section"><a href="#refinement">3.7.4. Refinement</a></span></dt><dt><span class="section"><a href="#qualifiedtypes">3.7.5. Qualified types</a></span></dt><dt><span class="section"><a href="#realizations">3.7.6. Realizations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#declarations">4. Declarations</a></span></dt><dd><dl><dt><span class="section"><a href="#compilationunitstructure">4.1. Compilation unit structure</a></span></dt><dd><dl><dt><span class="section"><a href="#topleveldeclarations">4.1.1. Toplevel and nested declarations</a></span></dt><dt><span class="section"><a href="#packages">4.1.2. Packages</a></span></dt></dl></dd><dt><span class="section"><a href="#imports">4.2. Imports</a></span></dt><dd><dl><dt><span class="section"><a href="#typeimports">4.2.1. Type imports</a></span></dt><dt><span class="section"><a href="#methodattributeimports">4.2.2. Function and value imports</a></span></dt><dt><span class="section"><a href="#aliasimports">4.2.3. Alias imports</a></span></dt><dt><span class="section"><a href="#wildcardimports">4.2.4. Wildcard imports</a></span></dt><dt><span class="section"><a href="#importedname">4.2.5. Imported name</a></span></dt></dl></dd><dt><span class="section"><a href="#parameters">4.3. Parameters</a></span></dt><dd><dl><dt><span class="section"><a href="#parameterlists">4.3.1. Parameter lists</a></span></dt><dt><span class="section"><a href="#requiredparameters">4.3.2. Required parameters</a></span></dt><dt><span class="section"><a href="#defaultedparameters">4.3.3. Defaulted parameters</a></span></dt><dt><span class="section"><a href="#valueparameters">4.3.4. Value parameters</a></span></dt><dt><span class="section"><a href="#callableparameters">4.3.5. Callable parameters</a></span></dt><dt><span class="section"><a href="#sequencedparameters">4.3.6. Variadic parameters</a></span></dt></dl></dd><dt><span class="section"><a href="#interfaces">4.4. Interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="#interfacebodies">4.4.1. Interface bodies</a></span></dt><dt><span class="section"><a href="#interfaceinheritance">4.4.2. Interface inheritance</a></span></dt><dt><span class="section"><a href="#sealedinterfaces">4.4.3. Sealed interfaces</a></span></dt><dt><span class="section"><a href="#interfaceswithcases">4.4.4. Interfaces with enumerated cases</a></span></dt><dt><span class="section"><a href="#interfacealiases">4.4.5. Interface aliases</a></span></dt><dt><span class="section"><a href="#d0e7181">4.4.6. Dynamic interfaces</a></span></dt></dl></dd><dt><span class="section"><a href="#classes">4.5. Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#callabletypeofclass">4.5.1. Callable type of a class</a></span></dt><dt><span class="section"><a href="#initializersection">4.5.2. Initializer section</a></span></dt><dt><span class="section"><a href="#declarationsection">4.5.3. Declaration section</a></span></dt><dt><span class="section"><a href="#classinheritance">4.5.4. Class inheritance</a></span></dt><dt><span class="section"><a href="#abstractandformalclasses">4.5.5. Abstract, final, sealed, formal, and default classes</a></span></dt><dt><span class="section"><a href="#classrefinement">4.5.6. Member class refinement</a></span></dt><dt><span class="section"><a href="#anonymousclasses">4.5.7. Anonymous classes</a></span></dt><dt><span class="section"><a href="#classeswithcases">4.5.8. Classes with enumerated cases</a></span></dt><dt><span class="section"><a href="#classaliases">4.5.9. Class aliases</a></span></dt></dl></dd><dt><span class="section"><a href="#typealiasedeclarations">4.6. Type aliases</a></span></dt><dt><span class="section"><a href="#functions">4.7. Functions</a></span></dt><dd><dl><dt><span class="section"><a href="#callabletypeoffunction">4.7.1. Callable type of a function</a></span></dt><dt><span class="section"><a href="#functionswithblocks">4.7.2. Functions with blocks</a></span></dt><dt><span class="section"><a href="#functionswithspecifiers">4.7.3. Functions with specifiers</a></span></dt><dt><span class="section"><a href="#returntypeinference">4.7.4. Function return type inference</a></span></dt><dt><span class="section"><a href="#functionforwarddeclaration">4.7.5. Forward declaration of functions</a></span></dt><dt><span class="section"><a href="#multipleparameterlists">4.7.6. Functions with multiple parameter lists</a></span></dt><dt><span class="section"><a href="#formalmethods">4.7.7. Formal and default methods</a></span></dt><dt><span class="section"><a href="#methodrefinement">4.7.8. Method refinement</a></span></dt></dl></dd><dt><span class="section"><a href="#values">4.8. Values</a></span></dt><dd><dl><dt><span class="section"><a href="#references">4.8.1. References</a></span></dt><dt><span class="section"><a href="#getters">4.8.2. Getters</a></span></dt><dt><span class="section"><a href="#setters">4.8.3. Setters</a></span></dt><dt><span class="section"><a href="#valuetypeinference">4.8.4. Value type inference</a></span></dt><dt><span class="section"><a href="#valueforwarddeclaration">4.8.5. Forward declaration of values</a></span></dt><dt><span class="section"><a href="#formalattributes">4.8.6. Formal and default attributes</a></span></dt><dt><span class="section"><a href="#attributerefinement">4.8.7. Attribute refinement</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#statementblocks">5. Statements, blocks, and control structures</a></span></dt><dd><dl><dt><span class="section"><a href="#blockstructure">5.1. Block structure and references</a></span></dt><dd><dl><dt><span class="section"><a href="#declarationnameuniqueness">5.1.1. Declaration name uniqueness</a></span></dt><dt><span class="section"><a href="#scopeofdeclaration">5.1.2. Scope of a declaration</a></span></dt><dt><span class="section"><a href="#visibility">5.1.3. Visibility</a></span></dt><dt><span class="section"><a href="#hiddendeclarations">5.1.4. Hidden declarations</a></span></dt><dt><span class="section"><a href="#referenceabilityofdeclaration">5.1.5. References and block structure</a></span></dt><dt><span class="section"><a href="#typeinferenceandblockstructure">5.1.6. Type inference and block structure</a></span></dt><dt><span class="section"><a href="#unqualifiedreferenceresolution">5.1.7. Unqualified reference resolution</a></span></dt><dt><span class="section"><a href="#qualifiedreferenceresolution">5.1.8. Qualified reference resolution</a></span></dt></dl></dd><dt><span class="section"><a href="#blocksandstatements">5.2. Blocks and statements</a></span></dt><dd><dl><dt><span class="section"><a href="#expressionstatements">5.2.1. Expression statements</a></span></dt><dt><span class="section"><a href="#controldirectives">5.2.2. Control directives</a></span></dt><dt><span class="section"><a href="#specificationstatements">5.2.3. Specification statements</a></span></dt><dt><span class="section"><a href="#definitereturn">5.2.4. Definite return</a></span></dt><dt><span class="section"><a href="#definiteinitialization">5.2.5. Definite initialization</a></span></dt><dt><span class="section"><a href="#definiteuninitialization">5.2.6. Definite uninitialization</a></span></dt></dl></dd><dt><span class="section"><a href="#controlstructures">5.3. Control structures and assertions</a></span></dt><dd><dl><dt><span class="section"><a href="#controlstructurevariables">5.3.1. Control structure variables</a></span></dt><dt><span class="section"><a href="#iterationvariables">5.3.2. Iteration variables</a></span></dt><dt><span class="section"><a href="#controlstructureconditions">5.3.3. Control structure conditions</a></span></dt><dt><span class="section"><a href="#booleanconditions">5.3.4. Boolean conditions</a></span></dt><dt><span class="section"><a href="#assignabilityexistencenonemptinessconditions">5.3.5. Assignability, existence, and nonemptiness conditions</a></span></dt><dt><span class="section"><a href="#ifelse">5.3.6. if/else</a></span></dt><dt><span class="section"><a href="#switchcaseelse">5.3.7. switch/case/else</a></span></dt><dt><span class="section"><a href="#forelse">5.3.8. for/else</a></span></dt><dt><span class="section"><a href="#while">5.3.9. while</a></span></dt><dt><span class="section"><a href="#trycatchfinally">5.3.10. try/catch/finally</a></span></dt><dt><span class="section"><a href="#assertions">5.3.11. Assertions</a></span></dt><dt><span class="section"><a href="#dynamicblocks">5.3.12. Dynamic blocks</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#expressions">6. Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#literalvalues">6.1. Literal values</a></span></dt><dd><dl><dt><span class="section"><a href="#naturalnumber">6.1.1. Integer number literals</a></span></dt><dt><span class="section"><a href="#floatnumber">6.1.2. Floating point number literals</a></span></dt><dt><span class="section"><a href="#character">6.1.3. Character literals</a></span></dt><dt><span class="section"><a href="#string">6.1.4. Character string literals</a></span></dt></dl></dd><dt><span class="section"><a href="#stringtemplates">6.2. String templates</a></span></dt><dt><span class="section"><a href="#selfreferences">6.3. Self references and the current package reference</a></span></dt><dd><dl><dt><span class="section"><a href="#this">6.3.1. this</a></span></dt><dt><span class="section"><a href="#outer">6.3.2. outer</a></span></dt><dt><span class="section"><a href="#super">6.3.3. super</a></span></dt><dt><span class="section"><a href="#thispackage">6.3.4. package</a></span></dt></dl></dd><dt><span class="section"><a href="#anonymousfunctions">6.4. Anonymous functions</a></span></dt><dd><dl><dt><span class="section"><a href="#parametertypeinference">6.4.1. Anonymous function parameter type inference</a></span></dt></dl></dd><dt><span class="section"><a href="#compoundexpressions">6.5. Compound expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#baseexpressions">6.5.1. Base expressions</a></span></dt><dt><span class="section"><a href="#memberexpressions">6.5.2. Member expressions</a></span></dt><dt><span class="section"><a href="#valuereferences">6.5.3. Value references</a></span></dt><dt><span class="section"><a href="#callablereferences">6.5.4. Callable references</a></span></dt><dt><span class="section"><a href="#staticexpressions">6.5.5. Static expressions</a></span></dt><dt><span class="section"><a href="#staticvaluereferences">6.5.6. Static value references</a></span></dt><dt><span class="section"><a href="#staticcallablereferences">6.5.7. Static callable references</a></span></dt></dl></dd><dt><span class="section"><a href="#invocationexpressions">6.6. Invocation expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#directinvocations">6.6.1. Direct invocations</a></span></dt><dt><span class="section"><a href="#defaultarguments">6.6.2. Default arguments</a></span></dt><dt><span class="section"><a href="#tupletypeofarglist">6.6.3. The type of a list of arguments</a></span></dt><dt><span class="section"><a href="#listedarguments">6.6.4. Listed arguments</a></span></dt><dt><span class="section"><a href="#spreadarguments">6.6.5. Spread arguments</a></span></dt><dt><span class="section"><a href="#comprehensions">6.6.6. Comprehensions</a></span></dt><dt><span class="section"><a href="#positionalarguments">6.6.7. Positional argument lists</a></span></dt><dt><span class="section"><a href="#namedarguments">6.6.8. Named argument lists</a></span></dt><dt><span class="section"><a href="#anonymousarguments">6.6.9. Anonymous arguments</a></span></dt><dt><span class="section"><a href="#specifiedarguments">6.6.10. Specified arguments</a></span></dt><dt><span class="section"><a href="#inlinedeclarationarguments">6.6.11. Inline declaration arguments</a></span></dt><dt><span class="section"><a href="#enumeration">6.6.12. Iterable and tuple enumeration</a></span></dt><dt><span class="section"><a href="#dynamicenumerations">6.6.13. Dynamic enumerations</a></span></dt></dl></dd><dt><span class="section"><a href="#miscexpressions">6.7. Conditional expressions and anonymous class expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#inlineconditionalexpressions">6.7.1. Inline conditional expressions</a></span></dt><dt><span class="section"><a href="#letexpressions">6.7.2. Let expressions</a></span></dt><dt><span class="section"><a href="#inlineanonymousclassexpressions">6.7.3. Inline anonymous class expressions</a></span></dt></dl></dd><dt><span class="section"><a href="#operators">6.8. Operators</a></span></dt><dd><dl><dt><span class="section"><a href="#operatorprecedence">6.8.1. Operator precedence</a></span></dt><dt><span class="section"><a href="#operatordefinition">6.8.2. Operator definition</a></span></dt><dt><span class="section"><a href="#basic">6.8.3. Basic invocation and assignment operators</a></span></dt><dt><span class="section"><a href="#equalitycomparison">6.8.4. Equality and comparison operators</a></span></dt><dt><span class="section"><a href="#logical">6.8.5. Logical operators</a></span></dt><dt><span class="section"><a href="#nullvalues">6.8.6. Operators for handling null values</a></span></dt><dt><span class="section"><a href="#listmap">6.8.7. Correspondence, subrange, and stream operators</a></span></dt><dt><span class="section"><a href="#constructors">6.8.8. Operators for creating objects</a></span></dt><dt><span class="section"><a href="#conditionals">6.8.9. Conditional operators</a></span></dt><dt><span class="section"><a href="#arithmetic">6.8.10. Arithmetic operators</a></span></dt><dt><span class="section"><a href="#sets">6.8.11. Set operators</a></span></dt></dl></dd><dt><span class="section"><a href="#metamodelexpressions">6.9. Metamodel expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#typeofametamodelexpression">6.9.1. Type of a metamodel expression</a></span></dt></dl></dd><dt><span class="section"><a href="#referenceexpressions">6.10. Reference expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#declarationreferences">6.10.1. Declaration references</a></span></dt><dt><span class="section"><a href="#packageandmodulereferences">6.10.2. Package and module references</a></span></dt><dt><span class="section"><a href="#typeofareferenceexpression">6.10.3. Type of a reference expression</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#annotations">7. Annotations</a></span></dt><dd><dl><dt><span class="section"><a href="#programelementannotations">7.1. Annotations of program elements</a></span></dt><dd><dl><dt><span class="section"><a href="#annotationlists">7.1.1. Annotation lists</a></span></dt><dt><span class="section"><a href="#annotationargments">7.1.2. Annotation arguments</a></span></dt></dl></dd><dt><span class="section"><a href="#annotationdefinition">7.2. Annotation definition</a></span></dt><dd><dl><dt><span class="section"><a href="#annotationconstructors">7.2.1. Annotation constructors</a></span></dt><dt><span class="section"><a href="#annotationtypes">7.2.2. Annotation types</a></span></dt><dt><span class="section"><a href="#constrainedannotationtypes">7.2.3. Constrained annotation types</a></span></dt></dl></dd><dt><span class="section"><a href="#annotationvalues">7.3. Annotation values</a></span></dt><dt><span class="section"><a href="#languageannotations">7.4. Language annotations</a></span></dt><dd><dl><dt><span class="section"><a href="#declarationmodifiers">7.4.1. Declaration modifiers</a></span></dt><dt><span class="section"><a href="#documentation">7.4.2. Documentation</a></span></dt></dl></dd><dt><span class="section"><a href="#serialization">7.5. Serialization</a></span></dt></dl></dd><dt><span class="chapter"><a href="#execution">8. Execution</a></span></dt><dd><dl><dt><span class="section"><a href="#objectinstancesidentity">8.1. Object instances, identity, and reference passing</a></span></dt><dd><dl><dt><span class="section"><a href="#valuetypeoptimizations">8.1.1. Value type optimizations</a></span></dt><dt><span class="section"><a href="#reification">8.1.2. Type argument reification</a></span></dt></dl></dd><dt><span class="section"><a href="#sequentialexecutionandclosure">8.2. Sequential execution and closure</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e16982">8.2.1. Frames</a></span></dt><dt><span class="section"><a href="#d0e17027">8.2.2. Current instances and current frames</a></span></dt><dt><span class="section"><a href="#currentinstanceofaclassorinterface">8.2.3. Current instance of a class or interface</a></span></dt><dt><span class="section"><a href="#currentframeofablock">8.2.4. Current frame of a block</a></span></dt><dt><span class="section"><a href="#initialization">8.2.5. Initialization</a></span></dt><dt><span class="section"><a href="#classinstanceoptimization">8.2.6. Class instance optimization</a></span></dt><dt><span class="section"><a href="#executionofexpressionandspecificationstatements">8.2.7. Execution of expression and specification statements</a></span></dt><dt><span class="section"><a href="#executionofcontroldirectives">8.2.8. Execution of control directives</a></span></dt><dt><span class="section"><a href="#exceptionpropagation">8.2.9. Exception propagation</a></span></dt><dt><span class="section"><a href="#toplevelinitialization">8.2.10. Initialization of toplevel references</a></span></dt><dt><span class="section"><a href="#d0e17267">8.2.11. Initialization of late references</a></span></dt></dl></dd><dt><span class="section"><a href="#executionofcontrolstructures">8.3. Execution of control structures and assertions</a></span></dt><dd><dl><dt><span class="section"><a href="#evaluationofconditions">8.3.1. Evaluation of condition lists</a></span></dt><dt><span class="section"><a href="#validationofassertions">8.3.2. Validation of assertions</a></span></dt><dt><span class="section"><a href="#executionofconditionals">8.3.3. Execution of conditionals</a></span></dt><dt><span class="section"><a href="#executionofloops">8.3.4. Execution of loops</a></span></dt><dt><span class="section"><a href="#exceptionhandling">8.3.5. Exception handling</a></span></dt><dt><span class="section"><a href="#dynamictypechecking">8.3.6. Dynamic type checking</a></span></dt></dl></dd><dt><span class="section"><a href="#evaluationinvocationandassignment">8.4. Evaluation, invocation, and assignment</a></span></dt><dd><dl><dt><span class="section"><a href="#dynamicdispatch">8.4.1. Dynamic dispatch</a></span></dt><dt><span class="section"><a href="#evaluation">8.4.2. Evaluation</a></span></dt><dt><span class="section"><a href="#assignment">8.4.3. Assignment</a></span></dt><dt><span class="section"><a href="#invocation">8.4.4. Invocation</a></span></dt><dt><span class="section"><a href="#anonymousfunctionevaluation">8.4.5. Evaluation of anonymous functions</a></span></dt><dt><span class="section"><a href="#enumerationevaluation">8.4.6. Evaluation of enumerations</a></span></dt><dt><span class="section"><a href="#spreadevaluation">8.4.7. Evaluation of spread arguments and comprehensions</a></span></dt></dl></dd><dt><span class="section"><a href="#operatorexpressions">8.5. Operator expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#operatorexpressionoptimization">8.5.1. Operator expression optimization</a></span></dt><dt><span class="section"><a href="#numericoperations">8.5.2. Numeric operations</a></span></dt></dl></dd><dt><span class="section"><a href="#comprehensionevaluation">8.6. Evaluation of comprehensions</a></span></dt><dd><dl><dt><span class="section"><a href="#forclause">8.6.1. for clause</a></span></dt><dt><span class="section"><a href="#ifclause">8.6.2. if clause</a></span></dt><dt><span class="section"><a href="#expressionclause">8.6.3. Expression clause</a></span></dt></dl></dd><dt><span class="section"><a href="#concurrency">8.7. Concurrency</a></span></dt></dl></dd><dt><span class="chapter"><a href="#modulesystem">9. Module system</a></span></dt><dd><dl><dt><span class="section"><a href="#moduleruntime">9.1. The module runtime and module isolation</a></span></dt><dd><dl><dt><span class="section"><a href="#classloaders">9.1.1. Module isolation for the Java platform</a></span></dt><dt><span class="section"><a href="#requirejs">9.1.2. Module isolation for the JavaScript platform</a></span></dt><dt><span class="section"><a href="#assemblies">9.1.3. Assemblies</a></span></dt></dl></dd><dt><span class="section"><a href="#sourcelayout">9.2. Source layout</a></span></dt><dt><span class="section"><a href="#modules">9.3. Module architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#modulenamesandversionidentifiers">9.3.1. Module names and version identifiers</a></span></dt><dt><span class="section"><a href="#modulearchivenamesjava">9.3.2. Module archive names for the Java platform</a></span></dt><dt><span class="section"><a href="#modulescriptnamesjs">9.3.3. Module script names for the JavaScript platform</a></span></dt><dt><span class="section"><a href="#sourcearchivenames">9.3.4. Source archive names</a></span></dt><dt><span class="section"><a href="#docarchivenames">9.3.5. Documentation archive names</a></span></dt><dt><span class="section"><a href="#modulearchives">9.3.6. Module archives</a></span></dt><dt><span class="section"><a href="#modulescripts">9.3.7. Module scripts</a></span></dt><dt><span class="section"><a href="#sourcearchives">9.3.8. Source archives</a></span></dt><dt><span class="section"><a href="#docarchives">9.3.9. Documentation archives</a></span></dt><dt><span class="section"><a href="#modulerepositories">9.3.10. Module repositories</a></span></dt><dt><span class="section"><a href="#packagedescriptors">9.3.11. Package descriptors</a></span></dt><dt><span class="section"><a href="#moduledescriptors">9.3.12. Module descriptors</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e15"></a>Welcome to Ceylon</h2></div></div><div></div></div><p>This project is the work of a team of people who are fans of Java
    and of the Java ecosystem, of its practical orientation, of its culture of 
    openness, of its developer community, of its roots in the world of business 
    computing, and of its ongoing commitment to portability. 
    However, we recognize that the language and class libraries, designed more 
    than 15 years ago, are no longer the best foundation for a range of today's 
    business computing problems. We further recognize that Java failed in one
    environment it was originally promoted for: the web browser.</p><p>The goal of this project is to make a clean break with the legacy 
    Java SE platform, by improving upon the Java language and class libraries, 
    and by providing a modular architecture for a new platform based upon the 
    Java Virtual Machine. A further goal is to bridge the gap between the web
    client and server by supporting execution on JavaScript virtual machines.</p><p>Of course, we recognize that the ability to interoperate with existing 
    Java code, thereby leveraging existing investment in the Java ecosystem, is a 
    critical requirement of any successor to the Java platform.</p><p>Java is a simple language to learn and Java code is easy to read and
    understand. Java provides a level of typesafety that is appropriate for
    business computing and enables sophisticated tooling with features like
    refactoring support, code completion, and code navigation. Ceylon aims to 
    retain the overall model of Java, while getting rid of some of Java's warts,
    and improving upon Java's facilities for creating abstractions and writing 
    generic libraries and frameworks.
    </p><p>Ceylon has the following goals:</p><div class="itemizedlist"><ul type="disc"><li><p>to be appropriate for large scale development, but to also
            be <span class="emphasis"><em>fun</em></span>,</p></li><li><p>to execute on the JVM, and on JavaScript virtual machines, 
            and to interoperate with native Java and JavaScript code,</p></li><li><p>to provide language-level modularity,</p></li><li><p>to be easy to learn for Java and C# developers,</p></li><li><p>to eliminate some of Java's verbosity, while retaining its 
            readability&#8212;Ceylon does <span class="emphasis"><em>not</em></span> aim to be 
            the most concise/cryptic language around,</p></li><li><p>to provide an elegant and more flexible syntax to support 
            frameworks, declarative programming, and meta-programming, and, 
            in particular</p></li><li><p>to provide a declarative syntax for expressing hierarchical 
            information like user interface definition, externalized data, and 
            system configuration, thereby eliminating Java's dependence upon 
            XML,</p></li><li><p>to support and encourage a more functional style of programming 
            with immutable objects and first class functions, alongside the
            familiar imperative mode,</p></li><li><p>to expand compile-time typesafety with compile-time safe handling 
            of null values, compile-time safe typecasts, and a more typesafe approach 
            to reflection, and</p></li><li><p>to make it easy to <span class="emphasis"><em>get things done</em></span>.</p></li></ul></div><p>Unlike other alternative JVM languages, Ceylon aims to completely replace 
    the legacy Java SE class libraries.</p><p>Therefore, the Ceylon SDK provides:</p><div class="itemizedlist"><ul type="disc"><li><p>a compiler that compiles Ceylon and Java source to Java 
            bytecode, and cross-compiles Ceylon to JavaScript,</p></li><li><p>command-line tooling for compiling modules and 
            documentation, and managing modules in module repositories,</p></li><li><p>Eclipse-based tooling for developing, compiling, testing, and 
            debugging programs written in Ceylon,</p></li><li><p>a module runtime for modular programs that execute on the Java
            Virtual Machine, and</p></li><li><p>a set of class libraries that provides much of the functionality
            of the Java SE platform, together with the core functionality of the
            Java EE platform.</p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><p>This document defines the syntax and semantics of the Ceylon language.
    The intended audience includes compiler implementors, interested parties
    who wish to contribute to the evolution of the language, and experienced 
    developers seeking a precise definition of language constructs. However, in
    light of the newness of the language, we will begin with an overview of the
    main features of the language and SDK. A brief introduction to programming 
    in the language may be found at the following address:</p><pre data-language="ceylon">http://ceylon-lang.org/documentation/tour/</pre><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="languageoverview"></a>1.1.&nbsp;Language overview</h2></div></div><div></div></div><p>
        Ceylon is a general-purpose programming  language featuring a syntax similar 
        to Java and C#. It is imperative, statically-typed, block-structured, 
        object-oriented, and higher-order. By <span class="emphasis"><em>statically-typed</em></span>, 
        we mean that the compiler performs extensive type checking, with the help of 
        type annotations that appear in the code. By <span class="emphasis"><em>object-oriented</em></span>, 
        we mean that the language supports user-defined types and features a nominative 
        type system where a type is a set of named attributes and operations, and that 
        it supports inheritance and subtype polymorphism. By <span class="emphasis"><em>higher-order</em></span>, 
        we mean that every referenceable program element (every attribute, every 
        operation, and every type) is also a value. By <span class="emphasis"><em>block-structured</em></span>, 
        we mean to say that the language features lexical scoping and an extremely 
        regular recursive syntax for declarations and statements.
        </p><p>
        Ceylon improves upon the Java language and type system to reduce verbosity 
        and increase typesafety compared to Java and C#. Ceylon encourages a more 
        functional, somewhat less imperative style of programming, resulting in code 
        which is easier to reason about, and easier to refactor. 
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="runtimeandplatform"></a>1.1.1.&nbsp;Runtime and platform</h3></div></div><div></div></div><p>
            Ceylon programs execute in any standard Java Virtual Machine or on any
            JavaScript virtual machine, and take advantage of the memory management and 
            concurrency features of the virtual machine in which they execute. Ceylon
            programs are packaged into <span class="emphasis"><em>modules</em></span> with well-defined
            inter-module dependencies, and always execute inside a runtime environment 
            with module isolation.
            </p><p>
            The Ceylon compiler is able to compile Ceylon code that calls Java classes or 
            interfaces, and Java code that calls Ceylon classes or interfaces. JavaScript
            code is able to interact with Ceylon classes and functions compiled to JavaScript. 
            Via a special <span class="emphasis"><em>dynamic</em></span> mode, code written in Ceylon may call
            functions defined natively in JavaScript.
            </p><p>
            Moreover, Ceylon provides its own native SDK as a replacement for the Java 
            platform class libraries. Certain SDK modules depend upon services available
            only on the Java platform. Other SDK modules, including the core 
            <span class="emphasis"><em>language module</em></span>, are cross-platform and may also be used 
            in a JavaScript virtual machine.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="thetypesystem"></a>1.2.&nbsp;Type system</h2></div></div><div></div></div><p>
        Ceylon, like Java and C#, features a hybrid type system with both subtype 
        polymorphism and parameteric polymorphism. A type is either a stateless 
        <span class="emphasis"><em>interface</em></span>, a stateful <span class="emphasis"><em>class</em></span>, a 
        <span class="emphasis"><em>type parameter</em></span>, or a <span class="emphasis"><em>union</em></span> or 
        <span class="emphasis"><em>intersection</em></span> of other types. A class, interface, or 
        type parameter may be defined as a subtype of another type. A class or 
        interface may declare type parameters, which abstract the definition of the 
        class or interface over all types which may be substituted for the type 
        parameters.
        </p><p>
        Like C#, and unlike Java, Ceylon's type system is fully reified. In 
        particular, generic type arguments are reified, eliminating many problems 
        that result from type erasure in Java.
        </p><p>
        There are no primitive types or arrays in Ceylon&#8212;every Ceylon type can 
        be represented within the language itself. So all values are instances of the 
        type hierarchy root <tt class="literal">Anything</tt>, which is a class. However, 
        the Ceylon compiler is permitted to optimize certain code to take advantage 
        of the optimized performance of primitive types on the Java or JavaScript VM.
        </p><p>
        Furthermore, all types inferred or even computed internally by the Ceylon 
        compiler are expressible within the language itself. Within the type system,
        <span class="emphasis"><em>non-denoteable</em></span> types simply do not arise. The type system 
        is based upon computation of <span class="emphasis"><em>principal types</em></span>. There is no 
        legal expression which does not have a unique principal type expressible within 
        the language. The principal type of an expression is a subtype of all other 
        types to which the expression could be soundly assigned.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mixininheritance"></a>1.2.1.&nbsp;Mixin inheritance</h3></div></div><div></div></div><p>
            Ceylon supports a restricted form of multiple inheritance, often called 
            <span class="emphasis"><em>mixin inheritance</em></span>. A class must extend exactly one other 
            class. But a class or interface may satisfy (extend or implement) an arbitrary 
            number of interfaces.
            </p><p>
            Classes hold state and define logic to initialize that state when the class is 
            instantiated. A concrete class is a class that contains only concrete member 
            definitions. Concrete classes may be directly instantiated. An abstract class 
            may contain formal member declarations. Abstract classes may not be instantiated.
            </p><p>
            Interfaces may define concrete members, but may not hold state (references to 
            other objects) or initialization logic. This restriction helps eliminate the 
            problems traditionally associated with multiple inheritance. Ceylon never 
            performs any kind of "linearization" of the supertypes of a type. Interfaces 
            may not be directly instantiated.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="algrebraictypesselftypes"></a>1.2.2.&nbsp;Algebraic types, self types, and type families</h3></div></div><div></div></div><p>
            Ceylon does not feature Java-style enumerated types as a first-class construct. 
            Instead, any abstract type may specify its <span class="emphasis"><em>cases</em></span>&#8212;an
            enumerated list of instances and/or subtypes. This facility is used to simulate 
            both enumerated types and functional-style "algebraic" (sum) types. 
            </p><pre data-language="ceylon">interface Identity of Person | Organization { ... }</pre><p>
            A closely related feature is support for <span class="emphasis"><em>self types</em></span> and 
            <span class="emphasis"><em>type families</em></span>. A self type is a type parameter of an 
            abstract type (like <tt class="literal">Comparable</tt>) which represents the type of 
            a concrete instantiation (like <tt class="literal">String</tt>) of the abstract type,
            within the definition of the abstract type itself. In a type family, the self 
            type of a type is declared not by the type itself, but by a containing type 
            which groups together a set of related types.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="simplifiedgenerics"></a>1.2.3.&nbsp;Simplified generics</h3></div></div><div></div></div><p>
            Ceylon doesn't have raw types, implicit bounds, or wildcard capture. And the 
            Ceylon compiler never even uses any kind of "non-denotable" type to reason 
            about the type system. So generics-related error messages are understandable 
            to humans.
            </p><p>
            Ceylon features <span class="emphasis"><em>declaration-site variance</em></span>. A type parameter 
            may be marked as covariant or contravariant by the class or interface that 
            declares the parameter.
            </p><p>
            Ceylon has a somewhat more expressive system of generic type constraints with 
            a cleaner, more regular syntax. The syntax for declaring constraints on a type 
            parameter looks very similar to a class or interface declaration. Ceylon supports 
            upper bound type constraints and also <span class="emphasis"><em>enumerated bounds</em></span>.
            </p><pre data-language="ceylon">interface Producer&lt;out Value, in Rate&gt; 
        given Value satisfies Object 
        given Rate of Float|Decimal { ... }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="unionandintersectiontypes"></a>1.2.4.&nbsp;Union and intersection types</h3></div></div><div></div></div><p>
            A <span class="emphasis"><em>union type</em></span>, for example <tt class="literal">String|Number</tt>, 
            or <span class="emphasis"><em>intersection type</em></span>, for example 
            <tt class="literal">Identifiable&amp;List&lt;String&gt;</tt>, may be formed from 
            two or more types defined elsewhere. 
            </p><p>
            Union types make it possible to write code that operates polymorphically 
            over types defined in disparate branches of the type hierarchy without the 
            need for intermediate adaptor classes. Intersection types make it possible 
            to operate polymorphically over all subtypes of a list of types. Union and
            intersection types provide some of the benefits of structural ("duck") 
            typing, within the confines of a nominative type system, and therefore 
            certain Ceylon idioms are reminiscent of code written in dynamically-typed
            languages.  
            </p><p>
            Union and intersection types play a central role in generic type argument 
            inference and therefore underly the whole system of principal typing. For
            example, the following expression has type 
            <tt class="literal">HashMap&lt;String,Integer|Float&gt;</tt>:
            </p><pre data-language="ceylon">HashMap { "float"-&gt;0.0, "integer"-&gt;0 }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typealiasesandtypeinference"></a>1.2.5.&nbsp;Type aliases and type inference</h3></div></div><div></div></div><p>    
            Type aliases and type inference help reduce the verbosity of code which 
            uses generic types, eliminating the need to repeatedly specify generic
            type arguments.
            </p><p>
            A <span class="emphasis"><em>type alias</em></span> is similar to a C-style <tt class="literal">typedef</tt>.
            </p><pre data-language="ceylon">interface Strings =&gt; Sequence&lt;String&gt;;</pre><pre data-language="ceylon">alias Number =&gt; Integer|Float|Whole|Decimal;</pre><p>
            Local <span class="emphasis"><em>type inference</em></span> allows a type annotation to be
            eliminated altogether. The type of a block-local value or function is 
            inferred from its definition if the keyword <tt class="literal">value</tt> or 
            <tt class="literal">function</tt> occurs in place of the type declaration.
            </p><pre data-language="ceylon">value name = person.name;</pre><pre data-language="ceylon">function sqrt(Float x) =&gt; x^0.5;</pre><p>
            The type of a control-structure variable also may be inferred.
            </p><pre data-language="ceylon">for (n in 0..max) { ... }</pre><p>
            Ceylon features an especially elegant approach to generic type argument 
            inference, making it possible to instantiate container types, even 
            inhomogeneous container types, without the need to explicitly mention any 
            types at all.  
            </p><pre data-language="ceylon">value numbers = { -1, 0, -1, -1.0, 0.0, 1.0 };</pre><p>
            By limiting type inference to local declarations, Ceylon ensures that all 
            types may be inferred by the compiler in a single pass of the source code. 
            Type inference works in the "downward" and "outward" directions. The compiler 
            is able to determine the type of an expression without considering the rest 
            of the statement or declaration in which it appears.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metaprogramming"></a>1.2.6.&nbsp;Metaprogramming</h3></div></div><div></div></div><p>In other statically typed languages, runtime metaprogramming, 
            or <span class="emphasis"><em>reflection</em></span>, is a messy business involving
            untypesafe strings and typecasting. Even worse, in Java, generic
            type arguments are erased at runtime, and unavailable via reflection. 
            Ceylon, uniquely, features a <span class="emphasis"><em>typesafe metamodel</em></span> 
            and typed <span class="emphasis"><em>metamodel expressions</em></span>. Since generic 
            type arguments are reified at runtime, the metamodel fully captures 
            generic types at both compile time and execution time.</p><p>Ceylon's support for program element <span class="emphasis"><em>annotations</em></span>
            is based around this metamodel. Annotations are more flexible than
            in Java or C#, and have a much cleaner syntax.</p><p>Ceylon does not support macros or any other kind of compile-time
            metaprogramming.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectorientedprogramming"></a>1.3.&nbsp;Object-oriented programming</h2></div></div><div></div></div><p>The primary unit of organization of an object-oriented program is
        the class. But Ceylon, unlike Java, doesn't require that <span class="emphasis"><em>every</em></span> 
        function or value belong to a class. It's perfectly normal to program 
        with a mix of classes and toplevel functions. Contrary to popular belief, 
        this does not make the program less object-oriented. A function is, after 
        all, an object.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="initializationandinstantiation"></a>1.3.1.&nbsp;Class initialization and instantiation</h3></div></div><div></div></div><p>
            Ceylon does not feature any Java-like constructor declaration and so each 
            Ceylon class has a parameter list, and exactly one 
            <span class="emphasis"><em>initializer</em></span>&#8212;the body of the class. This helps
            reduce verbosity and results in a more regular block structure.
            </p><pre data-language="ceylon">class Point(Float x, Float y) { ... }</pre><p>
            The Ceylon compiler guarantees that the value of any attribute of a class 
            is initialized before it is used in an expression.
            </p><p>
            A class may be a member of an outer class. Such a member class may be 
            refined (overridden) by a subclass of the outer class. Instantiation is 
            therefore a polymorphic operation in Ceylon, eliminating the need for a 
            factory method in some circumstances.
            </p><p>
            Ceylon provides a streamlined syntax for defining <span class="emphasis"><em>anonymous 
            classes</em></span>. An anonymous class is a class which is instantiated 
            only in exactly the place it is defined. Among other uses, the 
            <tt class="literal">object</tt> declaration is useful for creating singleton 
            objects or method-local interface implementations. 
            </p><pre data-language="ceylon">object origin extends Point(0.0, 0.0) {}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="methodsandattributes"></a>1.3.2.&nbsp;Functions, methods, values, and attributes</h3></div></div><div></div></div><p><span class="emphasis"><em>Functions</em></span> and <span class="emphasis"><em>values</em></span> are 
            the bread and butter of programming. Ceylon functions are similar to Java 
            methods, except that they don't need to belong to a class. Ceylon values 
            are polymorphic, and abstract their internal representation, similar to 
            C# properties.</p><pre data-language="ceylon">String name =&gt; firstName + " " + lastName;</pre><p>The Ceylon compiler guarantees that any value is initialized before 
            it is used in an expression.</p><p>
            A function belonging to a type is called a <span class="emphasis"><em>method</em></span>. 
            A value belonging to a type is called an <span class="emphasis"><em>attribute</em></span>.  
            There are no <tt class="literal">static</tt> members. Instead, a function or 
            value may be declared as a direct <span class="emphasis"><em>toplevel</em></span> member 
            of a package, or as a member of a singleton anonymous class. This 
            approach, along with certain other features, gives the language a more 
            regular block structure.
            </p><p>
            By default, an attribute or value may not be assigned a new value after
            its initial value has been specified. Mutable attributes and variable 
            values must be explicitly declared using the <tt class="literal">variable</tt> 
            annotation.
            </p><p>
            Ceylon does not support function overloading. Each method of a type has a 
            distinct name.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="defaultparameters"></a>1.3.3.&nbsp;Defaulted parameters and variadic parameters</h3></div></div><div></div></div><p>
            Instead of method and constructor overloading, Ceylon supports parameters 
            with default values and <span class="emphasis"><em>variadic</em></span> parameters.
            </p><pre data-language="ceylon">void addItem(Product product, Integer quantity=1) { ... }</pre><pre data-language="ceylon">String join(String* strings) { ... }</pre><p>
            Furthermore, a generic method may be used to emulate parameter type 
            overloading.
            </p><pre data-language="ceylon">Number sum&lt;Number&gt;(Number* numbers) 
        given Number of Integer | Float { ... }</pre><p>Therefore, a single method in Ceylon may emulate the signatures of 
            several overloaded methods in Java.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="firstclassfunctions"></a>1.3.4.&nbsp;First-class functions and higher-order programming</h3></div></div><div></div></div><p>
            Ceylon supports first-class function types and higher-order functions. A 
            function declaration may specify a <span class="emphasis"><em>callable parameter</em></span> 
            that accepts references to other functions with a certain signature. 
            </p><pre data-language="ceylon">String find(Boolean where(String string)) { ... }</pre><p>
            The argument of such a callable parameter may be either a reference to a 
            named function declared elsewhere, or a new function defined inline as part 
            of the method invocation. 
            </p><pre data-language="ceylon">value result = { "C", "Java", "Ceylon" }.find((String s) =&gt; s.size&gt;1);</pre><p>
            The type of a function is expressed within the type system as an 
            instantiation of the interface <tt class="literal">Callable</tt>. The parameter 
            types are expressed as a tuple type. So the type of the function 
            <tt class="literal">(String s) =&gt; s.size&gt;1</tt> is 
            <tt class="literal">Callable&lt;Boolean,[String]&gt;</tt>, which may be 
            abbreviated to <tt class="literal">Boolean(String)</tt>.
            </p><p>
            Methods and attributes may also be used as functions.
            </p><pre data-language="ceylon">value names = people.map(Person.name);</pre><pre data-language="ceylon">value values = keys.map(keyedValues.get);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="namingconventionsandannotations"></a>1.3.5.&nbsp;Naming conventions, annotations, and inline documentation</h3></div></div><div></div></div><p>
            The Ceylon compiler enforces the traditional Smalltalk naming convention:
            type names begin with an initial uppercase letter&#8212;for example, 
            <tt class="literal">Liberty</tt> or <tt class="literal">RedWine</tt>&#8212;member names 
            and local names with an initial lowercase letter or underscore&#8212;for
            example, <tt class="literal">blonde</tt>, <tt class="literal">immanentize()</tt> or 
            <tt class="literal">boldlyGo()</tt>.
            </p><p>
            These restrictions allow a much cleaner syntax for program element 
            annotations than the syntax found in either Java or C#. Declaration 
            "modifiers" like <tt class="literal">shared</tt>, <tt class="literal">abstract</tt>, 
            and <tt class="literal">variable</tt> aren't keywords in Ceylon, they're ordinary 
            annotations.
            </p><pre data-language="ceylon">"Base type for higher-order abstract stuff."
shared abstract class AbstractMetaThingy() { ... }</pre><p>
            The documentation compiler reads inline documentation specified 
            using the <tt class="literal">doc</tt> annotation.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="structureddata"></a>1.3.6.&nbsp;Named arguments and tree-like structures</h3></div></div><div></div></div><p>
            Ceylon's named argument lists provide an elegant means of initializing objects 
            and collections. The goal of this facility is to replace the use of XML for 
            expressing hierarchical structures such as documents, user interfaces, 
            configuration and serialized data.
            </p><pre data-language="ceylon">Html page = Html {
    doctype = html5;
    Head { title = "Ceylon: home page"; };
    Body {
        H2 ( "Welcome to Ceylon ``language.version``!" ),
        P ( "Now get your code on :)" )
    };
}
</pre><p>
            An especially important application of this facility is Ceylon's built-in 
            support for program element annotations.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modularity"></a>1.3.7.&nbsp;Modularity</h3></div></div><div></div></div><p>
            Toplevel declarations are organized into <span class="emphasis"><em>packages</em></span> and 
            <span class="emphasis"><em>modules</em></span>. Ceylon features language-level access control 
            via the <tt class="literal">shared</tt> annotation which can be used to express 
            block-local, package-private, module-private, and public visibility for 
            a program element. There's no equivalent to Java's <tt class="literal">protected</tt>.
            </p><p>A module corresponds to a versioned packaged archive. Its 
            <span class="emphasis"><em>module descriptor</em></span> expresses its dependencies to other
            modules. The tooling and execution model for the language is based around 
            modularity and module archives.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="thelanguagemodule"></a>1.4.&nbsp;Language module</h2></div></div><div></div></div><p>The Ceylon language module defines a set of built-in types which form 
        the basis for several powerful features of the language. The following 
        functionality is defined as syntactic "sugar" that makes it easier and more 
        convenient to interact with the language module.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="operatorsandoperatorpolymorphism"></a>1.4.1.&nbsp;Operators and operator polymorphism</h3></div></div><div></div></div><p>
            Ceylon features a rich set of operators, including most of the operators 
            supported by C and Java. True operator overloading is not supported. 
            However, each operator is defined to act upon a certain class or interface 
            type, allowing application of the operator to any class which extends or 
            satisfies that type. For example, the <tt class="literal">+</tt> operator may be
            applied to any class that satisfies the interface <tt class="literal">Summable</tt>. 
            This approach is called <span class="emphasis"><em>operator polymorphism</em></span>.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="numerictypes"></a>1.4.2.&nbsp;Numeric and character types</h3></div></div><div></div></div><p>Ceylon's numeric type system is much simpler than C, C# or Java, with
            exactly two built-in numeric types (compared to six in Java and eleven in 
            C#). The built-in types are classes representing integers and floating point 
            numbers. <tt class="literal">Integer</tt> and <tt class="literal">Float</tt> values are 
            64 bit by default, and may be optimized for 32 bit architectures via use of 
            the <tt class="literal">small</tt> annotation.</p><p>The module <tt class="literal">ceylon.math</tt> provides two additional
            numeric types representing arbitrary precision integers and arbitrary 
            precision decimals.</p><p>Ceylon has <tt class="literal">Character</tt> and <tt class="literal">String</tt>
            classes, and, unlike Java or C#, every character is a full 32-bit Unicode
            codepoint. Conveniently, a <tt class="literal">String</tt> is a 
            <tt class="literal">List&lt;Character&gt;</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="compiletimesafety"></a>1.4.3.&nbsp;Compile-time safety for optional values and type narrowing</h3></div></div><div></div></div><p>
            There is no primitive null in Ceylon. The null value is an instance of 
            the class <tt class="literal">Null</tt> that is not assignable to user-defined 
            class or interface types. An <span class="emphasis"><em>optional type</em></span> is a 
            union type like <tt class="literal">Null|String</tt>, which may be abbreviated
            to <tt class="literal">String?</tt>. An optional type is not assignable to a 
            non-optional type except via use of the special-purpose 
            <tt class="literal">if (exists ... )</tt> construct. Thus, the Ceylon compiler 
            is able to detect illegal use of a null value at compile time. Therefore, 
            there is no equivalent to Java's <tt class="literal">NullPointerException</tt> 
            in Ceylon.
            </p><p>
            Similarly, there are no C-style typecasts in Ceylon. Instead, the 
            <tt class="literal">if (is ... )</tt> and <tt class="literal">case (is ... )</tt> 
            constructs may be used to narrow the type of an object reference without 
            risk of a <tt class="literal">ClassCastException</tt>. The combination of
            <tt class="literal">case (is ... )</tt> with algebraic types amounts to a kind
            of language-level support for the visitor pattern.
            </p><p>
            Alternatively, <span class="emphasis"><em>type assertions</em></span>, written 
            <tt class="literal">assert (is ... )</tt> or <tt class="literal">assert (exists ... )</tt>
            may be used to narrow the type of a reference.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="iterableobjectsandcomprehensions"></a>1.4.4.&nbsp;Iterable objects and comprehensions</h3></div></div><div></div></div><p>The interface <tt class="literal">Iterable</tt> represents a stream of
            values, which might be evaluated lazily. This interface is of central
            importance in the language module, and so the language provides a
            syntactic abbreviation for the type of an iterable object. The 
            abbreviation <tt class="literal">{String*}</tt> means 
            <tt class="literal">Iterable&lt;String&gt;</tt>. There is a convenient syntax
            for instantiating an iterable object, given a list of values:</p><pre data-language="ceylon">{String*} words = {"hello", "world", "goodbye"};</pre><p>A <span class="emphasis"><em>nonempty iterable</em></span> is an iterable object
            which always produces at least one value. A nonempty iterabe type is
            written <tt class="literal">{String+}</tt>. Distinguishing nonempty streams
            of values lets us correctly express the type of functions like
            <tt class="literal">max()</tt>:</p><pre data-language="ceylon">{Float+} oneOrMore = .... ;
{Float*} zeroOrMore = .... ;
Float maxOfOneOrMore = max(oneOrMore); //never null
Float? maxOfZeroOrMore = max(zeroOrMore); //might be null</pre><p><span class="emphasis"><em>Comprehensions</em></span> are an expressive syntax for
            filtering and transforming streams of values. For example, they may be 
            used when instantiating an iterable object or collection:</p><pre data-language="ceylon">value adults = { for (p in people) if (p.age&gt;18) p.name };</pre><pre data-language="ceylon">value peopleByName = HashMap { for (p in people) p.name-&gt;p };</pre><p>Comprehensions are evaluated lazily.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sequencesandtuples"></a>1.4.5.&nbsp;Sequences and tuples</h3></div></div><div></div></div><p><span class="emphasis"><em>Sequences</em></span> are Ceylon's version of arrays. 
            However, the <tt class="literal">Sequential</tt> interface does not provide 
            operations for mutating the elements of the sequence&#8212;sequences
            are considered immutable. Because this interface is so useful, a type 
            like <tt class="literal">Sequential&lt;String&gt;</tt> may be abbreviated to 
            <tt class="literal">[String*]</tt>, or, for the sake of tradition, to 
            <tt class="literal">String[]</tt>.</p><p>A <span class="emphasis"><em>nonempty sequence</em></span> is a kind of sequence
            which always has at least one element. A nonempty sequence type is 
            written <tt class="literal">[String+]</tt>. The special-purpose 
            <tt class="literal">if (nonempty ... )</tt> construct narrows a sequence 
            type to a nonempty sequence type.</p><p><span class="emphasis"><em>Tuples</em></span> are a kind of sequence where the 
            type of each element is encoded into the static type of the tuple.
            <tt class="literal">Tuple</tt> is just an ordinary class in Ceylon, but 
            the language lets us write down tuple types using a streamlined 
            syntax. For example, <tt class="literal">[Float,Float]</tt> is a pair of 
            <tt class="literal">Float</tt>s. There's also a convenient syntax for 
            instantiating tuples and accessing their elements.</p><pre data-language="ceylon">[Float,Float] origin = [0.0, 0.0];
Float x = origin[0];
Float y = origin[1];
Null z = origin[2]; //only two elements!</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="lexical"></a>Chapter&nbsp;2.&nbsp;Lexical structure</h2></div></div><div></div></div><p>Every Ceylon source file is a sequence of Unicode characters. Lexical
    analysis of the character stream, according to the grammar specified in this
    chapter, results in a stream of tokens. These tokens form the input of the 
    parser grammar defined in the later chapters of this specification. The
    Ceylon lexer is able to completely tokenize a character stream in a single 
    pass.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whitespace"></a>2.1.&nbsp;Whitespace</h2></div></div><div></div></div><p><span class="emphasis"><em>Whitespace</em></span> is composed of strings of Unicode 
        <tt class="literal">SPACE</tt>, <tt class="literal">CHARACTER TABULATION</tt>, 
        <tt class="literal">FORM FEED (FF)</tt>, <tt class="literal">LINE FEED (LF)</tt> and 
        <tt class="literal">CARRIAGE RETURN (CR)</tt> characters.</p><pre data-language="bnf">Whitespace: " " | Tab | Formfeed | Newline | CarriageReturn</pre><pre data-language="bnf">Tab: "\{CHARACTER TABULATION}"</pre><pre data-language="bnf">Formfeed: "\{FORM FEED (FF)}"</pre><pre data-language="bnf">Newline: "\{LINE FEED (LF)}"</pre><pre data-language="bnf">CarriageReturn: "\{CARRIAGE RETURN (CR)}"</pre><p>Outside of a comment, string literal, or single quoted literal,
        whitespace acts as a token separator and is immediately discarded by
        the lexer. Whitespace is not used as a statement separator.</p><p>Source text is divided into lines by <span class="emphasis"><em>line-terminating 
        character sequences</em></span>. The following Unicode character sequences 
        terminate a line:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">LINE FEED (LF)</tt>,</p></li><li><p><tt class="literal">CARRIAGE RETURN (CR)</tt>, and</p></li><li><p><tt class="literal">CARRIAGE RETURN (CR)</tt> followed by
                <tt class="literal">LINE FEED (LF)</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="comments"></a>2.2.&nbsp;Comments</h2></div></div><div></div></div><p>There are two kinds of comments:</p><div class="itemizedlist"><ul type="disc"><li><p>a <span class="emphasis"><em>multiline comment</em></span> begins with 
                <tt class="literal">/*</tt> and extends until <tt class="literal">*/</tt>, 
                and</p></li><li><p>an <span class="emphasis"><em>end-of-line comment</em></span> begins with 
                <tt class="literal">//</tt> or <tt class="literal">#!</tt> and extends until 
                the next line terminating character sequence.</p></li></ul></div><p>Both kinds of comments can be nested.</p><pre data-language="bnf">LineComment: ("//"|"#!") ~(Newline | CarriageReturn)* (CarriageReturn Newline | CarriageReturn | Newline)?</pre><pre data-language="bnf">MultilineComment: "/*" (MultilineCommentCharacter | MultilineComment)* "*/"</pre><pre data-language="bnf">MultilineCommentCharacter: ~("/"|"*") | ("/" ~"*") =&gt; "/" | ("*" ~"/") =&gt; "*"</pre><p>The following examples are legal comments:</p><pre data-language="ceylon">//this comment stops at the end of the line</pre><pre data-language="ceylon">/*
   but this is a comment that spans
   multiple lines
*/</pre><pre data-language="ceylon">#!/usr/bin/ceylon</pre><p>Comments are treated as whitespace by both the compiler and documentation
        compiler. Comments may act as token separators, but their content is immediately 
        discarded by the lexer and they are not visible to the parser.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="identifiersandkeywords"></a>2.3.&nbsp;Identifiers and keywords</h2></div></div><div></div></div><p><span class="emphasis"><em>Identifiers</em></span> may contain letters, digits and 
        underscores.</p><pre data-language="bnf">LowercaseCharacter: LowercaseLetter | "_"</pre><pre data-language="bnf">UppercaseCharacter: UppercaseLetter</pre><pre data-language="bnf">IdentifierCharacter: LowercaseCharacter | UppercaseCharacter | Number</pre><p>The lexer classifies Unicode uppercase letters, lowercase letters, 
        and numeric characters depending on the general category of the character
        as defined by the Unicode standard.</p><div class="itemizedlist"><ul type="disc"><li><p>
                    A <tt class="literal">LowercaseLetter</tt> is any character whose 
                    general category is <tt class="literal">Ll</tt> or any character whose 
                    general category is <tt class="literal">Lo</tt> or <tt class="literal">Lm</tt> 
                    which has the property <tt class="literal">Other_Lowercase</tt>.
                </p></li><li><p>
                    An <tt class="literal">UppercaseLetter</tt> is any character whose 
                    general category is <tt class="literal">Lu</tt> or <tt class="literal">Lt</tt>, 
                    or any character whose general category is <tt class="literal">Lo</tt> or 
                    <tt class="literal">Lm</tt> which does not have the property
                    <tt class="literal">Other_Lowercase</tt>.
                </p></li><li><p>
                    A <tt class="literal">Number</tt> is any character whose general 
                    category is <tt class="literal">Nd</tt>, <tt class="literal">Nl</tt>, or 
                    <tt class="literal">No</tt>.
                </p></li></ul></div><p>All identifiers are case sensitive: <tt class="literal">Person</tt> and
        <tt class="literal">person</tt> are two different legal identifiers.</p><p>The lexer distinguishes identifiers which begin with an initial 
        uppercase character from identifiers which begin with an initial lowercase
        character or underscore. Additionally, an identifier may be qualified using 
        the prefix <tt class="literal">\i</tt> or <tt class="literal">\I</tt> to disambiguate it 
        from a reserved word or to explicitly specify whether it should be considered
        an initial uppercase or initial lowercase identifier.</p><pre data-language="bnf">LIdentifier: LowercaseCharacter IdentifierCharacter* | "\i" IdentifierCharacter+</pre><pre data-language="bnf">UIdentifier: UppercaseCharacter IdentifierCharacter* | "\I" IdentifierCharacter+</pre><p>The following examples are legal identifiers:</p><pre data-language="ceylon">Person</pre><pre data-language="ceylon">name</pre><pre data-language="ceylon">personName</pre><pre data-language="ceylon">_id</pre><pre data-language="ceylon">x2</pre><pre data-language="ceylon">\I_id</pre><pre data-language="ceylon">\Iobject</pre><pre data-language="ceylon">\iObject</pre><pre data-language="ceylon">\iclass</pre><p>The prefix <tt class="literal">\I</tt> or <tt class="literal">\i</tt> is not 
        considered part of the identifier name. Therefore, <tt class="literal">\iperson</tt>
        is just an initial lowercase identifier named <tt class="literal">person</tt> and
        <tt class="literal">\Iperson</tt> is an initial <span class="emphasis"><em>uppercase</em></span> 
        identifier named <tt class="literal">person</tt>.</p><p>The following reserved words are not legal identifier names unless they 
        appear escaped using <tt class="literal">\i</tt> or <tt class="literal">\I</tt>:</p><p><tt class="literal">
        assembly module package import
        alias class interface object given value assign void function new
        of extends satisfies abstracts
        in out
        return break continue throw
        assert dynamic
        if else switch case for while try catch finally then let
        this outer super
        is exists nonempty
        </tt></p><i><span class="comment"><p>Note: <tt class="literal">assembly</tt>, <tt class="literal">abstracts</tt>, 
        <tt class="literal">new</tt>, and <tt class="literal">let</tt> are reserved for possible use 
        in a future release of the language.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="literals"></a>2.4.&nbsp;Literals</h2></div></div><div></div></div><p>A <span class="emphasis"><em>literal</em></span> is a single token that represents a
        Unicode character, a character string, or a numeric value.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="numericliterals"></a>2.4.1.&nbsp;Numeric literals</h3></div></div><div></div></div><p>An <span class="emphasis"><em>integer literal</em></span> may be expressed in decimal, 
            hexadecimal, or binary notation:</p><pre data-language="bnf">IntegerLiteral: DecimalLiteral | HexLiteral | BinLiteral</pre><p>A <span class="emphasis"><em>decimal literal</em></span> has a list of digits and an
            optional magnitude:</p><pre data-language="bnf">DecimalLiteral: Digits Magnitude?</pre><p><span class="emphasis"><em>Hexadecimal literals</em></span> are prefixed by <tt class="literal">#</tt>:</p><pre data-language="bnf">HexLiteral: "#" HexDigits</pre><p><span class="emphasis"><em>Binary literals</em></span> are prefixed by <tt class="literal">$</tt>:</p><pre data-language="bnf">BinLiteral: "$" BinDigits</pre><p>A <span class="emphasis"><em>floating point literal</em></span> is distinguished by the
            presence of a decimal point or fractional magnitude:</p><pre data-language="bnf">FloatLiteral: NormalFloatLiteral | ShortcutFloatLiteral</pre><p>Most floating point literals have a list of digits including a decimal 
            point, and an optional exponent or magnitude.</p><pre data-language="bnf">NormalFloatLiteral: Digits "." FractionalDigits (Exponent | Magnitude | FractionalMagnitude)?</pre><p>The decimal point is optional if a fractional magitude is specified.</p><pre data-language="bnf">ShortcutFloatLiteral: Digits FractionalMagnitude</pre><p>Decimal digits may be separated into groups of three using an underscore.</p><pre data-language="bnf">Digits: Digit+ | Digit{1..3} ("_" Digit{3})+</pre><pre data-language="bnf">FractionalDigits: Digit+ | (Digit{3} "_")+ Digit{1..3} </pre><p>Hexadecimal or binary digits may be separated into groups of four using 
            an underscore. Hexadecimal digits may even be separated into groups of two.</p><pre data-language="bnf">HexDigits: HexDigit+ | HexDigit{1..4} ("_" HexDigit{4})+ | HexDigit{1..2} ("_" HexDigit{2})+</pre><pre data-language="bnf">BinDigits: BinDigit+ | BinDigit{1..4} ("_" Digit{4})+</pre><p>A digit is a decimal, hexadecimal, or binary digit.</p><pre data-language="bnf">Digit: "0".."9"</pre><pre data-language="bnf">HexDigit: "0".."9" | "A".."F" | "a".."f"</pre><pre data-language="bnf">BinDigit: "0"|"1"</pre><p>A floating point literal may include either an <span class="emphasis"><em>exponent</em></span> 
            (for scientific notation) or a <span class="emphasis"><em>magnitude</em></span> (an SI unit
            prefix). A decimal integer literal may include a magnitude.</p><pre data-language="bnf">Exponent: ("E"|"e") ("+"|"-")? Digit+</pre><pre data-language="bnf">Magnitude: "k" | "M" | "G" | "T" | "P"</pre><pre data-language="bnf">FractionalMagnitude: "m" | "u" | "n" | "p" | "f"</pre><p>The magnitude of a numeric literal is interpreted as follows:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">k</tt> means <tt class="literal">e+3</tt>,</p></li><li><p><tt class="literal">M</tt> means <tt class="literal">e+6</tt>,</p></li><li><p><tt class="literal">G</tt> means <tt class="literal">e+9</tt>,</p></li><li><p><tt class="literal">T</tt> means <tt class="literal">e+12</tt>,</p></li><li><p><tt class="literal">P</tt> means <tt class="literal">e+15</tt>,</p></li><li><p><tt class="literal">m</tt> means <tt class="literal">e-3</tt>,</p></li><li><p><tt class="literal">u</tt> means <tt class="literal">e-6</tt>,</p></li><li><p><tt class="literal">n</tt> means <tt class="literal">e-9</tt>,</p></li><li><p><tt class="literal">p</tt> means <tt class="literal">e-12</tt>, and</p></li><li><p><tt class="literal">f</tt> means <tt class="literal">e-15</tt>.</p></li></ul></div><p>The following examples are legal numeric literals:</p><pre data-language="ceylon">69</pre><pre data-language="ceylon">6.9</pre><pre data-language="ceylon">0.999e-10</pre><pre data-language="ceylon">1.0E2</pre><pre data-language="ceylon">10000</pre><pre data-language="ceylon">1_000_000</pre><pre data-language="ceylon">12_345.678_9</pre><pre data-language="ceylon">1.5k</pre><pre data-language="ceylon">12M</pre><pre data-language="ceylon">2.34p</pre><pre data-language="ceylon">5u</pre><pre data-language="ceylon">$1010_0101</pre><pre data-language="ceylon">#D00D</pre><pre data-language="ceylon">#FF_FF_FF</pre><p>The following are <span class="emphasis"><em>not</em></span> valid numeric literals:</p><pre data-language="ceylon">.33  //Error: floating point literals may not begin with a decimal point</pre><pre data-language="ceylon">1.  //Error: floating point literals may not end with a decimal point</pre><pre data-language="ceylon">99E+3  //Error: floating point literals with an exponent must contain a decimal point</pre><pre data-language="ceylon">12_34  //Error: decimal digit groups must be of length three</pre><pre data-language="ceylon">#FF.00  //Error: floating point numbers may not be expressed in hexadecimal notation</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="characterliterals"></a>2.4.2.&nbsp;Character literals</h3></div></div><div></div></div><p>A single <span class="emphasis"><em>character literal</em></span> consists of a Unicode 
            character, inside single quotes.</p><pre data-language="bnf">CharacterLiteral: "'" Character "'"</pre><pre data-language="bnf">Character: ~("'" | "\") | EscapeSequence</pre><p>A character may be identified by an <span class="emphasis"><em>escape sequence</em></span>.
            Every escape sequence begins with a backslash. An escape sequence is replaced
            by its corresponding Unicode character during lexical analysis.</p><pre data-language="bnf">EscapeSequence: "\" (SingleCharacterEscape | "{" CharacterCode "}")</pre><pre data-language="bnf">SingleCharacterEscape: "b" | "t" | "n" | "f" | "r" | "\" | """ | "'" | "`"</pre><p>The single-character escape sequences have their traditional interpretations as
            Unicode characters:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">\b</tt> means <tt class="literal">BACKSPACE</tt>,</p></li><li><p><tt class="literal">\t</tt> means <tt class="literal">CHARACTER TABULATION</tt>,</p></li><li><p><tt class="literal">\n</tt> means <tt class="literal">LINE FEED (LF)</tt>,</p></li><li><p><tt class="literal">\f</tt> means <tt class="literal">FORM FEED (FF)</tt>,</p></li><li><p><tt class="literal">\r</tt> means <tt class="literal">CARRIAGE RETURN (CR)</tt>, 
                    and</p></li><li><p><tt class="literal">\\</tt>, <tt class="literal">\`</tt>, <tt class="literal">\'</tt>, 
                    and <tt class="literal">\"</tt> mean <tt class="literal">REVERSE SOLIDUS</tt>, 
                    <tt class="literal">GRAVE ACCENT</tt>, <tt class="literal">APOSTROPHE</tt>, and 
                    <tt class="literal">QUOTATION MARK</tt>, respectively.</p></li></ul></div><p>A Unicode codepoint escape is a four-digit or eight-digit hexadecimal literal,
            or a Unicode character name, surrounded by braces, and means the Unicode character
            with the specified codepoint or character name.</p><pre data-language="bnf">CharacterCode: "#" ( HexDigit{4} | HexDigit{8} ) | UnicodeCharacterName</pre><p>Legal Unicode character names are defined by the Unicode specification.</p><p>The following are legal character literals:</p><pre data-language="ceylon">'A'</pre><pre data-language="ceylon">'#'</pre><pre data-language="ceylon">' '</pre><pre data-language="ceylon">'\n'</pre><pre data-language="ceylon">'\{#212B}'</pre><pre data-language="ceylon">'\{ALCHEMICAL SYMBOL FOR GOLD}'</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="stringliterals"></a>2.4.3.&nbsp;String literals</h3></div></div><div></div></div><p>A character <span class="emphasis"><em>string literal</em></span> is a sequence of Unicode 
            characters, inside double quotes.</p><pre data-language="bnf">StringLiteral: """ StringCharacter* """</pre><pre data-language="bnf">StringCharacter: ~( "\" | """ | "`" ) | "`" ~"`" | EscapeSequence</pre><p>A string literal may contain escape sequences. An escape sequence is 
            replaced by its corresponding Unicode character during lexical analysis.</p><p>A sequence of two backticks is used to delimit an interpolated expression
            embedded in a string template.</p><pre data-language="bnf">StringStart: """ StringCharacter* "``"</pre><pre data-language="bnf">StringMid: "``" StringCharacter* "``"</pre><pre data-language="bnf">StringEnd: "``" StringCharacter* """</pre><p>A <span class="emphasis"><em>verbatim string</em></span> is a character sequence delimited
            by a sequence of three double quotes. Verbatim strings do not contain escape
            sequences or interpolated expressions, so every character occurring inside the
            verbatim string is interpreted literally.</p><pre data-language="bnf">VerbatimStringLiteral: """"" VerbatimCharacter* """""</pre><pre data-language="bnf">VerbatimCharacter: ~""" | """ ~""" | """ """ ~"""</pre><p>The following are legal strings:</p><pre data-language="ceylon">"Hello!"</pre><pre data-language="ceylon">"\{00E5}ngstr\{00F6}ms"</pre><pre data-language="ceylon">" \t\n\f\r,;:"</pre><pre data-language="ceylon">"\{POLICE CAR} \{TROLLEYBUS} \{WOMAN WITH BUNNY EARS}"</pre><pre data-language="ceylon">"""This program prints "hello world" to the console."""</pre><p>The column in which the first character of a string literal occurs, excluding the 
            opening quote characters, is called the <span class="emphasis"><em>initial column</em></span> of the string 
            literal. Every following line of a multiline string literal must contain whitespace up to 
            the initial column. That is, if the string contents begin at the <tt class="literal">n</tt>th 
            character in a line of text, the following lines must start with <tt class="literal">n</tt> 
            whitespace characters. This required whitespace is removed from the string literal during 
            lexical analysis.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="operatorsanddelimiters"></a>2.5.&nbsp;Operators and delimiters</h2></div></div><div></div></div><p>The following character sequences are operators and/or punctuation:</p><p><tt class="literal">
        , ; ...
        { } ( ) [ ] `
        ?
        . ?. *. 
        = =&gt;
        + - * / % ^ **
        ++ --
        .. : -&gt;
        ! &amp;&amp; ||
        ~ &amp; |
        === == != &lt; &gt; &lt;= &gt;= &lt;=&gt;
        += -= /= *= %= |= &amp;= ~= ||= &amp;&amp;=
        </tt></p><p>Certain symbols serve dual or multiple purposes in the grammar.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="typesystem"></a>Chapter&nbsp;3.&nbsp;Type system</h2></div></div><div></div></div><p>Every value in a Ceylon program is an instance of a type that can be expressed 
    within the Ceylon language as a <span class="emphasis"><em>class</em></span>. The language does not 
    define any primitive or compound types that cannot, in principle, be expressed within 
    the language itself.</p><p>A class, fully defined in <a href="#classes" title="4.5.&nbsp;Classes">&sect;4.5 Classes</a>, is a recipe for producing 
    new values, called <span class="emphasis"><em>instances</em></span>
    of the class (or simply <span class="emphasis"><em>objects</em></span>), and defines the operations and 
    attributes of the resulting values. A class instance may hold references to other 
    objects, and has an identity distinct from these references.</p><p>Each class declaration defines a type. However, not all types are classes. It 
    is often advantageous to write generic code that abstracts the concrete class of a 
    value. This technique is called <span class="emphasis"><em>polymorphism</em></span>. Ceylon features 
    two different kinds of polymorphism:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>subtype polymorphism</em></span>, where a subtype <tt class="literal">B</tt>
            inherits a supertype <tt class="literal">A</tt>, and</p></li><li><p><span class="emphasis"><em>parametric polymorphism</em></span>, where a type definition 
            <tt class="literal">A&lt;T&gt;</tt> is parameterized by a <span class="emphasis"><em>generic type 
            parameter</em></span> <tt class="literal">T</tt>.</p></li></ul></div><p>Ceylon, like Java and many other object-oriented languages, features a single
    inheritance model for classes. A class may directly inherit at most one other class, 
    and all classes eventually inherit, directly or indirectly, the class 
    <tt class="literal">Anything</tt> defined in the module <tt class="literal">ceylon.language</tt>, 
    which acts as the root of the class hierarchy.</p><p>A truly hierarchical type system is much too restrictive for more abstract 
    programming tasks. Therefore, in addition to classes, Ceylon recognizes the following 
    kinds of type:</p><div class="itemizedlist"><ul type="disc"><li><p>An <span class="emphasis"><em>interface</em></span>, defined in <a href="#interfaces" title="4.4.&nbsp;Interfaces">&sect;4.4 Interfaces</a>, 
            is an abstract type schema that cannot itself be directly instantiated. An 
            interface may define concrete members, but these members may not hold references 
            to other objects. A class may inherit one or more interfaces. An instance of a 
            class that inherits an interface is also considered an instance of the interface.</p></li><li><p>A <span class="emphasis"><em>generic type parameter</em></span>, defined in 
            <a href="#generictypeparameters" title="3.5.&nbsp;Generic type parameters">&sect;3.5 Generic type parameters</a>, is considered a type within the 
            declaration that it parameterizes. In fact, it is an abstraction over many types: 
            it generalizes the declaration to all types which could be assigned to the 
            parameter.</p></li><li><p>An <span class="emphasis"><em>applied type</em></span>, defined in 
            <a href="#generictypearguments" title="3.6.&nbsp;Generic type arguments">&sect;3.6 Generic type arguments</a>, is formed by specifying arguments for the 
            generic type parameters of a parameterized type.</p></li><li><p>A <span class="emphasis"><em>union type</em></span>, defined in <a href="#uniontypes" title="3.2.3.&nbsp;Union types">&sect;3.2.3 Union types</a>, 
            is a type to which each of an enumerated list of types is assignable.</p></li><li><p>An <span class="emphasis"><em>intersection type</em></span>, defined in 
            <a href="#intersectiontypes" title="3.2.4.&nbsp;Intersection types">&sect;3.2.4 Intersection types</a>, is a type which is assignable to each of an 
            enumerated list of types.</p></li></ul></div><p>Although we often use the term <span class="emphasis"><em>parameterized type</em></span> or even
    <span class="emphasis"><em>generic type</em></span> to refer to a parameterized type definition, it is
    important to keep in mind that a parameterized type definition is not itself a type.
    Rather, it is a <span class="emphasis"><em>type constructor</em></span>, a function that maps types 
    to types. Given a list of type arguments, the function yields an applied type.</p><p>In light of the fact that Ceylon makes it so easy to construct new types from
    existing types <span class="emphasis"><em>without the use of inheritance</em></span>, by forming unions, 
    intersections, and applied types, it's often useful to assign a name to such a type.</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>type alias</em></span>, defined in 
            <a href="#typealiasedeclarations" title="4.6.&nbsp;Type aliases">&sect;4.6 Type aliases</a>, <a href="#classaliases" title="4.5.9.&nbsp;Class aliases">&sect;4.5.9 Class aliases</a>, 
            and <a href="#interfacealiases" title="4.4.5.&nbsp;Interface aliases">&sect;4.4.5 Interface aliases</a>, is a synonym for an expression 
            involving other types or generic types. A type alias may itself be 
            generic.</p></li></ul></div><p>The Ceylon type system is much more complete than most other object oriented
    languages. In Ceylon, it's possible to answer questions that might at first sound
    almost nonsensical if you're used to languages with more traditional type systems. 
    For example:</p><div class="itemizedlist"><ul type="disc"><li><p>What is the type of a variable that may or may not hold a value of 
            type <tt class="literal">Element</tt>?</p></li><li><p>What is the type of a parameter that accepts either an 
            <tt class="literal">Integer</tt> or a <tt class="literal">Float</tt>?</p></li><li><p>What is the type of a parameter that accepts values which are instances 
            of both <tt class="literal">Persistent</tt> and <tt class="literal">Printable</tt>?</p></li><li><p>What is the type of a function which accepts any non-null value and 
            returns a <tt class="literal">String</tt>?</p></li><li><p>What is the type of a function that accepts one or more
            <tt class="literal">String</tt>s and returns an iterable object producing at least 
            one <tt class="literal">String</tt>?</p></li><li><p>What is the type of a sequence consisting of a <tt class="literal">String</tt>
            followed by two <tt class="literal">Float</tt>s?</p></li><li><p>What is the type of a list with no elements?</p></li></ul></div><p>The answers, as we shall see, are: <tt class="literal">Element?</tt>, 
    <tt class="literal">Integer|Float</tt>, <tt class="literal">Persistent&amp;Printable</tt>, 
    <tt class="literal">String(Object)</tt>, <tt class="literal">{String+}(String+)</tt>,   
    <tt class="literal">[String,Float,Float]</tt>, and <tt class="literal">List&lt;Nothing&gt;</tt>.</p><p>It's important that there is always a unique "best" answer to questions
    like these in Ceylon. The "best" answer is called the <span class="emphasis"><em>principal type
    of an expression</em></span>. Every other type to which the expression is 
    assignable is a supertype of the principal type.</p><p>Thus, every legal Ceylon expression has a unique, well-defined type, 
    representable within the type system, without reference to how the expression 
    is used or to what type it is assigned. This is the case even when type inference 
    or type argument inference comes into play.</p><p>Neither this specification nor the internal implementation of the Ceylon 
    compiler itself use any kind of "non-denotable" types. Every type mentioned 
    here or inferred internally by the compiler has a representation within the 
    language itself. Thus, the programmer is never exposed to confusing error 
    messages referring to mysterious types that are not part of the syntax of the 
    language.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="identifiernaming"></a>3.1.&nbsp;Identifier naming</h2></div></div><div></div></div><p>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase letter. Methods, attributes, parameters, 
        and locals must be named with an initial lowercase letter or underscore.
        The grammar for identifiers is defined by 
        <a href="#identifiersandkeywords" title="2.3.&nbsp;Identifiers and keywords">&sect;2.3 Identifiers and keywords</a>.</p><pre data-language="bnf">TypeName: UIdentifier</pre><pre data-language="bnf">MemberName: LIdentifier</pre><p>A package or module name is a sequence of identifiers, each with an 
        initial lowercase letter or underscore.</p><pre data-language="bnf">PackageName: LIdentifier</pre><p>Ceylon defines three identifier namespaces:</p><div class="itemizedlist"><ul type="disc"><li><p>classes, interfaces, type aliases, and type parameters share 
                a single namespace,</p></li><li><p>functions, values, and parameters share a single namespace, 
                and</p></li><li><p>packages have their own dedicated namespace.</p></li></ul></div><p>The Ceylon parser is able to unambiguously identify which namespace an 
        identifier belongs to.</p><p>An identifier that begins with an initial lowercase letter may be 
        <span class="emphasis"><em>forced</em></span> into the namespace of types by prefixing the
        identifier <tt class="literal">\I</tt>. An identifier that begins with an initial
        uppercase letter may be forced into the namespace of methods and attributes
        by prefixing the identifier <tt class="literal">\i</tt>. A keyword may be used as 
        an identifier by prefixing the keyword with either <tt class="literal">\i</tt> or 
        <tt class="literal">\I</tt>. This allows interoperation with languages like Java 
        which do not enforce these naming conventions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="type"></a>3.2.&nbsp;Types</h2></div></div><div></div></div><p>A <span class="emphasis"><em>type</em></span> or <span class="emphasis"><em>type schema</em></span> is a name 
        (an initial uppercase identifier) and an optional list of type parameters, with 
        a set of:</p><div class="itemizedlist"><ul type="disc"><li><p>value schemas,</p></li><li><p>function schemas, and</p></li><li><p>class schemas.</p></li></ul></div><p>The value, function, and class schemas are called the <span class="emphasis"><em>members</em></span> 
        of the type.</p><p>Speaking formally:</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>value schema</em></span> is a name (an initial 
                lowercase identifier) with a type and mutability.</p></li><li><p>A <span class="emphasis"><em>function schema</em></span> is a name (an initial 
                lowercase identifier) and an optional list of type parameters, with a 
                type (often called the <span class="emphasis"><em>return type</em></span>) and a sequence 
                of one or more parameter lists.</p></li><li><p>A <span class="emphasis"><em>class schema</em></span> is a type schema with exactly
                one parameter list.</p></li><li><p>A <span class="emphasis"><em>parameter list</em></span> is a list of names (initial 
                lowercase identifiers) with types. The <span class="emphasis"><em>signature</em></span> of 
                a parameter list is formed by discarding the names, leaving the list of 
                types.</p></li></ul></div><p>Speaking slightly less formally, we usually refer to an <span class="emphasis"><em>attribute</em></span>, 
        <span class="emphasis"><em>method</em></span>, or <span class="emphasis"><em>member class</em></span> of a type, meaning 
        a value schema, function schema, or class schema that is a member of the type.</p><p>A function or value schema may occur outside of a type schema. If it occurs 
        directly in a compilation unit, we often call it a <span class="emphasis"><em>toplevel function</em></span> 
        or <span class="emphasis"><em>toplevel value</em></span>.</p><p>A value schema, function schema, or parameter list with a missing type or types 
        may be defined. A value schema, function schema, or parameter list with a missing type 
        is called <span class="emphasis"><em>partially typed</em></span>.</p><p>Two signatures are considered identical if they have exactly the same types, at
        exactly the same positions, and missing types at exactly the same positions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="memberdistinctness"></a>3.2.1.&nbsp;Member distinctness</h3></div></div><div></div></div><p>Overloading is illegal in Ceylon. A type may not have:</p><div class="itemizedlist"><ul type="disc"><li><p>two attributes with the same name,</p></li><li><p>a method and an attribute with the same name,</p></li><li><p>two methods with the same name, or</p></li><li><p>two member classes with the same name.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="subtyping"></a>3.2.2.&nbsp;Subtyping</h3></div></div><div></div></div><p>A type may be a <span class="emphasis"><em>subtype</em></span> of another type. Subtyping obeys 
            the following rules:</p><div class="itemizedlist"><ul type="disc"><li><p>Identity: <tt class="literal">X</tt> is a subtype of <tt class="literal">X</tt>.</p></li><li><p>Transitivity: if <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>
                    and <tt class="literal">Y</tt> is a subtype of <tt class="literal">Z</tt> then
                    <tt class="literal">X</tt> is a subtype of <tt class="literal">Z</tt>.</p></li><li><p>Noncircularity: if <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>
                    and <tt class="literal">Y</tt> is a subtype of <tt class="literal">X</tt> then
                    <tt class="literal">Y</tt> and <tt class="literal">X</tt> are the same type.</p></li><li><p>Single root: all types are subtypes of the class <tt class="literal">Anything</tt>
                    defined in the module <tt class="literal">ceylon.language</tt>.</p></li></ul></div><p>Every interface type is a subtype of the class <tt class="literal">Object</tt> 
            defined in <tt class="literal">ceylon.language</tt>.</p><p>If <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>, then:</p><div class="itemizedlist"><ul type="disc"><li><p>For each non-<tt class="literal">variable</tt> attribute of <tt class="literal">Y</tt>, 
                    <tt class="literal">X</tt> has an attribute with the same name, whose type is 
                    assignable to the type of the attribute of <tt class="literal">Y</tt>.</p></li><li><p>For each <tt class="literal">variable</tt> attribute of <tt class="literal">Y</tt>, 
                    <tt class="literal">X</tt> has a <tt class="literal">variable</tt> attribute with the 
                    same name and the same type.</p></li><li><p>For each method of <tt class="literal">Y</tt>, <tt class="literal">X</tt> has a 
                    method with the same name, with the same number of parameter lists, with 
                    the same signatures, and whose return type is assignable to the return type 
                    of the method of <tt class="literal">Y</tt>.</p></li><li><p>For each member class of <tt class="literal">Y</tt>, <tt class="literal">X</tt>
                    has a member class of the same name, with a parameter list with the same 
                    signature, that is a subtype of the member class of <tt class="literal">Y</tt>.</p></li></ul></div><p>Furthermore, we say that <tt class="literal">X</tt> is <span class="emphasis"><em>assignable</em></span>
            to <tt class="literal">Y</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="uniontypes"></a>3.2.3.&nbsp;Union types</h3></div></div><div></div></div><p>For any types <tt class="literal">X</tt> and <tt class="literal">Y</tt>, the 
            <span class="emphasis"><em>union</em></span>, or <span class="emphasis"><em>disjunction</em></span>, <tt class="literal">X|Y</tt>, 
            of the types may be formed. A union type is a supertype of both of the given types 
            <tt class="literal">X</tt> and <tt class="literal">Y</tt>, and an instance of either type is an 
            instance of the union type.</p><p>The union type constructor <tt class="literal">|</tt> is associative, so the union 
            of three types, <tt class="literal">X</tt>, <tt class="literal">Y</tt>, and <tt class="literal">Z</tt>, 
            may be written <tt class="literal">X|Y|Z</tt>.</p><pre data-language="bnf">UnionType: IntersectionType ("|" IntersectionType)*</pre><p>If <tt class="literal">X</tt> and <tt class="literal">Y</tt> are both subtypes of a third type 
            <tt class="literal">Z</tt>, then <tt class="literal">X|Y</tt> inherits all members of <tt class="literal">Z</tt>.</p><pre data-language="ceylon">void write(String|Integer|Float printable) { ... }</pre><p>Union types satisfy the following rules, for any types <tt class="literal">X</tt>,
            <tt class="literal">Y</tt>, and <tt class="literal">Z</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        Commutativity: <tt class="literal">X|Y</tt> is the same 
                        type as <tt class="literal">Y|X</tt>.
                    </p></li><li><p>
                        Associativity: <tt class="literal">X|(Y|Z)</tt> is the same 
                        type as <tt class="literal">(X|Y)|Z</tt>.
                    </p></li><li><p>
                        Simplification: if <tt class="literal">X</tt> is a subtype 
                        of <tt class="literal">Y</tt>, then <tt class="literal">X|Y</tt> 
                        is the same type as <tt class="literal">Y</tt>.
                    </p></li><li><p>
                        Subtypes: <tt class="literal">X</tt> is a subtype of 
                        <tt class="literal">X|Y</tt>.
                    </p></li><li><p>
                        Supertypes: if both <tt class="literal">X</tt> and 
                        <tt class="literal">Y</tt> are subtypes of <tt class="literal">Z</tt>, 
                        then <tt class="literal">X|Y</tt> is also a subtype of
                        <tt class="literal">Z</tt>.
                    </p></li></ul></div><p>The following results follow from these rules:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">X|Nothing</tt> is the same  type as <tt class="literal">X</tt> 
                        for any type <tt class="literal">X</tt>, and
                    </p></li><li><p>
                        <tt class="literal">X|Anything</tt> is the same type as <tt class="literal">Anything</tt>
                        for any type <tt class="literal">X</tt>.
                    </p></li></ul></div><p>Finally:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">X&lt;T&gt;</tt> is covariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;|X&lt;V&gt;</tt> is a
                    subtype of <tt class="literal">X&lt;U|V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">X&lt;T&gt;</tt> is contravariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;|X&lt;V&gt;</tt> is a
                    subtype of <tt class="literal">X&lt;U&amp;V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="intersectiontypes"></a>3.2.4.&nbsp;Intersection types</h3></div></div><div></div></div><p>For any types <tt class="literal">X</tt> and <tt class="literal">Y</tt>, the 
            <span class="emphasis"><em>intersection</em></span>, or <span class="emphasis"><em>conjunction</em></span>,
            <tt class="literal">X&amp;Y</tt>, of the types may be formed. An intersection type is a 
            subtype of both of the given types <tt class="literal">X</tt> and <tt class="literal">Y</tt>, 
            and any object which is an instance of both types is an instance of the intersection 
            type.</p><p>The intersection type constructor <tt class="literal">&amp;</tt> is associative, 
            so the intersection of three types, <tt class="literal">X</tt>, <tt class="literal">Y</tt>, 
            and <tt class="literal">Z</tt>, may be written <tt class="literal">X&amp;Y&amp;Z</tt>.</p><pre data-language="bnf">IntersectionType: PrimaryType ("&amp;" PrimaryType)*</pre><p>The intersection <tt class="literal">X&amp;Y</tt> inherits all members of both
            <tt class="literal">X</tt> and <tt class="literal">Y</tt>.</p><pre data-language="ceylon">void store(Persistent&amp;Printable&amp;Identifiable storable) { ... }</pre><p>Intersection types satisfy the following rules, for any types <tt class="literal">X</tt>,
            <tt class="literal">Y</tt>, and <tt class="literal">Z</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        Commutativity: <tt class="literal">X&amp;Y</tt> is the same 
                        type as <tt class="literal">Y&amp;X</tt>.
                    </p></li><li><p>
                        Associativity: <tt class="literal">X&amp;(Y&amp;Z)</tt> is the same 
                        type as <tt class="literal">(X&amp;Y)&amp;Z</tt>.
                    </p></li><li><p>
                        Simplification: if <tt class="literal">X</tt> is a subtype 
                        of <tt class="literal">Y</tt>, then <tt class="literal">X&amp;Y</tt> 
                        is the same type as <tt class="literal">X</tt>.
                    </p></li><li><p>
                        Supertypes: <tt class="literal">X</tt> is a supertype of 
                        <tt class="literal">X&amp;Y</tt>.
                    </p></li><li><p>
                        Subtypes: if both <tt class="literal">X</tt> and 
                        <tt class="literal">Y</tt> are supertypes of <tt class="literal">Z</tt>, 
                        then <tt class="literal">X&amp;Y</tt> is also a supertype of
                        <tt class="literal">Z</tt>.
                    </p></li><li><p>
                        Distributivity over union: <tt class="literal">X&amp;(Y|Z)</tt> is the same 
                        type as <tt class="literal">(X&amp;Y)|(X&amp;Z)</tt>.
                    </p></li></ul></div><p>The following results follow from these rules:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">X&amp;Nothing</tt> is the same type as <tt class="literal">Nothing</tt> 
                        for any type <tt class="literal">X</tt>, and
                    </p></li><li><p>
                        <tt class="literal">X&amp;Anything</tt> is the same type as <tt class="literal">X</tt>
                        for any type <tt class="literal">X</tt>.
                    </p></li></ul></div><p>Finally:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">X&lt;T&gt;</tt> is covariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;&amp;X&lt;V&gt;</tt> is a
                    supertype of <tt class="literal">X&lt;U&amp;V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">X&lt;T&gt;</tt> is contravariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;&amp;X&lt;V&gt;</tt> is a
                    supertype of <tt class="literal">X&lt;U|V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bottomtype"></a>3.2.5.&nbsp;The bottom type</h3></div></div><div></div></div><p>The special type <tt class="literal">Nothing</tt>, sometimes called the
            <span class="emphasis"><em>bottom type</em></span>, represents:</p><div class="itemizedlist"><ul type="disc"><li><p>the intersection of all types, or, equivalently</p></li><li><p>the empty set.</p></li></ul></div><p><tt class="literal">Nothing</tt> is assignable to all other types, but has
            no instances.</p><p>The type schema for <tt class="literal">Nothing</tt> is empty, that is, it
            is considered to have no members.</p><p><tt class="literal">Nothing</tt> is considered to belong to the module
            <tt class="literal">ceylon.language</tt>. However, it cannot be defined within
            the language.</p><p>Because of the restrictions imposed by Ceylon's mixin inheritance 
            model:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">X</tt> and <tt class="literal">Y</tt> are classes, and
                <tt class="literal">X</tt> is not a subclass of <tt class="literal">Y</tt>, and 
                <tt class="literal">Y</tt> is not a subclass of <tt class="literal">X</tt>, then
                the intersection type <tt class="literal">X&amp;Y</tt> is equivalent to 
                <tt class="literal">Nothing</tt>.</p></li><li><p>If <tt class="literal">X</tt> is an interface, the intersection type 
                <tt class="literal">X&amp;Null</tt> is equivalent to <tt class="literal">Nothing</tt>.</p></li><li><p>If <tt class="literal">X</tt> is an interface, and <tt class="literal">Y</tt>
                is a <tt class="literal">final</tt> class, and <tt class="literal">Y</tt> is not a
                subtype of <tt class="literal">X</tt>, then the intersection type 
                <tt class="literal">X&amp;Y</tt> is equivalent to <tt class="literal">Nothing</tt>.</p></li><li><p>If <tt class="literal">X&lt;T&gt;</tt> is invariant in its type parameter
                <tt class="literal">T</tt>, and the distinct types <tt class="literal">A</tt> and 
                <tt class="literal">B</tt> do not involve type parameters, then 
                <tt class="literal">X&lt;A&gt;&amp;X&lt;B&gt;</tt> is equivalent to 
                <tt class="literal">Nothing</tt>.</p></li></ul></div><i><span class="comment"><p>Note: an expression of type <tt class="literal">Nothing</tt> results 
            in a compiler warning.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="principaltyping"></a>3.2.6.&nbsp;Principal typing</h3></div></div><div></div></div><p>An expression, as defined in <a href="#expressions" title="Chapter&nbsp;6.&nbsp;Expressions">Chapter&nbsp;6, <i>Expressions</i></a>, occurring at a 
            certain location, may be <span class="emphasis"><em>assignable</em></span> to a type. In this case, 
            every evaluation of the expression at runtime produces an instance of a class that 
            is a subtype of the type, or results in a thrown exception, as defined in 
            <a href="#execution" title="Chapter&nbsp;8.&nbsp;Execution">Chapter&nbsp;8, <i>Execution</i></a>.</p><p>Given an expression occurring at a certain location, a type <tt class="literal">T</tt>
            is the <span class="emphasis"><em>principal type</em></span> of the expression if, given any type
            <tt class="literal">U</tt> to which the expression is assignable, <tt class="literal">T</tt> 
            is a subtype of <tt class="literal">U</tt>. Thus, the principal type is the "most precise"
            type for the expression. The type system guarantees that every expression has a 
            principal type. Thus, we refer uniquely to <span class="emphasis"><em>the type of an expression</em></span>, 
            meaning its principal type at the location at which it occurs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeexpressions"></a>3.2.7.&nbsp;Type expressions</h3></div></div><div></div></div><p>Function and value declarations usually declare a type, by specifying
            a <span class="emphasis"><em>type expression</em></span>.</p><pre data-language="bnf">Type: UnionType | EntryType</pre><p>Type expressions are formed by combining types using union, intersection, 
            and type abbreviations.</p><p>Type expressions support grouping using angle brackets:</p><pre data-language="bnf">GroupedType: "&lt;" Type "&gt;"</pre><p>Applied types are identified by the name of the type (a class, interface, 
            type alias, or type parameter), together with a list of type arguments if the 
            type declaration is generic.</p><pre data-language="bnf">TypeNameWithArguments: TypeName TypeArguments?</pre><p>Type names are resolved to type declarations according to 
            <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a> and 
            <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list of the 
            realization of the type declaration, as defined by 
            <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><i><span class="comment"><p>Note: this is too heavy-handed. There is no reason to enforce 
            types constraint in any place other than generic class instantiations, generic 
            function invocations, <tt class="literal">extends</tt>, and <tt class="literal">satisfies</tt>. 
            However, this restriction makes interoperation with Java generics more 
            straightforward.</p></span></i><p>If the type is a class, interface, or type alias nested inside a containing 
            class or interface, the type must be fully qualified by its containing types, 
            except when used inside the body of a containing type.</p><pre data-language="bnf">BaseType: TypeNameWithArguments | GroupedType</pre><pre data-language="bnf">QualifiedType: BaseType ("." TypeNameWithArguments)*</pre><p>If a type declaration is generic, a type argument list must be specified. 
            If a type declaration is not generic, no type argument list may be specified.</p><pre data-language="ceylon">BufferedReader.Buffer</pre><pre data-language="ceylon">Entry&lt;Integer,Element&gt;</pre><i><span class="comment"><p>Note: the name of a type may not be qualified by its package name.
            Alias imports, as defined in <a href="#aliasimports" title="4.2.3.&nbsp;Alias imports">&sect;4.2.3 Alias imports</a> may be used to 
            disambiguate type names.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typenameabbreviations"></a>3.2.8.&nbsp;Type abbreviations</h3></div></div><div></div></div><p>Certain important types may be written using an abbreviated syntax.</p><pre data-language="bnf">PrimaryType: AtomicType | OptionalType | SequenceType | CallableType</pre><pre data-language="bnf">AtomicType: QualifiedType | EmptyType | TupleType | IterableType</pre><p>First, there are postfix-style abbreviations for <span class="emphasis"><em>optional types</em></span>, 
            <span class="emphasis"><em>sequence types</em></span>, and <span class="emphasis"><em>callable types</em></span>.</p><pre data-language="bnf">OptionalType: PrimaryType "?"</pre><pre data-language="bnf">SequenceType: PrimaryType "[" "]"</pre><pre data-language="bnf">CallableType: PrimaryType "(" TypeList? ")"</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X?</tt> means <tt class="literal">Null|X</tt> for any 
                    type <tt class="literal">X</tt>,</p></li><li><p><tt class="literal">X[]</tt> means <tt class="literal">Sequential&lt;X&gt;</tt> 
                    for any type <tt class="literal">X</tt>, and</p></li><li><p><tt class="literal">X(Y,Z)</tt> means <tt class="literal">Callable&lt;X,[Y,Z]&gt;</tt>
                    where <tt class="literal">Y,Z</tt> is a list of types of any length.</p></li></ul></div><p>More precisely, the type meant by a callable type abbreviation is
            <tt class="literal">Callable&lt;X,T&gt;</tt> where <tt class="literal">X</tt> is the type 
            outside the parentheses in the the callable type abbreviation, and 
            <tt class="literal">T</tt> is the tuple type formed by the types listed inside the 
            parentheses.</p><p>Next, abbreviations for <span class="emphasis"><em>iterable types</em></span> are written
            using braces.</p><pre data-language="bnf">IterableType: "{" UnionType ("*"|"+") "}"</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">{X*}</tt> means <tt class="literal">Iterable&lt;X,Null&gt;</tt> 
                    for any type <tt class="literal">X</tt>, and</p></li><li><p><tt class="literal">{X+}</tt> means <tt class="literal">Iterable&lt;X,Nothing&gt;</tt> 
                    for any type <tt class="literal">X</tt>.</p></li></ul></div><p>Next, abbreviations for <span class="emphasis"><em>sequence types</em></span> and 
            <span class="emphasis"><em>tuple types</em></span> may be written using brackets.</p><pre data-language="bnf">EmptyType: "[" "]"</pre><pre data-language="bnf">TupleType: "[" TypeList "]"</pre><pre data-language="bnf">TypeList: (DefaultedType ",")* (DefaultedType | VariadicType)</pre><pre data-language="bnf">DefaultedType: Type "="?</pre><pre data-language="bnf">VariadicType: UnionType ("*" | "+")</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">[]</tt> means <tt class="literal">Empty</tt>,</p></li><li><p><tt class="literal">[X*]</tt> means <tt class="literal">Sequential&lt;X&gt;</tt> 
                    for any type <tt class="literal">X</tt>,</p></li><li><p><tt class="literal">[X+]</tt> means <tt class="literal">Sequence&lt;X&gt;</tt> 
                    for any type <tt class="literal">X</tt>,</p></li><li><p><tt class="literal">[X,Y]</tt> means 
                    <tt class="literal">Tuple&lt;X|Y,X,Tuple&lt;Y,Y,[]&gt;&gt;</tt> for 
                    any types <tt class="literal">X,Y</tt>,</p></li><li><p><tt class="literal">[X,Y*]</tt> means 
                    <tt class="literal">Tuple&lt;X|Y,X,Sequential&lt;Y&gt;&gt;</tt> for 
                    any types <tt class="literal">X,Y</tt>,</p></li><li><p><tt class="literal">[X,Y+]</tt> means 
                    <tt class="literal">Tuple&lt;X|Y,X,Sequence&lt;Y&gt;&gt;</tt> for 
                    any types <tt class="literal">X,Y</tt>, and</p></li><li><p><tt class="literal">[X,Y=]</tt> means 
                    <tt class="literal">Tuple&lt;X|Y,X,Tuple&lt;Y,Y,[]&gt;&gt;|Tuple&lt;X,X,[]&gt;</tt> 
                    for any types <tt class="literal">X,Y</tt>.</p></li></ul></div><p>More precisely:</p><div class="itemizedlist"><ul type="disc"><li><p>A tuple type abbreviation of form <tt class="literal">[X, ... ]</tt>
                    means the type <tt class="literal">Tuple&lt;X|Y,X,T&gt;</tt> where 
                    <tt class="literal">T</tt> is the type meant by the type abbreviation formed 
                    by removing the first type <tt class="literal">X</tt> from the list of types 
                    in the original tuple type abbreviation, and <tt class="literal">T</tt> has 
                    the principal instantiation <tt class="literal">Y[]</tt>, as defined in
                    <a href="#principalinstantiations" title="3.7.&nbsp;Principal instantiations and polymorphism">&sect;3.7 Principal instantiations and polymorphism</a>.</p></li><li><p>A tuple type abbreviation of form <tt class="literal">[ ..., Y= ]</tt>
                    means the type <tt class="literal">U|V</tt> where <tt class="literal">U</tt> is the 
                    type meant by the whole tuple type abbreviation, and <tt class="literal">V</tt> 
                    is the type meant by the type abbreviation formed by removing the last 
                    type <tt class="literal">Y</tt> from the list of types in the whole tuple type 
                    abbreviation.</p></li></ul></div><p>In a tuple type or callable type expression:</p><div class="itemizedlist"><ul type="disc"><li><p>an <span class="emphasis"><em>defaulted element</em></span> is indicated with a
                    postfix <tt class="literal">=</tt> or <tt class="literal">*</tt>, and</p></li><li><p>a <span class="emphasis"><em>required element</em></span> is indicated with a 
                    postfix <tt class="literal">+</tt> or no special marker.</p></li></ul></div><p>In a tuple type or callable type expression, every defaulted element must 
            occur after every required element.</p><p>Finally, an <span class="emphasis"><em>entry type</em></span> may be abbreviated using an 
            arrow.</p><pre data-language="bnf">EntryType: UnionType "-&gt;" UnionType</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X-&gt;Y</tt> means <tt class="literal">Entry&lt;X,Y&gt;</tt>, 
                    for any types <tt class="literal">X</tt>, <tt class="literal">Y</tt>.</p></li></ul></div><i><span class="comment"><p>Note: the abbreviations <tt class="literal">T[]</tt> and 
            <tt class="literal">[T*]</tt> are synonyms. The syntax <tt class="literal">T[]</tt> is
            supported for reasons of nostalgia.</p></span></i><p>Abbreviations may be combined:</p><pre data-language="ceylon">String?[] words = { "hello", "world", null };
String? firstWord = words[0];

String-&gt;[Integer,Integer] onetwo = "onetwo"-&gt;[1, 2];

[Float+](Float x, Float[] xs) add = (Float x, Float[] xs) =&gt; [x, *xs];</pre><p>When a type appears in a value expression, these abbreviations cannot be used 
            (they cannot be disambiguated from operator expressions).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeinference"></a>3.2.9.&nbsp;Type inference</h3></div></div><div></div></div><p>Certain declarations which usually require an explicit type may omit the type, 
            forcing the compiler to infer it, by specifying the keyword <tt class="literal">value</tt>,
            as defined in <a href="#valuetypeinference" title="4.8.4.&nbsp;Value type inference">&sect;4.8.4 Value type inference</a>, or <tt class="literal">function</tt>,
            as defined in <a href="#returntypeinference" title="4.7.4.&nbsp;Function return type inference">&sect;4.7.4 Function return type inference</a>, where the type usually appears.</p><pre data-language="ceylon">value names = people*.name;</pre><pre data-language="ceylon">function parse(String text) =&gt; text.split(" .!?,:;()\n\f\r\t".contains);</pre><p>Type inference is only allowed for declarations which are referred to only by 
            statements and declarations that occur within the lexical scope of the declaration, 
            as specified by <a href="#typeinferenceandblockstructure" title="5.1.6.&nbsp;Type inference and block structure">&sect;5.1.6 Type inference and block structure</a>. A 
            <tt class="literal">value</tt> or <tt class="literal">function</tt> declaration may not:</p><div class="itemizedlist"><ul type="disc"><li><p>be annotated <tt class="literal">shared</tt>, as defined in
                    <a href="#visibility" title="5.1.3.&nbsp;Visibility">&sect;5.1.3 Visibility</a>,</p></li><li><p>occur as a toplevel declaration in a compilation unit, as 
                    defined in <a href="#topleveldeclarations" title="4.1.1.&nbsp;Toplevel and nested declarations">&sect;4.1.1 Toplevel and nested declarations</a>, or</p></li><li><p>be referred to by statements or declarations that occur earlier in 
                    the body containing of the declaration, as defined in 
                    <a href="#blockstructure" title="5.1.&nbsp;Block structure and references">&sect;5.1 Block structure and references</a>.</p></li></ul></div><p>Nor may a parameter or forward-declared value, as defined in 
            <a href="#valueforwarddeclaration" title="4.8.5.&nbsp;Forward declaration of values">&sect;4.8.5 Forward declaration of values</a>, or of a forward-declared function, as 
            defined in <a href="#functionforwarddeclaration" title="4.7.5.&nbsp;Forward declaration of functions">&sect;4.7.5 Forward declaration of functions</a>, have an inferred type.</p><p>These restrictions allow the compiler to infer undeclared types in a single 
            pass of the code.</p><i><span class="comment"><p>Note: in future releases of the language, the inferred type will
            be context-dependent, that is, in program elements immediately following an
            assignment or specification, the inferred type will be the type just assigned.
            When conditional execution results in definite assignment, the inferred type
            will be the union of the conditionally assigned types. This will allow us to to
            relax the restriction that forward-declared functions and values can't have their
            type inferred. For example:</p>
            <pre data-language="ceylon">value one;
if (float) {
    one = 1.0;
    Float float = one;
}
else {
    one = 1;
    Integer int = one;
}
Float|Integer num = one;</pre></span></i><p>An inferred type never involves an anonymous class, as defined in
            <a href="#anonymousclasses" title="4.5.7.&nbsp;Anonymous classes">&sect;4.5.7 Anonymous classes</a>. When an inferred type would involve an 
            anonymous class type, the anonymous class is replaced by the intersection 
            of the class type it extends with all interface types it satisfies.</p><i><span class="comment"><p>TODO: properly define how expressions with no type occurring 
            in a <tt class="literal">dynamic</tt> block affect type inference.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typealiaselimination"></a>3.2.10.&nbsp;Type alias elimination</h3></div></div><div></div></div><p>A <span class="emphasis"><em>type alias</em></span> is a synonym for another type. A
            generic type alias is a type constructor that produces a type alias, given 
            a list of type arguments.</p><p>Every type alias must be reducible to an equivalent type that does
            not involve any type aliases by recursive replacement of type aliases with
            the types they alias. Thus, circular type alias definitions, as in the 
            following example, are illegal:</p><pre data-language="ceylon">alias X =&gt; List&lt;Y&gt;;
alias Y =&gt; List&lt;X&gt;;</pre><p>Replacement of type aliases with the types they alias occurs at 
            compile time, so type aliases are not reified types, as specified in 
            <a href="#reification" title="8.1.2.&nbsp;Type argument reification">&sect;8.1.2 Type argument reification</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance"></a>3.3.&nbsp;Inheritance</h2></div></div><div></div></div><p>Inheritance is a static relationship between classes, interfaces, and type 
        parameters:</p><div class="itemizedlist"><ul type="disc"><li><p>a class may <span class="emphasis"><em>extend</em></span> another class, as defined
                by <a href="#classinheritance" title="4.5.4.&nbsp;Class inheritance">&sect;4.5.4 Class inheritance</a>,</p></li><li><p>a class may <span class="emphasis"><em>satisfy</em></span> one or more interfaces, 
                as defined by <a href="#classinheritance" title="4.5.4.&nbsp;Class inheritance">&sect;4.5.4 Class inheritance</a>,</p></li><li><p>an interface may <span class="emphasis"><em>satisfy</em></span> one or more other 
                interfaces, as defined by <a href="#interfaceinheritance" title="4.4.2.&nbsp;Interface inheritance">&sect;4.4.2 Interface inheritance</a>, or</p></li><li><p>a type parameter may <span class="emphasis"><em>satisfy</em></span> a class and/or 
                one or more interfaces or type parameters, as defined by 
                <a href="#generictypeconstraints" title="3.5.3.&nbsp;Generic type constraints">&sect;3.5.3 Generic type constraints</a>.</p></li></ul></div><p>If a type declaration extends or satisfies a type, we say it 
        <span class="emphasis"><em>inherits</em></span> the type.</p><p>Inheritance relationships may not produce cycles, since that would violate
        the noncircularity rule for subtyping. Thus, a class, interface, or type parameter
        may not, directly or indirectly, inherit itself.</p><i><span class="comment">
        <p>Note: when a type declaration specifies a relationship to other types, 
        Ceylon visually distinguishes between a list of types which conceptually 
        represents a combination of (intersection of) the types, and a list of types 
        which represents a choice between (union of) the types. For example, when a 
        class <tt class="literal">C</tt> satisfies multiple interfaces, they are written as 
        <tt class="literal">X&amp;Y&amp;Z</tt>. On the other hand, the cases of an 
        enumerated class <tt class="literal">E</tt> are written as <tt class="literal">X|Y|Z</tt>.
        This syntax emphasizes that <tt class="literal">C</tt> is also a subtype of the 
        intersection type <tt class="literal">X&amp;Y&amp;Z</tt>, and that <tt class="literal">E</tt> 
        may be narrowed to the union type <tt class="literal">X|Y|Z</tt> using a 
        <tt class="literal">switch</tt> statement or the <tt class="literal">of</tt> operator.</p>
        </span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritanceandsubtyping"></a>3.3.1.&nbsp;Inheritance and subtyping</h3></div></div><div></div></div><p>Inheritance relationships between classes, interfaces, and type parameters
            result in subtyping relationships between types.</p><div class="itemizedlist"><ul type="disc"><li><p>If a type <tt class="literal">X</tt> inherits a type <tt class="literal">Y</tt>, 
                then <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>.</p></li><li><p>If a generic type <tt class="literal">X</tt> inherits a type <tt class="literal">Y</tt> 
                that might involve the type parameters of <tt class="literal">X</tt>, then for any 
                instantiation <tt class="literal">U</tt> of <tt class="literal">X</tt> we can construct 
                a type <tt class="literal">V</tt> by, for every type parameter <tt class="literal">T</tt> 
                of <tt class="literal">X</tt>, substituting the corresponding type argument of 
                <tt class="literal">T</tt> given in <tt class="literal">U</tt> everywhere <tt class="literal">T</tt> 
                occurs in <tt class="literal">Y</tt>, and then <tt class="literal">U</tt> is a subtype of
                <tt class="literal">V</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="extendedclass"></a>3.3.2.&nbsp;Extension</h3></div></div><div></div></div><p>A class may extend another class, in which case the first class is a subtype
            of the second class and inherits its members.</p><pre data-language="bnf">ExtendedType: "extends" ("super" ".")? TypeNameWithArguments PositionalArguments</pre><p>The <tt class="literal">extends</tt> clause must specify exactly one superclass.</p><div class="itemizedlist"><ul type="disc"><li><p>If the superclass is a parameterized type, the <tt class="literal">extends</tt> 
                    clause must also explicitly specify type arguments.</p></li><li><p>The <tt class="literal">extends</tt> clause must specify arguments for the 
                    initializer parameters of the superclass.</p></li></ul></div><p>The type arguments may <span class="emphasis"><em>not</em></span> be inferred from the 
            initializer arguments.</p><pre data-language="ceylon">extends Person(name, org)</pre><p>A member class annotated <tt class="literal">actual</tt> may use the qualifier 
            <tt class="literal">super</tt> in the <tt class="literal">extends</tt> clause to refer to the 
            member class it refines. When the qualifier <tt class="literal">super</tt> appears, the
            following class name refers to a member class of the superclass of the class that
            contains the member class annotated <tt class="literal">actual</tt>.</p><pre data-language="ceylon">extends super.Buffer()</pre><p>The root class <tt class="literal">Anything</tt> defined in 
            <tt class="literal">ceylon.language</tt> does not have a superclass.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="satisfiedinterfaces"></a>3.3.3.&nbsp;Satisfaction</h3></div></div><div></div></div><p>The <tt class="literal">satisfies</tt> clause does double duty. It's used to 
            specify that a class or interface is a direct subtype of one or more interfaces, 
            and to specify upper bound type constraints applying to a type parameter.</p><i><span class="comment"><p>Note: for this reason the keyword is not named 
            "<tt class="literal">implements</tt>". It can't reasonably be said that a type 
            parameter "implements" its upper bounds. Nor can it be reasonably said that
            an interface "implements" its super-interfaces.</p></span></i><div class="itemizedlist"><ul type="disc"><li><p>A class or interface may satisfy one or more interfaces, in which case
                the class or interface is a subtype of the satisfied interfaces, and inherits 
                their members.</p></li><li><p>A type parameter may satisfy one or more interfaces, optionally, a class,
                and optionally, another type parameter. In this case, the satisfied types are 
                interpreted as upper bound type constraints on arguments to the type 
                parameter.</p></li></ul></div><i><span class="comment"><p>Note: currently, a type parameter upper bound may not be specified
            in combination with other upper bounds. This restriction will likely be removed in
            future.</p></span></i><pre data-language="bnf">SatisfiedTypes: "satisfies" PrimaryType ("&amp;" PrimaryType)*</pre><p>The <tt class="literal">satisfies</tt> clause may specify multiple types. If a 
            satisfied type is a parameterized type, the <tt class="literal">satisfies</tt> clause 
            must specify type arguments.</p><pre data-language="ceylon">satisfies Sequence&lt;Element&gt; &amp; Collection&lt;Element&gt;</pre><p>A <tt class="literal">satisfies</tt> clause may not contain two types produced from 
            the same type declaration.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="casesandcoverage"></a>3.4.&nbsp;Case enumeration and coverage</h2></div></div><div></div></div><p><span class="emphasis"><em>Coverage</em></span> is a static relationship between classes, 
        interfaces, and type parameters, produced through the use of <span class="emphasis"><em>case 
        enumeration</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>An <tt class="literal">abstract</tt> class or interface may be an 
            <span class="emphasis"><em>enumerated type</em></span>, with an enumerated list of 
            disjoint subtypes called <span class="emphasis"><em>cases</em></span>, as defined by
            <a href="#classeswithcases" title="4.5.8.&nbsp;Classes with enumerated cases">&sect;4.5.8 Classes with enumerated cases</a> and 
            <a href="#interfaceswithcases" title="4.4.4.&nbsp;Interfaces with enumerated cases">&sect;4.4.4 Interfaces with enumerated cases</a>.</p></li><li><p>A type parameter may have an <span class="emphasis"><em>enumerated bound</em></span>,
            with an enumerated list possible type arguments, as defined by
            <a href="#generictypeconstraints" title="3.5.3.&nbsp;Generic type constraints">&sect;3.5.3 Generic type constraints</a>.</p></li><li><p>An <tt class="literal">abstract</tt> class or interface may have a 
            <span class="emphasis"><em>self type</em></span>, a type parameter representing the
            concrete type of an instance.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="coverage"></a>3.4.1.&nbsp;Coverage</h3></div></div><div></div></div><p>Coverage is a strictly weaker relationship than assignability:</p><div class="itemizedlist"><ul type="disc"><li><p>If a type is a subtype of a second type, then the second type
                covers the first type.</p></li><li><p>If a type has a self type, then its self type covers the type.</p></li><li><p>If a type <tt class="literal">X</tt> enumerates its cases 
                <tt class="literal">X1</tt>, <tt class="literal">X2</tt>, etc, then the union 
                <tt class="literal">X1|X2|...</tt> of its cases covers the type.</p></li><li><p>If a generic type <tt class="literal">X</tt> enumerates its cases, 
                <tt class="literal">X1</tt>, <tt class="literal">X2</tt>, etc, which might involve
                the type parameters of <tt class="literal">X</tt>, then for any instantiation 
                <tt class="literal">U</tt> of <tt class="literal">X</tt>, and for each case 
                <tt class="literal">Xi</tt>, we can construct a type <tt class="literal">Ui</tt> by,
                for every type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt>,
                substituting the corresponding type argument of <tt class="literal">T</tt> 
                given in <tt class="literal">U</tt> everywhere <tt class="literal">T</tt> occurs in 
                <tt class="literal">Xi</tt>, and then the union type <tt class="literal">U1|U2|...</tt>
                of all the resulting types <tt class="literal">Ui</tt> covers 
                <tt class="literal">Y</tt>.</p></li><li><p>If a type <tt class="literal">X</tt> covers two types <tt class="literal">A</tt> 
                and <tt class="literal">B</tt>, then <tt class="literal">X</tt> also covers their
                union <tt class="literal">A|B</tt>.</p></li><li><p>Coverage is transitive. If <tt class="literal">X</tt> covers
                <tt class="literal">Y</tt> and <tt class="literal">Y</tt> covers <tt class="literal">Z</tt>,
                then <tt class="literal">X</tt> covers <tt class="literal">Z</tt>.</p></li></ul></div><p>It follows that coverage obeys the identity property of assignability:
            a type covers itself. However, coverage does not obey the noncircularity property 
            of assignability. It is possible to have distinct types <tt class="literal">A</tt> and 
            <tt class="literal">B</tt> where <tt class="literal">A</tt> covers <tt class="literal">B</tt> and 
            <tt class="literal">B</tt> covers <tt class="literal">A</tt>.</p><p>Case enumeration allows safe use of a type in a <tt class="literal">switch</tt> 
            statement, or as the subject of the <tt class="literal">of</tt> operator. The 
            compiler is able to statically validate that the <tt class="literal">switch</tt> 
            contains an exhaustive list of all cases of the type, by checking that the
            union of cases enumerated in the <tt class="literal">switch</tt> covers the type,
            or that the second operand of <tt class="literal">of</tt> covers the type.</p><i><span class="comment">
            <p>Note: however, a type is <span class="emphasis"><em>not</em></span> considered automatically 
            assignable to the union of its cases, or to its self type. Instead, the type
            must be <span class="emphasis"><em>explicitly</em></span> narrowed to the union of its cases, 
            or to its self type, using either the <tt class="literal">of</tt> operator or the
            <tt class="literal">switch</tt> construct. This narrowing type conversion can be
            statically checked&#8212;if <tt class="literal">X</tt> covers <tt class="literal">Y</tt>
            then <tt class="literal">Y of X</tt> is guaranteed to succeed at runtime.
            Unfortunately, and quite unintuitively, the compiler is not able to analyse 
            coverage implicitly at the same time as assignability, because that results in 
            undecidability!</p>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cases"></a>3.4.2.&nbsp;Cases</h3></div></div><div></div></div><p>The <tt class="literal">of</tt> clause does triple duty. It's used to define
            self types and type families, enumerated types, and enumerated type 
            constraints. The <tt class="literal">of</tt> clause may specify multiple types, 
            called <span class="emphasis"><em>cases</em></span>.</p><pre data-language="bnf">CaseTypes: "of" CaseType ("|" CaseType)*</pre><pre data-language="bnf">CaseType: MemberName | PrimaryType</pre><p>If an interface or <tt class="literal">abstract</tt> class with an 
            <tt class="literal">of</tt> clause has exactly one case, and it is a type parameter 
            of the interface or <tt class="literal">abstract</tt> class, or of the immediately 
            containing type, if any, then that type parameter is a 
            <span class="emphasis"><em>self type</em></span> of the interface or <tt class="literal">abstract</tt> 
            class, and:</p><div class="itemizedlist"><ul type="disc"><li><p>the self type parameter covers the declared type within the 
                    body of the declaration,</p></li><li><p>the type argument to the self type parameter in an 
                    instantiation of the declared type covers the instantiation, 
                    and</p></li><li><p>every type which extends or satisfies an instantiation of the 
                    declared type must also be covered by the type argument to the self
                    type parameter in the instantiation.</p></li></ul></div><pre data-language="ceylon">shared abstract class Comparable&lt;Other&gt;() of Other 
        given Other satisfies Comparable&lt;Other&gt; {
    
    shared formal Integer compare(Other that);
    
    shared Integer reverseCompare(Other that) =&gt; that.compare(this) of Other;
    
}</pre><pre data-language="ceylon">Comparable&lt;Item&gt; comp = ... ;
Item item = comp of Item;</pre><p>Otherwise, an interface or <tt class="literal">abstract</tt> class with an 
            <tt class="literal">of</tt> clause may have multiple cases, but each case must be 
            either:</p><div class="itemizedlist"><ul type="disc"><li><p>a subtype of the interface or <tt class="literal">abstract</tt> 
                    class, or</p></li><li><p>a value reference to a toplevel anonymous class that is a 
                    subtype of the interface or <tt class="literal">abstract</tt> class.</p></li></ul></div><p>Then the interface or <tt class="literal">abstract</tt> class is an
            <span class="emphasis"><em>enumerated type</em></span>, and every subtype of the interface 
            or <tt class="literal">abstract</tt> class must be a subtype of exactly one of 
            the enumerated subtypes. A class or interface may not be a subtype of more 
            than one case of an enumerated type.</p><pre data-language="ceylon">of larger | smaller | equal</pre><pre data-language="ceylon">of Root&lt;Element&gt; | Leaf&lt;Element&gt; | Branch&lt;Element&gt;</pre><p>A type parameter with an <tt class="literal">of</tt> clause may specify 
            multiple cases, as defined in <a href="#generictypeconstraints" title="3.5.3.&nbsp;Generic type constraints">&sect;3.5.3 Generic type constraints</a>.</p><p>An <tt class="literal">of</tt> clause may not contain:</p><div class="itemizedlist"><ul type="disc"><li><p>two types produced from the same type declaration, or</p></li><li><p>two value references to a single toplevel anonymous class.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="genericenumeratedtypes"></a>3.4.3.&nbsp;Generic enumerated types</h3></div></div><div></div></div><p>If a generic enumerated type <tt class="literal">X</tt> has a case type 
            <tt class="literal">C</tt>, then <tt class="literal">C</tt> must directly extend or 
            satisfy an instantiation <tt class="literal">Y</tt> of <tt class="literal">X</tt>, and 
            for each type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt> and 
            corresponding argument <tt class="literal">A</tt> of <tt class="literal">T</tt> given 
            in <tt class="literal">Y</tt>, either:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X</tt> is covariant in <tt class="literal">T</tt> and 
                    <tt class="literal">A</tt> is exactly <tt class="literal">Nothing</tt>,</p></li><li><p><tt class="literal">X</tt> is contravariant in <tt class="literal">T</tt> 
                    and <tt class="literal">A</tt> is exactly the intersection of all upper 
                    bounds on <tt class="literal">T</tt>, or <tt class="literal">Anything</tt> if 
                    <tt class="literal">T</tt> has no upper bounds, or</p></li><li><p><tt class="literal">C</tt> is an instantiation of a generic type 
                    <tt class="literal">G</tt> and <tt class="literal">A</tt> is exactly 
                    <tt class="literal">S</tt> for some type parameter <tt class="literal">S</tt> 
                    of <tt class="literal">G</tt>, and <tt class="literal">S</tt> must have the same 
                    variance as <tt class="literal">T</tt>.</p></li></ul></div><p>For example, the following covariant enumerated type is legal:</p><pre data-language="ceylon">interface List&lt;out Element&gt; 
        of Cons&lt;Element&gt; | nil { ... }

class Cons&lt;out Element&gt;(Element element) 
        satisfies List&lt;Element&gt; { ... }

object nil 
        satisfies List&lt;Nothing&gt; { ... }</pre><p>As is the following contravariant enumerated type:</p><pre data-language="ceylon">interface Consumer&lt;in Event&gt; 
        of Logger | Handler&lt;Event&gt; 
        given Event satisfies AbstractEvent { ... }

interface Logger 
        satisfies Consumer&lt;AbstractEvent&gt; { ... }

interface Handler&lt;in Event&gt; 
        satisfies Consumer&lt;AbstractEvent&gt; 
        given Event satisfies AbstractEvent { ... }</pre><p>But the following enumerated type is not legal, since it is possible 
            to choose a legal argument <tt class="literal">T</tt> of the type parameter 
            <tt class="literal">Type</tt> of <tt class="literal">Expression</tt>, such that the case 
            types <tt class="literal">StringLiteral</tt> and <tt class="literal">NumberLiteral</tt> 
            aren't subtypes of the instantiation <tt class="literal">Expression&lt;T&gt;</tt>:</p><pre data-language="ceylon">interface Expression&lt;out Type&gt;
        of Function&lt;Type&gt; | StringLiteral | NumberLiteral { ... }

interface Function&lt;out Type&gt; 
        satisfies Expression&lt;Type&gt; { ... }

interface StringLiteral
        satisfies Expression&lt;String&gt; { ... }

interface NumberLiteral
        satisfies Expression&lt;Integer|Float&gt; { ... }</pre><i><span class="comment"><p>Note: these rules could be relaxed to allow the definition of
            generic enumerated types where the list of cases of an instantiation of a 
            generic type depends upon the given type arguments (a "generalized" algebraic
            type).</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="disjointtypes"></a>3.4.4.&nbsp;Disjoint types</h3></div></div><div></div></div><p>Two types are said to be <span class="emphasis"><em>disjoint</em></span> if it is impossible
            to have a value that is an instance of both types. If <tt class="literal">X</tt> and 
            <tt class="literal">Y</tt> are disjoint, then their intersection <tt class="literal">X&amp;Y</tt>
            is the bottom type <tt class="literal">Nothing</tt>.</p><p>Two types <tt class="literal">X</tt> and <tt class="literal">Y</tt> are disjoint if
            either:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X</tt> and <tt class="literal">Y</tt> are both classes and
                    <tt class="literal">X</tt> is not a subclass of <tt class="literal">Y</tt> and 
                    <tt class="literal">Y</tt> is not a subclass of <tt class="literal">X</tt>,</p></li><li><p><tt class="literal">X</tt> is the class <tt class="literal">Null</tt> and 
                    <tt class="literal">Y</tt> is an interface,</p></li><li><p><tt class="literal">X</tt> is an anonymous class or an instantiation 
                    of a <tt class="literal">final</tt> class and <tt class="literal">Y</tt> is an 
                    instantiation of a class of interface, and <tt class="literal">X</tt> 
                    does not inherit <tt class="literal">Y</tt>,</p></li><li><p><tt class="literal">X</tt> is an anonymous class or a <tt class="literal">final</tt> 
                    class with no type parameters and <tt class="literal">Y</tt> is a type in 
                    which no type parameter reference occurs, and <tt class="literal">X</tt> 
                    is not a suptype of <tt class="literal">Y</tt>,</p></li><li><p><tt class="literal">X</tt> is a type parameter and <tt class="literal">Y</tt> 
                    and the intersection of the upper bounds of <tt class="literal">X</tt> are 
                    disjoint,</p></li><li><p><tt class="literal">X</tt> is an union type <tt class="literal">A|B</tt> and 
                    both <tt class="literal">Y</tt> and <tt class="literal">A</tt> are disjoint and 
                    <tt class="literal">Y</tt> and <tt class="literal">B</tt> are disjoint,</p></li><li><p><tt class="literal">X</tt> is an intersection type <tt class="literal">A&amp;B</tt> 
                    and either <tt class="literal">Y</tt> and <tt class="literal">A</tt> are disjoint or
                    <tt class="literal">Y</tt> and <tt class="literal">B</tt> are disjoint, or</p></li><li><p><tt class="literal">X</tt> and <tt class="literal">Y</tt> inherit disjoint
                    instantiations of a generic type <tt class="literal">Z</tt>, that is, two 
                    instantiations of <tt class="literal">Z</tt> that have the intersection
                    <tt class="literal">Nothing</tt>, as defined below, in 
                    <a href="#principalinstantiationinheritance" title="3.7.2.&nbsp;Principal instantiation inheritance">&sect;3.7.2 Principal instantiation inheritance</a>.</p></li></ul></div><p>Furthermore, as a special case, the types <tt class="literal">X</tt> and 
            <tt class="literal">Y</tt> are disjoint if:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X</tt> is an invariant subtype of <tt class="literal">Sequence&lt;A&gt;</tt>, 
                    <tt class="literal">Y</tt> is an invariant subtype of <tt class="literal">Sequence&lt;B&gt;</tt>,
                    and <tt class="literal">A</tt> and <tt class="literal">B</tt> are disjoint,</p></li><li><p><tt class="literal">X</tt> is an invariant subtype of <tt class="literal">Sequential&lt;A&gt;</tt>, 
                    <tt class="literal">Y</tt> is an invariant subtype of <tt class="literal">Tuple&lt;J,B,V&gt;</tt>,
                    and <tt class="literal">A</tt> and <tt class="literal">B</tt> are disjoint or <tt class="literal">X</tt> and
                    <tt class="literal">V</tt> are disjoint, or</p></li><li><p><tt class="literal">X</tt> is an invariant subtype of <tt class="literal">Tuple&lt;I,A,U&gt;</tt>,
                    <tt class="literal">Y</tt> is an invariant subtype of <tt class="literal">Tuple&lt;J,B,V&gt;</tt>,
                    and <tt class="literal">A</tt> and <tt class="literal">B</tt> are disjoint or <tt class="literal">U</tt> and
                    <tt class="literal">C</tt> are disjoint.</p></li></ul></div><i><span class="comment"><p>Note: the soundness of these rules is guaranteed by the implementations of the
            <tt class="literal">sealed</tt> types <tt class="literal">Sequence</tt>, <tt class="literal">Sequential</tt>, and
            <tt class="literal">Tuple</tt> in the module <tt class="literal">ceylon.language</tt>.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generictypeparameters"></a>3.5.&nbsp;Generic type parameters</h2></div></div><div></div></div><p>Function, class, and interface schemas may be parameterized by one or more 
        generic type parameters. A parameterized type schema defines a type constructor, 
        a function that produces a type given a tuple of compatible type arguments. A 
        parameterized class or function schema defines a function that produces the 
        signature of an invokable operation given a tuple of compatible type arguments.</p><pre data-language="bnf">TypeParameters: "&lt;" (TypeParameter ",")* TypeParameter "&gt;"</pre><p>A declaration with type parameters is called <span class="emphasis"><em>generic</em></span> or
        <span class="emphasis"><em>parameterized</em></span>.</p><div class="itemizedlist"><ul type="disc"><li><p>A type schema with no type parameters defines exactly one type. A 
            parameterized type schema defines a template for producing types: one type 
            for each possible combination of type arguments that satisfy the type constraints 
            specified by the type. The types of members of the this type are determined by 
            replacing every appearance of each type parameter in the schema of the 
            parameterized type definition with its type argument.</p></li><li><p>A function schema with no type parameters defines exactly one operation 
            per type. A parameterized function declaration defines a template for producing
            overloaded operations: one operation for each possible combination of type 
            arguments that satisfy the type constraints specified by the method declaration.</p></li><li><p>A class schema with no type parameters defines exactly one instantiation 
            operation. A parameterized class schema defines a template for producing 
            overloaded instantiation operations: one instantiation operation for each possible 
            combination of type arguments that satisfy the type constraints specified by the 
            class declaration. The type of the object produced by an instantiation operation is 
            determined by substituting the same combination of type arguments for the type 
            parameters of the parameterized class schema.</p></li></ul></div><i><span class="comment"><p>Note: by convention, type parameter names should be constructed from
        meaningful words. The use of single-letter type parameter names is discouraged. The 
        name of a type parameter should be chosen so that declarations within the body of 
        the parameterized declaration read naturally. For example, 
        <tt class="literal">class Entry&lt;Key,Item&gt;</tt> is reasonable, since
        <tt class="literal">Key key</tt> and <tt class="literal">Item item</tt> read naturally within 
        the body of the <tt class="literal">Entry</tt> class. The following identifier names 
        usually refer to a type parameter: <tt class="literal">Element</tt>, <tt class="literal">Other</tt>,
        <tt class="literal">This</tt>, <tt class="literal">Value</tt>, <tt class="literal">Key</tt>, 
        <tt class="literal">Item</tt>, <tt class="literal">Argument</tt>, <tt class="literal">Args</tt> and 
        <tt class="literal">Result</tt>. Avoid, where reasonable, using these names for interfaces 
        and classes.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeparametersandvariance"></a>3.5.1.&nbsp;Type parameters and variance</h3></div></div><div></div></div><p>A <span class="emphasis"><em>type parameter</em></span> allows a declaration to be abstracted 
            over a constrained set of types.</p><pre data-language="bnf">TypeParameter: Variance? TypeName ("=" Type)</pre><p>Every type parameter has a name and a <span class="emphasis"><em>variance</em></span>.</p><pre data-language="bnf">Variance: "out" | "in"</pre><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>covariant</em></span> type parameter is indicated using the
                    keyword <tt class="literal">out</tt>.</p></li><li><p>A <span class="emphasis"><em>contravariant</em></span> type parameter is indicated using 
                    the keyword <tt class="literal">in</tt>.</p></li><li><p>By default, a type parameter is <span class="emphasis"><em>invariant</em></span>.</p></li></ul></div><p>A type parameter may, optionally, have a <span class="emphasis"><em>default type argument</em></span>. 
            A type parameter with a default type argument must occur after every type parameter 
            with no default type argument in the type parameter list.</p><p>The default type argument for a type parameter must satisfy the constraints on 
            the type parameter.</p><i><span class="comment"><p>TODO: this restriction could be relaxed, and the assignability of the
            default type argument to the type constraints checked at use-sites where the default 
            type argument is used in type expressions.</p></span></i><p>A default type argument expression for a type parameter of a generic declaration
            may not involve:</p><div class="itemizedlist"><ul type="disc"><li><p>the type parameter itself,</p></li><li><p>any type parameter of the declaration that occurs later in the list 
                    of type parameters, nor</p></li><li><p>the generic declaration.</p></li></ul></div><p>Within the body of the schema it parameterizes, a type parameter is itself a 
            type. The type parameter is a subtype of every upper bound of the type parameter. 
            However, a class or interface may not extend or satisfy a type parameter.</p><pre data-language="ceylon">&lt;Key, out Item&gt;</pre><pre data-language="ceylon">&lt;in Message&gt;</pre><pre data-language="ceylon">&lt;out Element=Object&gt;</pre><pre data-language="ceylon">&lt;in Left, in Right, out Result&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="variancevalidation"></a>3.5.2.&nbsp;Variance validation</h3></div></div><div></div></div><p>A covariant type parameter may only appear in <span class="emphasis"><em>covariant positions</em></span> 
            of the parameterized schema. A contravariant type parameter may only appear in 
            <span class="emphasis"><em>contravariant positions</em></span> of the parameterized schema. An 
            invariant type parameter may appear in any position.</p><p>Furthermore, a type with a contravariant type parameter may only appear in a
            covariant position in an extended type, satisfied type, case type, or upper bound
            type constraint.</p><i><span class="comment"><p>Note: this restriction exists to eliminate certain undecidable cases
            described in the paper Taming Wildcards in Java's Type System, by Tate et al.</p></span></i><p>To determine if a type expression occurs in a covariant or contravariant 
            position, we first consider how the type occurs syntactically.</p><p>For a generic function we examine the return type of the function, which
            is a covariant position.</p><p>For a generic type schema we examine each <tt class="literal">shared</tt> 
            member, along with extended/satisfied types and case types.</p><i><span class="comment"><p>Note: since the visibility rules are purely lexical in nature, it is 
            legal for a member expression occurring in the body of a class or interface to have 
            a receiver expression other that is not a self-reference, as defined in 
            <a href="#selfreferences" title="6.3.&nbsp;Self references and the current package reference">&sect;6.3 Self references and the current package reference</a>, and refer to an un-<tt class="literal">shared</tt> member 
            of the class or interface. In this special case, the member is treated as if it were 
            <tt class="literal">shared</tt> for the purposes of the following variance validation 
            rules.</p></span></i><div class="itemizedlist"><ul type="disc"><li><p>An extended type, satisfied type, or case type of the type schema 
                    itself is a covariant position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> method declaration of the parameterized 
            type schema:</p><div class="itemizedlist"><ul type="disc"><li><p>The return type of the method is a covariant position.</p></li><li><p>Any parameter type of the method is a contravariant position.</p></li><li><p>Any upper bound of a type parameter of the method is a contravariant 
                    position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> attribute declaration that is not
            variable:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of the attribute is a covariant position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> reference declaration that is 
            variable:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of the attribute is an invariant position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> nested class declaration of the 
            parameterized type schema:</p><div class="itemizedlist"><ul type="disc"><li><p>Any initializer parameter type of the class is a contravariant 
                    position.</p></li><li><p>Any upper bound of a type parameter of the class is a contravariant 
                    position.</p></li><li><p>An extended type, satisfied type, or case type of the nested class
                    is a covariant position.</p></li><li><p>Every covariant position of the nested class schema is a covariant
                    position of the containing type schema. Every contravariant position of 
                    the nested class schema is a contravariant position of the containing type 
                    schema.</p></li></ul></div><p>In a <tt class="literal">shared</tt> nested interface declaration of the 
            parameterized type schema:</p><div class="itemizedlist"><ul type="disc"><li><p>An extended type, satisfied type, or case type of the nested interface 
                    is a covariant position.</p></li><li><p>Every covariant position of the nested interface schema is a covariant
                    position of the containing type schema. Every contravariant position of 
                    the nested interface schema is a contravariant position of the containing 
                    type schema.</p></li></ul></div><p>For parameters of callable parameters, we first determine if the callable
            parameter itself is covariant or contravariant:</p><div class="itemizedlist"><ul type="disc"><li><p>A callable parameter of a method or nested class is contravariant.</p></li><li><p>A callable parameter of a covariant parameter is contravariant.</p></li><li><p>A callable parameter of a contravariant parameter is covariant.</p></li></ul></div><p>Then:</p><div class="itemizedlist"><ul type="disc"><li><p>The return type of a covariant callable parameter is a covariant 
                    position.</p></li><li><p>The return type of a contravariant callable parameter is a 
                    contravariant position.</p></li><li><p>The type of a parameter of a covariant callable parameter is a 
                    contravariant position.</p></li><li><p>The type of a parameter of a contravariant callable parameter is a 
                    covariant position.</p></li></ul></div><p>Finally, to determine if a type parameter that occurs as a type argument occurs
            in a covariant or contravariant position, we must consider the declared variance
            of the corresponding type parameter:</p><div class="itemizedlist"><ul type="disc"><li><p>A type argument of a covariant type parameter of a type in a covariant 
                    position is a covariant position.</p></li><li><p>A type argument of a contravariant type parameter of a type in a 
                    covariant position is a contravariant position.</p></li><li><p>A type argument of a covariant type parameter of a type in a 
                    contravariant position is a contravariant position.</p></li><li><p>A type argument of a contravariant type parameter of a type in a 
                    contravariant position is a covariant position.</p></li><li><p>A type argument of an invariant type parameter of a type in any position 
                    is an invariant position.</p></li><li><p>A type argument of any type parameter of a type in an invariant position 
                    is an invariant position.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="generictypeconstraints"></a>3.5.3.&nbsp;Generic type constraints</h3></div></div><div></div></div><p>A parameterized method, class, or interface declaration may declare constraints 
            upon ordinary type parameters using the <tt class="literal">given</tt> clause.</p><pre data-language="bnf">TypeConstraints: TypeConstraint+</pre><p>There may be at most one <tt class="literal">given</tt> clause per type parameter.</p><pre data-language="bnf">TypeConstraint: "given" TypeName TypeConstraintInheritance</pre><pre data-language="bnf">TypeConstraintInheritance: CaseTypes? SatisfiedTypes?</pre><i><span class="comment">
            <p>Note that the syntax for a type constraint is essentially the same syntax 
            used for other type declarations such as class and interface declarations.</p>
            </span></i><p>There are two different kinds of type constraint:</p><div class="itemizedlist"><ul type="disc"><li><p>An <span class="emphasis"><em>upper bound</em></span>, <tt class="literal">given X satisfies T</tt>, 
                    specifies that the type parameter <tt class="literal">X</tt> is a subtype of 
                    a given type <tt class="literal">T</tt>.</p></li><li><p>An <span class="emphasis"><em>enumerated bound</em></span>, <tt class="literal">given X of T|U|V</tt>
                    specifies that the type parameter <tt class="literal">X</tt> represents one 
                    of the enumerated types.</p></li></ul></div><p>The types listed in an enumerated bound must be mutually disjoint, and each
            type must be a class or interface type.</p><i><span class="comment"><p>TODO: Should we allow unions in upper bounds? Should we allow 
            intersections in enumerated bounds?</p></span></i><p>A single <tt class="literal">given</tt> clause may specify multiple constraints on 
            a certain type parameter. In particular, it may specify multiple upper bounds
            together with an enumerated bound. If multiple upper bounds are specified, at most
            one upper bound may be a class, and at most one upper bound may be a type parameter.</p><i><span class="comment"><p>Note: in Ceylon 1.0, a type parameter with multiple upper bounds may 
            not have an upper bound which is another type parameter.</p></span></i><pre data-language="ceylon">given Value satisfies Ordinal &amp; Comparable&lt;Value&gt;</pre><pre data-language="ceylon">given Quantities satisfies Correspondence&lt;Key,Decimal&gt;</pre><pre data-language="ceylon">given Argument of String | Integer | Float</pre><p>A type parameter is a subtype of its upper bounds.</p><pre data-language="ceylon">class Holder&lt;Value&gt;(shared Value value) 
        extends Object
        given Value satisfies Object {
    shared actual Boolean equals(Object that) {
        if (is Holder&lt;Value&gt; that) {
            return value==that.value;
        }
        else {
            return false;
        }
    }
    shared actual Integer hash =&gt;  value.hash;
}</pre><p>Every type parameter has an implicit upper bound of type 
            <tt class="literal">Anything</tt>.</p><p>An enumerated bound allows the use of an exhaustive <tt class="literal">switch</tt>
            with expressions of the parameter type.</p><pre data-language="ceylon">Characters uppercase&lt;Characters&gt;(Characters chars) 
       given Characters of String | Range&lt;Character&gt; { 
    switch (Characters)
    case (satisfies String) { 
        return chars.uppercased;
    }
    case (satisfies Range&lt;Character&gt;) { 
        return chars.first.uppercased..chars.last.uppercased;
    }
}</pre><i><span class="comment"><p>TODO: Do we need lower bound type constraints? The syntax would be:</p>
            <pre data-language="ceylon">given T abstracts One|Two</pre><p>With union types
            they don't appear to be anywhere near as useful. However, perhaps they are useful
            when combined with contravariant types. (A lower bound on a parameter which occurs 
            as the argument of a contravariant type is more like an upper bound).</p></span></i><i><span class="comment"><p>Note: since we have reified types, it would be possible to support
            a type constraint that allows instantiation of the type parameter.</p>
            <pre data-language="ceylon">given T(Object arg)</pre>
            <p>The problem with this is that then inferring <tt class="literal">T</tt> is fragile.
            And if we don't let it be inferred, we may as well pass <tt class="literal">T</tt> as an
            ordinary parameter. So Ceylon, unlike C#, doesn't support this.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generictypearguments"></a>3.6.&nbsp;Generic type arguments</h2></div></div><div></div></div><p>A list of <span class="emphasis"><em>type arguments</em></span> produces a new type schema 
        from a parameterized type schema, or a new function schema from a from a
        parameterized function schema. In the case of a type schema, this new schema is
        the schema of an applied type.</p><p>A type argument list is a list of types.</p><pre data-language="bnf">TypeArguments: "&lt;" (Type ",")* Type "&gt;"</pre><p>A type argument may itself be an applied type, or type parameter,
        or may involve unions and intersections.</p><pre data-language="ceylon">&lt;Key, List&lt;Item&gt;&gt;</pre><pre data-language="ceylon">&lt;String, Person?&gt;</pre><pre data-language="ceylon">&lt;String[], [{Object*}]&gt;</pre><p>Type arguments are assigned to type parameters according to the positions
        they occur in the list.</p><p>Given the schema of a generic declaration, we form the new schema by 
        <span class="emphasis"><em>type argument substitution</em></span>. Each type argument is substituted 
        for every appearance of the corresponding type parameter in the schema of the 
        generic declaration, including:</p><div class="itemizedlist"><ul type="disc"><li><p>attribute types,</p></li><li><p>method return types,</p></li><li><p>method parameter types,</p></li><li><p>initializer parameter types, and</p></li><li><p>type arguments of extended classes and satisfied interfaces.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeargumentsandconstraints"></a>3.6.1.&nbsp;Type arguments and type constraints</h3></div></div><div></div></div><p>A generic type constraint affects the type arguments that can be assigned 
            to a type parameter:</p><div class="itemizedlist"><ul type="disc"><li><p>A type argument to a type parameter <tt class="literal">T</tt> with an 
                    upper bound must be a type which is a subtype of all upper bounds of
                    <tt class="literal">T</tt>.</p></li><li><p>A type argument to a type parameter <tt class="literal">T</tt> with an 
                    enumerated type bound must be a subtype of one of the enumerated types
                    of <tt class="literal">T</tt>, or it must be a type parameter <tt class="literal">A</tt> 
                    with an enumerated type bound where every enumerated type of 
                    <tt class="literal">A</tt> is also an enumerated type of <tt class="literal">T</tt>.</p></li></ul></div><p>A type argument list <span class="emphasis"><em>conforms</em></span> to a type parameter list 
            if, for every type parameter in the list, either:</p><div class="itemizedlist"><ul type="disc"><li><p>there is a type argument that satisfies the constraints of the type 
                    parameter, or</p></li><li><p>there is no explicit type argument but the type parameter has a 
                    default type argument, in which case the type argument is defaulted by
                    substituting the arguments of all type parameters that occur earlier in
                    the list of type parameters of the declaration into this default type
                    argument.</p></li></ul></div><p>There must be at least as many type parameters as type arguments. There must 
            be at least as many type arguments as type parameters without default values.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="producedtypes"></a>3.6.2.&nbsp;Applied types and and variance</h3></div></div><div></div></div><p>If a type argument list conforms to a type parameter list, the combination
            of the parameterized type together with the type argument list is itself a type,
            called an <span class="emphasis"><em>applied type</em></span>. We also call the applied type an 
            <span class="emphasis"><em>instantiation</em></span> of the generic type.</p><p>For a generic type <tt class="literal">X</tt>, the instantiations <tt class="literal">Y</tt> 
            and <tt class="literal">Z</tt> of <tt class="literal">X</tt> represent the same type if and 
            only if for every <tt class="literal">A</tt> in the list of type arguments specified
            in <tt class="literal">Y</tt> and corresponding <tt class="literal">B</tt> in the list of type 
            arguments specified in <tt class="literal">Z</tt>, <tt class="literal">A</tt> is exactly the 
            same type as <tt class="literal">B</tt>.</p><p>For a generic type <tt class="literal">X</tt>, and instantiations 
            <tt class="literal">Y</tt> and <tt class="literal">Z</tt> of <tt class="literal">X</tt>, 
            <tt class="literal">Y</tt> is a subtype of <tt class="literal">Z</tt> if and only if, for 
            every type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt>, and 
            corresponding arguments <tt class="literal">A</tt> specified in <tt class="literal">Y</tt> 
            and <tt class="literal">B</tt> specified in <tt class="literal">Z</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">T</tt> is a covariant type parameter, and
                        <tt class="literal">A</tt> is a subtype of <tt class="literal">B</tt>, or
                    </p></li><li><p>
                        <tt class="literal">T</tt> is a contravariant type parameter, and
                        <tt class="literal">B</tt> is a subtype of <tt class="literal">A</tt>, or
                    </p></li><li><p>
                        <tt class="literal">T</tt> is an invariant type parameter (neither 
                        covariant nor contravariant), and <tt class="literal">A</tt> and
                        <tt class="literal">B</tt> are exactly the same type.
                    </p></li></ul></div><i><span class="comment"><p>Note that if <tt class="literal">T</tt> is an invariant type parameter
            of <tt class="literal">X&lt;T&gt;</tt>, then a type <tt class="literal">Z</tt> is a subtype 
            of <tt class="literal">X&lt;A&gt;</tt> if and only if <tt class="literal">Z</tt> has the 
            principal instantiation <tt class="literal">X&lt;A&gt;</tt>.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeargumentinference"></a>3.6.3.&nbsp;Type argument inference</h3></div></div><div></div></div><p>When a direct invocation expression, as defined by 
            <a href="#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>, for a generic function or a direct 
            instantiation expression for a generic class does not explicitly specify type 
            arguments, the type arguments are inferred from the argument expression types. 
            The types of the argument expressions and the declared types of the corresponding 
            parameters determine an <span class="emphasis"><em>inferred lower bound</em></span> or 
            <span class="emphasis"><em>inferred upper bound</em></span> for each type parameter.</p><p>If a list of argument expressions has types <tt class="literal">A1,A2,...</tt> 
            and the corresponding list of parameters has declared types <tt class="literal">P1,P2,...</tt>, 
            the inferred lower bound for a type parameter <tt class="literal">T</tt> of the generic
            declaration is the conjunction of:</p><div class="itemizedlist"><ul type="disc"><li><p>all inferred lower bounds <tt class="literal">Ai</tt> on <tt class="literal">Pi</tt> 
                    for <tt class="literal">T</tt>.</p></li></ul></div><p>The inferred upper bound for a type parameter <tt class="literal">T</tt> of the generic
            declaration is the conjunction of:</p><div class="itemizedlist"><ul type="disc"><li><p>all upper bounds <tt class="literal">Xi</tt> explicitly declared by a type 
                    constraint on <tt class="literal">T</tt> of form <tt class="literal">given T satisfies Xi</tt>, 
                    if any, with</p></li><li><p>all inferred upper bounds <tt class="literal">Ai</tt> on <tt class="literal">Pi</tt> 
                    for <tt class="literal">T</tt>.</p></li></ul></div><i><span class="comment"><p>TODO: What should we do about upper bound constraints that involve
            other type parameters? Currently the typechecker simply ignores any upper bound 
            that involves any type parameter.</p></span></i><p>Given types <tt class="literal">A</tt> and <tt class="literal">P</tt>, we determine 
            the <span class="emphasis"><em>inferred lower bound</em></span> <tt class="literal">A</tt> on 
            <tt class="literal">P</tt> for <tt class="literal">T</tt> according to the nature of 
            <tt class="literal">A</tt> and <tt class="literal">P</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">P</tt> is exactly <tt class="literal">T</tt>, and
                    the location at which <tt class="literal">P</tt> occurs in the parameter 
                    list is not a contravariant location, the inferred lower bound 
                    <tt class="literal">A</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt> 
                    is <tt class="literal">T abstracts A</tt>.</p></li><li><p>If <tt class="literal">P</tt> is a union type <tt class="literal">Q|R</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the lower bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the lower bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>. <span class="emphasis"><em>Note: this case is special.</em></span></p></li><li><p>If <tt class="literal">P</tt> is an intersection type <tt class="literal">Q&amp;R</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the lower bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the lower bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is a union type <tt class="literal">B|C</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the lower bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the lower bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is an intersection type <tt class="literal">B&amp;C</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the lower bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the lower bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">P</tt> is an applied type <tt class="literal">Q&lt;P1,P2,...&gt;</tt> 
                    of a parameterized type <tt class="literal">Q</tt>, and <tt class="literal">A</tt> 
                    is a subtype of an applied type <tt class="literal">Q&lt;A1,A2,..&gt;</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of all lower bounds <tt class="literal">Ai</tt> 
                    on <tt class="literal">Pi</tt> for <tt class="literal">T</tt>.</p></li><li><p>Otherwise, if <tt class="literal">A</tt> is not a union or intersection, 
                    and if <tt class="literal">P</tt> is neither an applied type, a union, or an
                    intersection, nor exactly <tt class="literal">T</tt>, the lower bound 
                    <tt class="literal">A</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>
                    is <span class="emphasis"><em>null</em></span>.</p></li></ul></div><p>Where:</p><div class="itemizedlist"><ul type="disc"><li><p>the conjunction of a lower bound <tt class="literal">T abstracts A</tt>
                    with a lower bound <tt class="literal">T abstracts B</tt> is the lower bound 
                    <tt class="literal">T abstracts A|B</tt>,</p></li><li><p>the disjunction of a lower bound <tt class="literal">T abstracts A</tt>
                    with a lower bound <tt class="literal">T abstracts B</tt> is the lower bound 
                    <tt class="literal">T abstracts A&amp;B</tt>,</p></li><li><p>the conjunction or disjunction of a lower bound <tt class="literal">T abstracts A</tt>
                    with a null lower bound is <tt class="literal">T abstracts A</tt>, and</p></li><li><p>the conjunction or disjunction of two null lower bounds is null.</p></li></ul></div><p>Given types <tt class="literal">A</tt> and <tt class="literal">P</tt>, we determine 
            the <span class="emphasis"><em>inferred upper bound</em></span> <tt class="literal">A</tt> on 
            <tt class="literal">P</tt> for <tt class="literal">T</tt> according to the nature of 
            <tt class="literal">A</tt> and <tt class="literal">P</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">P</tt> is exactly <tt class="literal">T</tt>, and
                    the location at which <tt class="literal">P</tt> occurs in the parameter 
                    list is not a covariant location, the inferred upper bound 
                    <tt class="literal">A</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt> 
                    is <tt class="literal">T satisfies A</tt>.</p></li><li><p>If <tt class="literal">P</tt> is a union type <tt class="literal">Q|R</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the upper bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the upper bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>. <span class="emphasis"><em>Note: this case is special.</em></span></p></li><li><p>If <tt class="literal">P</tt> is an intersection type <tt class="literal">Q&amp;R</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the upper bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the upper bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is a union type <tt class="literal">B|C</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the upper bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the upper bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is an intersection type <tt class="literal">B&amp;C</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the upper bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the upper bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">P</tt> is an applied type <tt class="literal">Q&lt;P1,P2,...&gt;</tt> 
                    of a parameterized type <tt class="literal">Q</tt>, and <tt class="literal">A</tt> 
                    is a subtype of an applied type <tt class="literal">Q&lt;A1,A2,..&gt;</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of all upper bounds <tt class="literal">Ai</tt> 
                    on <tt class="literal">Pi</tt> for <tt class="literal">T</tt>.</p></li><li><p>Otherwise, if <tt class="literal">A</tt> is not a union or intersection, 
                    and if <tt class="literal">P</tt> is neither an applied type, a union, or an
                    intersection, nor exactly <tt class="literal">T</tt>, the upper bound 
                    <tt class="literal">A</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>
                    is <span class="emphasis"><em>null</em></span>.</p></li></ul></div><p>Where:</p><div class="itemizedlist"><ul type="disc"><li><p>the conjunction of an upper bound <tt class="literal">T satisfies A</tt>
                    with an upper bound <tt class="literal">T satisfies B</tt> is the upper bound 
                    <tt class="literal">T satisfies A&amp;B</tt>,</p></li><li><p>the disjunction of an upper bound <tt class="literal">T satisfies A</tt>
                    with an upper bound <tt class="literal">T satisfies B</tt> is the upper bound 
                    <tt class="literal">T satisfies A|B</tt>,</p></li><li><p>the conjunction or disjunction of an upper bound <tt class="literal">T satisfies A</tt>
                    with a null upper bound is <tt class="literal">T satisfies A</tt>, and</p></li><li><p>the conjunction or disjunction of two null upper bounds is null.</p></li></ul></div><p>The inferred type argument to a covariant or invariant type parameter 
            <tt class="literal">T</tt> of the generic declaration is:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Nothing</tt>, if the inferred lower bound for 
                    <tt class="literal">T</tt> is null, or, otherwise,</p></li><li><p>the type <tt class="literal">A</tt>, where the inferred lower bound for 
                    <tt class="literal">T</tt> is <tt class="literal">T abstracts A</tt>.</p></li></ul></div><p>The inferred type argument to a contravariant type parameter 
            <tt class="literal">T</tt> of the generic declaration is:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Anything</tt>, if the inferred upper bound for 
                    <tt class="literal">T</tt> is null, or, otherwise,</p></li><li><p>the type <tt class="literal">A</tt>, where the inferred upper bound for 
                    <tt class="literal">T</tt> is <tt class="literal">T satisfies A</tt>.</p></li></ul></div><p>An argument expression with no type occurring in a <tt class="literal">dynamic</tt>
            block, as defined in <a href="#dynamicblocks" title="5.3.12.&nbsp;Dynamic blocks">&sect;5.3.12 Dynamic blocks</a>, may cause type argument inference 
            to fail. When combining bounds using union, any constituent bound with no type results 
            in a bound with no type. When combining bounds using intersection, any constituent 
            bound with no type is eliminated. If the resulting inferred upper or lower bound has no 
            type, type argument inference is impossible for the type argument, and type arguments 
            must be specified explicitly.</p><p>If the inferred type argument does not satisfy the generic type 
            constraints on <tt class="literal">T</tt>, a compilation error results.</p><p>Consider the following invocation:</p><pre data-language="ceylon">[Element+] prepend&lt;Element&gt;(Element head, Element[] sequence) { ... }
value result = prepend(null, {"hello", "world"});</pre><p>The inferred type of <tt class="literal">Element</tt> is the union type 
            <tt class="literal">String?</tt>.</p><p>Now consider:</p><pre data-language="ceylon">class Bag&lt;out Element&gt;(Element* elements) {
    shared Bag&lt;ExtraElement&gt; with&lt;ExtraElement&gt;(ExtraElement* elements) 
            given ExtraElement abstracts Element { ... }
}
Bag&lt;String&gt; bag = Bag("hello", "world");
value biggerBag = bag.with(1, 2, 5.0);</pre><p>The inferred type of <tt class="literal">ExtraElement</tt> is the union 
            type <tt class="literal">Integer|Float|String</tt>.</p><p>Finally consider:</p><pre data-language="ceylon">interface Delegate&lt;in Value&gt; { ... }
class Consumer&lt;in Value&gt;(Delegate&lt;Value&gt;* delegates) { ... }
Delegate&lt;String&gt; delegate1 = ... ;
Delegate&lt;Object&gt; delegate2 = ... ; 
value consumer = Consumer(delegate1, delegate2);</pre><p>The inferred type of <tt class="literal">Value</tt> is 
            <tt class="literal">Consumer&lt;String&gt;</tt>.</p><i><span class="comment"><p>TODO: What about upper bounds in which the type parameter 
            itself appears (the infamous self-type problem with
            <tt class="literal">Comparable</tt> and <tt class="literal">Numeric</tt>) or in which 
            another type parameter appears?</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="principalinstantiations"></a>3.7.&nbsp;Principal instantiations and polymorphism</h2></div></div><div></div></div><p>Inheritance interacts with type parameterization to produce subtyping 
        relationships between instantiations of generic types. The notion of an
        <span class="emphasis"><em>inherited instantiation</em></span> and the notion of a 
        <span class="emphasis"><em>principal instantation</em></span> help us reason about these 
        relationships.</p><i><span class="comment"><p>Warning: this section is not for the faint of heart. Feel 
        free to skip to <a href="#declarations" title="Chapter&nbsp;4.&nbsp;Declarations">Chapter&nbsp;4, <i>Declarations</i></a>, unless you're really, really 
        interested in precisely how the compiler reasons about inheritance of generic 
        types.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritedinstantiations"></a>3.7.1.&nbsp;Inherited instantiations</h3></div></div><div></div></div><p>For a generic type <tt class="literal">Y</tt>, inheritance produces subtypes 
            with <span class="emphasis"><em>inherited instantiations</em></span> of the generic type.</p><div class="itemizedlist"><ul type="disc"><li><p>If a type <tt class="literal">X</tt> directly extends or satisfies an 
                instantiation <tt class="literal">V</tt> of <tt class="literal">Y</tt>, then 
                <tt class="literal">X</tt> has the inherited instantiation <tt class="literal">V</tt> 
                of <tt class="literal">Y</tt>.</p></li><li><p>If a generic type <tt class="literal">X</tt> extends or satisfies an 
                instantiation <tt class="literal">V</tt> of <tt class="literal">Y</tt>, that may 
                involve the type parameters of <tt class="literal">X</tt>, then for any 
                instantiation <tt class="literal">U</tt> of <tt class="literal">X</tt>, we can 
                construct an instantiation <tt class="literal">W</tt> of <tt class="literal">Y</tt> 
                by, for every type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt>, 
                substituting the type argument of <tt class="literal">T</tt> given in 
                <tt class="literal">U</tt> everywhere <tt class="literal">T</tt> occurs in 
                <tt class="literal">V</tt>, and then <tt class="literal">U</tt> has the inherited 
                instantiation <tt class="literal">W</tt> of <tt class="literal">Y</tt>.</p></li><li><p>If a type <tt class="literal">X</tt> is a subtype of a type 
                <tt class="literal">Y</tt>, and <tt class="literal">Y</tt> has an inherited 
                instantiation <tt class="literal">W</tt> of a generic type <tt class="literal">Z</tt>, 
                then <tt class="literal">X</tt> also has this inherited instantiation.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="principalinstantiationinheritance"></a>3.7.2.&nbsp;Principal instantiation inheritance</h3></div></div><div></div></div><p>If a class or interface type <tt class="literal">X</tt> has the inherited 
            instantiations <tt class="literal">V</tt> and <tt class="literal">W</tt> of some 
            generic type <tt class="literal">Y</tt>, then:</p><div class="itemizedlist"><ul type="disc"><li><p>for every invariant type parameter <tt class="literal">T</tt> of 
                    <tt class="literal">Y</tt>, the type argument <tt class="literal">A</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt> and the type 
                    argument <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt> must be exactly the same type, and,
                    furthermore,</p></li><li><p><tt class="literal">X</tt> is a subtype of an instantiation 
                     <tt class="literal">U</tt> of <tt class="literal">Y</tt> such that 
                     <tt class="literal">U</tt> is a subtype of 
                     <tt class="literal">V&amp;W</tt>.</p></li></ul></div><p>Therefore, if a type <tt class="literal">X</tt> is a subtype of the 
            instantiations <tt class="literal">V</tt> and <tt class="literal">W</tt> of some generic 
            type <tt class="literal">Y</tt>, then either:</p><div class="itemizedlist"><ul type="disc"><li><p>for some invariant type parameter <tt class="literal">T</tt> of 
                    <tt class="literal">Y</tt>, the argument of <tt class="literal">A</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt> and the argument
                    <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt> are distinct types, and either <tt class="literal">A</tt>
                    or <tt class="literal">B</tt> involves a type parameter, or</p></li><li><p>if, for some invariant type parameter <tt class="literal">T</tt> 
                    of <tt class="literal">Y</tt>, the argument of <tt class="literal">A</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt> and the argument
                    <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt> are distinct types, and neither <tt class="literal">A</tt>
                    nor <tt class="literal">B</tt> involve a type parameter, then the type 
                    <tt class="literal">V&amp;W</tt> is the bottom type <tt class="literal">Nothing</tt>, 
                    and we say that <tt class="literal">V</tt> and <tt class="literal">W</tt> are 
                    <span class="emphasis"><em>disjoint instantiations</em></span> of <tt class="literal">Y</tt>, 
                    or, otherwise,</p></li><li><p><tt class="literal">X</tt> must be a subtype of an instantiation 
                    <tt class="literal">P</tt> of <tt class="literal">Y</tt> formed by taking each
                    type parameter <tt class="literal">T</tt> of <tt class="literal">Y</tt>, and 
                    constructing a type argument <tt class="literal">C</tt> for 
                    <tt class="literal">T</tt> from the type arguments <tt class="literal">A</tt> 
                    of <tt class="literal">T</tt> given in <tt class="literal">V</tt> and 
                    <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt>:</p><div class="itemizedlist"><ul type="circle"><li><p>if <tt class="literal">Y</tt> is invariant in <tt class="literal">T</tt>, 
                            then <tt class="literal">C</tt> is the same type as <tt class="literal">A</tt>
                            and <tt class="literal">B</tt>,</p></li><li><p>if <tt class="literal">Y</tt> is covariant in <tt class="literal">T</tt>, 
                            then <tt class="literal">C</tt> is <tt class="literal">A&amp;B</tt>, or</p></li><li><p>if <tt class="literal">Y</tt> is contravariant in <tt class="literal">T</tt>,
                            then <tt class="literal">C</tt> is <tt class="literal">A|B</tt>.</p></li></ul></div></li></ul></div><p>Finally, the following identities result from principal instantiation 
            inheritance. For any generic type <tt class="literal">X&lt;T&gt;</tt>, and for any given 
            types <tt class="literal">A</tt> and <tt class="literal">B</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X&lt;A&gt;&amp;X&lt;B&gt;</tt> is exactly equivalent 
                    to <tt class="literal">X&lt;A&amp;B&gt;</tt> if <tt class="literal">X&lt;T&gt;</tt>
                    is covariant in <tt class="literal">T</tt>, unless either <tt class="literal">A</tt>
                    or <tt class="literal">B</tt> involves type parameters, and</p></li><li><p><tt class="literal">X&lt;A&gt;&amp;X&lt;B&gt;</tt> is exactly equivalent
                    to <tt class="literal">X&lt;A|B&gt;</tt> if <tt class="literal">X&lt;T&gt;</tt> is 
                    contravariant in <tt class="literal">T</tt>, unless either <tt class="literal">A</tt>
                    or <tt class="literal">B</tt> involves type parameters.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="principalinstantiationofasupertype"></a>3.7.3.&nbsp;Principal instantiation of a supertype</h3></div></div><div></div></div><p>If a type <tt class="literal">X</tt> is a subtype of some instantiation 
            <tt class="literal">V</tt> of a generic type <tt class="literal">Y</tt>, then, as a 
            result of the principal instantiation inheritance restriction, we can 
            form a unique instantiation of <tt class="literal">Y</tt> that is a subtype of 
            every instantiation of <tt class="literal">Y</tt> to which <tt class="literal">X</tt> 
            is assignable. We call this type the <span class="emphasis"><em>principal instantiation of 
            <tt class="literal">Y</tt> for <tt class="literal">X</tt></em></span>.</p><p>We compute principal instantiations by making use of the identities
            observed above in <a href="#uniontypes" title="3.2.3.&nbsp;Union types">&sect;3.2.3 Union types</a>, <a href="#intersectiontypes" title="3.2.4.&nbsp;Intersection types">&sect;3.2.4 Intersection types</a>,
            and <a href="#principalinstantiationinheritance" title="3.7.2.&nbsp;Principal instantiation inheritance">&sect;3.7.2 Principal instantiation inheritance</a>. 
            For any generic type <tt class="literal">X</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>The principal instantiation of the union <tt class="literal">U|V</tt>
                    of two instantiations of <tt class="literal">X</tt>, <tt class="literal">U</tt> 
                    and <tt class="literal">V</tt>, is an instantiation <tt class="literal">P</tt> 
                    of <tt class="literal">X</tt> formed by taking each type parameter 
                    <tt class="literal">T</tt> of <tt class="literal">X</tt> and constructing a
                    type argument <tt class="literal">C</tt> for <tt class="literal">T</tt> from
                    the type arguments <tt class="literal">A</tt> of <tt class="literal">T</tt> 
                    given in <tt class="literal">U</tt> and <tt class="literal">B</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt>:</p><div class="itemizedlist"><ul type="circle"><li><p>if <tt class="literal">X</tt> is covariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A|B</tt>,</p></li><li><p>if <tt class="literal">X</tt> is contravariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A&amp;B</tt>, or</p></li><li><p>if <tt class="literal">X</tt> is invariant in <tt class="literal">T</tt>, 
                            and <tt class="literal">A</tt> and <tt class="literal">B</tt> are exactly 
                            the same type, then <tt class="literal">C</tt> is this type.</p></li></ul></div></li><li><p>The principal instantiation of the intersection <tt class="literal">U&amp;V</tt>
                    of two instantiations of <tt class="literal">X</tt>, <tt class="literal">U</tt> 
                    and <tt class="literal">V</tt>, is an instantiation <tt class="literal">P</tt> of
                    <tt class="literal">X</tt> formed by taking each type parameter 
                    <tt class="literal">T</tt> of <tt class="literal">X</tt> and constructing a
                    type argument <tt class="literal">C</tt> for <tt class="literal">T</tt> from
                    the type arguments <tt class="literal">A</tt> of <tt class="literal">T</tt> 
                    given in <tt class="literal">U</tt> and <tt class="literal">B</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt>:</p><div class="itemizedlist"><ul type="circle"><li><p>if <tt class="literal">X</tt> is covariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A&amp;B</tt>,</p></li><li><p>if <tt class="literal">X</tt> is contravariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A|B</tt>, or</p></li><li><p>if <tt class="literal">X</tt> is invariant in <tt class="literal">T</tt>, 
                            and <tt class="literal">A</tt> and <tt class="literal">B</tt> are exactly 
                            the same type, then <tt class="literal">C</tt> is this type.</p></li></ul></div></li><li><p>Finally, the principal instantiation of a generic type 
                    <tt class="literal">X</tt> for a type <tt class="literal">Y</tt> which
                    has one or more inherited instantiations of <tt class="literal">X</tt> 
                    is the principal instantiation of the intersection of all the
                    inherited instantiations of <tt class="literal">X</tt>.</p></li></ul></div><i><span class="comment"><p>Note: an intersection <tt class="literal">X&lt;A&gt;&amp;X&lt;P&gt;</tt> 
            of two instantiations of an invariant type, <tt class="literal">X&lt;T&gt;</tt> where 
            one type argument <tt class="literal">P</tt> is a type parameter introduces a known 
            hole in our type system. It is impossible to form a principal instantiation of 
            <tt class="literal">X</tt> for this intersection type without resorting to use-site 
            covariance, so we don't allow references to members of the intersection type.
            </p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="refinement"></a>3.7.4.&nbsp;Refinement</h3></div></div><div></div></div><p>A class or interface may declare an <tt class="literal">actual</tt> member 
            with the same name as a member that it inherits from a supertype if the supertype
            member is declared <tt class="literal">formal</tt> or <tt class="literal">default</tt>.
            Then we say that the first member <span class="emphasis"><em>refines</em></span> the second
            member, and it must obey restrictions defined in 
            <a href="#classrefinement" title="4.5.6.&nbsp;Member class refinement">&sect;4.5.6 Member class refinement</a>, <a href="#methodrefinement" title="4.7.8.&nbsp;Method refinement">&sect;4.7.8 Method refinement</a>, or
            <a href="#attributerefinement" title="4.8.7.&nbsp;Attribute refinement">&sect;4.8.7 Attribute refinement</a>.</p><p>A declaration may not be annotated both <tt class="literal">formal</tt> 
            and <tt class="literal">default</tt>.</p><p>If a declaration is annotated <tt class="literal">formal</tt>, 
            <tt class="literal">default</tt>, or <tt class="literal">actual</tt> then it must 
            also be annotated <tt class="literal">shared</tt>.</p><p>For any class or interface <tt class="literal">X</tt>, and for every declared
            or inherited member of <tt class="literal">X</tt> that is not refined by some other
            declared or inherited member of <tt class="literal">X</tt>, and for every other member 
            declared or inherited by <tt class="literal">X</tt> that directly or indirectly refines 
            a declaration that the first member itself directly or indirectly refines, the 
            principal instantiation for <tt class="literal">X</tt> of the type that declares the 
            first member must be a subtype of the principal instantiation for <tt class="literal">X</tt> 
            of the type that declares the second member.</p><i><span class="comment"><p>Note: a related restriction is defined in 
            <a href="#declarationnameuniqueness" title="5.1.1.&nbsp;Declaration name uniqueness">&sect;5.1.1 Declaration name uniqueness</a>.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="qualifiedtypes"></a>3.7.5.&nbsp;Qualified types</h3></div></div><div></div></div><p>A type declaration that directly occurs in the body of another type
            is called a <span class="emphasis"><em>nested type</em></span>. If a nested type is annotated 
            <tt class="literal">shared</tt>, it may be used in a type expression outside the 
            body in which it is declared, if and only if it occurs as a 
            <span class="emphasis"><em>qualified type</em></span>, as specified in 
            <a href="#typeexpressions" title="3.2.7.&nbsp;Type expressions">&sect;3.2.7 Type expressions</a>.</p><p>The qualified types <tt class="literal">X.U</tt> and <tt class="literal">Y.V</tt> 
            are exactly the same types if and only if <tt class="literal">U</tt> is exactly 
            the same type as <tt class="literal">V</tt>, and in the case that this type is
            a member of a generic type <tt class="literal">Z</tt>, then the principal 
            instantiation of <tt class="literal">Z</tt> for <tt class="literal">X</tt> is exactly
            the same type as the principal instantiation of <tt class="literal">Z</tt> for
            <tt class="literal">Y</tt>.</p><p>A qualified type <tt class="literal">X.U</tt> is a subtype of a qualified
            type <tt class="literal">Y.V</tt> if <tt class="literal">U</tt> is a subtype of 
            <tt class="literal">V</tt>, and in the case that <tt class="literal">V</tt> is a member 
            of a generic type <tt class="literal">Z</tt>, then <tt class="literal">X</tt> is a 
            subtype of the principal instantiation of <tt class="literal">Z</tt> for 
            <tt class="literal">Y</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="realizations"></a>3.7.6.&nbsp;Realizations</h3></div></div><div></div></div><p>Given a member declared by <tt class="literal">Y</tt>, and a declaration that 
            refines it, we can construct a <span class="emphasis"><em>refined realization</em></span> of 
            the member or nested type:</p><div class="itemizedlist"><ul type="disc"><li><p>first determine the principal instantiation of <tt class="literal">Y</tt>
                    for the class or interface which refines the member, and then</p></li><li><p>substitute the type arguments in this principal instantiation 
                    into the member schema.</p></li></ul></div><p>Given an unqualified reference, as defined in 
            <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>, to a declaration, and, in 
            the case of a generic declaration, a list of type arguments for the type 
            parameters of the declaration, we can construct an <span class="emphasis"><em>unqualified 
            realization</em></span> of the declaration:</p><div class="itemizedlist"><ul type="disc"><li><p>if the declaration is a member declared by a type 
                    <tt class="literal">Y</tt>, first determine the principal instantiation 
                    of <tt class="literal">Y</tt> for the inheriting or declaring class or 
                    interface, and then</p></li><li><p>again, only if the declaration is a member declared by a 
                    type, substitute the type arguments in this principal 
                    instantiation into the declaration schema, and, finally,</p></li><li><p>substitute the type arguments into the declaration schema.</p></li></ul></div><p>Given a qualified reference, as defined in 
            <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>, with a qualifying type 
            <tt class="literal">X</tt>, to a member or nested type declared by <tt class="literal">Y</tt>, 
            and, in the case of a generic member or generic nested type, a list of 
            type arguments for the type parameters of the member, we can construct a 
            <span class="emphasis"><em>qualified realization</em></span> of the member or nested type:</p><div class="itemizedlist"><ul type="disc"><li><p>first determining the principal instantiation of 
                    <tt class="literal">Y</tt> for <tt class="literal">X</tt>, and then</p></li><li><p>substituting the type arguments in this principal 
                    instantiation into the declaration schema, and, finally,</p></li><li><p>in the case of a generic member or generic nested type, 
                    substituting the type arguments into the declaration schema.</p></li></ul></div><p>If, for any given qualified or unqualified reference, it is impossible 
            to form the principal instantiation of the type that declares the referenced 
            declaration, due to the hole described above in 
            <a href="#principalinstantiationofasupertype" title="3.7.3.&nbsp;Principal instantiation of a supertype">&sect;3.7.3 Principal instantiation of a supertype</a>, it is impossible to 
            form a realization, and the reference to the declaration is illegal.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="declarations"></a>Chapter&nbsp;4.&nbsp;Declarations</h2></div></div><div></div></div><p>Ceylon is a statically typed language. Classes, interfaces, functions, values 
    and aliases must be declared before use. The declaration of a function or value must 
    include an explicit type, or allow the type to be inferred. Static typing allows the 
    compiler to detect many errors, including:</p><div class="itemizedlist"><ul type="disc"><li><p>typing errors in identifier names,</p></li><li><p>references to types which do not exist or are not 
        visible,</p></li><li><p>references to type members which do not exist or are not 
        visible,</p></li><li><p>argument lists which do not match parameter lists,</p></li><li><p>type argument lists which do not match type parameter 
        lists,</p></li><li><p>operands to which an operator cannot apply,</p></li><li><p>incompatible assignment of an expression of one type to a
        program element of a different type,</p></li><li><p>evaluation of a value before it has been explicitly specified 
        or assigned,</p></li><li><p>assignment to a non-<tt class="literal">variable</tt> value,</p></li><li><p>failure to refine a <tt class="literal">formal</tt> member of a 
        supertype,</p></li><li><p>refinement of a non-<tt class="literal">formal</tt>, 
        non-<tt class="literal">default</tt> member of a supertype,</p></li><li><p><tt class="literal">switch</tt> statements which do not exhaust all
        cases of an enumerated type.</p></li></ul></div><p>All declarations follow a general pattern:</p><pre data-language="ceylon">Annotations
(keyword | Type) (TypeName | MemberName) TypeParameters? Parameters*
CaseTypes? ExtendedType? SatisfiedTypes?
TypeConstraints?
(Definition | ";")</pre><p>A type parameter does not need an explicit declaration of this form unless it has 
    constraints. In the case that it does have constraints, the constraint declaration does 
    follow the general pattern.</p><p>This consistent pattern for declarations, together with the strict block structure
    of the language, makes Ceylon a highly regular language.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compilationunitstructure"></a>4.1.&nbsp;Compilation unit structure</h2></div></div><div></div></div><p>A <span class="emphasis"><em>compilation unit</em></span> is a text file, with the filename 
        extension <tt class="literal">.ceylon</tt>.</p><i><span class="comment"><p>Note: it is recommended that source file names contain only 
        characters from the ASCII character set. This minimizes problems when 
        transferring Ceylon source between operating systems.</p></span></i><p>There are three kinds of compilation unit:</p><div class="itemizedlist"><ul type="disc"><li><p>A regular compilation unit contains a list of toplevel type, 
                value, or function definitions.</p></li><li><p>A <span class="emphasis"><em>module descriptor</em></span>, defined in
                <a href="#moduledescriptors" title="9.3.12.&nbsp;Module descriptors">&sect;9.3.12 Module descriptors</a>, contains a 
                <tt class="literal">module</tt> declaration. The file must be named
                <tt class="literal">module.ceylon</tt>.</p></li><li><p>A <span class="emphasis"><em>package descriptor</em></span>, defined in
                <a href="#packagedescriptors" title="9.3.11.&nbsp;Package descriptors">&sect;9.3.11 Package descriptors</a>, contains a 
                <tt class="literal">package</tt> declaration. The file must be named
                <tt class="literal">package.ceylon</tt>.</p></li></ul></div><p>Any compilation unit may begin with a list of imported types, values, 
        and functions.</p><pre data-language="bnf">Import* (ModuleDescriptor | PackageDescriptor | Declaration*)</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="topleveldeclarations"></a>4.1.1.&nbsp;Toplevel and nested declarations</h3></div></div><div></div></div><p>A <span class="emphasis"><em>toplevel declaration</em></span> defines a type&#8212;a class 
            or interface&#8212;or a type alias, or a function or value.</p><pre data-language="bnf">Declaration: FunctionValueDeclaration | TypeDeclaration | ParameterDeclaration</pre><pre data-language="bnf">FunctionValueDeclaration: FunctionDeclaration | ValueDeclaration | SetterDeclaration</pre><pre data-language="bnf">TypeDeclaration: ClassDeclaration | ObjectDeclaration | InterfaceDeclaration | TypeAliasDeclaration</pre><p>A toplevel declaration is not polymorphic and so may not be annotated 
            <tt class="literal">formal</tt>, <tt class="literal">default</tt>, or 
            <tt class="literal">actual</tt>.</p><i><span class="comment"><p>Note: in a future release of the language, we might relax this 
            restriction and support package extension with toplevel member refinement. This
            can be viewed as a regularization of the language. The practical application is
            that it would make toplevel invocations and instantiations polymorphic, obviating
            the need for things like dependency injection.</p></span></i><p>Most toplevel declarations contain nested declarations.</p><p>Nested declarations are often mixed together with executable statements.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="packages"></a>4.1.2.&nbsp;Packages</h3></div></div><div></div></div><p>Each compilation unit belongs to exactly one <span class="emphasis"><em>package</em></span>.
            Every toplevel declaration of the compilation unit also belongs directly to this 
            package. The package is identified by the location of the text file on the file 
            system, relative to a root <span class="emphasis"><em>source directory</em></span>, as defined in 
            <a href="#sourcelayout" title="9.2.&nbsp;Source layout">&sect;9.2 Source layout</a>.</p><p>A package is a namespace. A full package name is a period-separated list of 
            all-lowercase identifiers.</p><pre data-language="bnf">FullPackageName: PackageName ("." PackageName)*</pre><i><span class="comment"><p>Note: it is recommended that package names contain only characters
            from the ASCII character set.</p></span></i><p>There is also a <span class="emphasis"><em>default package</em></span> whose name is empty.
            It is impossible to import declarations from this package.</p><p>Every package belongs to exactly one module, as specified in 
            <a href="#modules" title="9.3.&nbsp;Module architecture">&sect;9.3 Module architecture</a>. The default package belongs to the default
            module.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="imports"></a>4.2.&nbsp;Imports</h2></div></div><div></div></div><p>Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a declaration defined in a compilation unit in another package 
        only if it explicitly <span class="emphasis"><em>imports</em></span> the declaration using the 
        <tt class="literal">import</tt> statement.</p><pre data-language="bnf">Import: "import" FullPackageName "{" ImportElements "}"</pre><p>For a given package, there may be at most one <tt class="literal">import</tt>
        statement per compilation unit.</p><p>An <tt class="literal">import</tt> statement may import from a package if and 
        only if:</p><div class="itemizedlist"><ul type="disc"><li><p>the package belongs to the same module as the compilation unit 
                containing the <tt class="literal">import</tt> statement, as specified by 
                <a href="#sourcelayout" title="9.2.&nbsp;Source layout">&sect;9.2 Source layout</a>, or</p></li><li><p>the package is declared <tt class="literal">shared</tt> in its
                package descriptor, and the module descriptor of the module to which
                the compilation unit containing the <tt class="literal">import</tt> statement 
                belongs, as specified by <a href="#sourcelayout" title="9.2.&nbsp;Source layout">&sect;9.2 Source layout</a>, explicitly or 
                implicitly imports the module containing the package, as defined by 
                <a href="#moduledescriptors" title="9.3.12.&nbsp;Module descriptors">&sect;9.3.12 Module descriptors</a>.</p></li></ul></div><p>Each <tt class="literal">import</tt> statement imports one or more toplevel 
        declarations from the given package, specifying a list of <span class="emphasis"><em>import
        elements</em></span>.</p><pre data-language="bnf">ImportElements: (ImportElement ",")* (ImportElement | ImportWildcard)</pre><pre data-language="bnf">ImportElement: ImportTypeElement | ImportFunctionValueElement</pre><p>An import element is a reference to either:</p><div class="itemizedlist"><ul type="disc"><li><p>a single toplevel type (a class, interface, or alias) of the 
                package,</p></li><li><p>a single toplevel function or value of the package, or</p></li><li><p>all toplevel declarations of the package.</p></li></ul></div><p>An import element may not refer to a declaration that is not visible to
        the compilation unit, as defined by <a href="#visibility" title="5.1.3.&nbsp;Visibility">&sect;5.1.3 Visibility</a>.</p><p>An <tt class="literal">import</tt> statement may not contain two import elements
        which refer to the same declaration.</p><p>Note that toplevel declarations in the package <tt class="literal">ceylon.language</tt> 
        never need to be explicitly imported. They are implicitly imported by every 
        compilation unit.</p><p>An imported function or value may not hide, as defined in 
        <a href="#hiddendeclarations" title="5.1.4.&nbsp;Hidden declarations">&sect;5.1.4 Hidden declarations</a>, any of the modifiers declared in 
        <tt class="literal">ceylon.language</tt> listed in <a href="#declarationmodifiers" title="7.4.1.&nbsp;Declaration modifiers">&sect;7.4.1 Declaration modifiers</a>,
        unless the modifier itself has an alias import in the compilation unit.</p><i><span class="comment"><p>Note: an unused import results in a compiler warning.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeimports"></a>4.2.1.&nbsp;Type imports</h3></div></div><div></div></div><p>An import element that specifies a type name imports the toplevel type 
            with that name from the given package.</p><pre data-language="bnf">ImportTypeElement: TypeAlias? TypeName ("{" ImportElements "}")?</pre><p>A compilation unit may not import two types with the same name.</p><pre data-language="ceylon">import java.util { Set, List, Map }</pre><p>The import element may be followed by a list of nested import elements, 
            which must specify aliases.</p><i><span class="comment"><p>Note: as a special exception to the usual language rules, to 
            support interoperation with Java, a nested import element which references a
            <tt class="literal">static</tt> member of a Java type results in a Ceylon
            <span class="emphasis"><em>toplevel</em></span> reference to the <tt class="literal">static</tt> member. 
            In this case, the import element may omit the explicit alias.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="methodattributeimports"></a>4.2.2.&nbsp;Function and value imports</h3></div></div><div></div></div><p>An import element that specifies a function or value name imports the 
            toplevel function or value with that name from the given package.</p><pre data-language="bnf">ImportFunctionValueElement: FunctionValueAlias? MemberName</pre><p>A compilation unit may not import two methods or attributes with the same 
            name.</p><pre data-language="ceylon">import ceylon.math { sqr, sqrt, e, pi }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aliasimports"></a>4.2.3.&nbsp;Alias imports</h3></div></div><div></div></div><p>The optional alias clause in a fully-explicit import allows resolution 
            of cross-namespace declaration name collisions.</p><pre data-language="bnf">TypeAlias: TypeName "="</pre><pre data-language="bnf">FunctionValueAlias: MemberName "="</pre><p>An alias assigns a different name to the imported declaration, or to a
            member of the imported declaration. This name is visible within the compilation
            unit in which the <tt class="literal">import</tt> statement occurs.</p><pre data-language="ceylon">import java.util { JavaMap = Map }</pre><pre data-language="ceylon">import my.math { fib = fibonnacciNumber }</pre><pre data-language="ceylon">import java.lang { 
    Math { sin, cos, ln=log }, 
    System { sysprops=properties },
    Char=Character { upper=toUpperCase, lower=toLowerCase, char=charValue } 
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="wildcardimports"></a>4.2.4.&nbsp;Wildcard imports</h3></div></div><div></div></div><p>The elipsis <tt class="literal">...</tt> acts as a wildcard in 
            <tt class="literal">import</tt> statements. An <tt class="literal">import</tt> statement 
            that specifies a wildcard imports every toplevel declaration of the imported 
            package, except for any declaration whose name collides with the name of a 
            toplevel declaration in the compilation unit in which the <tt class="literal">import</tt> 
            statement appears.</p><pre data-language="bnf">ImportWildcard: "..."</pre><p>An <tt class="literal">import</tt> statement may specify a list of alias imports 
            followed by a wildcard. In this case, the alias imports are imported with the 
            specified names, and all other toplevel declarations are imported with their 
            declared names.</p><pre data-language="ceylon">import ceylon.collection { ... }</pre><pre data-language="ceylon">import my.math { fib = fibonnacciNumber, ... }</pre><i><span class="comment"><p>Note: overuse of wildcard imports is discouraged.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="importedname"></a>4.2.5.&nbsp;Imported name</h3></div></div><div></div></div><p>Inside a compilation unit which imports a declaration, the declaration
            may be referred to, as specified in <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a> 
            and <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>, by its <span class="emphasis"><em>imported 
            name</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>For an import element with an alias, the imported name is the 
                    alias.</p></li><li><p>For an import element with no alias, or for a wildcard import, 
                    the imported name is the original name of the declaration.</p></li></ul></div><p>An import element may not result in an imported name that is the same
            as the name of a toplevel declaration contained in the compilation unit in
            which the import element occurs.</p><p>Two import elements occurring in the same compilation unit may not result 
            in the same imported name.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="parameters"></a>4.3.&nbsp;Parameters</h2></div></div><div></div></div><p>A function or class declaration may declare <span class="emphasis"><em>parameters</em></span>.
        A parameter is a value or function belonging to the declaration it parameterizes.
        Parameters are distinguished from other values or functions because they occur in
        a <span class="emphasis"><em>parameter list</em></span>. A value or function is a parameter of a 
        class or function if it is:</p><div class="itemizedlist"><ul type="disc"><li><p>declared inline in a parameter list of the class or function, or</p></li><li><p>declared normally, within the body of the class or function, but named 
                in a parameter list of the class or function.</p></li></ul></div><p>The following class definitions are semantically identical:</p><pre data-language="ceylon">class Person(shared String name, shared variable Integer age=0, Address* addresses) {}</pre><pre data-language="ceylon">class Person(name, age=0, addresses) {
    shared String name;
    shared variable Integer age;
    Address* addresses;
}</pre><p>A parameter declaration may only occur in a parameter list, or directly, as
        defined by <a href="#blockstructure" title="5.1.&nbsp;Block structure and references">&sect;5.1 Block structure and references</a>, in the body of a class or function. A 
        parameter declaration may not occur directly in the body of a getter or in a body of 
        a control structure. Nor may a parameter declaration appear as a toplevel declaration 
        in a compilation unit.</p><pre data-language="bnf">ParameterDeclaration: (ValueParameter | CallableParameter | VariadicParameter) ";"</pre><p>Every parameter declaration that occurs outside a parameter list must be named
        in the parameter list of the class or function in whose body it directly occurs, and
        its default argument, if any, must be specified in the parameter list.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="parameterlists"></a>4.3.1.&nbsp;Parameter lists</h3></div></div><div></div></div><p>A parameter list is a list of parameter declarations and of names of parameters
            declared in the body of the class or function to which the parameter list belongs. A 
            parameter list may include, optionally:</p><div class="itemizedlist"><ul type="disc"><li><p>one or more <span class="emphasis"><em>required parameters</em></span>,</p></li><li><p>one or more <span class="emphasis"><em>defaulted parameters</em></span> (parameters with 
                    default values), and/or</p></li><li><p>a <span class="emphasis"><em>variadic parameter</em></span>.</p></li></ul></div><p>In a parameter list, defaulted parameters, if any, must occur after required 
            parameters, if any. The variadic parameter, if any, must occur last.</p><pre data-language="bnf">Parameters: "(" ( (Required ",")* ( Required | (Defaulted ",")* (Defaulted | Variadic) ) )? ")"</pre><p>Every parameter list has a type, which captures the types of the individual 
            parameters in the list, whether they are defaulted, and whether the last parameter 
            is variadic. This type is always an subtype of <tt class="literal">Anything[]</tt>. The 
            type of an empty parameter list with no parameters is <tt class="literal">[]</tt>.</p><p>A parameter may not be annotated <tt class="literal">formal</tt>, but it may be
            annotated <tt class="literal">default</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="requiredparameters"></a>4.3.2.&nbsp;Required parameters</h3></div></div><div></div></div><p>A required parameter is a value or callable parameter without a default 
            argument.</p><p>A required parameter in a parameter list may be a parameter declaration, 
            or the name of a non-variadic parameter declared in the body of the function or 
            class.</p><pre data-language="bnf">Required: ValueParameter | CallableParameter | MemberName</pre><p>Required parameters must occur before any other parameters in the parameter 
            list.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="defaultedparameters"></a>4.3.3.&nbsp;Defaulted parameters</h3></div></div><div></div></div><p>A defaulted parameter is a value or callable parameter that specifies an 
            expression that produces a <span class="emphasis"><em>default argument</em></span>. A defaulted 
            parameter may be either:</p><div class="itemizedlist"><ul type="disc"><li><p>a non-variadic parameter declaration, together with a default 
                    argument expression, or</p></li><li><p>the name of a non-variadic parameter declared in the body of the 
                    function or class, together with its default argument expression.</p></li></ul></div><pre data-language="bnf">Defaulted: ValueParameter Specifier | CallableParameter LazySpecifier | MemberName Specifier</pre><p>The <tt class="literal">=</tt> and <tt class="literal">=&gt;</tt> specifiers are used 
            throughout the language. In a parameter list they are used to specify a default
            argument.</p><pre data-language="bnf">Specifier: "=" Expression</pre><pre data-language="bnf">LazySpecifier: "=&gt;" Expression</pre><p>The default argument expression may involve other parameters declared 
            earlier in the parameter list or lists. It may not involve parameters declared 
            later in the parameter list or lists.</p><p>The default argument expression may not involve an assignment, compound
            assignment, increment, or decrement operator.</p><p>Defaulted parameters must occur after required parameters in the parameter 
            list.</p><pre data-language="ceylon">(Product product, Integer quantity=1, Price pricing(Product p) =&gt; p.price)</pre><p>A parameter of a method or class annotated <tt class="literal">actual</tt> may 
            not specify a default argument. Instead, it inherits the default argument, if 
            any, of the corresponding parameter of the method it refines.</p><p>If two parameter lists are almost identical, differing only in that the 
            first parameter of one list is defaulted, and the first parameter of the second 
            list is required, and <tt class="literal">P</tt> is the the type of the second 
            parameter list, then the type of the first parameter list is 
            <tt class="literal">[]|P</tt>.</p><i><span class="comment"><p>Note: in Ceylon 1.0, for a function with multiple parameter lists, 
            defaulted parameters may only occur in the first parameter list. This restriction
            will be removed.</p></span></i><i><span class="comment"><p>TODO: Should we, purely for consistency, let you write 
            <tt class="literal">f(Float x) =&gt; x</tt> in a parameter list, when the callable 
            parameter is declared in the body of the function or class?</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="valueparameters"></a>4.3.4.&nbsp;Value parameters</h3></div></div><div></div></div><p>A <span class="emphasis"><em>value parameter</em></span> is a reference, as specified in
            <a href="#references" title="4.8.1.&nbsp;References">&sect;4.8.1 References</a>, that is named or defined in a parameter list. 
            Like any other value declaration, it has a name, type, and, optionally, 
            annotations.</p><pre data-language="bnf">ValueParameter: Annotations ValueParameterPrefix MemberName</pre><pre data-language="bnf">ValueParameterPrefix: Type | "dynamic"</pre><p>A value parameter may be declared using the keyword <tt class="literal">dynamic</tt> 
            in place of the parameter type, indicating that it is a partially typed declaration.
            Such a parameter has no type.</p><p>If a value parameter <tt class="literal">x</tt> has type <tt class="literal">X</tt>, 
            and a parameter list has type <tt class="literal">P</tt> with the principal instantiation 
            <tt class="literal">Sequential&lt;Y&gt;</tt>, then the type of a new parameter list 
            formed by prepending <tt class="literal">x</tt> to the first parameter list is:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Tuple&lt;X|Y,X,P&gt;</tt>, or </p></li><li><p><tt class="literal">[]|Tuple&lt;X|Y,X,P&gt;</tt> if <tt class="literal">x</tt> is 
                defaulted.</p></li></ul></div><p>The default argument expression, if any, for a callable parameter is 
            specified using an ordinary <tt class="literal">=</tt> specifier. The type of the 
            default argument expression must be assignable to the declared type of the 
            value parameter.</p><pre data-language="ceylon">(String label, Anything() onClick)</pre><pre data-language="ceylon">({Value*} values, Comparison(Value,Value) by)</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="callableparameters"></a>4.3.5.&nbsp;Callable parameters</h3></div></div><div></div></div><p>A <span class="emphasis"><em>callable parameter</em></span> is a function, as specified 
            in <a href="#functions" title="4.7.&nbsp;Functions">&sect;4.7 Functions</a>, named or defined in a parameter list. Like 
            any other function declaration, it has a name, type, one or more parameter 
            lists, and, optionally, annotations.</p><pre data-language="bnf">CallableParameter: Annotations CallableParameterPrefix MemberName Parameters+</pre><pre data-language="bnf">CallableParameterPrefix: Type | "void"</pre><p>If a callable parameter <tt class="literal">f</tt> has callable type 
            <tt class="literal">Callable&lt;X,A&gt;</tt>, as specified below in 
            <a href="#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>, and a parameter list has type 
            <tt class="literal">P</tt> with the principal instantiation 
            <tt class="literal">Sequential&lt;Y&gt;</tt>, then the type of a new parameter list 
            formed by prepending <tt class="literal">f</tt> to the first parameter list is:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Tuple&lt;Y|Callable&lt;X,A&gt;,Callable&lt;X,A&gt;,P&gt;</tt>, 
                or</p></li><li><p><tt class="literal">[]|Tuple&lt;Y|Callable&lt;X,A&gt;,Callable&lt;X,A&gt;,P&gt;</tt> 
                if <tt class="literal">f</tt> is defaulted.</p></li></ul></div><p>The default argument expression, if any, for a callable parameter is 
            specified using a lazy <tt class="literal">=&gt;</tt> specifier. The type of the 
            default argument expression must be assignable to the return type of the 
            callable parameter.</p><pre data-language="ceylon">(String label, void onClick())</pre><pre data-language="ceylon">({Value*} values, Comparison by(Value x, Value y))</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sequencedparameters"></a>4.3.6.&nbsp;Variadic parameters</h3></div></div><div></div></div><p>A <span class="emphasis"><em>variadic parameter</em></span> is a value parameter that accepts 
            multiple arguments:</p><div class="itemizedlist"><ul type="disc"><li><p>A variadic parameter declared <tt class="literal">T*</tt> accepts zero or
                    more arguments of type <tt class="literal">T</tt>, and has type <tt class="literal">[T*]</tt>.</p></li><li><p>A variadic parameter declared <tt class="literal">T+</tt> accepts one or
                    more arguments of type <tt class="literal">T</tt>, and has type <tt class="literal">[T+]</tt>.</p></li></ul></div><pre data-language="bnf">VariadicParameter: Annotations ParameterPrefix MemberName</pre><pre data-language="bnf">VariadicParameterPrefix: UnionType ("*" | "+")</pre><p>A variadic parameter in a parameter list may be a variadic parameter 
            declaration, or the name of a variadic parameter declared in the body of
            the function or class.</p><pre data-language="bnf">Variadic: VariadicParameter | MemberName</pre><p>The variadic parameter must be the last parameter in a parameter list. A
            variadic parameter may not have a default argument. A variadic parameter declared
            <tt class="literal">T+</tt> may not occur in a parameter list with defaulted parameters.</p><pre data-language="ceylon">(Name name, Organization? org=null, Address* addresses)</pre><pre data-language="ceylon">(Float+ floats)</pre><p>The type of a parameter list containing just a variadic parameter of type
            <tt class="literal">T*</tt> is <tt class="literal">[T*]</tt> The type of a parameter list 
            containing just a variadic parameter of type <tt class="literal">T+</tt> is 
            <tt class="literal">[T+]</tt>.</p><i><span class="comment"><p>Note: in Ceylon 1.0, for a function with multiple parameter lists, 
            a variadic parameters may only occur in the first parameter list. This restriction
            will be removed.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="interfaces"></a>4.4.&nbsp;Interfaces</h2></div></div><div></div></div><p>An <span class="emphasis"><em>interface</em></span> is a type schema, together with 
        implementation details for some members of the type. Interfaces may not 
        be directly instantiated.</p><pre data-language="bnf">InterfaceDeclaration: Annotations InterfaceHeader (InterfaceBody | TypeSpecifier ";")</pre><p>An interface declaration may optionally specify a list of type 
        parameters. An interface declaration may also have a list of interfaces 
        is satisfies, a self type or an enumerated list of cases, and/or a list 
        of type constraints.</p><pre data-language="bnf">InterfaceHeader: ("interface"|"dynamic") TypeName TypeParameters? InterfaceInheritance TypeConstraints?</pre><pre data-language="bnf">InterfaceInheritance: CaseTypes? SatisfiedTypes?</pre><p>To obtain a concrete instance of an interface, it is necessary to 
        define and instantiate a class that satisfies the interface, or define 
        an anonymous class that satisfies the interface.</p><p>The body of an interface contains:</p><div class="itemizedlist"><ul type="disc"><li><p>member (method, attribute, and member class) declarations, 
                and</p></li><li><p>nested interface, type alias, and <tt class="literal">abstract</tt> 
                class declarations.</p></li></ul></div><pre data-language="bnf">InterfaceBody: "{" Declaration* "}"</pre><p>Unlike the body of a class, method, or attribute, the body of an 
        interface is not executable, and does not directly contain procedural 
        code.</p><pre data-language="ceylon">shared interface Comparable&lt;Other&gt; {
    shared formal Comparison compare(Other other);
    shared Boolean largerThan(Other other) =&gt; compare(other)==larger;
    shared Boolean smallerThan(Other other) =&gt; compare(other)==smaller;
}</pre><p>An interface may declare <tt class="literal">formal</tt> methods, attributes,
        and member classes, and concrete methods, getters, setters, and member classes.
        A reference declaration, as defined in <a href="#references" title="4.8.1.&nbsp;References">&sect;4.8.1 References</a>, or 
        anonymous class declaration, as defined in <a href="#anonymousclasses" title="4.5.7.&nbsp;Anonymous classes">&sect;4.5.7 Anonymous classes</a>,
        may not directly occur in the body of an interface.</p><p>A non-<tt class="literal">abstract </tt> nested class declaration is called a
        <span class="emphasis"><em>member class</em></span> of the interface. A nested interface or 
        <tt class="literal">abstract</tt> class declaration is not part of the schema of the 
        interface type, and is therefore not considered a member of the interface.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="interfacebodies"></a>4.4.1.&nbsp;Interface bodies</h3></div></div><div></div></div><p>The body of an interface consists purely of declarations. The following 
            constructs may not occur sequentially in the body of an interface:</p><div class="itemizedlist"><ul type="disc"><li><p>a statement or control structure,</p></li><li><p>a reference declaration,</p></li><li><p>a forward-declared method or attribute declaration, or</p></li><li><p>an <tt class="literal">object</tt> declaration.</p></li></ul></div><p>Within an interface body, a <span class="emphasis"><em>super reference</em></span> 
            is any occurrence of the expression <tt class="literal">super</tt>, unless it also
            occurs in the body of a nested class or interface declaration. A statement or 
            declaration contained in the interface body may not:</p><div class="itemizedlist"><ul type="disc"><li><p>pass a super reference as an argument of an instantiation, 
                  method invocation, or <tt class="literal">extends</tt> clause expression or as 
                  the value of a value assignment or specification,</p></li><li><p>use a super reference as an operand of any operator except the
                  member selection operator, or the <tt class="literal">of</tt> operator as 
                  specified in <a href="#super" title="6.3.3.&nbsp;super">&sect;6.3.3 super</a>,</p></li><li><p>return a super reference, or</p></li><li><p>narrow the type of a super reference using the 
                  <tt class="literal">if (is ...)</tt> construct or 
                  <tt class="literal">case (is ...)</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="interfaceinheritance"></a>4.4.2.&nbsp;Interface inheritance</h3></div></div><div></div></div><p>An interface may satisfy any number of other interfaces.</p><pre data-language="ceylon">shared interface List&lt;Element&gt;
        satisfies Collection&lt;Element&gt; &amp; Correspondence&lt;Integer,Element&gt;
        given Element satisfies Object {
    ...
}</pre><p>Every type listed in the <tt class="literal">satisfies</tt> clause must 
            be an interface. An interface may not satisfy the same interface twice 
            (not even with distinct type arguments).</p><i><span class="comment"><p>Note: this second restriction is not strictly necessary.
            In fact, <tt class="literal">satisfies List&lt;One&gt;&amp;List&lt;Two&gt;</tt>
            means the same thing as <tt class="literal">satisfies List&lt;One&amp;Two&gt;</tt>,
            and the compiler already needs to be able to figure that out when it 
            comes to multiple instantiations of the same interface inherited 
            indirectly. Still, the restriction seems harmless enough.</p></span></i><p>The interface is a subtype of every type listed in the 
            <tt class="literal">satisfies</tt> clause. The interface is also a subtype of 
            the type <tt class="literal">Object</tt> defined in 
            <tt class="literal">ceylon.language</tt>.</p><p>An interface inherits all members (methods, attributes and member 
            types) of every supertype. That is, every member of every supertype of the 
            interface is also a member of the interface.  Furthermore, 
            the interface inherits all nested types (interfaces and 
            <tt class="literal">abstract</tt> classes) of every supertype.</p><p>The schema of the inherited members is formed by substituting type 
            arguments specified in the <tt class="literal">satisfies</tt> clause.</p><p>An interface that satisfies a nested interface must be a member of 
            the type that declares the nested interface or of a subtype of the type 
            that declares the nested interface.</p><p>A user-defined interface may not satisfy the interface 
            <tt class="literal">Callable</tt> defined in <tt class="literal">ceylon.language</tt>
            nor directly satisfy the interface <tt class="literal">ConstrainedAnnotation</tt>
            defined in <tt class="literal">ceylon.language</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sealedinterfaces"></a>4.4.3.&nbsp;Sealed interfaces</h3></div></div><div></div></div><p>A toplevel or nested interface may be annotated <tt class="literal">sealed</tt>
            and is called a <tt class="literal">sealed</tt> interface.</p><p>An interface annotated <tt class="literal">sealed</tt> may not be satisfied 
            by a class or interface outside the module in which it is defined.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="interfaceswithcases"></a>4.4.4.&nbsp;Interfaces with enumerated cases</h3></div></div><div></div></div><p>An interface declaration may enumerate a list of cases of the interface.</p><pre data-language="ceylon">shared interface Node&lt;Element&gt; 
            of Root&lt;Element&gt; | Branch&lt;Element&gt; | Leaf&lt;Element&gt; { ... }</pre><p>The cases may be interfaces, classes, or toplevel anonymous classes. A 
            case may be an <tt class="literal">abstract</tt> class. Each case must be a direct 
            subtype of the interface type. An interface may not be a case of itself. An 
            interface declaration may not list the same case twice.</p><p>If an interface has an <tt class="literal">of</tt> clause, then every interface 
            or class which is a subtype of the interface must occurs as exactly one of the 
            enumerated cases of the interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="interfacealiases"></a>4.4.5.&nbsp;Interface aliases</h3></div></div><div></div></div><p>An interface declaration which specifies a reference to another interface
            type defines an <span class="emphasis"><em>interface alias</em></span> of the specified interface 
            type.</p><pre data-language="bnf">TypeSpecifier: "=&gt;" Type</pre><p>The specified type must be an <span class="emphasis"><em>interface type</em></span>, that is,
            a reference to an interface with no type parameters, or an instantiation of a 
            generic interface. An interface alias simply assigns an alternative name to the 
            original interface type. A reference to the alias may occur anywhere a reference 
            to an interface may occur.</p><pre data-language="ceylon">shared interface PeopleByName =&gt; Map&lt;String,Person&gt;;</pre><pre data-language="ceylon">interface Compare&lt;Value&gt; =&gt; Comparison(Value,Value);</pre><p>If the aliased interface is a parameterized type, the aliased type must
            explicitly specify type arguments.</p><p>A class or interface may satisfy an interface alias, in which case, the
            class or interface inherits the aliased interface type.</p><p>Interface aliases are not reified types. The metamodel reference for an 
            interface alias type&#8212;for example, <tt class="literal">PeopleByName</tt>&#8212;returns 
            the metamodel object for the aliased interface&#8212;in this case, 
            <tt class="literal">Map&lt;String,Person&gt;</tt>, as specified in 
            <a href="#reification" title="8.1.2.&nbsp;Type argument reification">&sect;8.1.2 Type argument reification</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7181"></a>4.4.6.&nbsp;Dynamic interfaces</h3></div></div><div></div></div><p>A <span class="emphasis"><em>dynamic interface</em></span> is an interface declared with the 
            keyword <tt class="literal">dynamic</tt>. Dynamic interfaces may be used to model the 
            type of objects defined in dynamically typed native code.</p><p>Every declaration nested inside a dynamic interface must be declared 
            <tt class="literal">formal</tt>. A dynamic interface may not satisfy any interface 
            that is not also a dynamic interface.</p><p>Within a dynamic block, defined in <a href="#dynamicblocks" title="5.3.12.&nbsp;Dynamic blocks">&sect;5.3.12 Dynamic blocks</a>, 
            assignment of a value with no Ceylon type to a dynamic interface type does not 
            result in an <tt class="literal">AssertionError</tt>, as defined in 
            <a href="#dynamictypechecking" title="8.3.6.&nbsp;Dynamic type checking">&sect;8.3.6 Dynamic type checking</a>. Instead, the value is coerced to the
            dynamic interface type.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classes"></a>4.5.&nbsp;Classes</h2></div></div><div></div></div><p>A <span class="emphasis"><em>class</em></span> is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type.</p><pre data-language="bnf">ClassDeclaration: Annotations ClassHeader (ClassBody | ClassSpecifier ";")</pre><p>An ordinary class declaration specifies a list of parameters required 
        to instantiate the type, and, optionally a list of type parameters.  A class 
        declaration may have a superclass, a list of interfaces it satisfies, a self
        type or an enumerated list of cases, and/or a list of type constraints.</p><pre data-language="bnf">ClassHeader: "class" TypeName TypeParameters? Parameters ClassInheritance TypeConstraints?</pre><pre data-language="bnf">ClassInheritance: CaseTypes? ExtendedType? SatisfiedTypes?</pre><p>To obtain an instance of a class, it is necessary to instantiate the
        class, or a subclass of the class.</p><p>The body of a class contains:</p><div class="itemizedlist"><ul type="disc"><li><p>member (method, attribute, and member class) declarations,</p></li><li><p>nested interface, type alias, and <tt class="literal">abstract</tt> 
                class declarations, and</p></li><li><p>instance initialization code.</p></li></ul></div><pre data-language="bnf">ClassBody: "{" (Declaration | Statement)* "}"</pre><p>The body of a class may contain executable code.</p><pre data-language="ceylon">shared class Counter(Integer initialCount=0) {
    
    variable Integer n = initialCount;
    
    print("Initial count: ``n``");
    
    shared Integer count =&gt; n;
    
    shared void increment() {
        n++;
        print("Count: ``n``");
    }
    
}</pre><p>A non-<tt class="literal">abstract </tt> nested class declaration is called a
        <span class="emphasis"><em>member class</em></span> of the class. A nested interface or 
        <tt class="literal">abstract</tt> class declaration is not part of the schema of the 
        class type, and is therefore not considered a member of the class.</p><p>Ceylon classes do not have seperate nested constructor declarations. 
        Instead, the body of the class declares <span class="emphasis"><em>initializer parameters</em></span>. 
        An initializer parameter may be used anywhere in the class body, including in 
        method and attribute definitions.</p><pre data-language="ceylon">shared class Key(Lock lock) {
    shared void lock() {
        lock.engage(this);
        print("Locked.");
    }
    shared void unlock() {
        lock.disengage(this);
        print("Unlocked.");
    }
    shared Boolean locked =&gt; lock.engaged;
}</pre><p>An initializer parameter may be <tt class="literal">shared</tt>.</p><pre data-language="ceylon">shared class Point(shared Float x, shared Float y) { ... }</pre><pre data-language="ceylon">shared class Counter(count=0) {
    shared variable Integer count;
    shared void increment() =&gt; count++;
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="callabletypeofclass"></a>4.5.1.&nbsp;Callable type of a class</h3></div></div><div></div></div><p>The <span class="emphasis"><em>callable type</em></span> of a class captures the type and parameter 
            types of the class. The callable type is <tt class="literal">Callable&lt;T,P&gt;</tt>, where
            <tt class="literal">T</tt> is the class and <tt class="literal">P</tt> is the type of the initializer
            parameter list of the class.</p><p>An <tt class="literal">abstract</tt> class is not callable, except from the 
            <tt class="literal">extends</tt> clause of a subclass, or the class specifier of a class alias.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="initializersection"></a>4.5.2.&nbsp;Initializer section</h3></div></div><div></div></div><p>The initial part of the body of a class is called the 
            <span class="emphasis"><em>initializer</em></span> of the class and contains a mix of declarations, 
            statements and control structures. The initializer is executed every time the 
            class is instantiated.</p><p>A class initializer is responsible for initializing the state of the new 
            instance of the class, before a reference to the new instance is available to 
            clients.</p><pre data-language="ceylon">shared abstract class Point() {
    shared formal Float x;
    shared formal Float y;
}</pre><pre data-language="ceylon">shared class DiagonalPoint(Float distance) 
        extends Point() {
    
    value d = distance / 2^0.5;
    x =&gt; d;
    y =&gt; d;
    
    "must have correct distance from origin" 
    assert (x^2 + y^2 == distance^2);
    
}</pre><pre data-language="ceylon">shared object origin 
        extends Point() {
    x =&gt; 0.0;
    y =&gt; 0.0;
}</pre><p>Within a class initializer, a <span class="emphasis"><em>self reference to the instance 
            being initialized</em></span> is:</p><div class="itemizedlist"><ul type="disc"><li><p>any occurrence of the expression <tt class="literal">this</tt> or
                    <tt class="literal">super</tt>, unless it also occurs in the body of a 
                    nested class or interface declaration,</p></li><li><p>any occurrence of the expression <tt class="literal">outer</tt> in 
                    the body of a class or interface declaration immediately contained 
                    by the class, or</p></li><li><p>in the case of an anonymous class, any base expression, or 
                    qualified expression with receiver expression <tt class="literal">outer</tt>, 
                    that is a value reference to the anonymous class.</p></li></ul></div><p>A statement or declaration contained in the initializer of a class may 
            not evaluate an attribute, invoke a method, or instantiate a member class upon 
            the instance being initialized, including upon a self reference to the instance 
            being initialized, if the attribute, method, or member class:</p><div class="itemizedlist"><ul type="disc"><li><p>occurs later in the body of the class,</p></li><li><p>is annotated <tt class="literal">formal</tt> or <tt class="literal">default</tt>,
                  or</p></li><li><p>is inherited from an interface or superclass, and is not refined 
                  by a declaration occurring earlier in the body of the class.</p></li></ul></div><p>A member class contained in the initializer of a class may not 
            <tt class="literal">extend</tt> a member or nested class of an interface or 
            superclass of the class.</p><p>Furthermore, a statement or declaration contained in the initializer 
            of a class may not:</p><div class="itemizedlist"><ul type="disc"><li><p>pass a self reference to the instance being initialized as an 
                  argument of an instantiation, method invocation, or <tt class="literal">extends</tt> 
                  clause expression or as the value of a value assignment or specification,</p></li><li><p>use a self reference to the instance being initialized as an 
                  operand of any operator except the member selection operator, or
                  the <tt class="literal">of</tt> operator,</p></li><li><p>return a self reference to the instance being initialized, or</p></li><li><p>attempt to narrow the type of a self reference to the instance 
                  being initialized using the <tt class="literal">if (is ...)</tt> construct 
                  or <tt class="literal">case (is ...)</tt>.</p></li></ul></div><p>Nor may the class pass a self reference to the instance being 
            initialized as an argument of its own <tt class="literal">extends</tt> clause 
            expression, if any.</p><p>As a special exception to these rules, a statement contained in an 
            initializer may assign a self-reference to the instance being initialized
            to a reference annotated <tt class="literal">late</tt>.</p><p>For example, the following code fragments are not legal:</p><pre data-language="ceylon">class Graph() {
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
    class Node() {
        nodes.add(this);    //compiler error (this reference in initializer)
    }
}</pre><pre data-language="ceylon">class Graph() {
    class Node() {}
    Node createNode() {
        Node node = Node();
        nodes.add(node);    //compiler error (forward reference in initializer)
        return node;
    }
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
}</pre><p>But this code fragment is legal:</p><pre data-language="ceylon">class Graph() {
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
    Node createNode() {
        Node node = Node();
        nodes.add(node);
        return node;
    }
    class Node() {}
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="declarationsection"></a>4.5.3.&nbsp;Declaration section</h3></div></div><div></div></div><p>The remainder of the body of the class consists purely of declarations, 
            similar to the body of an interface. The following constructs may not occur 
            sequentially in the declaration section:</p><div class="itemizedlist"><ul type="disc"><li><p>a statement or control structure,</p></li><li><p>a reference declaration,</p></li><li><p>a forward-declared method or attribute declaration not
                    annotated <tt class="literal">late</tt>,</p></li><li><p>an <tt class="literal">object</tt> declaration with a non-empty 
                    initializer section, or</p></li><li><p>an <tt class="literal">object</tt> declaration that directly extends 
                    a class other than <tt class="literal">Object</tt> or <tt class="literal">Basic</tt> 
                    in <tt class="literal">ceylon.language</tt>.</p></li></ul></div><p>However, the declarations in this second section may freely use 
            <tt class="literal">this</tt> and <tt class="literal">super</tt>, and may invoke any method,
            evaluate any attribute, or instantiate any member class of the class or its 
            superclasses.</p><p>Within the declaration section of a class body, a <span class="emphasis"><em>super 
            reference</em></span> is any occurrence of the expression <tt class="literal">super</tt>, 
            unless it also occurs in the body of a nested class or interface declaration. A 
            statement or declaration contained in the declaration section of a class body may 
            not:</p><div class="itemizedlist"><ul type="disc"><li><p>pass a super reference as an argument of an instantiation, 
                  method invocation, or <tt class="literal">extends</tt> clause expression or as 
                  the value of a value assignment or specification,</p></li><li><p>use a super reference as an operand of any operator except the
                  member selection operator, or the <tt class="literal">of</tt> operator as 
                  specified in <a href="#super" title="6.3.3.&nbsp;super">&sect;6.3.3 super</a>,</p></li><li><p>return a super reference, or</p></li><li><p>narrow the type of a super reference using the 
                  <tt class="literal">if (is ...)</tt> construct or 
                  <tt class="literal">case (is ...)</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classinheritance"></a>4.5.4.&nbsp;Class inheritance</h3></div></div><div></div></div><p>A class may extend another class.</p><pre data-language="ceylon">shared class Customer(Name name, Organization? org = null) 
        extends Person(name, org) { 
    ... 
}</pre><p>The class is a subtype of the type specified by the <tt class="literal">extends</tt> 
            clause. If a class does not explicitly specify a superclass using <tt class="literal">extends</tt>,
            its superclass is the class <tt class="literal">Basic</tt> defined in 
            <tt class="literal">ceylon.language</tt>.
            </p><p>A class may satisfy any number of interfaces.</p><pre data-language="ceylon">class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt; &amp; Identifier {
    ... 
}</pre><p>The class is a subtype of every type listed in the <tt class="literal">satisfies</tt> 
            clause. A class may not satisfy the same interface twice (not even with distinct 
            type arguments).</p><p>A class inherits all members (methods, attributes, and member types) of every 
            supertype. That is, every member of every supertype of the class is also a member 
            of the class.  Furthermore, the class inherits all nested types (interfaces and 
            <tt class="literal">abstract</tt> classes) of every supertype.</p><p>Unless the class is declared <tt class="literal">abstract</tt> or 
            <tt class="literal">formal</tt>, the class:</p><div class="itemizedlist"><ul type="disc"><li><p>must declare or inherit a member that refines each 
                    <tt class="literal">formal</tt> member of every interface it satisfies directly 
                    or indirectly, and</p></li><li><p>must declare or inherit a member that refines each 
                    <tt class="literal">formal</tt> member of its superclass.</p></li></ul></div><p>The schema of the inherited members is formed by substituting type arguments
            specified in the <tt class="literal">extends</tt> or <tt class="literal">satisfies</tt> clause.</p><p>A subclass must pass values to each superclass initialization parameter in 
            the <tt class="literal">extends</tt> clause.</p><pre data-language="ceylon">shared class SpecialKey1()
        extends Key( SpecialLock() ) {
    ...
}</pre><pre data-language="ceylon">shared class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</pre><p>A subclass of a nested class must be a member of the type that declares 
             the nested class or of a subtype of the type that declares the nested class. 
             A class that satisfies a nested interface must be a member of the type that 
             declares the nested interface or of a subtype of the type that declares the 
             nested interface.</p><p>A user-defined class may not satisfy the interface 
             <tt class="literal">Callable</tt> defined in <tt class="literal">ceylon.language</tt> nor 
             directly satisfy the interface <tt class="literal">ConstrainedAnnotation</tt> 
             defined in <tt class="literal">ceylon.language</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="abstractandformalclasses"></a>4.5.5.&nbsp;Abstract, final, sealed, formal, and default classes</h3></div></div><div></div></div><p>A toplevel or nested class may be annotated <tt class="literal">abstract</tt>
            and is called an <tt class="literal">abstract</tt> class.</p><p>A toplevel or nested class may be annotated <tt class="literal">final</tt>
            and is called a <tt class="literal">final</tt> class.</p><p>A toplevel or nested class may be annotated <tt class="literal">sealed</tt>
            and is called a <tt class="literal">sealed</tt> class.</p><p>If a class annotated <tt class="literal">shared</tt> is a member of a containing 
            class or interface, then the class may be annotated <tt class="literal">formal</tt>
            and is called a <tt class="literal">formal</tt> member class, or, sometimes, an 
            <span class="emphasis"><em>abstract member class</em></span>.</p><p>An <tt class="literal">abstract</tt> class or <tt class="literal">formal</tt> member
            class may have <tt class="literal">formal</tt> members.</p><p>An <tt class="literal">abstract</tt> class may not be instantiated.</p><p>A <tt class="literal">formal</tt> member class may be instantiated.</p><p>A class which is not annotated <tt class="literal">formal</tt> or 
            <tt class="literal">abstract</tt> is called a <span class="emphasis"><em>concrete</em></span> class.</p><p>A concrete class may not have <tt class="literal">formal</tt> members.</p><p>A class annotated <tt class="literal">final</tt> must be a concrete class.</p><p>A class annotated <tt class="literal">final</tt> may not have <tt class="literal">default</tt> 
            members.</p><p>If a concrete class annotated <tt class="literal">shared</tt> is a member of a 
            containing class or interface, then the class may be annotated 
            <tt class="literal">default</tt> and is called a <tt class="literal">default</tt> member
            class.</p><p>A toplevel class may not be annotated <tt class="literal">formal</tt> or 
            <tt class="literal">default</tt>.</p><p>An un-<tt class="literal">shared</tt> class may not be annotated 
            <tt class="literal">formal</tt> or <tt class="literal">default</tt>.</p><p>A class annotated <tt class="literal">sealed</tt> may not be instantiated or
            extended outside the module in which it is defined.</p><p>A member class annotated <tt class="literal">sealed formal</tt> must belong to
            a <tt class="literal">sealed</tt> class or interface.</p><i><span class="comment"><p>Note: a <tt class="literal">formal</tt> member class would be a
            reasonably syntax for declaring virtual types. We think we don't need 
            virtual types because they don't offer much that type parameters don't
            already provide. For example:</p>
            <pre data-language="ceylon">shared formal class Buffer(Character...) 
        satisfies Sequence&lt;Character&gt;;</pre></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classrefinement"></a>4.5.6.&nbsp;Member class refinement</h3></div></div><div></div></div><p>Member class refinement is a unique feature of Ceylon, akin to the
            "factory method" pattern of many other languages.</p><div class="itemizedlist"><ul type="disc"><li><p>A member class annotated <tt class="literal">formal</tt> or
                    <tt class="literal">default</tt> may be refined by any class or 
                    interface which is a subtype of the class or interface which 
                    declares the member class.</p></li><li><p>A member class annotated <tt class="literal">formal</tt> 
                    <span class="emphasis"><em>must</em></span> be refined by every concrete class 
                    which is a subtype of the class or interface that declares the 
                    member class, unless the class inherits a concrete member class 
                    from a superclass that refines the <tt class="literal">formal</tt> 
                    member class.</p></li></ul></div><p>A member class of a subtype <span class="emphasis"><em>refines</em></span> a member 
            class of a supertype if the member class of the supertype is
            <tt class="literal">shared</tt> and the two classes have the same name. The 
            first class is called the <span class="emphasis"><em>refining</em></span> class, and the 
            second class is called the <span class="emphasis"><em>refined</em></span> class.</p><p>Then, given the refined realization of the class it refines, as 
            defined in <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>, and, after substituting the 
            type parameters of the refined class for the type parameters of the 
            refining class in the schema of the refining class, the refining class 
            must:</p><div class="itemizedlist"><ul type="disc"><li><p>have the same number of type parameters as the refined 
                    schema, and for each type parameter the intersection of its
                    upper bounds must be a supertype of the intersection of the 
                    upper bounds of the corresponding type parameter of the 
                    realization,</p></li><li><p>have a parameter list with the same signature as the 
                    realization, and</p></li><li><p>directly or indirectly extend the class it refines.</p></li></ul></div><p>Furthermore:</p><div class="itemizedlist"><ul type="disc"><li><p>the refining class must be annotated <tt class="literal">actual</tt>, 
                    and</p></li><li><p>the refined class must be annotated <tt class="literal">formal</tt>
                    or <tt class="literal">default</tt>.</p></li></ul></div><p>If a member class is annotated <tt class="literal">actual</tt>, it must 
            refine some member class of a supertype.</p><p>A member class may not, directly or indirectly, refine two different
            member classes not themselves annotated <tt class="literal">actual</tt>.</p><p>Then instantiation of the member class is polymorphic, and the actual
            subtype instantiated depends upon the concrete type of the containing class
            instance.</p><pre data-language="ceylon">shared abstract class Reader() {
    shared formal class Buffer(Character* chars) 
            satisfies Character[] {}
    ...
}</pre><pre data-language="ceylon">shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character* chars) 
            extends super.Buffer(chars) {
        ...
    }
    ...
}</pre><p>All of the above rules apply equally to member classes which are 
            aliases.</p><pre data-language="ceylon">shared abstract class Reader() {
    shared formal class Buffer(Character* chars) =&gt; AbstractBuffer(*chars);
    ...
}</pre><pre data-language="ceylon">shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character* chars) =&gt; FileBuffer(*chars);
    ...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="anonymousclasses"></a>4.5.7.&nbsp;Anonymous classes</h3></div></div><div></div></div><p>An <tt class="literal">object</tt> declaration makes it possible to define
            a class, instantiate the class, and declare a value referring to the 
            resulting class instance in a single declaration.</p><pre data-language="bnf">ObjectDeclaration: Annotations ObjectHeader ClassBody</pre><p>An <tt class="literal">object</tt> has an initial lowercase identifier.
            An <tt class="literal">object</tt> declaration does not specify parameters or
            type parameters.</p><pre data-language="bnf">ObjectHeader: "object" MemberName ObjectInheritance</pre><pre data-language="bnf">ObjectInheritance: ExtendedType? SatisfiedTypes?</pre><p>An <tt class="literal">object</tt> declaration specifies the name of the
            value and the schema, supertypes, and implementation of the class. It
            does not specify a type name. Instead, the type has a name assigned 
            internally by the compiler that is not available at compilation time.</p><p>An <tt class="literal">object</tt> class:</p><div class="itemizedlist"><ul type="disc"><li><p>is implicitly <tt class="literal">final</tt>,</p></li><li><p>may not be extended by another class,</p></li><li><p>may not be <tt class="literal">abstract</tt> or <tt class="literal">formal</tt>, 
                    and</p></li><li><p>may not declare <tt class="literal">default</tt> members.</p></li></ul></div><p>If the <tt class="literal">object</tt> is annotated <tt class="literal">shared</tt>, 
            the class is <tt class="literal">shared</tt>.</p><p>This class never appears in types inferred by local declaration type 
            inference or generic type argument inference. Instead, occurrences of the class 
            are replaced with the intersection of the extended type with all satisfied
            types.</p><p>An <tt class="literal">object</tt> value is a reference, as defined in
            <a href="#references" title="4.8.1.&nbsp;References">&sect;4.8.1 References</a>, and:</p><div class="itemizedlist"><ul type="disc"><li><p>is non-<tt class="literal">variable</tt>, and</p></li><li><p>may not be refined or declared <tt class="literal">default</tt>.</p></li></ul></div><p>If the <tt class="literal">object</tt> is annotated <tt class="literal">shared</tt>, 
            the value is <tt class="literal">shared</tt>. If the <tt class="literal">object</tt>
            is annotated <tt class="literal">actual</tt>, it refines an attribute of a 
            supertype.</p><p>The following declaration:</p><pre data-language="ceylon">shared object red extends Color('FF0000') {
     string =&gt; "Red";
}</pre><p>Is exactly equivalent to:</p><pre data-language="ceylon">shared final class \Ired() extends Color('FF0000') {
     string =&gt; "Red";
}

shared \Ired red = \Ired();</pre><p>Where <tt class="literal">\Ired</tt> is a name generated by the compiler.
            The algorithm for generating this name is not specified here.</p><p>Note that a member of an anonymous class that is not annotated 
            <tt class="literal">actual</tt> may only be accessed from within the body of 
            the anonymous class or by directly invoking the <tt class="literal">object</tt> 
            attribute.</p><pre data-language="ceylon">shared object sql {
    shared String escape(String string) { ... }
}

...

String escapedSearchString = sql.escape(searchString);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classeswithcases"></a>4.5.8.&nbsp;Classes with enumerated cases</h3></div></div><div></div></div><p>A class declaration may enumerate a list of cases of the class.</p><pre data-language="ceylon">shared abstract class Boolean() 
        of true | false {}
        
shared object true extends Boolean() { string =&gt; "true"; }
shared object false extends Boolean() { string =&gt; "false"; }</pre><pre data-language="ceylon">shared abstract class Node&lt;Element&gt;(String name) 
        of Branch&lt;Element&gt; | Leaf&lt;Element&gt; { ... }
        
shared class Leaf&lt;Element&gt;(String name, Element element) 
        extends Node&lt;Element&gt;(name) { ... }
        
shared class Branch&lt;Element&gt;(String name, Node&lt;Element&gt; left, Node&lt;Element&gt; right) 
        extends Node&lt;Element&gt;(name) { ... }</pre><p>The cases may be classes or toplevel anonymous classes. A case may 
            be an <tt class="literal">abstract</tt> class. Each case must be a direct 
            subclass of the enumerated class. A class may not be a case of itself. A 
            class declaration may not list the same case twice.</p><p>If a class has an <tt class="literal">of</tt> clause, then every class 
            that directly extends the class must occur as exactly one of the enumerated 
            cases of the class.</p><p>A non-<tt class="literal">abstract</tt> class may not have an 
            <tt class="literal">of</tt> clause.</p><i><span class="comment"><p>Note: in a future release of the language, we will introduce 
            an abbreviated syntax like:</p>
            <pre data-language="ceylon">shared abstract class Boolean(shared actual String string) 
        of object true ("true") | 
           object false ("false") {}</pre>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classaliases"></a>4.5.9.&nbsp;Class aliases</h3></div></div><div></div></div><p>A class declaration which specifies a reference to another class type 
            defines a <span class="emphasis"><em>class alias</em></span> of the specified class type.</p><pre data-language="bnf">ClassSpecifier: "=&gt;" ("super" ".")? TypeNameWithArguments PositionalArguments</pre><p>The specified type must be a <span class="emphasis"><em>class type</em></span>, that is,
            a reference to a class with no type parameters, or an instantiation of a generic 
            class. A class alias simply assigns an alternative name to the original class 
            type. A reference to the alias may occur anywhere a reference to a class may 
            occur.</p><pre data-language="ceylon">shared class People(Person* people) =&gt; ArrayList&lt;Person&gt;(*people);</pre><pre data-language="ceylon">class Named&lt;Value&gt;(String name, Value val) 
        given Value satisfies Object
        =&gt; Entry&lt;String,Value&gt;(name, val);</pre><p>Arguments to the initializer parameters of the aliased class must be
            specified.</p><p>If the aliased class is a parameterized type, the aliased type must
            explicitly specify type arguments.</p><p>The type arguments may not be inferred from the initializer arguments.</p><i><span class="comment"><p>Note: currently the compiler imposes a restriction that the 
            callable type of the aliased class must be assignable to the callable type 
            of the class alias. This restriction will be removed in future.</p></span></i><p>If a toplevel class alias or un-<tt class="literal">shared</tt> class alias
            aliases an <tt class="literal">abstract</tt> class, the alias must be annotated 
            <tt class="literal">abstract</tt>, and it may not be directly instantiated.</p><p>If a <tt class="literal">shared</tt> class alias nested inside the body 
            of a class or interface aliases an <tt class="literal">abstract</tt> class, the 
            alias must be annotated <tt class="literal">abstract</tt> or <tt class="literal">formal</tt>.
            If it is annotated <tt class="literal">formal</tt>, it is considered a member 
            class of the containing class or interface. If it is annotated 
            <tt class="literal">abstract</tt>, it is considered an abstract nested class of
            the containing class or interface.</p><p>A class or interface may extend a class alias, in which case, the 
            class inherits the aliased class type.</p><p>Class aliases are not reified types. The metamodel reference for a 
            class alias type&#8212;for example, <tt class="literal">People</tt>&#8212;returns 
            the metamodel object for the aliased class&#8212;in this case, 
            <tt class="literal">ArrayList&lt;Person&gt;</tt>, as specified in 
            <a href="#reification" title="8.1.2.&nbsp;Type argument reification">&sect;8.1.2 Type argument reification</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="typealiasedeclarations"></a>4.6.&nbsp;Type aliases</h2></div></div><div></div></div><p>A type alias declaration assigns a name to an arbitrary type expression,
        usually involving a union and/or intersection of types.</p><pre data-language="bnf">TypeAliasDeclaration: Annotations AliasHeader TypeSpecifier</pre><pre data-language="bnf">AliasHeader: "alias" TypeName TypeParameters? TypeConstraints?</pre><p>The specified type may be any kind of type. A reference to the alias 
        may be used anywhere a union or intersection type may be used. The alias may
        not appear in an <tt class="literal">extends</tt> or <tt class="literal">satisfies</tt>
        clause. The alias may not be instantiated.</p><pre data-language="ceylon">shared alias Number =&gt; Integer|Float|Decimal|Whole;</pre><pre data-language="ceylon">alias ListLike&lt;Value&gt; =&gt; List&lt;Value&gt;|Map&lt;Integer,Value&gt;;</pre><pre data-language="ceylon">alias Numbered&lt;Num,Value&gt; given Num satisfies Ordinal&lt;Num&gt; 
        =&gt; Correspondence&lt;Num,Value&gt;;</pre><i><span class="comment"><p>Note: class, interface, and type aliases use a "fat arrow" lazy 
        specifier <tt class="literal">=&gt;</tt> instead of <tt class="literal">=</tt> because the
        type parameters declared on the left of the specifier are in scope on the right
        of the specifier. An alias is in general a type constructor.</p></span></i><p>A class or interface may not extend or satisfy a type alias.</p><p>Type aliases are not reified types. The metamodel reference for a type 
        alias type&#8212;for example, <tt class="literal">Number</tt>&#8212;returns the 
        metamodel object for the aliased type&#8212;in this case, 
        <tt class="literal">Integer|Float|Decimal|Whole</tt>, as specified in 
        <a href="#reification" title="8.1.2.&nbsp;Type argument reification">&sect;8.1.2 Type argument reification</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="functions"></a>4.7.&nbsp;Functions</h2></div></div><div></div></div><p>A <span class="emphasis"><em>function</em></span> is a callable block of code. A function 
        may have parameters and may return a value. If a function belongs to a type,
        it is called a <span class="emphasis"><em>method</em></span>.</p><pre data-language="bnf">FunctionDeclaration: Annotations FunctionHeader (Block | LazySpecifier? ";")</pre><p>All function declarations specify the function name, one or more parameter 
        lists, and, optionally, a list of type parameters. A generic function declaration 
        may have a list of type constraints.</p><pre data-language="bnf">FunctionHeader: FunctionPrefix MemberName TypeParameters? Parameters+ TypeConstraints?</pre><p>A function declaration may specify a type, called the <span class="emphasis"><em>return 
        type</em></span>, to which the values the method returns are assignable, or it may
        specify that the function is a <tt class="literal">void</tt> function&#8212;a function 
        which does not return a useful value, and only useful for its effect.</p><pre data-language="bnf">FunctionPrefix: Type | "function" | "dynamic" | "void"</pre><p>Instead of an explicit return type, a function may be declared using:</p><div class="itemizedlist"><ul type="disc"><li><p>the keyword <tt class="literal">dynamic</tt>, indicating that it is a
                partially typed declaration with no return type, or</p></li><li><p>the keyword <tt class="literal">function</tt>, indicating that its return
		        type is inferred.</p></li></ul></div><p>A function implementation may be specified using either:</p><div class="itemizedlist"><ul type="disc"><li><p>a block of code, or</p></li><li><p>a lazy specifier.</p></li></ul></div><p>If a function is a parameter, it must not specify any implementation.</p><p>The return type of a <tt class="literal">void</tt> function is considered to be 
        <tt class="literal">Anything</tt> defined in <tt class="literal">ceylon.language</tt>.</p><i><span class="comment"><p>Note: a <tt class="literal">void</tt> function with a concrete 
        implementation returns the value <tt class="literal">null</tt>. However, since a
        <tt class="literal">void</tt> function may be a reference to a non-<tt class="literal">void</tt> 
        function, or a method refined by a non-<tt class="literal">void</tt> function, 
        this behavior can not be depended upon and is not implied by the semantics 
        of <tt class="literal">void</tt>.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="callabletypeoffunction"></a>4.7.1.&nbsp;Callable type of a function</h3></div></div><div></div></div><p>The <span class="emphasis"><em>callable type</em></span> of a function captures the return
            type and parameter types of the function.</p><div class="itemizedlist"><ul type="disc"><li><p>The callable type of a function with a single parameter list is 
                <tt class="literal">Callable&lt;R,P&gt;</tt> where <tt class="literal">R</tt> is the 
                return type of the method, or <tt class="literal">Anything</tt> if the function is 
                <tt class="literal">void</tt>, and <tt class="literal">P</tt> is the type of the
                parameter list.</p></li><li><p>The callable type of a function with multiple parameter lists is 
                <tt class="literal">Callable&lt;O,P&gt;</tt>, where <tt class="literal">O</tt> is the
                callable type of a method produced by eliminating the first parameter list, 
                and <tt class="literal">P</tt> is the type of the first parameter list of the
                function.</p></li></ul></div><i><span class="comment"><p>Note: the identification of <tt class="literal">void</tt> with
            <tt class="literal">Anything</tt> instead of <tt class="literal">Null</tt> or some other
            unit type will probably be contraversial. This approach allows a 
            non-<tt class="literal">void</tt> method to refine a <tt class="literal">void</tt>
            method or a non-<tt class="literal">void</tt> function to be assigned to a 
            <tt class="literal">void</tt> functional parameter. Thus, we avoid rejecting 
            perfectly well-typed code.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="functionswithblocks"></a>4.7.2.&nbsp;Functions with blocks</h3></div></div><div></div></div><p>A function implementation may be a block.</p><div class="itemizedlist"><ul type="disc"><li><p>If the function is declared <tt class="literal">void</tt>, the block 
                    may not contain a <tt class="literal">return</tt> directive that specifies 
                    an expression.</p></li><li><p>Otherwise, every conditional execution path of the block must 
                    end in a <tt class="literal">return</tt> directive that specifies an 
                    expression assignable to the return type of the function, or in a 
                    <tt class="literal">throw</tt> directive, as specified in 
                    <a href="#definitereturn" title="5.2.4.&nbsp;Definite return">&sect;5.2.4 Definite return</a>.</p></li></ul></div><pre data-language="ceylon">shared Integer add(Integer x, Integer y) {
    return x + y;
}</pre><pre data-language="ceylon">shared void printAll(Object* objects) {
    for (obj in objects) {
        print(obj);
    }
}</pre><pre data-language="ceylon">shared void addEntry(Key-&gt;Item entry) {
    map.put(entry.key,entry.item);
}</pre><pre data-language="ceylon">shared Set&lt;Element&gt; singleton&lt;Element&gt;(Element element) 
        given Element satisfies Comparable&lt;Element&gt; {
    return TreeSet { element };
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="functionswithspecifiers"></a>4.7.3.&nbsp;Functions with specifiers</h3></div></div><div></div></div><p>Alternatively, a function implementation may be a lazy specifier, that
            is, an expression specified using <tt class="literal">=&gt;</tt>. The type of the 
            specified expression must be assignable to the return type of the function.
            In the case of a function declared <tt class="literal">void</tt>, the expression
            must be a legal statement.</p><pre data-language="ceylon">shared Integer add(Integer x, Integer y) =&gt; x + y;</pre><pre data-language="ceylon">shared void addEntry(Key-&gt;Item entry) =&gt; map.put(entry.key,entry.item);</pre><pre data-language="ceylon">shared Set&lt;Element&gt; singleton&lt;Element&gt;(Element element) 
            given Element satisfies Comparable&lt;Element&gt;
        =&gt; TreeSet { element };</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="returntypeinference"></a>4.7.4.&nbsp;Function return type inference</h3></div></div><div></div></div><p>A non-<tt class="literal">void</tt>, un-<tt class="literal">shared</tt>  function with 
            a block or lazy specifier may be declared using the keyword <tt class="literal">function</tt> 
            in place of the explicit return type declaration. Then the function return type is 
            inferred:</p><div class="itemizedlist"><ul type="disc"><li><p>if the function implementation is a lazy specifier, then the 
                    return type of the function is the type of the specified expression,</p></li><li><p>if the function implementation is a block, and the function contains 
                    no <tt class="literal">return</tt> directive, then the return type of the method 
                    is <tt class="literal">Nothing</tt> (this is the case where the method always 
                    terminates in a <tt class="literal">throw</tt> directive), or,</p></li><li><p>otherwise, the return type of the function is the union of all 
                    returned expression types of <tt class="literal">return</tt> directives
                    of the method body.</p></li></ul></div><p>This function has inferred return type <tt class="literal">Integer</tt>.</p><pre data-language="ceylon">function add(Integer x, Integer y) =&gt; x + y;</pre><p>This function has inferred return type <tt class="literal">Float|Integer</tt>.</p><pre data-language="ceylon">function unit(Boolean floating) {
    if (floating) {
        return 1.0;
    }
    else {
        return 1;
    }
}</pre><p>This function has inferred return type <tt class="literal">Nothing</tt>.</p><pre data-language="ceylon">function die() {
    throw;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="functionforwarddeclaration"></a>4.7.5.&nbsp;Forward declaration of functions</h3></div></div><div></div></div><p>The declaration of a function may be separated from the specification of 
            its implementation. If a function declaration does not have a lazy specifier, 
            or a block, and is not annotated <tt class="literal">formal</tt>, and is not a 
            parameter, it is a <span class="emphasis"><em>forward-declared</em></span> function.</p><p>A forward-declared function may later be specified using a specification
            statement, as defined in <a href="#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>. The 
            specification statement for a forward-declared function may be:</p><div class="itemizedlist"><ul type="disc"><li><p>a lazy specification statement with parameter lists of exactly
                    the same types as the function, and a specified expression assignable
                    to the declared type of the function, or</p></li><li><p>an ordinary specification statement with a specified expression
                    assignable to the callable type of the function.</p></li></ul></div><pre data-language="ceylon">Comparison order(String x, String y);
if (reverseOrder) {
    order(String x, String y) =&gt; y&lt;=&gt;x;
}
else {
    order(String x, String y) =&gt; x&lt;=&gt;y;
}</pre><pre data-language="ceylon">Comparison format(Integer x);
switch (base)
case (decimal) {
    format = (Integer i) =&gt; i.string; 
}
case (binary) {
    format = formatBin;
}
case (hexadecimal) {
    format = formatHex;
}</pre><p>Every forward-declared function must explicitly specify a type. It may 
            not be declared using the keyword <tt class="literal">function</tt>.</p><p>A toplevel function may not be forward-declared. A method of an interface
            may not be forward-declared. A method annotated <tt class="literal">default</tt> may 
            not be forward-declared.</p><p>If a <tt class="literal">shared</tt> method is forward-declared, its 
            implementation must be definitely specified by all conditional paths in the
            class initializer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="multipleparameterlists"></a>4.7.6.&nbsp;Functions with multiple parameter lists</h3></div></div><div></div></div><p>A function may declare multiple lists of parameters. A function with 
            more than one parameter list returns instances of <tt class="literal">Callable</tt>
            in <tt class="literal">ceylon.language</tt> when invoked. Every function with 
            multiple parameter lists is exactly equivalent to a function with a single
            parameter list that returns an anonymous function.</p><p>This function declaration:</p><pre data-language="ceylon">Boolean greaterThan&lt;Element&gt;(Element val)(Element element)
        given Element satisfies Comparable&lt;Element&gt; =&gt; 
                element&gt;val;</pre><p>is equivalent to the following:</p><pre data-language="ceylon">Boolean(Element) greaterThan&lt;Element&gt;(Element val)
        given Element satisfies Comparable&lt;Element&gt; =&gt; 
                (Element element) =&gt; element&gt;val;</pre><p>For a function with <tt class="literal">n</tt> parameter lists, there are 
            <tt class="literal">n-1</tt> inferred anonymous functions. The <tt class="literal">i</tt>th 
            inferred function:</p><div class="itemizedlist"><ul type="disc"><li><p>has a callable type formed by eliminating the first <tt class="literal">i</tt>
                    parameter lists of the original declared function,</p></li><li><p>has the <tt class="literal">i+1</tt>th parameter list of the original
                    declared function, and</p></li><li><p>if <tt class="literal">i&lt;n</tt>, returns the <tt class="literal">i+1</tt>th 
                    inferred function, or</p></li><li><p>otherwise, if <tt class="literal">i==n</tt>, has the implementation 
                    of the original declared function.</p></li></ul></div><p>Then the original function returns the first inferred anonymous function.</p><p>This method declaration:</p><pre data-language="ceylon">function fullName(String firstName)(String middleName)(String lastName)
        =&gt; firstName + " " + middleName + " " + lastName;</pre><p>Is equivalent to:</p><pre data-language="ceylon">function fullName(String firstName) =&gt;
        (String middleName) =&gt;
                (String lastName) =&gt;
                        firstName + " " + middleName + " " + lastName;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="formalmethods"></a>4.7.7.&nbsp;Formal and default methods</h3></div></div><div></div></div><p>If a function declaration does not have a lazy specifier, or a block, 
            and is annotated <tt class="literal">shared</tt>, and is a method of either:</p><div class="itemizedlist"><ul type="disc"><li><p>an interface, or</p></li><li><p>a class annotated <tt class="literal">abstract</tt> or 
                    <tt class="literal">formal</tt>,</p></li></ul></div><p>then the function declaration may be annotated <tt class="literal">formal</tt>, 
            and is called a <tt class="literal">formal</tt> method, or, sometimes, an 
            <span class="emphasis"><em>abstract method</em></span>.</p><pre data-language="ceylon">shared formal Item? get(Key key);</pre><p>A method which is not annotated <tt class="literal">formal</tt> is called 
            a <span class="emphasis"><em>concrete</em></span> method.</p><p>If a concrete method is annotated <tt class="literal">shared</tt>, and is 
            a member of a class or interface, then it may be annotated <tt class="literal">default</tt>
            and is called a <tt class="literal">default</tt> method.</p><pre data-language="ceylon">shared default void writeLine(String line) {
    write(line);
    write("\n");
}</pre><p>A method annotated <tt class="literal">formal</tt> may not specify an
            implementation (a lazy specifier, or a block).</p><p>A method annotated <tt class="literal">default</tt> must specify an
            implementation (a lazy specifier, or a block), and may not be 
            forward-declared.</p><p>Every <tt class="literal">formal</tt> method must explicitly specify a type. 
            It may not be declared using the keyword <tt class="literal">function</tt>.</p><p>A toplevel method may not be annotated <tt class="literal">formal</tt> or
            <tt class="literal">default</tt>.</p><p>An un-<tt class="literal">shared</tt>  method may not be annotated 
            <tt class="literal">formal</tt> or <tt class="literal">default</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="methodrefinement"></a>4.7.8.&nbsp;Method refinement</h3></div></div><div></div></div><p>Methods may be refined, just like in other object-oriented languages.</p><div class="itemizedlist"><ul type="disc"><li><p>A class or interface may refine any <tt class="literal">formal</tt> 
                or <tt class="literal">default</tt> method it inherits, unless it inherits 
                a non-<tt class="literal">formal</tt> non-<tt class="literal">default</tt> method 
                that refines the method.</p></li><li><p>A concrete class must refine every <tt class="literal">formal</tt> 
                method it inherits, unless it inherits a non-<tt class="literal">formal</tt>
                method that refines the method.</p></li></ul></div><p>A method of a subtype <span class="emphasis"><em>refines</em></span> a method of a 
            supertype if the method of the supertype is <tt class="literal">shared</tt> 
            and the two methods have the same name. The first method is called the
            <span class="emphasis"><em>refining</em></span> method, and the second method is called
            the <span class="emphasis"><em>refined</em></span> method.</p><p>Then, given the refined realization of the method it refines, as 
            defined in <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>, and, after substituting the
            type parameters of the refined method for the type parameters of the
            refining method in the schema of the refining method, the refining method 
            must:</p><div class="itemizedlist"><ul type="disc"><li><p>have the same number of type parameters as the refined 
                    schema, and for each type parameter the intersection of its 
                    upper bounds must be a supertype of the intersection of the 
                    upper bounds of the corresponding type parameter of the 
                    realization,</p></li><li><p>have the same number of parameter lists, with the same
                    signatures, as the realization, and</p></li><li><p>have a return type that is assignable to the return type 
                    of the realization, or</p></li><li><p>if it has no return type, the refined method must also 
                    have no return type.</p></li></ul></div><i><span class="comment"><p>Note: in a future release of the language, we would like 
            to support contravariant refinement of method parameter types.</p></span></i><p>Furthermore:</p><div class="itemizedlist"><ul type="disc"><li><p>the refining method must be annotated <tt class="literal">actual</tt>, 
                    and</p></li><li><p>the refined method must be annotated <tt class="literal">formal</tt>
                    or <tt class="literal">default</tt>.</p></li></ul></div><p>If a method is annotated <tt class="literal">actual</tt>, it must refine 
            some method defined by a supertype.</p><p>A method may not, directly or indirectly, refine two different 
            methods not themselves annotated <tt class="literal">actual</tt>.</p><p>Then invocation of the method is polymorphic, and the actual method 
            invoked depends upon the concrete type of the class instance.</p><pre data-language="ceylon">shared abstract class AbstractSquareRooter() {
    shared formal Float squareRoot(Float x);
}</pre><pre data-language="ceylon">class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    shared actual Float squareRoot(Float x) =&gt; x^0.5;
}</pre><p>Alternatively, a subtype may refine a method using a specification
            statement, as defined in <a href="#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>. The 
            specification statement must satisfy the requirements of
            <a href="#functionforwarddeclaration" title="4.7.5.&nbsp;Forward declaration of functions">&sect;4.7.5 Forward declaration of functions</a> above for specification 
            of a forward-declared function.</p><pre data-language="ceylon">class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    squareRoot(Float x) =&gt; x^0.5;
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="values"></a>4.8.&nbsp;Values</h2></div></div><div></div></div><p>There are two basic kinds of <span class="emphasis"><em>value</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>reference</em></span> defines state. It has a persistent 
                value, determined at the moment it is specified or assigned.</p></li><li><p>A <span class="emphasis"><em>getter</em></span> defines how a value is evaluated. It 
                is defined using a block or lazy specifier, which is executed every time 
                the value is evaluated. A getter may have a matching 
                <span class="emphasis"><em>setter</em></span>.</p></li></ul></div><p>If a value belongs to a type, it is called an <span class="emphasis"><em>attribute</em></span>.</p><pre data-language="bnf">ValueDeclaration: Annotations ValueHeader (Block | (Specifier | LazySpecifier)? ";")</pre><p>All value declarations specify the value name.</p><pre data-language="bnf">ValueHeader: ValuePrefix MemberName</pre><p>A value declaration may specify a type.</p><pre data-language="bnf">ValuePrefix: Type | "value" | "dynamic"</pre><p>Instead of an explicit return type, a value may be declared using:</p><div class="itemizedlist"><ul type="disc"><li><p>the keyword <tt class="literal">dynamic</tt>, indicating that it is a
                partially typed declaration with no type, or</p></li><li><p>the keyword <tt class="literal">value</tt>, indicating that its type 
                is inferred.</p></li></ul></div><i><span class="comment"><p>Note: syntactically a value declaration looks like a function 
        declaration with zero parameter lists. It is often helpful, in thinking about the 
        syntax and semantics of Ceylon, to take the perspective that a value is a function 
        with zero parameter lists, or, alternatively, that a function is a value of type 
        <tt class="literal">Callable</tt>.</p></span></i><p>A value may be <span class="emphasis"><em>variable</em></span>, in which case it may be freely 
        assigned using the assignment and compound assignment operators defined in 
        <a href="#operators" title="6.8.&nbsp;Operators">&sect;6.8 Operators</a>. This is the case for a reference annotated 
        <tt class="literal">variable</tt>, or for a getter with a matching setter.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="references"></a>4.8.1.&nbsp;References</h3></div></div><div></div></div><p>The lifecycle and scope of the persistent value of a reference depends upon 
            where the reference declaration occurs:</p><div class="itemizedlist"><ul type="disc"><li><p>A toplevel reference represents global state associated with the 
                    lifecyle of a module, as defined by 
                    <a href="#toplevelinitialization" title="8.2.10.&nbsp;Initialization of toplevel references">&sect;8.2.10 Initialization of toplevel references</a>.</p></li><li><p>A reference declared directly inside the body of a class represents 
                    a persistent value associated with every instance of the class, as defined 
                    by <a href="#currentinstanceofaclassorinterface" title="8.2.3.&nbsp;Current instance of a class or interface">&sect;8.2.3 Current instance of a class or interface</a>. Repeated evaluation 
                    of the attribute of a particular instance of the class produces the same 
                    result until the attribute of the instance is assigned a new value.</p></li><li><p>A reference declared inside a block represents state associated with 
                    a frame, that is, with a particular execution of the containing block of 
                    code, as defined in <a href="#currentframeofablock" title="8.2.4.&nbsp;Current frame of a block">&sect;8.2.4 Current frame of a block</a>.</p></li></ul></div><p>The persistent value of a reference may be specified or initialized as part 
            of the declaration of the reference, or via a later specification statement, as
            defined in <a href="#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>, or assignment expression, as
            defined in <a href="#operators" title="6.8.&nbsp;Operators">&sect;6.8 Operators</a>, or, if it is a parameter, by an argument 
            to an invocation expression, as defined in <a href="#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>.</p><p>A reference annotated <tt class="literal">variable</tt> has a persistent value that 
            can be assigned multiple times. A reference not annotated <tt class="literal">variable</tt> 
            has a persistent value that can be specified exactly once and not subsequently 
            modified.</p><pre data-language="ceylon">variable Integer count = 0;</pre><pre data-language="ceylon">shared Decimal pi = calculatePi();</pre><pre data-language="ceylon">shared Integer[] evenDigits = [0,2,4,6,8];</pre><p>A reference declaration may have a specifier which specifies its persistent 
            value or, in the case of a variable reference, its initial persistent value. The type 
            of the specified expression must be assignable to the type of the reference.</p><p>If the specified expression has no type, and the declaration occurs within a 
            <tt class="literal">dynamic</tt> block, then the specification is not type-checked at 
            compile time.</p><p>If a reference is a parameter, it must not specify a persistent value.</p><p>A reference belonging to a class may be annotated <tt class="literal">late</tt>, in 
            which case the initializer of the class is not required to initialize its persistent
            value. Furthermore, a self-reference to an instance being initialized may be
            assigned to the reference.</p><p>A reference annotated <tt class="literal">late</tt> may not be initialized or 
            assigned a value by the class initializer. A parameter may not be annotated 
            <tt class="literal">late</tt>. A reference not belonging to a class may not be annotated 
            <tt class="literal">late</tt>.</p><p>If a class declares or inherits a <tt class="literal">variable</tt> reference, it 
            must (directly or indirectly) extend the class <tt class="literal">Basic</tt> defined in 
            <tt class="literal">ceylon.language</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="getters"></a>4.8.2.&nbsp;Getters</h3></div></div><div></div></div><p>A getter implementation may be a block.</p><pre data-language="ceylon">shared Float total {
    variable Float sum = 0.0;
    for (li in lineItems) {
        sum += li.amount;
    }
    return sum;
}</pre><p>Every conditional execution path of the block must end in a
            <tt class="literal">return</tt> directive that specifies an expression assignable 
            to the type of the value, or in a <tt class="literal">throw</tt> directive, as
            specified in <a href="#definitereturn" title="5.2.4.&nbsp;Definite return">&sect;5.2.4 Definite return</a>.</p><p>Alternatively, a getter implementation may be a lazy specifier, that
            is, an expression specified using <tt class="literal">=&gt;</tt>. The type of the 
            specified expression must be assignable to the type of the value.</p><pre data-language="ceylon">Name name =&gt; Name(firstName, initial, lastName);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="setters"></a>4.8.3.&nbsp;Setters</h3></div></div><div></div></div><p>A setter defines how the value of a getter is assigned.</p><pre data-language="bnf">SetterDeclaration: Annotations "assign" MemberName (Block | LazySpecifier)</pre><p>The name specified in a setter declaration must be the name of a
            matching getter that directly occurs earlier in the body containing the 
            setter declaration. If a getter has a setter, we say that the value is 
            <span class="emphasis"><em>variable</em></span>.</p><p>Within the body of the setter, a value reference to the getter 
            evaluates to the value being assigned.</p><p>A setter implementation may be a block. The block may not contain 
            a return directive that specifies an expression.</p><pre data-language="ceylon">shared String name { return join(firstName, lastName); }
assign name { firstName=first(name); lastName=last(name); }</pre><p>Alternatively, a setter implementation may be a lazy specifier. 
            The specified expression must be a legal statement.</p><pre data-language="ceylon">shared String name =&gt; join(n[0], n[1]);
assign name =&gt; n = [first(name), last(name)];</pre><p>A setter may not be annotated <tt class="literal">shared</tt>, 
            <tt class="literal">default</tt> or <tt class="literal">actual</tt>. The visibility 
            and refinement modifiers of an attribute with a setter are specified by 
            annotating the matching getter.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="valuetypeinference"></a>4.8.4.&nbsp;Value type inference</h3></div></div><div></div></div><p>An un-<tt class="literal">shared</tt>  value with a block, specifier, or lazy 
            specifier may be declared using the keyword <tt class="literal">value</tt> in place of 
            the explicit type declaration. Then the value's type is inferred:</p><div class="itemizedlist"><ul type="disc"><li><p>if the value is a reference with a specifier, then the type of the 
                    value is the type of the specified expression,</p></li><li><p>if the value is a getter, and the getter implementation is a lazy 
                    specifier, then the type of the value is the type of the specified 
                    expression,</p></li><li><p>if the value is a getter, and the getter implementation is a block, 
                    and the getter contains no <tt class="literal">return</tt> directive, then the 
                    type of the value is <tt class="literal">Nothing</tt> (this is the case where 
                    the getter always terminates in a <tt class="literal">throw</tt> directive), or</p></li><li><p>otherwise, the type of the value is the union of all returned 
                    expression types of <tt class="literal">return</tt> directives of the getter 
                    body.</p></li></ul></div><pre data-language="ceylon">value names = List&lt;String&gt;();</pre><pre data-language="ceylon">variable value count = 0;</pre><pre data-language="ceylon">value name =&gt; Name(firstName, initial, lastName);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="valueforwarddeclaration"></a>4.8.5.&nbsp;Forward declaration of values</h3></div></div><div></div></div><p>The declaration of a reference may be separated from the specification 
            or initialization of its persistent value. The declaration of a getter may be 
            separated from the specification of its implementation. If a value declaration 
            does not have a specifier, lazy specifier, or a block, and is not annotated 
            <tt class="literal">formal</tt>, it is a <span class="emphasis"><em>forward-declared</em></span> 
            value.</p><p>A forward-declared value may later be specified using a specification
            statement, as defined in <a href="#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>.</p><div class="itemizedlist"><ul type="disc"><li><p>The specification statement for a forward-declared getter is
                    a lazy specification statement with no parameter list, and a specified
                    expression assignable to the type of the value.</p></li><li><p>The specification statement for a forward-declared reference is
                    an ordinary specification statement with a specified expression
                    assignable to the type of the value.</p></li></ul></div><pre data-language="ceylon">String greeting;
switch (language)
case (en) {
    greeting = "Hello";
}
case (es) {
    greeting = "Hola";
}
else {
    throw LanguageNotSupported();
}
print(greeting);</pre><p>Every forward-declared value must explicitly specify a type. It may 
            not be declared using the keyword <tt class="literal">value</tt>.</p><p>A toplevel value may not be forward-declared. An attribute of an 
            interface may not be forward-declared. An attribute annotated 
            <tt class="literal">default</tt> may not be forward-declared.</p><p>A forward-declared getter may not have a setter.</p><p>If a <tt class="literal">shared</tt> value is forward-declared, its 
            implementation must be definitely specified by all conditional paths in the 
            class initializer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="formalattributes"></a>4.8.6.&nbsp;Formal and default attributes</h3></div></div><div></div></div><p>If a value declaration does not have a specifier, lazy specifier, or 
            a block, and is annotated <tt class="literal">shared</tt>, and is a member of 
            either:</p><div class="itemizedlist"><ul type="disc"><li><p>an interface, or</p></li><li><p>a class annotated <tt class="literal">abstract</tt> or 
                    <tt class="literal">formal</tt>,</p></li></ul></div><p>then the value declaration may be annotated <tt class="literal">formal</tt>, 
            and is called a <tt class="literal">formal</tt> attribute, or, sometimes, an 
            <span class="emphasis"><em>abstract attribute</em></span>.</p><pre data-language="ceylon">shared formal variable String firstName;</pre><p>An attribute which is not annotated <tt class="literal">formal</tt> is called 
            a <span class="emphasis"><em>concrete</em></span> attribute.</p><p>If a concrete attribute is annotated <tt class="literal">shared</tt>, and is 
            a member of a class or interface, then it may be annotated <tt class="literal">default</tt>
            and is called a <tt class="literal">default</tt> attribute.</p><pre data-language="ceylon">shared default String greeting = "Hello";</pre><p>An attribute annotated <tt class="literal">formal</tt> may not specify an
            implementation (a specifier, lazy specifier, or a block). Nor may there be 
            a setter for a formal attribute.</p><p>An attribute annotated <tt class="literal">default</tt> must specify an
            implementation (a specifier, lazy specifier, or a block), and may not be 
            forward-declared.</p><p>Every <tt class="literal">formal</tt> attribute must explicitly specify a type. 
            It may not be declared using the keyword <tt class="literal">function</tt>.</p><p>A toplevel attribute may not be annotated <tt class="literal">formal</tt> or
            <tt class="literal">default</tt>.</p><p>An un-<tt class="literal">shared</tt> attribute may not be annotated 
            <tt class="literal">formal</tt> or <tt class="literal">default</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="attributerefinement"></a>4.8.7.&nbsp;Attribute refinement</h3></div></div><div></div></div><p>Ceylon allows attributes to be refined, just like methods. This helps
            eliminate the need for Java-style getter and setter methods.</p><div class="itemizedlist"><ul type="disc"><li><p>A class or interface may refine any <tt class="literal">formal</tt> 
                or <tt class="literal">default</tt> attribute it inherits, unless it inherits 
                a non-<tt class="literal">formal</tt> non-<tt class="literal">default</tt> 
                attribute that refines the attribute.</p></li><li><p>A concrete class must refine every <tt class="literal">formal</tt> 
                attribute it inherits, unless it inherits a non-<tt class="literal">formal</tt>
                attribute that refines the attribute.</p></li></ul></div><p>Any non-variable attribute may be refined by a reference or getter. A 
            variable attribute may be refined by a <tt class="literal">variable</tt> refernce 
            or by a getter and setter pair.</p><i><span class="comment"><p>TODO: are you allowed to refine a getter or setter without also 
            refining its matching setter or getter?</p></span></i><p>An attribute of a subtype <span class="emphasis"><em>refines</em></span> an attribute
            of a supertype if the attribute of the supertype is <tt class="literal">shared</tt> 
            and the two attributes have the same name. The first attribute is called the 
            <span class="emphasis"><em>refining</em></span> attribute, and the second attribute is called 
            the <span class="emphasis"><em>refined</em></span> attribute.</p><p>Then, given the refined realization of the attribute it refines, as 
            defined in <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>, the refining attribute must:</p><div class="itemizedlist"><ul type="disc"><li><p>be variable, if the attribute it refines is variable, and</p></li><li><p>have <span class="emphasis"><em>exactly the same type</em></span> as the 
                    realization, if the attribute it refines is variable,</p></li><li><p>have a type that is assignable to the type of the refined 
                    schema, if the attribute it refines is not variable, or</p></li><li><p>if it has no type, the refined attribute must also have no 
                    type.</p></li></ul></div><p>Furthermore:</p><div class="itemizedlist"><ul type="disc"><li><p>the refining attribute must be annotated <tt class="literal">actual</tt>, 
                    and</p></li><li><p>the refined attribute must be annotated <tt class="literal">formal</tt>
                    or <tt class="literal">default</tt>.</p></li></ul></div><p>If an attribute is annotated <tt class="literal">actual</tt>, it must 
            refine some attribute defined by a supertype.</p><p>An attribute may not, directly or indirectly, refine two different
            attributes not themselves annotated <tt class="literal">actual</tt>.</p><p>A non-variable attribute may be refined by a variable attribute.</p><i><span class="comment"><p>TODO: Is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you refine an interface
            attribute, but not when you refine a superclass attribute?</p></span></i><p>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</p><pre data-language="ceylon">shared abstract class AbstractPi() {
    shared formal Float pi;
}</pre><pre data-language="ceylon">class ConcretePi() 
        extends AbstractPi() {
    shared actual Float pi = calculatePi();
}</pre><p>Alternatively, a subtype may refine an attribute using a specification 
            statement, as defined in <a href="#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>. The 
            specification statement must satisfy the requirements of 
            <a href="#valueforwarddeclaration" title="4.8.5.&nbsp;Forward declaration of values">&sect;4.8.5 Forward declaration of values</a> above for specification of a 
            forward-declared attribute.</p><pre data-language="ceylon">class ConcretePi() 
        extends AbstractPi() {
    pi = calculatePi();
}</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="statementblocks"></a>Chapter&nbsp;5.&nbsp;Statements, blocks, and control structures</h2></div></div><div></div></div><p>Function, value, and class bodies contain procedural code that is executed 
    when the function is invoked, the value evaluated, or the class instantiated. The 
    code contains expressions and control directives and is organized using blocks 
    and control structures.</p><i><span class="comment"><p>Note: the Ceylon language has a recursive block structure&#8212;statements 
    and declarations that are syntactically valid in the body of a toplevel declaration 
    are, in general, also syntactically valid in the body of a nested declaration or 
    of a control structure, and vice-versa.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blockstructure"></a>5.1.&nbsp;Block structure and references</h2></div></div><div></div></div><p>A <span class="emphasis"><em>body</em></span> is a block, defined in 
        <a href="#blocksandstatements" title="5.2.&nbsp;Blocks and statements">&sect;5.2 Blocks and statements</a>, class body, defined in 
        <a href="#classes" title="4.5.&nbsp;Classes">&sect;4.5 Classes</a>, interface body, defined in 
        <a href="#interfaces" title="4.4.&nbsp;Interfaces">&sect;4.4 Interfaces</a>, or comprehension clause, defined in
        <a href="#comprehensions" title="6.6.6.&nbsp;Comprehensions">&sect;6.6.6 Comprehensions</a>. Every body (except for a comprehension clause) 
        is list of semicolon-delimited statements, control structures, and declarations, 
        surrounded by braces. Some bodies end in a control directive. Every program 
        element in the list is said to <span class="emphasis"><em>directly occur</em></span> in the body. 
        A program element <span class="emphasis"><em>directly occurs earlier</em></span> than a second 
        program element if both program elements directly occur in a body and the first 
        program element occurs (lexically) earlier in the list than the second program 
        element.</p><p>A program element <span class="emphasis"><em>(indirectly) occurs</em></span> in a body if:</p><div class="itemizedlist"><ul type="disc"><li><p>the program element directly occurs in the body, or</p></li><li><p>the program element indirectly occurs inside the body of a declaration
                or control structure that occurs directly in the body.</p></li></ul></div><p>We sometimes say that the body <span class="emphasis"><em>contains</em></span> the program 
        element if the program element (indirectly) occurs in the body.</p><p>A program element <span class="emphasis"><em>(indirectly) occurs earlier</em></span> than a 
        second program element if:</p><div class="itemizedlist"><ul type="disc"><li><p>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</p></li><li><p>the second program element indirectly occurs inside the body of a 
                declaration or control structure, and the first program element directly 
                occurs earlier than the declaration or control structure.</p></li></ul></div><p>Then we also say that the second program element <span class="emphasis"><em>(indirectly) occurs 
        later</em></span> than the first. The set of program elements that occur later than a 
        program element is sometimes called the <span class="emphasis"><em>lexical scope</em></span> of the 
        program element.</p><p>A program element <span class="emphasis"><em>sequentially occurs</em></span> in a body if:</p><div class="itemizedlist"><ul type="disc"><li><p>the program element directly occurs in the body, or</p></li><li><p>the program element sequentially occurs inside the body of a control 
                structure that occurs directly in the body.</p></li></ul></div><p>A program element <span class="emphasis"><em>sequentially occurs earlier</em></span> than a 
        second program element if:</p><div class="itemizedlist"><ul type="disc"><li><p>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</p></li><li><p>the second program element sequentially occurs inside the body of a 
                control structure, and the first program element directly occurs earlier 
                than the declaration or control structure.</p></li></ul></div><p>If a program element sequentially occurs earlier than a second program element, 
        the <span class="emphasis"><em>sequence of statements</em></span> from the first program element to the
        second program element comprises:</p><div class="itemizedlist"><ul type="disc"><li><p>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the second program element, if the second program 
                element occurs directly in the same body as the first program element, or</p></li><li><p>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the declaration or control structure in whose body 
                the second program element sequentially occurs, followed by the sequence of 
                statements from the first statement of the declaration whose body contains 
                the second program element to the second program element itself, otherwise.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="declarationnameuniqueness"></a>5.1.1.&nbsp;Declaration name uniqueness</h3></div></div><div></div></div><p>A program element is contained within the <span class="emphasis"><em>namespace</em></span> 
            of a declaration if either:</p><div class="itemizedlist"><ul type="disc"><li><p>the declaration is a toplevel declaration, and the program 
                    element is a toplevel declaration of the same package,</p></li><li><p>the declaration directly occurs in a body, and the program
                    element sequentially occurs in the same body,</p></li><li><p>the declaration is a parameter or type parameter, and the
                    program element sequentially occurs in the body of the parameterized 
                    declaration, or</p></li><li><p>the program element is a control structure variable or 
                    iteration variable of a control structure that sequentially occurs 
                    in the namespace of the declaration.</p></li></ul></div><p>The namespace of a declaration may not contain a second declaration with 
            the same name. For example, the following is illegal:</p><pre data-language="ceylon">function fun(Float number) {
    if (number&lt;0.0) {
        Float number = 1.0; //error
        ...
    }
    ...
}</pre><p>A class or interface may not inherit a declaration with the same name as 
            a declaration it contains unless either:</p><div class="itemizedlist"><ul type="disc"><li><p>the contained declaration directly or indirectly refines the 
                    inherited declaration,</p></li><li><p>the contained declaration is not <tt class="literal">shared</tt>, or</p></li><li><p>the inherited declaration is not <tt class="literal">shared</tt>.</p></li></ul></div><p>A class or interface may not inherit two declarations with the same name 
            unless either:</p><div class="itemizedlist"><ul type="disc"><li><p>the class or interface contains a declaration that directly or 
                    indirectly refines both the inherited declarations (in which case both 
                    the inherited declarations directly or indirectly refine some member 
                    of a common supertype, as required by <a href="#classrefinement" title="4.5.6.&nbsp;Member class refinement">&sect;4.5.6 Member class refinement</a>,
                    <a href="#attributerefinement" title="4.8.7.&nbsp;Attribute refinement">&sect;4.8.7 Attribute refinement</a>, and 
                    <a href="#methodrefinement" title="4.7.8.&nbsp;Method refinement">&sect;4.7.8 Method refinement</a>),</p></li><li><p>one of the inherited declarations directly or indirectly refines 
                    the other inherited declaration, or</p></li><li><p>at least one of the inherited declarations is not 
                    <tt class="literal">shared</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scopeofdeclaration"></a>5.1.2.&nbsp;Scope of a declaration</h3></div></div><div></div></div><p>The scope of a declaration is governed by the body or package in which it 
            occurs. A declaration is <span class="emphasis"><em>in scope</em></span> at a program element if
            and only if either:</p><div class="itemizedlist"><ul type="disc"><li><p>the declaration is a parameter or type parameter of a declaration 
                    whose body contains the program element,</p></li><li><p>the declaration is a control structure variable or iteration 
                    variable belonging to a block of a control structure that contains the 
                    program element,</p></li><li><p>the program element belongs to or is contained in the body of the 
                    declaration itself,</p></li><li><p>the program element belongs to or is contained in the body of a 
                    class or interface which inherits the declaration,</p></li><li><p>the declaration directly occurs in a body containing the program
                    element,</p></li><li><p>the declaration is imported by the compilation unit containing the 
                    program element and is visible to the program element, or</p></li><li><p>the declaration is a toplevel declaration in the package containing 
                    the program element.</p></li></ul></div><p>Where:</p><div class="itemizedlist"><ul type="disc"><li><p>A control structure variable or iteration variable <span class="emphasis"><em>belongs</em></span> 
                    to a block of a control structure if the block immediately follows the declaration 
                    of the variable.</p></li><li><p>A program element <span class="emphasis"><em>belongs</em></span> to a declaration if it occurs
                    in the <tt class="literal">extends</tt>, <tt class="literal">satisfies</tt>, <tt class="literal">of</tt>,
                    or <tt class="literal">given</tt> clause of the declaration.</p></li></ul></div><p>Furthermore:</p><div class="itemizedlist"><ul type="disc"><li><p>A condition variable of a condition belonging to a condition list is 
                    in scope in any condition of the same condition list that occurs lexically 
                    later.</p></li><li><p>A resource expression variable of a <tt class="literal">try</tt> statement 
                    is in scope in any resource expression of the same resource expression list 
                    that occurs lexically later.</p></li><li><p>An iteration variable or condition variable of a comprehension is in 
                    scope in any clause of the comprehension that occurs lexically later, since
                    comprehension clauses are viewed as nested bodies.</p></li></ul></div><p>And finally, there are special rules for annotation lists, defined in 
            <a href="#annotationlists" title="7.1.1.&nbsp;Annotation lists">&sect;7.1.1 Annotation lists</a>:</p><div class="itemizedlist"><ul type="disc"><li><p>An annotation argument list belongs to the annotated declaration.</p></li><li><p>An annotation name is considered to occur directly in the compilation 
                    unit containing the program element.</p></li></ul></div><i><span class="comment"><p>Note: if no reference to an un-<tt class="literal">shared</tt> declaration 
            occurs within the scope of the declaration, a compiler warning is produced.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="visibility"></a>5.1.3.&nbsp;Visibility</h3></div></div><div></div></div><p>Classes, interfaces, functions, values, aliases, and type parameters 
            have names. Occurrence of a name in code implies a hard dependency from the 
            code in which the name occurs to the schema of the named declaration. We say 
            that a class, interface, value, function, alias, or type parameter is 
            <span class="emphasis"><em>visible</em></span> to a certain program element if its name may 
            occur in the code that belongs to that program element.</p><p>The visibility of a declaration depends upon where it occurs, and upon 
            whether it is annotated <tt class="literal">shared</tt>. A toplevel or member 
            declaration may be annotated <tt class="literal">shared</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>If a toplevel declaration is annotated <tt class="literal">shared</tt>, 
                    it is visible wherever the package that contains it is visible.
                    Otherwise, a toplevel declaration is visible only to code in the 
                    package containing its compilation unit.</p></li><li><p>If a member declaration is annotated <tt class="literal">shared</tt>, 
                    it is visible wherever the class or interface that contains it is 
                    visible. Otherwise, a declaration that occurs directly inside a class 
                    or interface body is visible only inside the class or interface 
                    declaration.</p></li></ul></div><p>A type parameter or a declaration that occurs directly inside a block 
            (the body of a function, getter, setter, or control structure) may not be 
            annotated <tt class="literal">shared</tt>.</p><div class="itemizedlist"><ul type="disc"><li><p>A type parameter is visible only inside the declaration to which 
                    it belongs.</p></li><li><p>A declaration that occurs directly inside a block is visible 
                    only inside the block.</p></li></ul></div><i><span class="comment"><p>TODO: Should we allow you to limit the effect of the 
            <tt class="literal">shared</tt> annotation by specifying a containing program 
            element or package?</p></span></i><p>We say that a type is <span class="emphasis"><em>visible</em></span> to a certain 
            program element if it is formed from references to classes, interfaces,
            type parameters, and type aliases whose declarations are visible to the 
            program element. For <tt class="literal">shared</tt> declarations:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of a value must be visible everywhere the value 
                    itself is visible.</p></li><li><p>The return type of a function must be visible everywhere 
                    the function itself is visible.</p></li><li><p>The satisfied interfaces of a class or interface must be 
                    visible everywhere the class or interface itself is visible.</p></li><li><p>The superclass of a class must be visible everywhere the 
                    class itself is visible.</p></li><li><p>The aliased type of a class alias, interface alias, or 
                    type alias must be visible everywhere the alias itself is 
                    visible.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="hiddendeclarations"></a>5.1.4.&nbsp;Hidden declarations</h3></div></div><div></div></div><p>If two declarations with the same name or imported name, as defined in 
            <a href="#importedname" title="4.2.5.&nbsp;Imported name">&sect;4.2.5 Imported name</a>, are both in scope at a certain program element, then 
            one declaration may <span class="emphasis"><em>hide</em></span> the other declaration.</p><div class="itemizedlist"><ul type="disc"><li><p>If an inner body is contained (directly or indirectly) in an outer 
                    body, a declaration that is in scope in the inner body but is not in 
                    scope in the outer body hides a declaration that is in scope in the outer 
                    body. (In particular, a declaration inherited by a nested class or 
                    interface hides a declaration of the containing body.)</p></li><li><p>An un-<tt class="literal">shared</tt> declaration occurring directly in 
                    the body of a class containing the program element hides a declaration 
                    inherited by the class.</p></li><li><p>An <tt class="literal">actual</tt> declaration hides the declaration it
                    refines.</p></li><li><p>A declaration occurring in a body containing the program element 
                    hides a declaration imported by the compilation unit containing the body
                    or implicitly imported from the module <tt class="literal">ceylon.language</tt>.</p></li><li><p>A toplevel declaration of the package containing the program element 
                    hides a declaration implicitly imported from the module 
                    <tt class="literal">ceylon.language</tt>.</p></li><li><p>A declaration explicitly imported by the compilation unit containing
                    the program element hides a declaration implicitly imported from the module 
                    <tt class="literal">ceylon.language</tt>.</p></li><li><p>A declaration explicitly imported by the compilation unit containing 
                    the program element hides a toplevel declaration of  the package containing the compilation unit.</p></li><li><p>A declaration explicity imported by name in the compilation unit 
                    containing the program element hides a declaration explicitly imported 
                    by wildcard in the compilation unit.</p></li></ul></div><p>For example, the following code is legal:</p><pre data-language="ceylon">class Person(name) {
    String name;
    shared String lowerCaseName {
        String name = this.name.lowercased;
        return name;
    }
}</pre><p>As is this code:</p><pre data-language="ceylon">class Point(x, y) {
    shared Float x; 
    shared Float y;
}

class Complex(Float x, Float y=0.0) 
        extends Point(x, y) {}</pre><p>When a member of a class is hidden by a nested declaration, the member 
            may be accessed via the self reference <tt class="literal">this</tt>, defined in
            <a href="#this" title="6.3.1.&nbsp;this">&sect;6.3.1 this</a>, or via the outer instance reference <tt class="literal">outer</tt>,
            defined in <a href="#outer" title="6.3.2.&nbsp;outer">&sect;6.3.2 outer</a>.</p><pre data-language="ceylon">shared class Item(name) {
    variable String name;
    shared void changeName(String name) {
        this.name = name;
    }
}</pre><pre data-language="ceylon">class Catalog(name) {
    shared String name;
    class Schema(name) {
        shared String name;
        Catalog catalog =&gt; outer;
        String catalogName =&gt; outer.name;
        class Table(name) {
            shared String name;
            Schema schema =&gt; outer;
            String schemaName =&gt; outer.name;
            String catalogName =&gt; catalog.name;
        }
    }
}</pre><p>When a toplevel declaration of a package is hidden by another declaration, 
            the toplevel declaration may be accessed via the containing package reference 
            <tt class="literal">package</tt>, defined in <a href="#thispackage" title="6.3.4.&nbsp;package">&sect;6.3.4 package</a>.</p><pre data-language="ceylon">Integer n =&gt; 0;
Integer f(Integer n) =&gt; n+package.n;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="referenceabilityofdeclaration"></a>5.1.5.&nbsp;References and block structure</h3></div></div><div></div></div><p>A declaration may be in scope at a program element, but not 
            <span class="emphasis"><em>referenceable</em></span> at the program element. A declaration 
            is referenceable at a program element if the declaration is in scope at 
            the program element and either:</p><div class="itemizedlist"><ul type="disc"><li><p>the program element occurs within the lexical scope of the 
                    declaration, or</p></li><li><p>the declaration does not directly occur in a block or in the
                    initializer section of a class body.</p></li></ul></div><p>Note that these rules have very different consequences for:</p><div class="itemizedlist"><ul type="disc"><li><p>a declaration that occurs in a block, as specified in 
                    <a href="#blocksandstatements" title="5.2.&nbsp;Blocks and statements">&sect;5.2 Blocks and statements</a>, or in an class initializer section, as
                    specified in <a href="#initializersection" title="4.5.2.&nbsp;Initializer section">&sect;4.5.2 Initializer section</a>, and
                    </p></li><li><p>a toplevel declaration, as specified in 
                    <a href="#topleveldeclarations" title="4.1.1.&nbsp;Toplevel and nested declarations">&sect;4.1.1 Toplevel and nested declarations</a>, or a declaration that occurs in a 
                    class declaration sectiony, as specified in <a href="#declarationsection" title="4.5.3.&nbsp;Declaration section">&sect;4.5.3 Declaration section</a>, 
                    or interface body, as specified in <a href="#interfacebodies" title="4.4.1.&nbsp;Interface bodies">&sect;4.4.1 Interface bodies</a>.</p></li></ul></div><p>Declarations that occurs in a block or class initializer section are interspersed
            with procedural code that initializes references. Therefore, a program element in a 
            block or initializer may not refer to a declaration that occurs later in the block or 
            class body. This restriction does not apply to declarations that occur in an interface 
            body or class declaration section. Nor does it apply to toplevel declarations, which
            are not considered to have a well-defined order.</p><p>The following toplevel function declarations, belonging to the same package, 
            are legal:</p><pre data-language="ceylon">Float x =&gt; y;</pre><pre data-language="ceylon">Float y =&gt; x;</pre><p>This code is not legal, since the body of a function is an ordinary block:</p><pre data-language="ceylon">Float-&gt;Float xy() {
    Float x =&gt; y;  //compiler error: y is not referenceable
    Float y =&gt; x;
    return x-&gt;y;
}</pre><p>This code is not legal, since all three statements occur in the initializer 
            section of the class body:</p><pre data-language="ceylon">class Point() {
    Float x =&gt; y;  //compiler error: y is not referenceable
    Float y =&gt; x;
    Float-&gt;Float xy = x-&gt;y;
}</pre><p>However, this code <span class="emphasis"><em>is</em></span> legal, since the statements occur 
            in the declaration section of the class body:</p><pre data-language="ceylon">class Point() {
    Float x =&gt; y;
    Float y =&gt; x;
}</pre><p>Likewise, this code is legal, since the statements occur in an interface 
            body:</p><pre data-language="ceylon">interface Point {
    Float x =&gt; y;
    Float y =&gt; x;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeinferenceandblockstructure"></a>5.1.6.&nbsp;Type inference and block structure</h3></div></div><div></div></div><p>A value declared using the keyword <tt class="literal">value</tt> or a
            function declared using the keyword <tt class="literal">function</tt> may be 
            in scope at a program element, but its type may not be 
            <span class="emphasis"><em>inferrable</em></span>, as defined by 
            <a href="#typeinference" title="3.2.9.&nbsp;Type inference">&sect;3.2.9 Type inference</a>, from the point of view of that program 
            element.</p><p>The type of a value or function declared using the keyword 
            <tt class="literal">value</tt> or <tt class="literal">function</tt> is inferrable 
            to a program element if the declaration is in scope at the program 
            element and the program element occurs within the lexical scope of the 
            declaration.</p><i><span class="comment"><p>Note: the type of a value or function declared using
            the keyword <tt class="literal">value</tt> or <tt class="literal">function</tt> is
            not inferrable within the body of the value or function 
            itself.</p></span></i><p>For any other declaration, including any declaration which 
            explicitly specifies its type, the type is considered inferrable to a 
            program element if the declaration is in scope at the program 
            element.</p><p>The following code is not legal:</p><pre data-language="ceylon">interface Point {
    value x =&gt; y;  //compiler error: type of y is not inferrable
    value y =&gt; x;
}</pre><p>However, this code is legal:</p><pre data-language="ceylon">interface Point {
    value x =&gt; y;
    Float y =&gt; x;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="unqualifiedreferenceresolution"></a>5.1.7.&nbsp;Unqualified reference resolution</h3></div></div><div></div></div><p>An <span class="emphasis"><em>unqualified reference</em></span> is:</p><div class="itemizedlist"><ul type="disc"><li><p>the type name in an unqualified type declaration or type 
                    argument, as defined by <a href="#typeexpressions" title="3.2.7.&nbsp;Type expressions">&sect;3.2.7 Type expressions</a>, for 
                    example <tt class="literal">String</tt> and <tt class="literal">Sequence</tt> 
                    in <tt class="literal">Sequence&lt;String&gt;</tt>,</p></li><li><p>the value, function, or type name in a base expression, 
                    as defined by <a href="#baseexpressions" title="6.5.1.&nbsp;Base expressions">&sect;6.5.1 Base expressions</a>, for example 
                    <tt class="literal">counter</tt> in <tt class="literal">counter.count</tt>, 
                    <tt class="literal">entries</tt> and <tt class="literal">people</tt> in 
                    <tt class="literal">entries(people*.name)</tt>, or 
                    <tt class="literal">Entry</tt>, <tt class="literal">name</tt>, and
                    <tt class="literal">item</tt> in <tt class="literal">Entry(name,item)</tt>, 
                    or</p></li><li><p>the type name in an unqualified type in a static expression, 
                    as defined by <a href="#staticexpressions" title="6.5.5.&nbsp;Static expressions">&sect;6.5.5 Static expressions</a>, for example 
                    <tt class="literal">Sequence</tt> in 
                    <tt class="literal">Sequence.iterator</tt>.</p></li></ul></div><p>If a program element contains an unqualified reference:</p><div class="itemizedlist"><ul type="disc"><li><p>there must be at least one declaration with the given name or 
                    imported name, as defined in <a href="#importedname" title="4.2.5.&nbsp;Imported name">&sect;4.2.5 Imported name</a>, in scope 
                    at the program element, and</p></li><li><p>if multiple declarations with the given name or imported name 
                    are in scope at the program element where the given name occurs, then 
                    it is guaranteed by the type system and 
                    <a href="#declarationnameuniqueness" title="5.1.1.&nbsp;Declaration name uniqueness">&sect;5.1.1 Declaration name uniqueness</a> that there is exactly one 
                    such declaration which is not hidden by any other declaration.</p></li></ul></div><p>Then the reference is to this unique unhidden declaration, and:</p><div class="itemizedlist"><ul type="disc"><li><p>the declaration must be referenceable at the program element,</p></li><li><p>the type of the declaration must be inferrable to the program 
                    element, and</p></li><li><p>if the declaration is forward-declared, it must be definitely
                    initialized at the program element.</p></li></ul></div><p>As a special exception to the above, if there is no declaration with the 
            given name or imported name in scope at the program element and the program element 
            occurs inside a <tt class="literal">dynamic</tt> block, then the unqualified reference 
            does not refer to any statically typed declaration.</p><p>If an unqualified reference refers to a member declaration of a type, then
            there is a unique <span class="emphasis"><em>inheriting or declaring class or interface</em></span> 
            for the unqualified reference, that is, the unique class or interface in whose 
            body the unqualified reference occurs, and which declares or inherits the member
            declaration, and for which the member is not hidden at the program element where
            the unqualified reference occurs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="qualifiedreferenceresolution"></a>5.1.8.&nbsp;Qualified reference resolution</h3></div></div><div></div></div><p>A <span class="emphasis"><em>qualified reference</em></span> is:</p><div class="itemizedlist"><ul type="disc"><li><p>the type name in a qualified type declaration or type argument, 
                    as defined by <a href="#typeexpressions" title="3.2.7.&nbsp;Type expressions">&sect;3.2.7 Type expressions</a>, for example 
                    <tt class="literal">Buffer</tt> 
                    in <tt class="literal">BufferedReader.Buffer</tt>,</p></li><li><p>the value, function, or type name in a member expression, as 
                    defined by <a href="#memberexpressions" title="6.5.2.&nbsp;Member expressions">&sect;6.5.2 Member expressions</a>, for example 
                    <tt class="literal">count</tt> in <tt class="literal">counter.count</tt>,
                    <tt class="literal">split</tt> in <tt class="literal">text.split()</tt>, or 
                    <tt class="literal">Buffer</tt> in <tt class="literal">br.Buffer()</tt>,</p></li><li><p>the type name in a qualified type in a static expression, as 
                    defined by <a href="#staticexpressions" title="6.5.5.&nbsp;Static expressions">&sect;6.5.5 Static expressions</a>, for example 
                    <tt class="literal">Buffer</tt> in 
                    <tt class="literal">BufferedReader.Buffer.size</tt>, or the member name 
                    in a static expression, for example <tt class="literal">iterator</tt> in 
                    <tt class="literal">Sequence.iterator</tt>, or <tt class="literal">size</tt> in 
                    <tt class="literal">BufferedReader.Buffer.size</tt>.</p></li></ul></div><p>Every qualified reference has a qualifying type:</p><div class="itemizedlist"><ul type="disc"><li><p>For a type declaration, the qualifying type is the full
                    qualified type the qualifies the type name.</p></li><li><p>For a value reference or callable reference, the 
                    qualifying type is the type of the receiver expression.</p></li><li><p>For a static reference, the qualifying type is the full 
                    qualified type the qualifies the type or member name.</p></li></ul></div><p>A qualified reference may not have <tt class="literal">Nothing</tt> as the
            qualifying type.</p><p>If a program element contains a qualified reference:</p><div class="itemizedlist"><ul type="disc"><li><p>the qualifying type must have or inherit at least one member 
                    or nested type with the given name or imported name, as defined in 
                    <a href="#importedname" title="4.2.5.&nbsp;Imported name">&sect;4.2.5 Imported name</a>, which is visible at the program 
                    element, and</p></li><li><p>if there are multiple visible members with the given name or 
                    imported name, then it is guaranteed by the type system and
                    <a href="#declarationnameuniqueness" title="5.1.1.&nbsp;Declaration name uniqueness">&sect;5.1.1 Declaration name uniqueness</a> that there is exactly 
                    one such member which is not refined by another member, except</p></li><li><p>if the qualifying type inherits a class or interface that
                    contains the program element, and an un-<tt class="literal">shared</tt>
                    declaration contained directly in the body of this class or 
                    interface has the same name as a <tt class="literal">shared</tt> member 
                    of the qualifying type, in which case the un-<tt class="literal">shared</tt>
                    declaration hides the <tt class="literal">shared</tt> member, or</p></li><li><p>if the qualifying type is an intersection type, in which case 
                    there may be multiple members which are not refined by another 
                    member, but where there is exactly one such member that is refined 
                    by each of these members, but is not refined by another member that 
                    is refined by all of these members, except</p></li><li><p>in the case of certain pathological intersection types, where 
                    two of the intersected types declare distinct members with the same 
                    name, that do not refine any member of a common supertype (in which 
                    case what we actually have are disjoint types that are nevertheless 
                    not considered provably disjoint within the rules of the typesystem), 
                    and in this case the qualified reference is considered illegal.</p></li></ul></div><p>Then the reference is to the unique member or nested class. If the 
            program element is contained in the body of a class or interface, and the 
            member declaration directly occurs in the body of the class or interface, 
            and the qualified reference is a value reference or callable reference, and 
            the receiver expression is a self reference to the instance being 
            initialized, then:</p><div class="itemizedlist"><ul type="disc"><li><p>the member declaration must be referenceable at the program
                    element,</p></li><li><p>the type of the member must be inferrable to the program 
                    element, and</p></li><li><p>if the member declaration is forward-declared, it must be 
                    definitely initialized at the program element.</p></li></ul></div><p>As a special exception to the above, if the program element occurs inside 
            a <tt class="literal">dynamic</tt> block, and the the receiver expression has no type, 
            then the qualified reference does not refer to any statically typed declaration.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blocksandstatements"></a>5.2.&nbsp;Blocks and statements</h2></div></div><div></div></div><p>A <span class="emphasis"><em>block</em></span> is list of semicolon-delimited statements, 
        control structures, and declarations, surrounded by braces.</p><pre data-language="bnf">Block: "{" (Declaration | Statement)* "}"</pre><p>A <span class="emphasis"><em>statement</em></span> is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a control structure, a 
        control directive, or an assertion.</p><pre data-language="bnf">Statement: ExpressionStatement | Specification | Assertion | DirectiveStatement | ControlStructure</pre><p>A statement or declaration contained in a block may not evaluate a value, 
        invoke a function, instantiate a class, or extend a class whose declaration 
        occurs later in the block.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="expressionstatements"></a>5.2.1.&nbsp;Expression statements</h3></div></div><div></div></div><p>Only certain expressions are valid statements:</p><div class="itemizedlist"><ul type="disc"><li><p>assignment,</p></li><li><p>prefix or postfix increment or decrement,</p></li><li><p>invocation of a method,</p></li><li><p>instantiation of a class.</p></li></ul></div><pre data-language="bnf">ExpressionStatement: ( Assignment | IncrementOrDecrement | Invocation ) ";"</pre><p>For example:</p><pre data-language="ceylon">x += 1;</pre><pre data-language="ceylon">x++;</pre><pre data-language="ceylon">print("Hello");</pre><pre data-language="ceylon">Main(process.arguments);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="controldirectives"></a>5.2.2.&nbsp;Control directives</h3></div></div><div></div></div><p>A <span class="emphasis"><em>control directive</em></span> statement ends execution of the 
            current block and forces the flow of execution to resume in some outer scope. 
            They may only occur as the lexically last statement of a block.</p><pre data-language="bnf">DirectiveStatement: Directive ";"</pre><p>There are four control directives:</p><div class="itemizedlist"><ul type="disc"><li>the <tt class="literal">return</tt> directive&#8212;to return a value from 
                a getter or non-<tt class="literal">void</tt> function or terminate execution of a 
                setter, class initializer, or <tt class="literal">void</tt> method,</li><li>the <tt class="literal">break</tt> directive&#8212;to terminate a loop,</li><li>the <tt class="literal">continue</tt> directive&#8212;to jump to the next 
                iteration of a loop, and</li><li>the <tt class="literal">throw</tt> directive&#8212;to raise an exception.</li></ul></div><pre data-language="bnf">Directive: Return | Throw | Break | Continue</pre><p>For example:</p><pre data-language="ceylon">throw Exception();</pre><pre data-language="ceylon">return x+y;</pre><pre data-language="ceylon">break;</pre><pre data-language="ceylon">continue;</pre><p>The <tt class="literal">return</tt> directive must sequentially occur in the body 
            of a function, getter, setter, or class initializer. In the case of a 
            setter, class initializer, or <tt class="literal">void</tt> function, no expression may 
            be specified. In the case of a getter or non-<tt class="literal">void</tt> function, an 
            expression must be specified. The expression type must be assignable to the return 
            type of the function or the type of the value. When the directive is executed, the 
            expression is evaluated to determine the return value of the function or getter.</p><pre data-language="bnf">Return: "return" Expression?</pre><p>If the specified expression has no type, or if the function or getter has
            no type, and the directive occurs within a <tt class="literal">dynamic</tt> block, then 
            the directive is not type-checked at compile time.</p><i><span class="comment"><p>Note: a <tt class="literal">return</tt> statement returns only from the
            innermost function, getter, setter, or class initializer, even in the case of a
            nested or anonymous function. There are no "non-local returns" in the language.</p></span></i><p>The <tt class="literal">break</tt> directive must sequentially occur in the body 
            of a loop.</p><pre data-language="bnf">Break: "break"</pre><p>The <tt class="literal">continue</tt> directive must sequentially occur in the body 
            of a loop.</p><pre data-language="bnf">Continue: "continue"</pre><p>A <tt class="literal">throw</tt> directive may appear anywhere and may specify an 
            expression, whose type must be a subtype of type <tt class="literal">Throwable</tt> 
            defined in <tt class="literal">ceylon.language</tt>. When the directive is executed, the 
            expression is evaluated and the resulting exception is thrown. If no expression is 
            specified, the directive is equivalent to <tt class="literal">throw Exception()</tt>.</p><pre data-language="bnf">Throw: "throw" Expression?</pre><p>If the specified expression has no type, and the directive occurs within a 
            <tt class="literal">dynamic</tt> block, then the directive is not type-checked at compile 
            time.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="specificationstatements"></a>5.2.3.&nbsp;Specification statements</h3></div></div><div></div></div><p>A <span class="emphasis"><em>specification</em></span> statement may specify or initialize the 
            persistent value of a forward-declared reference, or specify the implementation of 
            a forward-declared getter or function.</p><pre data-language="bnf">Specification: ValueSpecification | LazySpecification</pre><p>The persistent value of a forward-declared reference or the implementation 
            of a forward-declared function may be specified by a <span class="emphasis"><em>value specification 
            statement</em></span>. The value specification statement consists of an unqualified 
            value reference and an ordinary <tt class="literal">=</tt> specifier. The value reference 
            must refer to a declaration which sequentially occurs earlier in the body in which 
            the specification statement occurs.</p><pre data-language="bnf">ValueSpecification: MemberName Specifier ";"</pre><p>The type of the specified expression must be assignable to the type of the 
            reference, or to the callable type of the function.</p><p>If the specified expression has no type, or if the reference or function has 
            no type, and the specification occurs within a <tt class="literal">dynamic</tt> block, 
            then the specification is not type-checked at compile time.</p><pre data-language="ceylon">String greeting;
if (exists name) {
    greeting = "hello ``name``";
}
else {
    greeting = "hello world";
}</pre><pre data-language="ceylon">String process(String input);
if (normalize) {
    process = String.normalized;
}
else {
    process = (String s) =&gt; s;
}</pre><i><span class="comment"><p>Note: there is an apparent ambiguity here. Is the statement
            <tt class="literal">x=1;</tt> a value specification statement, or an assignment 
            expression statement? The language resolves this ambiguity by favoring the
            interpretation as a specification statement whenever that interpretation is
            viable. This is a transparent solution, since it accepts strictly more code 
            than the alternative interpretation, and for ambiguous cases the actual 
            semantics are identical between the two interpretations.</p></span></i><p>The implementation of forward-declared getter or function may be
            specified using a <span class="emphasis"><em>lazy specification statement</em></span>. The 
            specification statement consists of either:</p><div class="itemizedlist"><ul type="disc"><li><p>an unqualified value reference and a lazy 
                    <tt class="literal">=&gt;</tt> specifier, or</p></li><li><p>a unqualified callable reference, one or more parameter lists, 
                    and a lazy specifier.</p></li></ul></div><p>The value reference or callable reference must refer to a declaration 
            which sequentially occurs earlier in the body in which the specification 
            statement occurs.</p><p>A callable reference followed by a parameter list is itself considered 
            a callable reference, called a <span class="emphasis"><em>parameterized reference</em></span>. 
            If the parameter list has type <tt class="literal">P</tt> then the callable reference 
            must have the exact type <tt class="literal">Callable&lt;R,P&gt;</tt> for some type 
            <tt class="literal">R</tt>. Then the type of the parameterized reference is
            <tt class="literal">R</tt>.</p><pre data-language="bnf">ParameterizedReference: MemberName Parameters+</pre><p>Thus, the specification statement consists of a parameterized reference
            followed by a lazy specifier.</p><pre data-language="bnf">LazySpecification: (MemberName | ParameterizedReference) LazySpecifier ";"</pre><p>The type of the specified expression must be assignable to the type of 
            the parameterized reference, or to the type of the value reference.</p><pre data-language="ceylon">String greeting;
if (exists name) {
    greeting =&gt; "hello ``name``";
}
else {
    greeting =&gt; "hello world";
}</pre><pre data-language="ceylon">String process(String input);
if (normalize) {
    process(String input) =&gt; input.normalized;
}
else {
    process(String s) =&gt; s;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="definitereturn"></a>5.2.4.&nbsp;Definite return</h3></div></div><div></div></div><p>A sequence of statements may <span class="emphasis"><em>definitely return.</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>A sequence of statements definitely returns if it ends in a 
                    <tt class="literal">return</tt> or <tt class="literal">throw</tt> directive, or 
                    in a control structure that definitely returns, or contains an
                    assertion with a condition list that is never satisfied.</p></li><li><p>A body definitely returns if it contains a list of statements
                    that definitely returns.</p></li><li><p>An <tt class="literal">if</tt> conditional definitely returns if it has
                    an <tt class="literal">else</tt> block and both the <tt class="literal">if</tt>
                    and <tt class="literal">else</tt> blocks definitely return, or if its 
                    condition list is always satisfied and the <tt class="literal">if</tt> block
                    definitely returns, or if its condition list is never satisfied and it 
                    has an <tt class="literal">else</tt> block that definitely returns.</p></li><li><p>A <tt class="literal">switch</tt> conditional definitely returns if all
                    <tt class="literal">case</tt> blocks definitely return and the <tt class="literal">else</tt> 
                    block, if any, definitely returns.</p></li><li><p>A <tt class="literal">for</tt> loop definitely returns if it has an
                    <tt class="literal">else</tt> block that definitely returns, and there is
                    no <tt class="literal">break</tt> directive in the <tt class="literal">for</tt>
                    block, or if the iterated expression type is a nonempty type, and
                    the <tt class="literal">for</tt> block definitely returns.</p></li><li><p>A <tt class="literal">while</tt> loop definitely returns if its
                    condition list is always satisfied and the <tt class="literal">while</tt> 
                    block definitely returns.</p></li><li><p>A <tt class="literal">try/catch</tt> exception manager definitely 
                    returns if the <tt class="literal">try</tt> block definitely returns and
                    all <tt class="literal">catch</tt> blocks definitely return or if the
                    <tt class="literal">finally</tt> block definitely returns.</p></li></ul></div><p>The body of a non-<tt class="literal">void</tt> method or getter must definitely 
            return.</p><p>A body may not contain an additional statement, control structure, or
            declaration following a sequence of statements that definitely returns. Such a 
            statement, control structure, or declaration is considered 
            <span class="emphasis"><em>unreachable</em></span>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="definiteinitialization"></a>5.2.5.&nbsp;Definite initialization</h3></div></div><div></div></div><p>A sequence of statements may <span class="emphasis"><em>definitely initialize</em></span> a
            forward-declared declaration.</p><div class="itemizedlist"><ul type="disc"><li><p>A sequence of statements definitely initializes a declaration if 
                    one of the statements is a specification statement or assigment 
                    expression for the declaration or a control structure that definitely 
                    initializes the declaration, or if the sequence of statements ends in 
                    a <tt class="literal">return</tt> or <tt class="literal">throw</tt> directive, or 
                    contains an assertion with a condition list that is never satisfied.</p></li><li><p>An <tt class="literal">if</tt> conditional definitely initializes a 
                    declaration if it has an <tt class="literal">else</tt> block and both the 
                    <tt class="literal">if</tt> and <tt class="literal">else</tt> blocks definitely
                    initialize the declaration, of if its condition list is always satisfied
                    and the <tt class="literal">if</tt> block definitely initializes the declaration,
                    of if its condition list is never satisfied and it has an 
                    <tt class="literal">else</tt> block that definitely initializes the 
                    declaration.</p></li><li><p>A <tt class="literal">switch</tt> conditional definitely initializes a
                    declaration if all <tt class="literal">case</tt> blocks definitely initialize 
                    the declaration and the <tt class="literal">else</tt> block, if any, definitely 
                    initializes the declaration.</p></li><li><p>A <tt class="literal">for</tt> loop definitely initializes a declaration 
                    if it has an <tt class="literal">else</tt> block that definitely initializes 
                    the declaration, and there is no <tt class="literal">break</tt> directive in 
                    the <tt class="literal">for</tt> block, or if the iterated expression type is 
                    a nonempty type, and the <tt class="literal">for</tt> block definitely 
                    initializes the declaration.</p></li><li><p>A <tt class="literal">while</tt> loop definitely initializes a declaration
                    if its condition list is always satisfied and the <tt class="literal">while</tt>
                    block definitely initializes the declaration.</p></li><li><p>A <tt class="literal">try/catch</tt> exception manager definitely initializes 
                    a declaration if the <tt class="literal">try</tt> block definitely initializes the 
                    declaration and all <tt class="literal">catch</tt> blocks definitely initialize the 
                    declaration or if the <tt class="literal">finally</tt> block definitely initializes 
                    the declaration.</p></li></ul></div><i><span class="comment"><p>TODO: an assignment expression occurring within a containing expression
            may or may not definitely initialize a value. Specify this!</p></span></i><p>If a function or value declaration is referenceable at a certain statement or 
            declaration, it may additionally considered <span class="emphasis"><em>definitely initialized</em></span> 
            at that statement or declaration.</p><p>If a function declaration is definitely initialized at a certain statement or 
            declaration if it is referenceable at that statement or declaration and:</p><div class="itemizedlist"><ul type="disc"><li><p>it is a parameter,</p></li><li><p>it is not forward-declared, or</p></li><li><p>it is forward-declared and is definitely initialized by the sequence of 
                    statements from its declaration to the given statement or declaration.</p></li></ul></div><p>If a value declaration is definitely initialized at a certain statement or 
            declaration if it is referenceable at that statement or declaration and:</p><div class="itemizedlist"><ul type="disc"><li><p>it is a parameter,</p></li><li><p>it is not forward-declared and the given statement or declaration is not 
                    the value declaration itself, and does not occur within the body of the value 
                    declaration, or</p></li><li><p>it is forward-declared and is definitely initialized by the sequence of 
                    statements from its declaration to the given statement or declaration.</p></li></ul></div><p>A function or value declaration must be definitely initialized wherever any 
            value reference or callable reference to it occurs as an expression within the body 
            in which it is declared.</p><p>A <tt class="literal">shared</tt> forward-declared declaration belonging to a class 
            and not annotated <tt class="literal">late</tt> must be definitely initialized:</p><div class="itemizedlist"><ul type="disc"><li><p>at every <tt class="literal">return</tt> statement of the initializer of the 
                    containing class, and</p></li><li><p>at the very last expression statement, directive statement or 
                    specification statement of the initializer of the containing class.</p></li></ul></div><p>A specification statement for a method or non-<tt class="literal">variable</tt> 
            reference, getter, or function may not (indirectly) occur in a <tt class="literal">for</tt> 
            or <tt class="literal">while</tt> block unless the declaration itself occurs within the same
            <tt class="literal">for</tt> or <tt class="literal">while</tt> block.</p><i><span class="comment"><p>TODO: Furthermore, the typechecker does some tricky analysis to
            determine that code like the following can be accepted:</p>
            <pre data-language="ceylon">Boolean minors;
for (p in people) {
    if (p.age&lt;18) {
        minors = true;
        break;
    }
}
else {
    minors = false;
}</pre></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="definiteuninitialization"></a>5.2.6.&nbsp;Definite uninitialization</h3></div></div><div></div></div><p>A sequence of statements may <span class="emphasis"><em>possibly initialize</em></span> a 
            forward-declared declaration.</p><div class="itemizedlist"><ul type="disc"><li><p>A sequence of statements possibly initializes a declaration if one of 
                    the statements is a specification statement for the declaration or a control 
                    structure that possibly initializes the declaration.</p></li><li><p>An <tt class="literal">if</tt> conditional possibly initializes a declaration 
                    if either the <tt class="literal">if</tt> block possibly initializes the declaration 
                    and the condition list is not never satisfied, or if the <tt class="literal">else</tt> 
                    block, if any, possibly initializes the declaration and the condition list is 
                    not always satisfied.</p></li><li><p>A <tt class="literal">switch</tt> conditional possibly initializes a declaration 
                    if one of the <tt class="literal">case</tt> blocks possibly initializes the declaration 
                    or the <tt class="literal">else</tt> block, if any, possibly initializes the 
                    declaration.</p></li><li><p>A <tt class="literal">for</tt> loop possibly initializes a declaration if the 
                    <tt class="literal">for</tt> block possibly initializes the declaration or if it has 
                    an <tt class="literal">else</tt> block that possibly initializes the declaration.</p></li><li><p>A <tt class="literal">while</tt> loop possibly initializes a declaration if the 
                    <tt class="literal">while</tt> block possibly initializes the declaration and the
                    condition list is not never satisfied.</p></li><li><p>A <tt class="literal">try/catch</tt> exception manager possibly initializes a 
                    declaration if the <tt class="literal">try</tt> block possibly initializes the 
                    declaration, if one of the <tt class="literal">catch</tt> blocks possibly initializes 
                    the declaration, or if the <tt class="literal">finally</tt> block possibly initializes 
                    the declaration.</p></li></ul></div><p>A forward-declared declaration is considered <span class="emphasis"><em>definitely uninitialized</em></span> 
            at a certain statement or declaration if:</p><div class="itemizedlist"><ul type="disc"><li><p>it is not possibly initialized by the sequence of statements from its declaration 
                    to the given statement or declaration,</p></li><li><p>the statement does not (indirectly) occur in the <tt class="literal">for</tt> block or
                    <tt class="literal">else</tt> block of a <tt class="literal">for</tt> loop with a <tt class="literal">for</tt> 
                    block that possibly initializes it,</p></li><li><p>the statement does not (indirectly) occur in the <tt class="literal">while</tt> block of 
                    a <tt class="literal">while</tt> loop with a <tt class="literal">while</tt> block that possibly 
                    initializes it,</p></li><li><p>the statement does not (indirectly) occur in a <tt class="literal">catch</tt> block 
                    of a <tt class="literal">try/catch</tt> exception manager with a <tt class="literal">try</tt> block 
                    that possibly initializes it, and</p></li><li><p>the statement does not (indirectly) occur in the <tt class="literal">finally</tt> block 
                    of a <tt class="literal">try/catch</tt> exception manager with a <tt class="literal">try</tt> block 
                    or <tt class="literal">catch</tt> block that possibly initializes it.</p></li></ul></div><p>A function or non-<tt class="literal">variable</tt> value declaration must be definitely 
            uninitialized wherever any value reference or callable reference to it occurs as a specification 
            statement within the body in which it is declared.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="controlstructures"></a>5.3.&nbsp;Control structures and assertions</h2></div></div><div></div></div><p>Control of execution flow may be achieved using control directives and 
        <span class="emphasis"><em>control structures</em></span>. Control structures include conditionals, 
        loops, and exception management.</p><p>Ceylon provides the following control structures:</p><div class="itemizedlist"><ul type="disc"><li><p>the <tt class="literal">if/else</tt> conditional&#8212;for controlling 
                execution based on a boolean condition, type condition, or check for a 
                non-null or non-empty value,</p></li><li><p>the <tt class="literal">switch/case/else</tt> conditional&#8212;for 
                controlling execution using an enumerated list of values or types,</p></li><li><p>the <tt class="literal">while</tt> loop&#8212;for loops which terminate 
                based on a boolean condition, type condition, or check for a non-null or 
                non-empty value,</p></li><li><p>the <tt class="literal">for/else</tt> loop&#8212;for looping over elements 
                of an iterable object, and</p></li><li><p>the <tt class="literal">try/catch/finally</tt> exception manager&#8212;for 
                managing exceptions and controlling the lifecycle of objects which require 
                explicit destruction.</p></li></ul></div><pre data-language="bnf">ControlStructure: IfElse | SwitchCaseElse | While | ForFail | TryCatchFinally | Dynamic</pre><i><span class="comment"><p>Control structures are not considered to be expressions, and therefore 
        do not evaluate to a value. However, comprehensions&#8212;and conditional expressions, 
        planned for a future release of the language&#8212;are part of the expression syntax 
        and share much of the syntax and semantics of the control structures they resemble.
        </p></span></i><p><span class="emphasis"><em>Assertions</em></span> are runtime checks upon program invariants, or 
        function preconditions and postconditions. An assertion failure represents a bug in
        the program, and is not considered recoverable. Therefore, assertions should not be 
        used to control "normal" execution flow.</p><i><span class="comment"><p>Note: of course, in certain circumstances, it is appropriate to handle
        the exception that results from an assertion failure, for example, to display a message
        to the user, or in a testing framework to aggregate and report the failures that occurred
        in test assertions. A test failure may be considered "normal" occurrence from the point 
        of view of a testing framework, but it's not "normal" in the sense intended above.
        </p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="controlstructurevariables"></a>5.3.1.&nbsp;Control structure variables</h3></div></div><div></div></div><p>Assertions and some control structures allow inline declaration of a 
            <span class="emphasis"><em>variable</em></span>. A variable is a reference, as defined by 
            <a href="#references" title="4.8.1.&nbsp;References">&sect;4.8.1 References</a>.</p><pre data-language="bnf">TypedVariable: Type MemberName</pre><p>In most cases, the explicit type be omitted.</p><pre data-language="bnf">Variable: (Type | "value")? MemberName</pre><p>If the explicit type is missing from the declaration, the type of the variable 
            is inferred, according to rules that depend upon the control structure to which 
            the variable belongs.</p><p>A variable declared by an assertion is a reference scoped to the body in which 
            the <tt class="literal">assert</tt> statement occurs.</p><p>A variable declared by a control structure is a reference scoped to the block 
            that immediately follows the variable declaration:</p><div class="itemizedlist"><ul type="disc"><li><p>For a variable in an <tt class="literal">if</tt> condition, the scope of the
                    variable is the <tt class="literal">if</tt> block.</p></li><li><p>For a variable in a <tt class="literal">while</tt> condition, the scope of the
                    variable is the <tt class="literal">while</tt> block.</p></li><li><p>For a variable in a <tt class="literal">for</tt> iterator, the scope of the
                    variable is the <tt class="literal">for</tt> block.</p></li><li><p>For a variable in a <tt class="literal">try</tt> clause, the scope of the 
                    variable is the <tt class="literal">try</tt> block.</p></li><li><p>For a variable in a <tt class="literal">catch</tt> clause, the scope of the 
                    variable is the <tt class="literal">catch</tt> block.</p></li><li><p>For a variable in an <tt class="literal">assert</tt> statement, the scope of the 
                    variable is the body containing the <tt class="literal">assert</tt> statement.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="iterationvariables"></a>5.3.2.&nbsp;Iteration variables</h3></div></div><div></div></div><p>A <tt class="literal">for</tt> loop requires an <span class="emphasis"><em>iteration variable</em></span> 
            declaration. An iteration variable is a reference scoped to the body of the loop.</p><pre data-language="bnf">IteratorVariable: Variable | EntryVariablePair</pre><p>An iteration variable of type <tt class="literal">Entry</tt> may be specified in 
            destructured form.</p><pre data-language="bnf">EntryVariablePair: Variable "-&gt;" Variable</pre><p>If the type is missing from the declaration, the type of the iteration variable is 
            inferred:</p><div class="itemizedlist"><ul type="disc"><li><p>given an iterated expression which has the principal instantiation
                    <tt class="literal">Iterable&lt;X&gt;</tt>, the inferred type of the variable 
                    is <tt class="literal">X</tt>, unless</p></li><li><p>the destructured form is used for an iterated expression which is 
                    has the principal instantiation <tt class="literal">Iterable&lt;Entry&lt;X,Y&gt;&gt;</tt>,
                    in which case the inferred type of the first variable is <tt class="literal">X</tt>, 
                    and the inferred type of the second variable is <tt class="literal">Y</tt>.</p></li></ul></div><i><span class="comment"><p>TODO: Should we, purely for consistency, let you write 
            <tt class="literal">for (f(Float x) in functions)</tt>, even though it's not
            very useful?</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="controlstructureconditions"></a>5.3.3.&nbsp;Control structure conditions</h3></div></div><div></div></div><p>Some control structures expect conditions. There are four kinds of condition:</p><div class="itemizedlist"><ul type="disc"><li><p>a <span class="emphasis"><em>boolean condition</em></span> is satisfied when a boolean expression
                    evaluates to <tt class="literal">true</tt>,</p></li><li><p>an <span class="emphasis"><em>assignabilty condition</em></span> is satisfied when an expression
                     evaluates to an instance of a specified type,</p></li><li><p>an <span class="emphasis"><em>existence condition</em></span> is satisfied when an expression 
                    evaluates to a non-null value, and</p></li><li><p>a <span class="emphasis"><em>nonemptiness condition</em></span> is satisfied when an expression 
                    evaluates to a non-null, non-empty value.</p></li></ul></div><pre data-language="bnf">Condition: BooleanCondition | IsCondition | ExistsOrNonemptyCondition</pre><p>A condition list has one or more conditions.</p><pre data-language="bnf">ConditionList: "(" Condition ("," Condition) ")"</pre><p>A condition in the list may refer to a condition variable defined earlier in the list.</p><p>A condition list is considered to be <span class="emphasis"><em>always satisfied</em></span> if
            every condition in the list is always satisfied. A condition list is considered to be 
            <span class="emphasis"><em>never satisfied</em></span> if some condition in the list is never satisfied.</p><i><span class="comment"><p>TODO: are we going to support <tt class="literal">satisfies</tt> conditions on 
            type parameters, for example, <tt class="literal">if (Element satisfies Object)</tt>, to allow
            refinement of its upper bounds?</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="booleanconditions"></a>5.3.4.&nbsp;Boolean conditions</h3></div></div><div></div></div><p>A boolean condition is just an expression.</p><pre data-language="bnf">BooleanCondition: Expression</pre><p>The expression must be of type <tt class="literal">Boolean</tt>.</p><p>A boolean condition is considered to be <span class="emphasis"><em>always satisfied</em></span>
            if it is a value reference to <tt class="literal">true</tt>. A boolean condition is 
            considered to be <span class="emphasis"><em>never satisfied</em></span> if it is a value reference 
            to <tt class="literal">false</tt>.</p><i><span class="comment"><p>TODO: Should we do some more sophisticated static analysis to 
            determine if a condition is always/never satisfied?</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assignabilityexistencenonemptinessconditions"></a>5.3.5.&nbsp;Assignability, existence, and nonemptiness conditions</h3></div></div><div></div></div><p>An assignability, existence, or nonemptiness condition may contain either:</p><div class="itemizedlist"><ul type="disc"><li><p>an unqualified value reference to a non-<tt class="literal">variable</tt>,
                    non-<tt class="literal">default</tt> reference, or</p></li><li><p>an inline variable declaration together with an expression.</p></li></ul></div><p>In the case of an assignability or existence condition, the type of the variable 
            may be inferred.</p><pre data-language="bnf">IsCondition: "!"? "is" (TypedVariable Specifier | Type MemberName)</pre><pre data-language="bnf">ExistsOrNonemptyCondition: ("exists" | "nonempty") (Variable Specifier | MemberName)</pre><i><span class="comment"><p>TODO: are we going to allow <tt class="literal">is Type this</tt> and 
            <tt class="literal">is Type outer</tt> to narrow the type of a self reference?</p></span></i><p>The type of the value reference or expression must be:</p><div class="itemizedlist"><ul type="disc"><li><p>in the case of an assignability condition, a type which is not a subtype of 
                    the specified type, but whose intersection with the specified type is not exactly 
                    <tt class="literal">Nothing</tt>, except</p></li><li><p>in the case of a <span class="emphasis"><em>negated assignability condition</em></span> with 
                    <tt class="literal">!is</tt>, a type whose intersection with the specified type is not 
                    exactly <tt class="literal">Nothing</tt>, and which is not a supertype of the specified
                    type, or</p></li><li><p>in the case of an exists condition, a type whose intersection with 
                    <tt class="literal">Null</tt> is not exactly <tt class="literal">Nothing</tt> and whose 
                    intersection with <tt class="literal">Object</tt> is not exactly <tt class="literal">Nothing</tt>, 
                    or</p></li><li><p>in the case of a nonemptiness condition, a subtype of <tt class="literal">Anything[]?</tt> 
                    whose intersection with <tt class="literal">[]</tt> is not exactly <tt class="literal">Nothing</tt>, 
                    and whose intersection with <tt class="literal">[Nothing+]</tt> is not exactly 
                    <tt class="literal">Nothing</tt>.</p></li></ul></div><i><span class="comment"><p>Note: an assignability condition may narrow to an intersection or union 
            type.</p>
            <pre data-language="ceylon">if (is Printable&amp;Identifiable obj) { ... }</pre>
            <pre data-language="ceylon">if (is Integer|Float num) { ... }</pre></span></i><p>Every existence or nonemptiness condition is equivalent to&#8212;and may be 
            considered an abbreviation of&#8212;an assignability condition:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">exists x</tt> is equivalent to <tt class="literal">is Object x</tt>, 
                    and</p></li><li><p><tt class="literal">nonempty x</tt> is equivalent to <tt class="literal">is [E+] x</tt>
                    where <tt class="literal">x</tt> is an expression whose type has the principal 
                    instantiation <tt class="literal">E[]?</tt>.</p></li></ul></div><p>For an <tt class="literal">is</tt> assignability condition:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition contains a value reference, the value will be treated by the 
                    compiler as having type <tt class="literal">T&amp;X</tt> where the conditional expression 
                    is of type <tt class="literal">T</tt> and <tt class="literal">X</tt> is the specified type, 
                    inside the block that immediately follows the condition, unless</p></li><li><p>it is a <span class="emphasis"><em>negated assignability condition</em></span> with 
                    <tt class="literal">!is</tt>, in which case the value will be treated by the compiler as 
                    having type <tt class="literal">T~X</tt>.</p></li></ul></div><p>Where, for any given types <tt class="literal">T</tt> and <tt class="literal">X</tt>, the type
            <tt class="literal">T~X</tt> is determined as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if <tt class="literal">X</tt> covers <tt class="literal">T</tt>, as defined by
                    <a href="#coverage" title="3.4.1.&nbsp;Coverage">&sect;3.4.1 Coverage</a>, then <tt class="literal">T~X</tt> is 
                    <tt class="literal">Nothing</tt>,</p></li><li><p>if <tt class="literal">T</tt> is an intersection type, then <tt class="literal">T~X</tt> 
                    is the intersection of all <tt class="literal">U~X</tt> for every type <tt class="literal">U</tt> 
                    in the intersection,</p></li><li><p>if <tt class="literal">T</tt> is a union type, then <tt class="literal">T~X</tt> is the
                    union of all <tt class="literal">U~X</tt> for every type <tt class="literal">U</tt> in the
                    union,</p></li><li><p>if <tt class="literal">T</tt> is an enumerated type or an instantiation of a 
                    generic enumerated type, then <tt class="literal">T~X</tt> is the union of all 
                    <tt class="literal">C~X</tt> for every case <tt class="literal">C</tt> of 
                    <tt class="literal">T</tt>, or,</p></li><li><p>otherwise, <tt class="literal">T~X</tt> is <tt class="literal">T</tt>.</p></li></ul></div><p>If you prefer, you can think of the following:</p><pre data-language="ceylon">Transaction tx = ...
if (is Usable tx) { ... }</pre><p>As an abbreviation of:</p><pre data-language="ceylon">if (is Transaction&amp;Usable tx = tx) { ... }</pre><p>Where the <tt class="literal">tx</tt> declared by the condition hides the outer declaration
            of <tt class="literal">tx</tt> inside the block that follows.</p><p>For an <tt class="literal">exists</tt> existence condition:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition declares a variable, the declared type of the variable 
                    must be a supertype of <tt class="literal">T&amp;Object</tt>, where the specifier 
                    expression is of type <tt class="literal">T</tt>, and must be a subtype of
                    <tt class="literal">Object</tt>, or</p></li><li><p>if the condition contains a value reference, the value will be treated by 
                    the compiler as having type <tt class="literal">T&amp;Object</tt> inside the block that 
                    immediately follows the condition, where the conditional expression is of type 
                    <tt class="literal">T</tt>.</p></li></ul></div><p>For a <tt class="literal">nonempty</tt> nonemptiness condition:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition declares a variable, the declared type of the variable 
                    must be a supertype of <tt class="literal">T&amp;[E+]</tt>, where the specifier 
                    expression is of type <tt class="literal">T</tt> and <tt class="literal">T</tt> has the 
                    principal instantiation <tt class="literal">E[]?</tt>, and must be a subtype of
                    <tt class="literal">[Anything+]</tt>, or</p></li><li><p>if the condition contains a value reference, the value will be treated by 
                    the compiler as having type <tt class="literal">T&amp;[E+]</tt> inside the block that 
                    immediately follows the condition, where the conditional expression is of type 
                    <tt class="literal">T</tt> and <tt class="literal">T</tt> has the principal instantiation
                    <tt class="literal">E[]?</tt>.</p></li></ul></div><p>If you prefer, you can think of the following:</p><pre data-language="ceylon">if (exists name) { ... }</pre><p>As an abbreviation of:</p><pre data-language="ceylon">if (exists String name = name) { ... }</pre><p>Where the <tt class="literal">name</tt> declared by the condition hides the outer 
            declaration of <tt class="literal">name</tt> inside the block that follows.</p><p>As a special exception to the above, if a condition occurs in a <tt class="literal">dynamic</tt> 
            block, and conditional expression has no type, and the condition contains a value reference, 
            then:</p><div class="itemizedlist"><ul type="disc"><li><p>the value will be treated by the compiler as having type <tt class="literal">X</tt> 
                    where <tt class="literal">X</tt> is the specified type, inside the block that immediately 
                    follows the condition, unless</p></li><li><p>it is a negated assignability condition <tt class="literal">!is</tt>, an existence 
                    condition <tt class="literal">exists</tt>, or a nonempty condition <tt class="literal">nonempty</tt>, 
                    in which case the value will be treated by the compiler as having no type.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ifelse"></a>5.3.6.&nbsp;<tt class="literal">if/else</tt></h3></div></div><div></div></div><p>The <tt class="literal">if/else</tt> conditional has the following form:</p><pre data-language="bnf">IfElse: If Else?</pre><pre data-language="bnf">If: "if" ConditionList Block</pre><pre data-language="bnf">Else: "else" (Block | IfElse)</pre><p>Every <tt class="literal">if/else</tt> conditional construct has an 
            <tt class="literal">if</tt> clause. The construct may optionally include:</p><div class="itemizedlist"><ul type="disc"><li><p>a chain of an arbitrary number of child 
                    <tt class="literal">else if</tt> clauses, and/or</p></li><li><p>an <tt class="literal">else</tt> clause.</p></li></ul></div><pre data-language="ceylon">if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid = true;
}
else {
    throw NotEnoughMoneyException();
}</pre><pre data-language="ceylon">shared void welcome(User? user) {
    if (exists user) {
        print("Welcome back, ``user.name``!");
    }
    else {
        print("Welcome to Ceylon!");
    }
}</pre><pre data-language="ceylon">if (is CardPayment p = order.payment, 
        !p.paid) {
    p.card.charge(total);
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="switchcaseelse"></a>5.3.7.&nbsp;<tt class="literal">switch/case/else</tt></h3></div></div><div></div></div><p>The <tt class="literal">switch/case/else</tt> conditional has the following 
            form:</p><pre data-language="bnf">SwitchCaseElse: Switch Cases</pre><pre data-language="bnf">Switch: "switch" "(" Expression ")"</pre><pre data-language="bnf">Cases: CaseItem+ DefaultCaseItem?</pre><pre data-language="bnf">CaseItem: "case" "(" Case ")" Block</pre><pre data-language="bnf">DefaultCaseItem: "else" Block</pre><p>Every <tt class="literal">switch</tt> conditional construct has a
            <tt class="literal">switch</tt> clause. The construct must include:</p><div class="itemizedlist"><ul type="disc"><li><p>a chain of an arbitrary number of child 
                    <tt class="literal">case</tt> clauses, and/or</p></li><li><p>an <tt class="literal">else</tt> clause.</p></li></ul></div><p>Each <tt class="literal">case</tt> is either:</p><div class="itemizedlist"><ul type="disc"><li><p>a <span class="emphasis"><em>value case</em></span>&#8212;a list of string literals, 
                    character literals, integer literals, negated integer literals, and/or 
                    value references to anonymous classes, or</p></li><li><p>a <span class="emphasis"><em>type case</em></span>&#8212;an assignability condition 
                    of form <tt class="literal">is V</tt> for some type <tt class="literal">V</tt>.</p></li></ul></div><pre data-language="bnf">Case: CaseValue ("|" CaseValue)* | "is" Type</pre><pre data-language="bnf">CaseValue: LiteralCase | BaseExpression</pre><pre data-language="bnf">LiteralCase: "-"? IntegerLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral</pre><p>Every <tt class="literal">case</tt> has a type:</p><div class="itemizedlist"><ul type="disc"><li><p>for a value case, the type is the union of the types of the values, 
                    and</p></li><li><p>for a type case, the type is the specified type.</p></li></ul></div><p>The type of a case must be a subtype of the <tt class="literal">switch</tt>
            expression type.</p><p>For a value case, each value reference must be to an anonymous class that
            is a subtype of <tt class="literal">Identifiable|Null</tt>.</p><p>For a type case of type <tt class="literal">V</tt>, the intersection type 
            <tt class="literal">V&amp;U</tt> must not be exactly <tt class="literal">Nothing</tt>.</p><p>Two <tt class="literal">case</tt>s are said to be <span class="emphasis"><em>disjoint</em></span> 
            if the intersection of their types is exactly <tt class="literal">Nothing</tt>, as
            defined by <a href="#disjointtypes" title="3.4.4.&nbsp;Disjoint types">&sect;3.4.4 Disjoint types</a>, or if they are both value cases with 
            distinct literal values. In every <tt class="literal">switch</tt> statement, all 
            <tt class="literal">case</tt>s must be mutually disjoint.</p><p>A <tt class="literal">switch</tt> is <span class="emphasis"><em>exhaustive</em></span> if there 
            are no literal values in its <tt class="literal">case</tt>s, and the union type formed 
            by the types of the <tt class="literal">case</tt>s of the <tt class="literal">switch</tt> 
            covers the <tt class="literal">switch</tt> expression type, as defined by
            <a href="#coverage" title="3.4.1.&nbsp;Coverage">&sect;3.4.1 Coverage</a>.</p><p>If no <tt class="literal">else</tt> block is specified, the <tt class="literal">switch</tt> 
            must be exhaustive.</p><i><span class="comment"><p>Note: On the other hand, even if the <tt class="literal">switch</tt> 
            <span class="emphasis"><em>is</em></span> exhaustive, an <tt class="literal">else</tt> block may be 
            specified, in order to allow a <tt class="literal">switch</tt> that accommodates additional 
            cases without resulting in a compilation error.</p></span></i><p>As a special exception to the above, if a <tt class="literal">switch</tt> occurs in 
            a <tt class="literal">dynamic</tt> block, and the <tt class="literal">switch</tt> expression
            has no type, the cases are not statically type-checked for exhaustion.</p><i><span class="comment"><p>Note: an assignability condition <tt class="literal">case</tt> may narrow to 
            an intersection or union type.</p>
            <pre data-language="ceylon">case (is Persistent &amp; Serializable) { ... }</pre>
            <pre data-language="ceylon">case (is Integer | Float) { ... }</pre></span></i><p>If a <tt class="literal">switch</tt> has an assignability condition <tt class="literal">case</tt>,
            then the <tt class="literal">switch</tt> expression must be an unqualified value reference 
            to a non-<tt class="literal">variable</tt>, non-<tt class="literal">default</tt> reference.</p><p>For an assignability condition <tt class="literal">case</tt>, the value referred by the
            <tt class="literal">switch</tt> expression will be treated by the compiler as having the 
            intersection type of its declared type with the specified type inside the <tt class="literal">case</tt> 
            block. This intersection type must not be exactly <tt class="literal">Nothing</tt>.</p><p>As a special exception to the above, if a <tt class="literal">switch</tt> occurs in 
            a <tt class="literal">dynamic</tt> block, and the <tt class="literal">switch</tt> expression
            has no type, the value referred by the <tt class="literal">switch</tt> expression will be 
            treated by the compiler as having the the specified type inside the <tt class="literal">case</tt> 
            block.</p><pre data-language="ceylon">Boolean? maybe = ... ;
switch (maybe) 
case (null | false) {
    return false;
}
case (true) { 
    return true;
}</pre><pre data-language="ceylon">Integer|Float number = ... ;
switch (number)
case (is Integer) { 
    return sqrt(number.float);
} 
case (is Float) { 
    return sqrt(number);
}</pre><p>A Java-style overloaded method may be emulated as follows:</p><pre data-language="ceylon">shared void print&lt;Printable&gt;(Printable printable) 
        given Printable of String | Integer | Float {
    switch (printable)
    case (is String) { 
        print("\"``printable``\""); 
    }
    case (is Integer) { 
        print(printable + ".00"); 
    }
    case (is Float) { 
        print(formatFloat(printable, 2)); 
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="forelse"></a>5.3.8.&nbsp;<tt class="literal">for/else</tt></h3></div></div><div></div></div><p>The <tt class="literal">for/else</tt> loop has the following form:</p><pre data-language="bnf">ForFail: For Fail?</pre><pre data-language="bnf">For: "for" ForIterator Block</pre><pre data-language="bnf">Fail: "else" Block</pre><p>Every <tt class="literal">for/else</tt> conditional construct has an 
            <tt class="literal">for</tt> clause. The construct may optionally include
            an <tt class="literal">else</tt> clause, as specified in 
            <a href="#executionofloops" title="8.3.4.&nbsp;Execution of loops">&sect;8.3.4 Execution of loops</a>.</p><p>The <tt class="literal">for</tt> iterator consists of an iteration variable 
            declaration and an iterated expression that contains the range of values to 
            be iterated.</p><pre data-language="bnf">ForIterator: "(" IteratorVariable "in" Expression ")"</pre><p>The type of the iterated expression depends upon the iteration variable 
            declarations:</p><div class="itemizedlist"><ul type="disc"><li><p>The iterated expression must be an expression of type assignable to 
                <tt class="literal">Iterable&lt;X&gt;</tt> where <tt class="literal">X</tt> is the 
                declared type of the iteration variable.</p></li><li><p>If two iteration variables are defined, the iterated expression type 
                must be assignable to <tt class="literal">Iterable&lt;Entry&lt;U,V&gt;&gt;</tt>
                where <tt class="literal">U</tt> and <tt class="literal">V</tt> are the declared types 
                of the iteration variables.</p></li></ul></div><p>As a special exception to the above, if a <tt class="literal">for</tt> occurs in 
            a <tt class="literal">dynamic</tt> block, and the iterated expression has no type, the 
            iterator is not statically type-checked. If the iteration variable does not declare
            an explicit type, the iteration variable has no type.</p><pre data-language="ceylon">for (p in people) { 
    print(p.name);
}</pre><pre data-language="ceylon">variable Float sum = 0.0;
for (i in -10..10) {
    sum += x[i] else 0.0;
}</pre><pre data-language="ceylon">for (word -&gt; freq in wordFrequencyMap) { 
    print("The frequency of ``word`` is ``freq``."); 
}</pre><pre data-language="ceylon">for (p in group) {
    if (p.age &gt;= 18) {
        log.info("Found an adult: ``p.name``.");
        break;
    }
}
else {
    log.info("No adult in group.");
}
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="while"></a>5.3.9.&nbsp;<tt class="literal">while</tt></h3></div></div><div></div></div><p>The <tt class="literal">while</tt> loop has the form:</p><pre data-language="bnf">While: LoopCondition Block</pre><p>The loop condition list determines when the loop terminates.</p><pre data-language="bnf">LoopCondition: "while" ConditionList</pre><i><span class="comment"><p>TODO: does <tt class="literal">while</tt> need an <tt class="literal">else</tt> 
            block? Python has it, but what is the real usecase?</p></span></i><pre data-language="ceylon">variable Integer n=0;
variable [Integer*] seq = [];
while (n&lt;=max) {
    seq=seq.withTrailing(n);
    n+=step(n);
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="trycatchfinally"></a>5.3.10.&nbsp;<tt class="literal">try/catch/finally</tt></h3></div></div><div></div></div><p>The <tt class="literal">try/catch/finally</tt> exception manager has the 
            form:</p><pre data-language="bnf">TryCatchFinally: Try Catch* Finally?</pre><pre data-language="bnf">Try: "try" ("(" Resource ("," Resource) ")")? Block</pre><pre data-language="bnf">Catch: "catch" "(" Variable ")" Block</pre><pre data-language="bnf">Finally: "finally" Block</pre><p>Every <tt class="literal">try</tt> conditional construct has a
            <tt class="literal">try</tt> clause. The construct may optionally include:</p><div class="itemizedlist"><ul type="disc"><li><p>a chain of an arbitrary number of child 
                    <tt class="literal">catch</tt> clauses, and/or</p></li><li><p>a <tt class="literal">finally</tt> clause, as 
                    specified in <a href="#exceptionhandling" title="8.3.5.&nbsp;Exception handling">&sect;8.3.5 Exception handling</a>.</p></li></ul></div><p>Each <tt class="literal">catch</tt> block defines a variable. The type 
            of the variable must be assignable to <tt class="literal">Throwable</tt> in
            <tt class="literal">ceylon.language</tt>. If no type is explicitly specified, 
            the type is inferred to be <tt class="literal">Exception</tt>.</p><i><span class="comment"><p>Note: a <tt class="literal">catch</tt> block type may be a union 
            or intersection type:</p>
            <pre data-language="ceylon">catch (NotFoundException|DeletedException e) { ... }</pre></span></i><p>If there are multiple <tt class="literal">catch</tt> blocks in a certain
            control structure, then:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of a <tt class="literal">catch</tt> variable may not be 
                    a subtype of any catch variable of an earlier <tt class="literal">catch</tt> 
                    block belonging to the same control structure.</p></li><li><p>If the type of a <tt class="literal">catch</tt> variable is a union
                    type <tt class="literal">E1|E2|...|En</tt> then no member <tt class="literal">Ei</tt>
                    of the union may be a subtype of any catch variable of an earlier 
                    <tt class="literal">catch</tt> block belonging to the same control 
                    structure.</p></li></ul></div><p>The <tt class="literal">try</tt> block may have a list of <span class="emphasis"><em>resource
            expressions</em></span>, each of which may produce either:</p><div class="itemizedlist"><ul type="disc"><li><p>a <span class="emphasis"><em>destroyable resource</em></span>, or</p></li><li><p>an <span class="emphasis"><em>obtainable resource</em></span>.</p></li></ul></div><pre data-language="bnf">Resource: Expression | Variable Specifier</pre><p>A destroyable resource expression is:</p><div class="itemizedlist"><ul type="disc"><li><p>an instantiation expression, or</p></li><li><p>an inline variable declaration together with 
                an instantiation expression.</p></li></ul></div><p>The instantiation expression must be of type assignable to
            <tt class="literal">Destroyable</tt> in <tt class="literal">ceylon.language</tt>.</p><p>An obtainable resource expression is:</p><div class="itemizedlist"><ul type="disc"><li><p>an expression, or</p></li><li><p>an inline variable declaration together with 
                an expression.</p></li></ul></div><p>The expression must be of type assignable to 
            <tt class="literal">Obtainable</tt> in <tt class="literal">ceylon.language</tt>.</p><p>If no type is explicitly specified for a resource variable, the 
            type of the variable is inferred to be the type of the expression.</p><pre data-language="ceylon">try (File(path).lock) {
    file.open(write);
    ...
}
catch (FileNotFoundException fnfe) {
    print("file not found: ``path``");
}
catch (FileReadException fre) {
    print("could not read from file: ``path``");
}
finally {
    assert (file.closed);
}</pre><pre data-language="ceylon">try (Transaction()) {
    try (s = Session()) {
        return s.get(Person, id);
    }
    catch (NotFoundException|DeletedException e) {
        return null;
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assertions"></a>5.3.11.&nbsp;Assertions</h3></div></div><div></div></div><p>An assertion has an asserted condition list and, optionally, 
            an annotation list.</p><pre data-language="bnf">Assertion: Annotations "assert" ConditionList ";"</pre><p>The message carried by the assertion failure may be specified
            using a <tt class="literal">doc</tt> annotation.</p><pre data-language="ceylon">"total must be less than well-defined bound"
assert (exists bound, total&lt;bound);</pre><p>If the assertion contains an assignability, existence, or 
            nonemptiness condition containing a value reference then the compiler 
            treats the referenced value as having a narrowed type at program 
            elements that occur in the lexical scope of the assertion.</p><pre data-language="ceylon">{Element*} elements = ... ;
assert (nonempty elements);
Element first = elements.first;</pre><i><span class="comment"><p>TODO: how can we support interpolation in the assertion
            failure message?</p>
            <pre data-language="ceylon">assert (total&lt;bound) 
else "total must be less than ``bound``";</pre>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicblocks"></a>5.3.12.&nbsp;Dynamic blocks</h3></div></div><div></div></div><p>A <tt class="literal">dynamic</tt> block allows interoperation with 
            dynamically typed native code.</p><pre data-language="bnf">Dynamic: "dynamic" Block</pre><p>Inside a <tt class="literal">dynamic</tt> block an expression may have 
            no type, as specified in <a href="#expressions" title="Chapter&nbsp;6.&nbsp;Expressions">Chapter&nbsp;6, <i>Expressions</i></a>.</p><p>An expression with no type:</p><div class="itemizedlist"><ul type="disc"><li><p>may be specified or assigned to a typed value, as defined
                    in <a href="#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>,</p></li><li><p>may be passed as the argument of a typed parameter in an
                    invocation expression, as defined in 
                    <a href="#directinvocations" title="6.6.1.&nbsp;Direct invocations">&sect;6.6.1 Direct invocations</a>,</p></li><li><p>may be the invoked expression of an invocation, as defined
                    in <a href="#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>,</p></li><li><p>may be returned by a typed function or getter, or
                    thrown as an exception, as defined in 
                    <a href="#controldirectives" title="5.2.2.&nbsp;Control directives">&sect;5.2.2 Control directives</a>,</p></li><li><p>may be the operand of an operator expression, as defined in
                    <a href="#compoundexpressions" title="6.5.&nbsp;Compound expressions">&sect;6.5 Compound expressions</a>, or</p></li><li><p>may be the subject of a control structure condition, as 
                    defined in <a href="#assignabilityexistencenonemptinessconditions" title="5.3.5.&nbsp;Assignability, existence, and nonemptiness conditions">&sect;5.3.5 Assignability, existence, and nonemptiness conditions</a>,
                    a <tt class="literal">switch</tt>, as defined in <a href="#switchcaseelse" title="5.3.7.&nbsp;switch/case/else">&sect;5.3.7 switch/case/else</a>, 
                    or a <tt class="literal">for</tt> iterator, as defined in <a href="#forelse" title="5.3.8.&nbsp;for/else">&sect;5.3.8 for/else</a>.
                    </p></li></ul></div><p>Furthermore:</p><div class="itemizedlist"><ul type="disc"><li><p>a qualified or unqualified reference may not refer to a
                    statically typed declaration, as defined by 
                    <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a> and
                    <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.</p></li></ul></div><p>These situations result in <span class="emphasis"><em>dynamic type checking</em></span>,
            as defined in <a href="#dynamictypechecking" title="8.3.6.&nbsp;Dynamic type checking">&sect;8.3.6 Dynamic type checking</a>, since the usual static
            type checks are impossible.</p><i><span class="comment"><p>Note: within a <tt class="literal">dynamic</tt> block, Ceylon behaves like
            a language with optional static typing, performing static type checks where possible,
            and dynamic type checking where necessary.</p></span></i></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="expressions"></a>Chapter&nbsp;6.&nbsp;Expressions</h2></div></div><div></div></div><p>An <span class="emphasis"><em>expression</em></span> produces a value when executed. An 
    algorithm expressed using functions and expressions, rather than sequences 
    of statements is often easier to understand and refactor. Therefore, Ceylon
    has a highly flexible expressions syntax. Expressions are formed from:</p><div class="itemizedlist"><ul type="disc"><li><p>literal values, string templates, and self references,</p></li><li><p>evaluation and assignment of values,</p></li><li><p>invocation of functions and instantiation of classes,</p></li><li><p>callable references, static references, and anonymous functions,</p></li><li><p>comprehensions,</p></li><li><p>metamodel references,</p></li><li><p>enumeration of iterables and tuples, and</p></li><li><p>operators.</p></li></ul></div><p>Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    a value or parameter, Ceylon considers the <span class="emphasis"><em>type</em></span> of the 
    expression (the type of the objects that are produced when the expression 
    is evaluated). An expression is assignable to a program element if the type 
    of the expression is assignable to the declared type of the program 
    element.</p><p>Within a <tt class="literal">dynamic</tt> block, an expression may have no 
    type, in the sense that its type can not be determined using static analysis
    of the code.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="literalvalues"></a>6.1.&nbsp;Literal values</h2></div></div><div></div></div><p>Ceylon supports literal values of the following types:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Integer</tt> and <tt class="literal">Float</tt>,</p></li><li><p><tt class="literal">Character</tt>, and</p></li><li><p><tt class="literal">String</tt>.</p></li></ul></div><p>The types <tt class="literal">Integer</tt>, <tt class="literal">Float</tt>, 
        <tt class="literal">Character</tt>, and <tt class="literal">String</tt> are defined in the 
        module <tt class="literal">ceylon.language</tt>.</p><i><span class="comment"><p>Note: Ceylon does not need a special syntax for <tt class="literal">Boolean</tt> 
        literal values, since <tt class="literal">Boolean</tt> is just a class with the cases 
        <tt class="literal">true</tt> and <tt class="literal">false</tt>. Likewise, <tt class="literal">null</tt> 
        is just the singleton value of an anonymous class.</p></span></i><pre data-language="bnf">Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral</pre><p>All literal values are instances of immutable types. The value of a literal 
        expression is an instance of the type. How this instance is produced is not specified 
        here.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="naturalnumber"></a>6.1.1.&nbsp;Integer number literals</h3></div></div><div></div></div><p>An integer literal, as defined in 
            <a href="#numericliterals" title="2.4.1.&nbsp;Numeric literals">&sect;2.4.1 Numeric literals</a>, is an expression of type 
            <tt class="literal">Integer</tt>, representing a numeric integer.</p><pre data-language="ceylon">Integer five = 5;</pre><pre data-language="ceylon">Integer mask = $1111_0000;</pre><pre data-language="ceylon">Integer white = #FFFF;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="floatnumber"></a>6.1.2.&nbsp;Floating point number literals</h3></div></div><div></div></div><p>A floating point literal, as defined in 
            <a href="#numericliterals" title="2.4.1.&nbsp;Numeric literals">&sect;2.4.1 Numeric literals</a>, is an expression of type 
            <tt class="literal">Float</tt>, a floating-point representation of 
            a numeric value.</p><pre data-language="ceylon">shared Float pi = 3.14159;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="character"></a>6.1.3.&nbsp;Character literals</h3></div></div><div></div></div><p>A single character literal, as defined in 
            <a href="#characterliterals" title="2.4.2.&nbsp;Character literals">&sect;2.4.2 Character literals</a>, is an expression of type 
            <tt class="literal">Character</tt>, representing a single 32-bit
            Unicode character.</p><pre data-language="ceylon">if (exists ch=string[i], ch == '+') { ... }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="string"></a>6.1.4.&nbsp;Character string literals</h3></div></div><div></div></div><p>A character string literal or verbatim string, as defined 
            in <a href="#stringliterals" title="2.4.3.&nbsp;String literals">&sect;2.4.3 String literals</a>, is an expression of type
            <tt class="literal">String</tt>, representing a sequence of Unicode
            characters.</p><pre data-language="ceylon">person.name = "Gavin King";</pre><pre data-language="ceylon">print("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</pre><pre data-language="ceylon">String verbatim = """A verbatim string can have \ or a " in it."""";</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stringtemplates"></a>6.2.&nbsp;String templates</h2></div></div><div></div></div><p>A character <span class="emphasis"><em>string template</em></span> contains interpolated 
        expressions, surrounded by character string fragments.</p><pre data-language="bnf">StringTemplate: StringStart (ValueExpression StringMid)* ValueExpression StringEnd</pre><p>Each interpolated expression contained in the string template must have 
        a type assignable to <tt class="literal">Object</tt> defined in 
        <tt class="literal">ceylon.language</tt>.</p><pre data-language="ceylon">print("Hello, ``person.firstName`` ``person.lastName``, the time is ``Time()``.");</pre><pre data-language="ceylon">print("1 + 1 = ``1 + 1``");</pre><p>A string template is an expression of type <tt class="literal">String</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="selfreferences"></a>6.3.&nbsp;Self references and the current package reference</h2></div></div><div></div></div><p>The type of the following expressions depends upon the context in which 
        they appear.</p><pre data-language="bnf">SelfReference: "this" | "super" | "outer" | "package"</pre><p>A self reference expression may not occur outside of a class or 
        interface body.</p><p>The <span class="emphasis"><em>immediately containing class or interface</em></span> for
        a program element is the class or interface in which the program element 
        occurs, and which contains no other class or interface in which the program 
        element occurs. If there is no such class or interface, the program element
        has no immediately containing class or interface.</p><p>A <tt class="literal">this</tt>, <tt class="literal">outer</tt>, or 
        <tt class="literal">super</tt> self reference must have an immediately containing 
        class or interface. An <tt class="literal">outer</tt> self reference must have
        an immediately containing class or interface for its immediately containing 
        class or interface.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="this"></a>6.3.1.&nbsp;<tt class="literal">this</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">this</tt> refers to the current instance,
            as defined in <a href="#currentinstanceofaclassorinterface" title="8.2.3.&nbsp;Current instance of a class or interface">&sect;8.2.3 Current instance of a class or interface</a>, of the 
            immediately containing class or interface (the class or interface in which 
            the expression appears). Its type is the type of the immediately containing 
            class or interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outer"></a>6.3.2.&nbsp;<tt class="literal">outer</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">outer</tt> refers to the current instance,
            as defined in <a href="#currentinstanceofaclassorinterface" title="8.2.3.&nbsp;Current instance of a class or interface">&sect;8.2.3 Current instance of a class or interface</a>, of the 
            class or interface which immediately contains the immediately containing 
            class or interface. Its type is assignable to the type of this class or 
            interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="super"></a>6.3.3.&nbsp;<tt class="literal">super</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">super</tt> refers to the current instance 
            of the immediately containing class or interface. Its type is the 
            intersection of the immediate superclass and all immediate superinterfaces 
            of the class. A member reference such as <tt class="literal">super.x</tt> may not 
            resolve to a <tt class="literal">formal</tt> declaration, nor to any member 
            inherited from more than one supertype of the intersection type.</p><p>The keyword <tt class="literal">super</tt> may occur as the first operand
            of an <tt class="literal">of</tt> operator, in which case the second operand is
            any supertype of the class. The expression <tt class="literal">(super of Type)</tt>
            has type <tt class="literal">Type</tt>. A member reference such as 
            <tt class="literal">(super of Type).x</tt> may not resolve to a <tt class="literal">formal</tt> 
            member, nor to any member inherited from more than one supertype of 
            <tt class="literal">Type</tt>, nor to any member that is refined by the class or 
            any intermediate supertype of the class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="thispackage"></a>6.3.4.&nbsp;<tt class="literal">package</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">package</tt> is not an expression, and
            does not have a well-defined type. However, it may be used to qualify 
            and disambiguate a value reference or callable reference. A value
            reference or callable reference qualified by the keyword 
            <tt class="literal">package</tt> always refers to a toplevel member of the
            containing package, never to an imported declaration or nested 
            declaration.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="anonymousfunctions"></a>6.4.&nbsp;Anonymous functions</h2></div></div><div></div></div><p>An anonymous function is a function, as specified in 
        <a href="#functions" title="4.7.&nbsp;Functions">&sect;4.7 Functions</a>, with no name, defined within an expression. 
        It comprises one or more parameter lists, followed by an expression.</p><pre data-language="bnf">FunctionExpression: ("function" | "void")? Parameters+ (LazySpecifier | Block)</pre><p>The parameters are the parameters of the function. The lazy 
        specifier or block of code is the implementation of the function. If 
        the <tt class="literal">void</tt> keyword is specified, the function is a 
        <tt class="literal">void</tt> function. Otherwise, it is a 
        non-<tt class="literal">void</tt> function, and its return type is 
        inferred.</p><p>The type of an anonymous function expression is the callable 
        type of the function, as specified in 
        <a href="#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>.</p><pre data-language="ceylon">(Value x, Value y) =&gt; x&lt;=&gt;y</pre><pre data-language="ceylon">void (String name) =&gt; print(name)</pre><pre data-language="ceylon">(String string) {
    value mid = string.size / 2;
    return [string[...mid],string[mid+1...]];
}</pre><p>An anonymous function occurring in an <tt class="literal">extends</tt>
        clause may not contain a reference to a variable value.</p><i><span class="comment"><p>Note: evaluation of an anonymous function expression,
        as defined in <a href="#anonymousfunctionevaluation" title="8.4.5.&nbsp;Evaluation of anonymous functions">&sect;8.4.5 Evaluation of anonymous functions</a> results
        in instantiation of an object of type <tt class="literal">Callable</tt>.
        However, the members of this object are never in scope, do not hide
        other declarations, and are not referenceable from within the 
        anonymous function.</p></span></i><i><span class="comment"><p>Note: there is almost no semantic difference between the
        following function declarations:</p>
        <pre data-language="ceylon">Float f(Float x)(Float y) =&gt; x*y;</pre>
        <pre data-language="ceylon">Float(Float) f(Float x) =&gt; (Float y) =&gt; x*y;</pre>
        <p>The first form is strongly preferred.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="parametertypeinference"></a>6.4.1.&nbsp;Anonymous function parameter type inference</h3></div></div><div></div></div><p>If the type of a parameter of an anonymous function is 
            not declared explicitly, then the type of the parameter may in 
            certain cases be inferred if the anonymous function occurs:</p><div class="itemizedlist"><ul type="disc"><li><p>as a listed argument, as defined in 
                    <a href="#listedarguments" title="6.6.4.&nbsp;Listed arguments">&sect;6.6.4 Listed arguments</a>, in a positional 
                    argument list, or</p></li><li><p>as a specified argument, anonymous argument, or
                    listed argument, as defined in 
                    <a href="#namedarguments" title="6.6.8.&nbsp;Named argument lists">&sect;6.6.8 Named argument lists</a>, in a named argument 
                    list.</p></li></ul></div><p>Suppose the type of the <tt class="literal">i</tt>th parameter 
            <tt class="literal">p</tt> of an anonymous function is not declared 
            explicitly, and further suppose that the anonymous function
            occurs as the argument to a parameter <tt class="literal">x</tt> of
            some function or class in a direct invocation expression, as 
            defined in <a href="#directinvocations" title="6.6.1.&nbsp;Direct invocations">&sect;6.6.1 Direct invocations</a>.</p><p>Then the type of <tt class="literal">p</tt> may be inferred if 
            either:</p><div class="itemizedlist"><ul type="disc"><li><p>the function or class has no type parameters, or 
                    the invocation has an explicit type argument list, and 
                    <tt class="literal">x</tt> is a callable parameter with the 
                    same number of parameters as the anonymous function, and 
                    with <tt class="literal">i</tt>th parameter <tt class="literal">q</tt>,
                    </p></li><li><p>the function or class has at least one type parameter, 
                    and the invocation has no explicit type argument list, and 
                    <tt class="literal">x</tt> is a callable parameter with the same 
                    number of parameters as the anonymous function, and the type 
                    of the <tt class="literal">i</tt>th parameter <tt class="literal">q</tt>
                    of <tt class="literal">x</tt> does not involve any of the type 
                    parameters of the generic function or class, or</p></li><li><p><tt class="literal">x</tt> is a value parameter whose type 
                    does not involve any of the type parameters of the generic 
                    function or class and represents a function with the same 
                    number of parameters as the anonymous function, and with 
                    <tt class="literal">i</tt>th parameter <tt class="literal">q</tt>, 
                    according to <a href="#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>.</p></li></ul></div><p>Then the type of <tt class="literal">p</tt> is inferred to be the 
            type of <tt class="literal">q</tt> in the realization of the function or 
            class, as defined in <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>Otherwise, suppose the type of the <tt class="literal">i</tt>th
            parameter <tt class="literal">p</tt> of an anonymous function is not
            declared explicitly, and further suppose that the anonymous function
            occurs as the <tt class="literal">n</tt>th argument in the positional
            argument list of an indirect invocation expression.</p><p>Then if the callable type of the invoked expression represents
            a function whose <tt class="literal">n</tt>th parameter is a callable
            parameter with the same number of parameters as the anonymous
            function, according to <a href="#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>,
            then the type of <tt class="literal">p</tt> is inferred to be the type of 
            the corresponding <tt class="literal">i</tt>th parameter of this callable 
            parameter.</p><p>That is, if the type of the invoked expression is 
            <tt class="literal">Callable&lt;R,T&gt;</tt> where <tt class="literal">T</tt>
            is a tuple type whose <tt class="literal">n</tt>th element type is 
            <tt class="literal">Callable&lt;P,S&gt;</tt> and <tt class="literal">S</tt> is 
            in turn a tuple type whose <tt class="literal">i</tt>th element type is 
            <tt class="literal">Q</tt>, then <tt class="literal">Q</tt> is the inferred type 
            of <tt class="literal">p</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compoundexpressions"></a>6.5.&nbsp;Compound expressions</h2></div></div><div></div></div><p>An <span class="emphasis"><em>atom</em></span> is a literal or self reference, a
        string template, an iterable or tuple enumeration, or a parenthesized 
        expression.</p><pre data-language="bnf">Atom: Literal | StringTemplate | SelfReference | GroupedExpression | Iterable | Tuple | DynamicValue</pre><p>A <span class="emphasis"><em>primary</em></span> is formed by recursively forming 
        member expressions and invocation expressions from an atom, base 
        expression, or static expression.</p><pre data-language="bnf">Primary: Atom | BaseExpression | MemberExpression | StaticExpression | Invocation | Meta | Dec</pre><p>More complex expressions are formed by combining expressions using 
        operators, including assignment operators, and anonymous functions.</p><pre data-language="bnf">ValueExpression: Primary | OperatorExpression</pre><pre data-language="bnf">Expression: ValueExpression | FunctionExpression | OperatorInvocation | OperatorMemberExpression</pre><i><span class="comment"><p>Note: the grammar of operator expressions is defined by
        the table of operator precedence and associativity in 
        <a href="#operatorprecedence" title="6.8.1.&nbsp;Operator precedence">&sect;6.8.1 Operator precedence</a>. Thus, the rule
        <tt class="literal">OperatorExpression</tt> is not defined in BNF.</p></span></i><p>Parentheses are used for grouping:</p><pre data-language="bnf">GroupedExpression: "(" Expression ")"</pre><p>A compound expression occurring in a <tt class="literal">dynamic</tt> 
        block, and involving a qualified or unqualified reference with no type,
        or a reference to a declaration with no type, may also have no type.</p><p>In particular, if an operand expression has no type, and the type 
        of the operator expression depends upon the type of the operand, and the 
        operator expression occurs within a <tt class="literal">dynamic</tt> block, 
        then the whole operator expression has no type.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="baseexpressions"></a>6.5.1.&nbsp;Base expressions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>base expression</em></span> is an unqualified 
            identifier, with an optional list of type arguments:</p><pre data-language="bnf">BaseExpression: (MemberName | TypeName) TypeArguments?</pre><p>A base expression is either:</p><div class="itemizedlist"><ul type="disc"><li><p>a reference to a toplevel function, toplevel value, or 
                    toplevel class,</p></li><li><p>a reference within the lexical scope of the referenced 
                    function, value, or class, or</p></li><li><p>a reference within the body of the referenced function,
                    value, or class.</p></li></ul></div><p>The referenced declaration is determined by resolving the unqualified 
            reference as defined by <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>.
            The unqualified realization for the unqualified reference is determined
            according to <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list
            of the unqualified realization.</p><p>If a base expression is a reference to an attribute, method, or 
            member class of a class, the receiving instance is the current instance of 
            that class, as defined by <a href="#currentinstanceofaclassorinterface" title="8.2.3.&nbsp;Current instance of a class or interface">&sect;8.2.3 Current instance of a class or interface</a>.
            Otherwise, there is no receiving instance.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="memberexpressions"></a>6.5.2.&nbsp;Member expressions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>member expression</em></span> is a <span class="emphasis"><em>receiver
            expression</em></span>, followed by an identifier, with an optional list 
            of type arguments.</p><pre data-language="bnf">MemberExpression: (Primary ".") (MemberName | TypeName) TypeArguments?</pre><p>A member expression is a reference to a member of a type: an
            attribute, method, or member class.</p><p>The referenced member is determined by resolving the qualified 
            reference as defined by <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.
            The qualified realization for the qualified reference is determined
            according to <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list
            of the qualified realization.</p><p>The receiver expression produces the instance upon which the member 
            is invoked or evaluated. When a member expression is executed, the receiver 
            expression is evaluated to produce the receiving instance which is held 
            until the member is invoked or evaluated, as defined in 
            <a href="#evaluationinvocationandassignment" title="8.4.&nbsp;Evaluation, invocation, and assignment">&sect;8.4 Evaluation, invocation, and assignment</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="valuereferences"></a>6.5.3.&nbsp;Value references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>value reference</em></span> is a base expression or 
            member expression that references a value declaration.</p><p>The type of a value reference expression is the type of the 
            realization of the referenced value.</p><p>A value declaration is never generic, so a value reference never
            has a type argument list.</p><p>A value reference that does not occur within any <tt class="literal">dynamic</tt>
            block may not refer to a value declaration or value parameter with no type.</p><p>A value reference which occurs within a <tt class="literal">dynamic</tt> 
            block and which does not reference any statically typed declaration, or
            which references a value declaration or value parameter with no type, 
            has no type.</p><p>If a base expression or member expression does not reference any 
            statically typed declaration, and occurs within a <tt class="literal">dynamic</tt> 
            block, then it is considered a value reference.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="callablereferences"></a>6.5.4.&nbsp;Callable references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>callable reference</em></span> is a base expression or
            member expression that references something&#8212;a function or 
            class&#8212;that can be <span class="emphasis"><em>invoked</em></span> or 
            <span class="emphasis"><em>instantiated</em></span> by specifying a list of arguments.</p><p>A callable reference may be invoked immediately, or it may be passed 
            to other code which may invoke the reference. A callable reference captures 
            the return type and parameter list types of the function or class it refers 
            to, allowing compile-time validation of argument types when the callable 
            reference is invoked.</p><p>The type of a callable reference expression is the callable type of
            the realization of the referenced function or class.</p><p>If a callable reference expression refers to a generic declaration, 
            either:</p><div class="itemizedlist"><ul type="disc"><li><p>it must be immediately followed by an argument list, 
                    allowing the compiler to infer the type arguments, or</p></li><li><p>it must have an explicit type argument list.</p></li></ul></div><p>A callable reference may not appear as the receiver expression of
            a member expression.</p><i><span class="comment"><p>Note: this restriction exists to eliminate an ambiguity in
            the interpretation of static expressions such as <tt class="literal">Person.string</tt>
            and <tt class="literal">Person.equals</tt>.</p></span></i><p>A callable reference that does not occur within any <tt class="literal">dynamic</tt>
            block may not refer to a function declaration with no return type.</p><p>A callable reference which occurs within a <tt class="literal">dynamic</tt> 
            block and which references a function declaration with no return type, has 
            no type.</p><i><span class="comment"><p>Note: in a future release of the language, we would like to 
            add a syntax for obtaining a callable reference to an attribute, something
            like <tt class="literal">person.@name</tt>, to allow attributes to be passed by 
            reference. This would also allow static references like
            <tt class="literal">Person.@name</tt>.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="staticexpressions"></a>6.5.5.&nbsp;Static expressions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>static expression</em></span> is a type, followed by an identifier, 
            with an optional list of type arguments.</p><pre data-language="bnf">StaticExpression: (TypeName TypeArguments? ".")+ (MemberName | TypeName) TypeArguments?</pre><p>A static expression is a reference to a member of a type: an attribute, method, 
            or member class.</p><p>The referenced member is determined by resolving the qualified reference as defined 
            by <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>. The qualified realization for the 
            qualified reference is determined according to <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list of the 
            qualified realization.</p><p>Unlike member expressions, a static expression does not have a receiver expression. 
            All static expressions are callable expressions which accept an argument of the specified 
            type.</p><p>A static expression must reference a statically typed declaration with no missing 
            types, even within a <tt class="literal">dynamic</tt> block.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="staticvaluereferences"></a>6.5.6.&nbsp;Static value references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>static value reference</em></span> is a static 
            expression that references an attribute declaration.</p><pre data-language="ceylon">List&lt;Anything&gt;.size</pre><p>The type of a static value reference expression for an attribute 
            whose realization is of type <tt class="literal">X</tt>, and with qualifying 
            type <tt class="literal">T</tt>, is <tt class="literal">X(T)</tt>.</p><p>A value declaration is never generic, so a static value reference 
            never ends in a type argument list.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="staticcallablereferences"></a>6.5.7.&nbsp;Static callable references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>static callable reference</em></span> is a static 
            expression that references something&#8212;a method or member 
            class&#8212;that can be <span class="emphasis"><em>invoked</em></span> or 
            <span class="emphasis"><em>instantiated</em></span>.</p><pre data-language="ceylon">List&lt;String&gt;.filter</pre><pre data-language="ceylon">Iterable&lt;Integer&gt;.map&lt;String&gt;</pre><p>The type of a static callable reference expression for a method
            or member class whose realization has callable type <tt class="literal">C</tt>, 
            and with qualifying type <tt class="literal">T</tt>, is <tt class="literal">C(T)</tt>.</p><p>If a callable reference expression refers to a generic declaration, 
            it must end in an explicit type argument list.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="invocationexpressions"></a>6.6.&nbsp;Invocation expressions</h2></div></div><div></div></div><p>A callable expression&#8212;any expression of type 
        <tt class="literal">Callable</tt>&#8212;is <span class="emphasis"><em>invokable</em></span>. An 
        <span class="emphasis"><em>invocation</em></span> consists of an <span class="emphasis"><em>invoked expression</em></span>, 
        together with an argument list and, optionally, an explicit type argument list.</p><pre data-language="bnf">Invocation: Primary Arguments</pre><p>The invoked expression must be of type <tt class="literal">Callable&lt;R,P&gt;</tt>
        for some types <tt class="literal">R</tt> and <tt class="literal">P</tt>. Then the type of the 
        invocation expression is simply <tt class="literal">R</tt>.</p><p>If the invoked expression has no type, and occurs within a <tt class="literal">dynamic</tt> 
        block, then the whole invocation expression has no type, and the argument list is 
        not type-checked at compile time, unless it is a direct invocation expression.</p><p>An invocation expression must specify arguments for parameters of the callable 
        object, either as a positional argument list, or as a named argument list.</p><pre data-language="bnf">Arguments: PositionalArguments | NamedArguments</pre><p>Every argument list has a type, as specified below in 
        <a href="#positionalarguments" title="6.6.7.&nbsp;Positional argument lists">&sect;6.6.7 Positional argument lists</a> and <a href="#namedarguments" title="6.6.8.&nbsp;Named argument lists">&sect;6.6.8 Named argument lists</a>. If an 
        invocation is formed from a callable expression of type exactly 
        <tt class="literal">Callable&lt;R,P&gt;</tt> and an argument list of type 
        <tt class="literal">A</tt>, then <tt class="literal">A</tt> must be a subtype of 
        <tt class="literal">P</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="directinvocations"></a>6.6.1.&nbsp;Direct invocations</h3></div></div><div></div></div><p>Any invocation expression where the invoked expression is a callable 
            reference expression is called a <span class="emphasis"><em>direct invocation expression</em></span> 
            of the function or class to which the callable reference refers.</p><i><span class="comment"><p>TODO: Should we consider <tt class="literal">x{y=1;}{z=2;}</tt> a legal
            direct invocation if <tt class="literal">x</tt> has multiple parameter lists?</p></span></i><p>In a direct invocation expression:</p><div class="itemizedlist"><ul type="disc"><li><p>the compiler has one item of additional information about the schema 
                    of the method or class that is not reified by the <tt class="literal">Callable</tt> 
                    interface: the names of the parameters of the function or class, and
                    therefore named arguments may be used, and</p></li><li><p>type argument inference is possible, as defined in 
                    <a href="#typeargumentinference" title="3.6.3.&nbsp;Type argument inference">&sect;3.6.3 Type argument inference</a>, since the compiler has access to 
                    the type parameters and constraints of the function or class.</p></li></ul></div><p>If an invocation expression has a named argument list, it must be a direct
            invocation.</p><p>The type of a direct invocation expression is the return type of the 
            realization of the function, or the type of the realization of the class, as 
            defined in <a href="#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>If the function has no return type, and occurs within a <tt class="literal">dynamic</tt> 
            block, then the whole direct invocation expression has no type.</p><p>In a direct invocation expression of a function or class, the restriction
            above on the argument list type is equivalent to the following requirements. Given
            the parameter list of the realization of the function or class, and the arguments 
            of the direct invocation:</p><div class="itemizedlist"><ul type="disc"><li><p>for each required parameter, an argument must be given,</p></li><li><p>for each defaulted parameter, an argument may optionally be 
                    given,</p></li><li><p>if the parameter list has a variadic parameter of type 
                    <tt class="literal">T+</tt>, one or more arguments must be given,</p></li><li><p>if the parameter list has a variadic parameter of type 
                    <tt class="literal">T*</tt>, one or more arguments may optionally be 
                    given,</p></li><li><p>no additional arguments may be given,</p></li><li><p>for a required or defaulted parameter of type <tt class="literal">T</tt>, 
                    the type of the corresponding argument expression must be assignable to 
                    <tt class="literal">T</tt>, and</p></li><li><p>for a variadic parameter of type <tt class="literal">T*</tt> or 
                    <tt class="literal">T+</tt>, the type of every corresponding argument 
                    expression must be assignable to <tt class="literal">T</tt>.</p></li></ul></div><p>Furthermore, if type argument are inferred, then the inferred type 
            arguments must conform, as defined by <a href="#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, 
            to the type parameter list of the realization of the function or class.</p><p>If an argument expression has no type, or if its parameter has no type, 
            and the invocation occurs within a <tt class="literal">dynamic</tt> block, then the 
            argument is not type-checked at compile time.</p><p>An invocation expression that does not occur within any <tt class="literal">dynamic</tt>
            block may not assign an argument to a value parameter with no type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="defaultarguments"></a>6.6.2.&nbsp;Default arguments</h3></div></div><div></div></div><p>When no argument is assigned to a defaulted parameter by the caller, 
            the default argument defined by the parameter declaration of the realization,
            as defined by <a href="#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, of the function 
            or class is used. The default argument expression is evaluated every time the 
            method is invoked with no argument specified for the defaulted parameter.</p><p>This class:</p><pre data-language="ceylon">shared class Counter(Integer initialCount=0) { ... }</pre><p>May be instantiated using any of the following invocations:</p><pre data-language="ceylon">Counter()</pre><pre data-language="ceylon">Counter(1)</pre><pre data-language="ceylon">Counter {}</pre><pre data-language="ceylon">Counter { initialCount=10; }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tupletypeofarglist"></a>6.6.3.&nbsp;The type of a list of arguments</h3></div></div><div></div></div><p>A list of arguments may be formed from:</p><div class="itemizedlist"><ul type="disc"><li><p>any number of <span class="emphasis"><em>listed arguments</em></span>,
                    optionally followed by either</p></li><li><p>a <span class="emphasis"><em>spread argument</em></span>, or</p></li><li><p>a <span class="emphasis"><em>comprehension</em></span>.</p></li></ul></div><pre data-language="bnf">ArgumentList: ((ListedArgument ",")* (ListedArgument | SpreadArgument | Comprehension))?</pre><p>Every such list of arguments has a type, which captures the types of 
            the individual arguments in the list. This type is always a subtype of 
            <tt class="literal">Anything[]</tt>. The type of an empty list of arguments is 
            <tt class="literal">[]</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="listedarguments"></a>6.6.4.&nbsp;Listed arguments</h3></div></div><div></div></div><p>A listed argument is an expression.</p><pre data-language="bnf">ListedArgument: Expression</pre><p>If a listed argument is an expression of type <tt class="literal">T</tt>, and 
            a list of arguments has type <tt class="literal">P</tt> with principal instantiation 
            <tt class="literal">Sequential&lt;Y&gt;</tt>, then the type of a new argument list 
            formed by prepending the expression to the first parameter list is 
            <tt class="literal">Tuple&lt;T|Y,T,P&gt;</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spreadarguments"></a>6.6.5.&nbsp;Spread arguments</h3></div></div><div></div></div><p>A spread argument is an expression prefixed by the 
            <span class="emphasis"><em>spread operator</em></span> <tt class="literal">*</tt>.</p><pre data-language="bnf">SpreadArgument: "*" ValueExpression</pre><p>The spread operator is parsed with a precedence just lower than 
            the multiplication operator <tt class="literal">*</tt> and just higher than 
            the set union and complement operators <tt class="literal">|</tt> and
            <tt class="literal">~</tt>, and is not associative.</p><i><span class="comment"><p>Note: this restriction means that the symbol <tt class="literal">*</tt>
            always has the same precedence, wherever it occurs in the language.</p></span></i><p>The expression type <tt class="literal">T</tt> must have the principal 
            instantiation <tt class="literal">{X*}</tt> for some type <tt class="literal">X</tt>. 
            We form the <span class="emphasis"><em>sequential type of a spread argument</em></span> as 
            follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if the expression type <tt class="literal">T</tt> is an invariant 
                    subtype of <tt class="literal">X[]</tt>, for some type <tt class="literal">X</tt> 
                    then the sequential type of the spread argument is 
                    <tt class="literal">T</tt>, or, if not,</p></li><li><p>if the expression type <tt class="literal">T</tt> is an invariant 
                    subtype of <tt class="literal">{X+}</tt>, for some type <tt class="literal">X</tt> 
                    then the sequential type of the spread argument is 
                    <tt class="literal">[X+]</tt>, or, otherwise,</p></li><li><p>the expression type <tt class="literal">T</tt> is an invariant 
                    subtype of <tt class="literal">{X*}</tt>, for some type <tt class="literal">X</tt>
                    and the sequential type of the spread argument is 
                    <tt class="literal">X[]</tt>.</p></li></ul></div><p>When a spread argument with an expression type not assignable to 
            <tt class="literal">Anything[]</tt> is evaluated, the elements of the iterable
            automatically are packaged into a sequence.</p><i><span class="comment"><p>Note: the spread "operator" is not truly an operator in the
            sense of <a href="#operators" title="6.8.&nbsp;Operators">&sect;6.8 Operators</a>, and so a spread argument is not an 
            expresson. An expression, when evaluated, produces a single value. The
            spread operator produces multiple values. It is therefore more correct to 
            view the spread operator as simply part of the syntax of an argument list.
            </p></span></i><p>The type of a list of arguments containing only a spread argument of 
            sequential type <tt class="literal">S</tt> is simply <tt class="literal">S</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="comprehensions"></a>6.6.6.&nbsp;Comprehensions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>comprehension</em></span> accepts one or more streams of values 
            and produces a new stream of values. Any instance of <tt class="literal">Iterable</tt>
            is considered a stream of values. The comprehension has two or more
            <span class="emphasis"><em>clauses</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>A <tt class="literal">for</tt> clause specifies a source stream and an 
                    iteration variable, as defined in <a href="#iterationvariables" title="5.3.2.&nbsp;Iteration variables">&sect;5.3.2 Iteration variables</a>, 
                    representing the values produced by the stream.</p></li><li><p>An <tt class="literal">if</tt> clause specifies a condition list, as
                    defined in <a href="#controlstructureconditions" title="5.3.3.&nbsp;Control structure conditions">&sect;5.3.3 Control structure conditions</a>, used to filter
                    the values produced by the source stream or streams.</p></li><li><p>An expression clause produces the values of the resulting stream.</p></li></ul></div><p>Every comprehension begins with a <tt class="literal">for</tt> or <tt class="literal">if</tt>
            clause, and ends with an expression clause. There may be any number of intervening 
            <tt class="literal">for</tt> or <tt class="literal">if</tt> clauses. Each clause in the
            comprehension is considered a child of the clause that immediately precedes 
            it.</p><pre data-language="bnf">Comprehension: InitialComprehensionClause</pre><pre data-language="bnf">InitialComprehensionClause: ForComprehensionClause | IfComprehensionClause</pre><pre data-language="bnf">ForComprehensionClause: "for" ForIterator ComprehensionClause</pre><pre data-language="bnf">IfComprehensionClause: "if" ConditionList ComprehensionClause</pre><pre data-language="bnf">ComprehensionClause: ForComprehensionClause | IfComprehensionClause | Expression</pre><p>An expression that occurs in a child clause may refer to iteration 
            variables and condition variables declared by parent clauses. The types
            of such variables are specified in <a href="#controlstructures" title="5.3.&nbsp;Control structures and assertions">&sect;5.3 Control structures and assertions</a>.</p><i><span class="comment"><p>Note: each child clause can be viewed as a body nested inside 
            the parent clause. The scoping rules for variables declared by comprehension
            clauses reflects this model.</p></span></i><p>The type of a list of arguments containing only a comprehension is 
            <tt class="literal">[T*]</tt> where <tt class="literal">T</tt> is the type of the
            expression which terminates the comprehension, or <tt class="literal">[T+]</tt>
            if there are no <tt class="literal">if</tt> clauses, and if every 
            <tt class="literal">for</tt> clause has an iterated expression of nonempty
            type.</p><p>An comprehension occurring in an <tt class="literal">extends</tt> clause may 
            not contain a reference to a variable value.</p><i><span class="comment"><p>Note: a comprehension, like a spread argument, is not considered an 
            expression. An expression, when evaluated, produces a single value. A comprehension
            produces multiple values, like a spread argument, or like a series of listed 
            arguments. Therefore, a comprehension may only appear in an argument list or an 
            enumeration expression. This is, however, no limitation; we can simply wrap the
            comprehension in braces in order to get an expression of type <tt class="literal">{T*}</tt>,
            or in brackets to get an expression of type <tt class="literal">[T*]</tt>.</p></span></i><i><span class="comment"><p>TODO: properly define how expressions with no type occurring in a
            <tt class="literal">dynamic</tt> block affect comprehensions.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="positionalarguments"></a>6.6.7.&nbsp;Positional argument lists</h3></div></div><div></div></div><p>When invocation arguments are listed positionally, the argument list is 
            enclosed in parentheses.</p><pre data-language="bnf">PositionalArguments: "(" ArgumentList ")"</pre><p>The type of the positional argument list is the type of the list of arguments 
            it contains.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="namedarguments"></a>6.6.8.&nbsp;Named argument lists</h3></div></div><div></div></div><p>When invocation arguments are listed by name, the argument list is enclosed 
            in braces.</p><pre data-language="bnf">NamedArguments: "{" NamedArgument* ArgumentList "}"</pre><p>Named arguments may be listed in a different order to the corresponding
            parameters.</p><p>Each named argument in a named argument list is either:</p><div class="itemizedlist"><ul type="disc"><li><p>an <span class="emphasis"><em>anonymous argument</em></span>&#8212;an expression, with
                    no parameter name explicitly specified,</p></li><li><p>a <span class="emphasis"><em>specified argument</em></span>&#8212;a specification 
                    statement where name of the value of function being specified is interpreted
                    as the name of a parameter, or</p></li><li><p>an inline getter, function, or anonymous class declaration, whose name 
                    is interpreted as the name of a parameter.</p></li></ul></div><pre data-language="bnf">NamedArgument: AnonymousArgument | SpecifiedArgument | InlineDeclarationArgument</pre><p>Additionally, a named argument list has an ordinary list of arguments, which 
            may be empty. This argument list is interpreted as a single argument to a parameter 
            of type <tt class="literal">Iterable</tt>.</p><pre data-language="ceylon">{ initialCapacity=2; "hello", "world" }</pre><pre data-language="ceylon">{ initialCapacity=people.size; loadFactor=0.8; for (p in people) p.name-&gt;p }</pre><i><span class="comment"><p>Note: in a future release of the language, we would like to be able 
            to assign a local name to an anonymous argument or listed argument, allowing it to 
            be referenced later in the argument list. We might consider this a kind of "let"
            expression, perhaps.</p></span></i><p>Given a parameter list, and a named argument list, we may attempt to construct 
            an <span class="emphasis"><em>equivalent positional argument list</em></span> as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>Taking each argument in the named argument list in turn, on the order 
                    they occur lexically:</p><div class="itemizedlist"><ul type="circle"><li><p>if the argument is anonymous, assign it to the first unassigned
                            parameter of the parameter list, or</p></li><li><p>if the argument is named, assign it to the parameter with that
                            name in the parameter list.</p></li></ul></div><p>If for any argument, there is no unassigned parameter, no parameter with
                    the given name, or the parameter with the given name has already been assigned
                    an argument, construction of the positional argument list fails, and the 
                    invocation is not well-typed.</p></li><li><p>Next, if the parameter list has an unassigned parameter of type exactly
                    <tt class="literal">Iterable&lt;T,N&gt;</tt> for some types <tt class="literal">T</tt> and
                    <tt class="literal">N</tt>, then an iterable enumeration expression, as defined in
                    <a href="#enumeration" title="6.6.12.&nbsp;Iterable and tuple enumeration">&sect;6.6.12 Iterable and tuple enumeration</a>, is formed from the ordinary list of arguments, 
                    and assigned to that parameter.</p><p>If there is no such parameter, and the ordinary list of arguments is
                    nonempty, then construction of the positional argument list fails, and the 
                    invocation is not well-typed.</p></li><li><p>Finally, we assign each unassigned defaulted parameter its default 
                    argument.</p></li></ul></div><p>The resulting equivalent positional argument list is formed by ordering
            the arguments according to the position of their corresponding parameters in
            the parameter list, and then replacing any inline value, function, or object
            declarations with a reference to the declaration.</p><p>The type of a named argument list is the type of the equivalent positional 
            argument list.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="anonymousarguments"></a>6.6.9.&nbsp;Anonymous arguments</h3></div></div><div></div></div><p>An anonymous argument is just an expression followed by a semicolon.</p><pre data-language="bnf">AnonymousArgument: Expression ";"</pre><p>The type of the argument is the type of the expression.</p><pre data-language="ceylon">{
    Head { title="Hello"; };
    Body {
        Div { "Hello ``name``!" };
    };
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="specifiedarguments"></a>6.6.10.&nbsp;Specified arguments</h3></div></div><div></div></div><p>A specified argument is a value specification statement or lazy specification 
            statement, as defined in <a href="#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>, where the value
            reference or callable reference is treated as the name of a parameter of the invoked 
            function or class instead of using the usual rules for resolving unqualified names.</p><pre data-language="bnf">SpecifiedArgument: Specification</pre><div class="itemizedlist"><ul type="disc"><li><p>If a specified argument is a value specification statement, its type 
                    is the type of the specified expression.</p></li><li><p>If a specified argument is a lazy specification statement with no 
                    parameter lists, its type is the type of the specified expression.</p></li><li><p>Otherwise, if it is a lazy specification statement with a parameter 
                    list, its type is the callable type formed from the type of the expression,
                    interpreted as a function return type, and the types of its parameter lists, 
                    according to <a href="#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>.</p></li></ul></div><i><span class="comment"><p>Note: there is an ambiguity here between assignment expressions 
            and specified arguments. This ambiguity is resolved in favor of interpreting the
            argument as a specified argument. Therefore an anonymous argument in a named 
            argument list may not be an assignment expression.</p></span></i><pre data-language="ceylon">{ 
    product = getProduct(id); 
    quantity = 1; 
}</pre><pre data-language="ceylon">{ 
    by(Value x, Value y) =&gt; x&lt;=&gt;y;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inlinedeclarationarguments"></a>6.6.11.&nbsp;Inline declaration arguments</h3></div></div><div></div></div><p>An <span class="emphasis"><em>inline declaration argument</em></span> defines a getter,
            function, or anonymous class, and assigns it to a parameter.</p><pre data-language="bnf">InlineDeclarationArgument: ValueArgument | FunctionArgument | ObjectArgument</pre><p>An inline getter argument is a streamlined value declaration, as defined
            in <a href="#values" title="4.8.&nbsp;Values">&sect;4.8 Values</a>. The type of the argument is the declared or inferred 
            type of the value.</p><pre data-language="bnf">ValueArgument: ValueHeader (Block | (Specifier | LazySpecifier) ";")</pre><p>An inline function argument is a streamlined function declaration, as
            defined in <a href="#functions" title="4.7.&nbsp;Functions">&sect;4.7 Functions</a>. The type of the argument is the callable 
            type of the function, as defined by <a href="#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>.</p><pre data-language="bnf">FunctionArgument: FunctionHeader (Block | LazySpecifier ";")</pre><p>An inline anonymous class argument is a streamlined anonymous class 
            declaration, as defined in <a href="#anonymousclasses" title="4.5.7.&nbsp;Anonymous classes">&sect;4.5.7 Anonymous classes</a>. The type of the 
            argument is the anonymous class type.</p><pre data-language="bnf">ObjectArgument: ObjectHeader ClassBody</pre><p>A named argument may not have type parameters or annotations.</p><pre data-language="ceylon">{
    description = "Total";
    value amount { 
        variable Float total = 0.0;
        for (Item item in items) {
            sum += item.amount;
        }
        return total;
    }
}</pre><pre data-language="ceylon">{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello!"); 
    } 
}</pre><pre data-language="ceylon">{ 
    function by(Value x, Value y) =&gt; x&lt;=&gt;y;
}</pre><pre data-language="ceylon">{
    object iterator 
            satisfies Iterator&lt;Order&gt; {
        variable value done = false;
        shared actual Order|Finished next() {
            if (done) {
                return finished;
            }
            else {
                done=true;
                return order; 
            }
        }
    }   
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="enumeration"></a>6.6.12.&nbsp;Iterable and tuple enumeration</h3></div></div><div></div></div><p>An <span class="emphasis"><em>enumeration expression</em></span> is an abbreviation for
            tuple and iterable object instantiation. Iterable enumerations are delimited
            using braces. Tuple enumerations are delimited by brackets.</p><pre data-language="bnf">Iterable: "{" ArgumentList "}"</pre><pre data-language="bnf">Tuple: "[" ArgumentList "]"</pre><p>The type of an iterable enumeration expression is:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Iterable&lt;Nothing,Null&gt;</tt> if there are no 
                    argument expressions, or</p></li><li><p><tt class="literal">Iterable&lt;U,Nothing&gt;</tt> where 
                    <tt class="literal">U</tt>, the argument expression list is an invariant 
                    suptype of <tt class="literal">U[]</tt>.</p></li></ul></div><p>The type of a tuple enumeration expression is the type of the list of
            arguments it contains.</p><pre data-language="ceylon">{String+} = { "hello", "world" };</pre><pre data-language="ceylon">[] none = [];</pre><pre data-language="ceylon">[Float,Float] xy = [x, y];</pre><pre data-language="ceylon">[Float,Float, String*] xy = [x, y, *labels];</pre><p>Every argument expression must have a type, even if the enumeration expression
            occurs in a <tt class="literal">dynamic</tt> block.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicenumerations"></a>6.6.13.&nbsp;Dynamic enumerations</h3></div></div><div></div></div><p>A <span class="emphasis"><em>dynamic enumeration expression</em></span> creates a new 
            object with no class by enumerating its members, allowing interoperation 
            with dynamically typed native code.</p><pre data-language="bnf">DynamicValue: "dynamic" "[" NamedArgument* ArgumentList "]"</pre><p>A dynamic enumeration expression has no type.</p><p>Any argument names may be specified in the named argument list.</p><p>A dynamic enumeration expression must occur inside a
            <tt class="literal">dynamic</tt> block.</p><i><span class="comment"><p>The semantics of this construct are platform-dependent and
            beyond the scope of this specification.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="miscexpressions"></a>6.7.&nbsp;Conditional expressions and anonymous class expressions</h2></div></div><div></div></div><p>A <span class="emphasis"><em>conditional expression</em></span> resembles a control 
        structure but is part of the expression syntax, and evaluates to a value.</p><p>An <span class="emphasis"><em>inline class</em></span> is an anonymous class defined 
        within an expression.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inlineconditionalexpressions"></a>6.7.1.&nbsp;Inline conditional expressions</h3></div></div><div></div></div><i><span class="comment">
            <p>We plan to support inline <tt class="literal">if/then/else</tt> conditional 
            expressions, for example:</p>
            <pre data-language="ceylon">Integer port = if (exists setting = process.propertyValue("port")) 
                        then parseInteger(setting) else 8080;</pre>
            <p>Note that this is more powerful than the <tt class="literal">then</tt> and
            <tt class="literal">else</tt> operators because it allows all kinds of conditions,
            not only boolean conditions.</p>
            <p>Should we also support:</p>
            <div class="itemizedlist"><ul type="disc"><li><p>inline <tt class="literal">switch/case/else</tt> conditional 
                    expressions, or even</p></li><li><p>inline <tt class="literal">try/catch</tt> exceptional conditions?</p></li></ul></div>
            <p>For example:</p>
            <pre data-language="ceylon">Float evaluated =&gt; switch (expr)
        case (is Literal) expr.integer
        case (is Plus) expr.left.evaluated + expr.right.evaluated
        case (is Times) expr.left.evaluated * expr.right.evaluated;</pre>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="letexpressions"></a>6.7.2.&nbsp;Let expressions</h3></div></div><div></div></div><i><span class="comment">
            <p>Should we support let expressions, possibly reusing the keyword
            <tt class="literal">given</tt>?</p>
            <pre data-language="ceylon">given (dist = sqrt(x^2+y^2)) [x/dist,y/dist]</pre>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inlineanonymousclassexpressions"></a>6.7.3.&nbsp;Inline anonymous class expressions</h3></div></div><div></div></div><i><span class="comment">
            <p>Should we support inline <tt class="literal">object</tt> declarations, for 
            example:</p>
            <pre data-language="ceylon">iterator =&gt; object satisfies Iterable&lt;Nothing&gt; { next() =&gt; finished; }</pre>
            <p>Or, alternatively, a kind of named argument ""instantiation" syntax for
            interfaces and abstract classes:</p>
            <pre data-language="ceylon">iterator =&gt; Iterable { next() =&gt; finished; }</pre>
            <p>The first option is more flexible, but also more verbose. The second is
            streamlined for the common case and might even be able to do type argument
            inference as shown here.</p> 
            
            <p>If we go with the first option, should we support inline <tt class="literal">class</tt> 
            declarations? This would be like an inline <tt class="literal">object</tt> and an 
            anonymous function rolled into one. We could even support <tt class="literal">class</tt>
            arguments in named argument lists.</p>
            </span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="operators"></a>6.8.&nbsp;Operators</h2></div></div><div></div></div><p>Operators are syntactic shorthand for more complex expressions involving 
    invocation, evaluation, or instantiation. There is no support for user-defined 
    <span class="emphasis"><em>operator overloading</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>new operator symbols may not be defined outside of the operators
            specified below, and</p></li><li><p>the definition of the operators specified below may not be changed 
            or overloaded.</p></li></ul></div><p>However, many of the operators below are defined in terms of 
    <tt class="literal">default</tt> or <tt class="literal">formal</tt> methods or attributes.
    So, within well-defined limits a concrete implementation may customize the  
    behavior of an operator. This approach is called 
    <span class="emphasis"><em>operator polymorphism</em></span>.</p><p>Some examples:</p><pre data-language="ceylon">Float z = x * y + 1.0;</pre><pre data-language="ceylon">even = n % 2 == 0;</pre><pre data-language="ceylon">++count;</pre><pre data-language="ceylon">Integer j = i++;</pre><pre data-language="ceylon">if ( x &gt; 100 || x &lt; 0 ) { ... }</pre><pre data-language="ceylon">User user = users[userId] else guest;</pre><pre data-language="ceylon">List&lt;Item&gt; firstPage = results[0..20];</pre><pre data-language="ceylon">for (n in 0:length) { ... }</pre><pre data-language="ceylon">if (char in 'A'..'Z') { ... }</pre><pre data-language="ceylon">String[] names = people*.name;</pre><pre data-language="ceylon">this.total += item.price * item.quantity;</pre><pre data-language="ceylon">Float vol = length^3;</pre><pre data-language="ceylon">Vector scaled = scale ** vector;</pre><pre data-language="ceylon">map.contains(person.name-&gt;person);</pre><pre data-language="ceylon">if (!document.internal || user is Employee) { ... }</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="operatorprecedence"></a>6.8.1.&nbsp;Operator precedence</h3></div></div><div></div></div><p>There are 18 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict.</p><div class="itemizedlist"><ul type="disc"><li><p>Operators in layer 1 produce, transform, and combine
            values.</p></li><li><p>Operators in layer 2 compare or predicate values, producing
            a <tt class="literal">Boolean</tt> result.</p></li><li><p>Operators in layer 3 are logical operators that operate
            upon <tt class="literal">Boolean</tt> arguments to produce a <tt class="literal">Boolean</tt>
            value.</p></li><li><p>Operators in layer 4 perform assignment and conditional
            evaluation.</p></li></ul></div><p>Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators.</p><p>There is a single exception to this principle: the binary 
        exponentiation operator <tt class="literal">^</tt> has a higher precedence than 
        the prefix operators <tt class="literal">+</tt> and <tt class="literal">-</tt>. The 
        reason for this is that the following expressions should be equivalent:</p><pre data-language="ceylon">-x^2       //means -(x^2)</pre><pre data-language="ceylon">0 - x^2    //means 0 - (x^2)</pre><p>This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules:</p><div class="table"><a name="d0e13542"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Operations</th><th align="center">Operators</th><th align="center">Type</th><th align="center">Associativity</th></tr></thead><tbody><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 1</em></span></td></tr><tr><td align="center">Member invocation and selection, index, subrange,
                postfix increment, postfix decrement:</td><td align="center"><tt class="literal">.</tt>,
                <tt class="literal">*.</tt>, 
                <tt class="literal">?.</tt>, 
                <tt class="literal">()</tt>,
                <tt class="literal">{}</tt>,
                <tt class="literal">[]</tt>,
                <tt class="literal">[:]</tt>, 
                <tt class="literal">[..]</tt>, 
                <tt class="literal">[...]</tt>,
                <tt class="literal">++</tt>, 
                <tt class="literal">--</tt></td><td align="center">Binary / ternary / N-ary / unary postfix</td><td align="center">Left</td></tr><tr><td align="center">Prefix increment, prefix decrement:</td><td align="center"><tt class="literal">++</tt>, 
                <tt class="literal">--</tt></td><td align="center">Unary prefix</td><td align="center">Right</td></tr><tr><td align="center">Exponentiation:</td><td align="center"><tt class="literal">^</tt></td><td align="center">Binary</td><td align="center">Right</td></tr><tr><td align="center">Negation:</td><td align="center"><tt class="literal">+</tt>,
                <tt class="literal">-</tt></td><td align="center">Unary prefix</td><td align="center">Right</td></tr><tr><td align="center">Set intersection:</td><td align="center"><tt class="literal">&amp;</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Set union and complement:</td><td align="center"><tt class="literal">|</tt>,
                <tt class="literal">~</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Multiplication, division, remainder:</td><td align="center"><tt class="literal">*</tt>, 
                <tt class="literal">/</tt>, 
                <tt class="literal">%</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Scale:</td><td align="center"><tt class="literal">**</tt></td><td align="center">Binary</td><td align="center">Right</td></tr><tr><td align="center">Addition, subtraction:</td><td align="center"><tt class="literal">+</tt>, 
                <tt class="literal">-</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Range and entry construction:</td><td align="center"><tt class="literal">..</tt>,
                <tt class="literal">:</tt>,  
                <tt class="literal">-&gt;</tt></td><td align="center">Binary</td><td align="center">None</td></tr><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 2</em></span></td></tr><tr><td align="center">Existence, emptiness:</td><td align="center"><tt class="literal">exists</tt>, <tt class="literal">nonempty</tt></td><td align="center">Unary postfix</td><td align="center">None</td></tr><tr><td align="center">Comparison, containment,
                assignability, inheritance:</td><td align="center"><tt class="literal">&lt;=&gt;</tt>,
                <tt class="literal">&lt;</tt>, 
                <tt class="literal">&gt;</tt>, 
                <tt class="literal">&lt;=</tt>, 
                <tt class="literal">&gt;=</tt>,
                <tt class="literal">in</tt>,
                <tt class="literal">is</tt>,
                <tt class="literal">of</tt></td><td align="center">Binary (and ternary)</td><td align="center">None</td></tr><tr><td align="center">Equality, identity:</td><td align="center"><tt class="literal">==</tt>, 
                <tt class="literal">!=</tt>, 
                <tt class="literal">===</tt></td><td align="center">Binary</td><td align="center">None</td></tr><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 3</em></span></td></tr><tr><td align="center">Logical not:</td><td align="center"><tt class="literal">!</tt></td><td align="center">Unary prefix</td><td align="center">Right</td></tr><tr><td align="center">Logical and:</td><td align="center"><tt class="literal">&amp;&amp;</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Logical or:</td><td align="center"><tt class="literal">||</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 4</em></span></td></tr><tr><td align="center">Conditionals:</td><td align="center"><tt class="literal">then</tt>, 
                <tt class="literal">else</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Assignment:</td><td align="center"><tt class="literal">=</tt>, 
                <tt class="literal">+=</tt>, 
                <tt class="literal">-=</tt>, 
                <tt class="literal">*=</tt>, 
                <tt class="literal">/=</tt>, 
                <tt class="literal">%=</tt>, 
                <tt class="literal">&amp;=</tt>, 
                <tt class="literal">|=</tt>, 
                <tt class="literal">~=</tt>, 
                <tt class="literal">&amp;&amp;=</tt>, 
                <tt class="literal">||=</tt></td><td align="center">Binary</td><td align="center">Right</td></tr></tbody></table></div><p>It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator <tt class="literal">!</tt> has a very low
        precedence. The following expressions are equivalent:</p><pre data-language="ceylon">!x.y == 0.0  //means !(x.y == 0.0)</pre><pre data-language="ceylon">x.y != 0.0</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="operatordefinition"></a>6.8.2.&nbsp;Operator definition</h3></div></div><div></div></div><p>The following tables define the semantics of the Ceylon operators. 
        There are six basic operators which do not have a definition in terms of 
        other operators or invocations:</p><div class="itemizedlist"><ul type="disc"><li><p>the <span class="emphasis"><em>member selection</em></span> operator
                <tt class="literal">.</tt> separates the receiver expression and member 
                name in a member expression, as defined above in
                <a href="#memberexpressions" title="6.5.2.&nbsp;Member expressions">&sect;6.5.2 Member expressions</a>,</p></li><li><p>the <span class="emphasis"><em>argument specification</em></span> operators
                <tt class="literal">()</tt> and <tt class="literal">{}</tt> specify the 
                argument list of an invocation, as defined in
                <a href="#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a> and 
                <a href="#invocation" title="8.4.4.&nbsp;Invocation">&sect;8.4.4 Invocation</a>,</p></li><li><p>the <span class="emphasis"><em>assignment</em></span> operator
                <tt class="literal">=</tt> assigns a new value to a variable and 
                returns the new value after assignment, as defined in
                <a href="#assignment" title="8.4.3.&nbsp;Assignment">&sect;8.4.3 Assignment</a>,</p></li><li><p>the <span class="emphasis"><em>identity</em></span> operator
                <tt class="literal">===</tt> evaluates to <tt class="literal">true</tt> 
                if its argument expressions evaluate to references to the same 
                object, as defined in <a href="#objectinstancesidentity" title="8.1.&nbsp;Object instances, identity, and reference passing">&sect;8.1 Object instances, identity, and reference passing</a>,
                or to <tt class="literal">false</tt> otherwise,</p></li><li><p>the <span class="emphasis"><em>assignability</em></span> operator
                <tt class="literal">is</tt> evaluates to <tt class="literal">true</tt> if 
                its argument expression evaluates to an instance of a class, as 
                defined in <a href="#objectinstancesidentity" title="8.1.&nbsp;Object instances, identity, and reference passing">&sect;8.1 Object instances, identity, and reference passing</a>, that is a 
                subtype of the specified type, or to <tt class="literal">false</tt> 
                otherwise, and</p></li><li><p>the <span class="emphasis"><em>coverage</em></span> operator
                <tt class="literal">of</tt> narrows or widens the type of an expression 
                to any specified type that covers the expression type, as defined
                by <a href="#coverage" title="3.4.1.&nbsp;Coverage">&sect;3.4.1 Coverage</a>, without affecting the value of the
                expression.</p></li></ul></div><p>All other operators are defined below in terms of other operators 
        and/or invocations.</p><p>In the tables, the following pseudo-code is used, which is not legal
        Ceylon syntax:</p><p>First,</p><pre data-language="ceylon">if (b) then x else y   //pseudocode</pre><p>means the value of <tt class="literal">result</tt> after execution of the
        following:</p><pre data-language="ceylon">X result; if (b) { result=x; } else { result=y; }</pre><p>Second,</p><pre data-language="ceylon">let t=x in y   //pseudocode</pre><p>means the value of <tt class="literal">result</tt> after execution of the
        following:</p><pre data-language="ceylon">X t = x; Y result=y;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="basic"></a>6.8.3.&nbsp;Basic invocation and assignment operators</h3></div></div><div></div></div><p>These operators support method invocation and attribute evaluation and
        assignment.</p><div class="table"><a name="d0e14005"></a><p class="title"><b>Table&nbsp;6.2.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Invocation</em></span></td></tr><tr><td align="center"><tt class="literal">lhs.member</tt></td><td align="center">member</td><td align="center">&nbsp;</td><td align="center"><tt class="literal">X</tt></td><td align="center">a member of <tt class="literal">X</tt>, of type
            <tt class="literal">T</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">lhs(x,y,z)</tt> or 
            <tt class="literal">lhs{a=x;b=y;}</tt></td><td align="center">invoke</td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Callable &lt;T,P&gt;</tt></td><td align="center">argument list of type <tt class="literal">P</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs = rhs</tt></td><td align="center">assign</td><td align="center"><tt class="literal"></tt></td><td align="center">variable of type <tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Coverage</em></span></td></tr><tr><td align="center"><tt class="literal">lhs of Type</tt></td><td align="center">of</td><td align="center"><tt class="literal"></tt></td><td align="center"><tt class="literal">X</tt></td><td align="center">a literal type <tt class="literal">T</tt> that covers 
            <tt class="literal">X</tt></td><td align="center"><tt class="literal">T</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="equalitycomparison"></a>6.8.4.&nbsp;Equality and comparison operators</h3></div></div><div></div></div><p>These operators compare values for equality, order, magnitude, or membership,
        producing boolean values.</p><div class="table"><a name="d0e14124"></a><p class="title"><b>Table&nbsp;6.3.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Equality and identity</em></span></td></tr><tr><td align="center"><tt class="literal">lhs === rhs</tt></td><td align="center">identical</td><td align="center"><tt class="literal"></tt></td><td align="center"><tt class="literal">X given X satisfies Identifiable</tt></td><td align="center"><tt class="literal">Y given Y satisfies Identifiable</tt>
            where <tt class="literal">X&amp;Y</tt> is not <tt class="literal">Nothing</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs == rhs</tt></td><td align="center">equal</td><td align="center"><tt class="literal">lhs.equals(rhs)</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs != rhs</tt></td><td align="center">not equal</td><td align="center"><tt class="literal">!lhs.equals(rhs)</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Comparison</em></span></td></tr><tr><td align="center"><tt class="literal">lhs &lt;=&gt; rhs</tt></td><td align="center">compare</td><td align="center"><tt class="literal">lhs.compare(rhs)</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Comparison</tt></td></tr><tr><td align="center"><tt class="literal">lhs &lt; rhs</tt></td><td align="center">smaller</td><td align="center"><tt class="literal">lhs.compare(rhs)==smaller</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &gt; rhs</tt></td><td align="center">larger</td><td align="center"><tt class="literal">lhs.compare(rhs)==larger</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &lt;= rhs</tt></td><td align="center">small as</td><td align="center"><tt class="literal">lhs.compare(rhs)!=larger</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &gt;= rhs</tt></td><td align="center">large as</td><td align="center"><tt class="literal">lhs.compare(rhs)!=smaller</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Containment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs in rhs</tt></td><td align="center">in</td><td align="center"><tt class="literal">let x=lhs in rhs.contains(x)</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Category</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Assignability</em></span></td></tr><tr><td align="center"><tt class="literal">rhs is Type</tt></td><td align="center">is</td><td align="center">&nbsp;</td><td align="center">any type which is not a subtype of 
            <tt class="literal">T</tt>, whose intersection with 
            <tt class="literal">T</tt> is not <tt class="literal">Nothing</tt></td><td align="center">any literal type <tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr></tbody></table></div><i><span class="comment"><p>TODO: Should we have allow the operators <tt class="literal">&lt;=</tt> 
        and <tt class="literal">&gt;=</tt> to handle partial orders? A particular usecase is
        <tt class="literal">Set</tt> comparison.</p></span></i><p>A <span class="emphasis"><em>bounded comparison</em></span> is an abbreviation 
        for two binary comparisons:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">l&lt;x&lt;u</tt> means 
                <tt class="literal">let t=x in l&lt;t &amp;&amp; t&lt;u</tt>,</p></li><li><p><tt class="literal">l&lt;=x&lt;u</tt> means 
                <tt class="literal">let t=x in l&lt;=t &amp;&amp; t&lt;u</tt>,</p></li><li><p><tt class="literal">l&lt;x&lt;=u</tt> means 
                <tt class="literal">let t=x in l&lt;t &amp;&amp; t&lt;=u</tt>, and</p></li><li><p><tt class="literal">l&lt;=x&lt;=u</tt> means 
                <tt class="literal">let t=x in l&lt;=t &amp;&amp; t&lt;=u</tt></p></li></ul></div><p>for expressions <tt class="literal">l</tt>, <tt class="literal">u</tt>, 
        and <tt class="literal">x</tt>.</p><p>These abbreviations have the same precedence as the binary 
        <tt class="literal">&lt;</tt> and <tt class="literal">&lt;=</tt> operators, and, 
        like the binary forms, are not associative.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="logical"></a>6.8.5.&nbsp;Logical operators</h3></div></div><div></div></div><p>These are the usual logical operations for boolean values.</p><div class="table"><a name="d0e14428"></a><p class="title"><b>Table&nbsp;6.4.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Logical operators</em></span></td></tr><tr><td align="center"><tt class="literal">!rhs</tt></td><td align="center">not</td><td align="center"><tt class="literal">if (rhs) false else true</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs || rhs</tt></td><td align="center">conditional or</td><td align="center"><tt class="literal">if (lhs) true else rhs</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp;&amp; rhs</tt></td><td align="center">conditional and</td><td align="center"><tt class="literal">if (lhs) rhs else false</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Logical assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs ||= rhs</tt></td><td align="center">conditional or</td><td align="center"><tt class="literal">if (lhs) true else lhs=rhs</tt></td><td align="center">variable of type <tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp;&amp;= rhs</tt></td><td align="center">conditional and</td><td align="center"><tt class="literal">if (lhs) lhs=rhs else false</tt></td><td align="center">variable of type <tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="nullvalues"></a>6.8.6.&nbsp;Operators for handling null values</h3></div></div><div></div></div><p>These operators make it easy to work with optional expressions.</p><div class="table"><a name="d0e14554"></a><p class="title"><b>Table&nbsp;6.5.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Existence</em></span></td></tr><tr><td align="center"><tt class="literal">lhs exists</tt></td><td align="center">exists</td><td align="center"><tt class="literal">if (exists lhs) true else false</tt></td><td align="center">any type whose intersections with <tt class="literal">Object</tt>
            and <tt class="literal">Null</tt> are not <tt class="literal">Nothing</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs nonempty</tt></td><td align="center">nonempty</td><td align="center"><tt class="literal">if (nonempty lhs) true else false</tt></td><td align="center">any subtype of <tt class="literal">Anything[]?</tt>
            whose intersections with <tt class="literal">[]</tt> and 
            <tt class="literal">[Nothing+]</tt> are not <tt class="literal">Nothing</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Nullsafe invocation</em></span></td></tr><tr><td align="center"><tt class="literal">lhs?.member</tt></td><td align="center">nullsafe attribute</td><td align="center"><tt class="literal">if (exists lhs) lhs.member else null</tt></td><td align="center"><tt class="literal">X?</tt></td><td align="center">an attribute of type <tt class="literal">T</tt>
            of <tt class="literal">X</tt></td><td align="center"><tt class="literal">T?</tt></td></tr><tr><td align="center"><tt class="literal">lhs?.member</tt></td><td align="center">nullsafe method</td><td align="center">&nbsp;</td><td align="center"><tt class="literal">X?</tt></td><td align="center">a method of callable type 
            <tt class="literal">Callable &lt;T,P&gt;</tt> 
            of <tt class="literal">X</tt></td><td align="center"><tt class="literal">Callable &lt;T?,P&gt;</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="listmap"></a>6.8.7.&nbsp;Correspondence, subrange, and stream operators</h3></div></div><div></div></div><p>These operators provide a simplified syntax for accessing values 
        of a <tt class="literal">Correspondence</tt>, for obtaining subranges of 
        <tt class="literal">Ranged</tt> objects, and for spreading member access
        over a stream.</p><div class="table"><a name="d0e14687"></a><p class="title"><b>Table&nbsp;6.6.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Keyed item access</em></span></td></tr><tr><td align="center"><tt class="literal">lhs[index]</tt></td><td align="center">lookup</td><td align="center"><tt class="literal">lhs.item(index)</tt></td><td align="center"><tt class="literal">Correspondence&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">Y?</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Subranges</em></span></td></tr><tr><td align="center"><tt class="literal">lhs[from:length]</tt></td><td align="center">measured subrange</td><td align="center"><tt class="literal">lhs.measure(from,length)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y,Z&gt;</tt></td><td align="center"><tt class="literal">X</tt>, <tt class="literal">Integer</tt></td><td align="center"><tt class="literal">Z</tt></td></tr><tr><td align="center"><tt class="literal">lhs[from..to]</tt></td><td align="center">spanned subrange</td><td align="center"><tt class="literal">lhs.span(from,to)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y,Z&gt;</tt></td><td align="center"><tt class="literal">X</tt>, <tt class="literal">X</tt></td><td align="center"><tt class="literal">Z</tt></td></tr><tr><td align="center"><tt class="literal">lhs[from...]</tt></td><td align="center">upper spanned subrange</td><td align="center"><tt class="literal">lhs.spanFrom(from)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y,Z&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">Z</tt></td></tr><tr><td align="center"><tt class="literal">lhs[...to]</tt></td><td align="center">lower spanned subrange</td><td align="center"><tt class="literal">lhs.spanTo(to)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y,Z&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">Z</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Spread invocation</em></span></td></tr><tr><td align="center"><tt class="literal">lhs*.attribute</tt></td><td align="center">spread attribute</td><td align="center"><tt class="literal">[*lhs.map(X.attribute)]</tt></td><td align="center"><tt class="literal">Iterable&lt;X,N&gt;</tt></td><td align="center">attribute of <tt class="literal">X</tt> of
            type <tt class="literal">T</tt></td><td align="center"><tt class="literal">[T*]</tt> or <tt class="literal">[T+]</tt></td></tr><tr><td align="center"><tt class="literal">lhs*.method</tt></td><td align="center">spread method</td><td align="center"><tt class="literal">compose((Iterable&lt;T,N&gt; ts)=&gt;[*ts], lhs.spread(X.method))</tt></td><td align="center"><tt class="literal">Iterable&lt;X,N&gt;</tt></td><td align="center">method of <tt class="literal">X</tt> of
            callable type <tt class="literal">Callable &lt;T,P&gt;</tt></td><td align="center"><tt class="literal">Callable &lt;[T*],P&gt;</tt> or
            <tt class="literal">Callable &lt;[T+],P&gt;</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Spread multiplication</em></span></td></tr><tr><td align="center"><tt class="literal">lhs ** rhs</tt></td><td align="center">scale</td><td align="center"><tt class="literal">rhs.scale(lhs)</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">Scalable&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">Y</tt></td></tr></tbody></table></div><p>There are two special cases related to sequences. A type <tt class="literal">X</tt>
    is a <span class="emphasis"><em>sequence type</em></span> if <tt class="literal">X</tt> is a subtype of 
    <tt class="literal">Sequential&lt;Anything&gt;</tt>.</p><p>For any sequence type <tt class="literal">X</tt> and integer <tt class="literal">n</tt>, 
    we can form the <span class="emphasis"><em><tt class="literal">n</tt>th tail type, <tt class="literal">Xn</tt>, 
    of <tt class="literal">X</tt></em></span> as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>for every <tt class="literal">i&lt;=0</tt>, <tt class="literal">Xi</tt> 
            is <tt class="literal">X</tt>, and</p></li><li><p>for every <tt class="literal">i&gt;0</tt>, if <tt class="literal">Xi</tt> 
            has the principal instantiation <tt class="literal">Tuple&lt;Ui,Fi,Yi&gt;</tt> 
            then <tt class="literal">X(i+1)</tt> is <tt class="literal">Yi</tt>, or, 
            otherwise, <tt class="literal">X(i+1)</tt> is <tt class="literal">Xi</tt>.</p></li></ul></div><p>For any sequence type <tt class="literal">X</tt> and integer <tt class="literal">n</tt>, 
    we can form the <span class="emphasis"><em><tt class="literal">n</tt>th element type, <tt class="literal">En</tt>, 
    of <tt class="literal">X</tt></em></span> as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if <tt class="literal">Xn</tt> has the principal instantiation
            <tt class="literal">Tuple&lt;Un,Fn,Yn&gt;</tt> then <tt class="literal">En</tt> 
            is <tt class="literal">Fn</tt>, or, otherwise, <tt class="literal">Xn</tt>
            has the principal instantiation <tt class="literal">Sequential&lt;Fn&gt;</tt> 
            and <tt class="literal">En</tt> is <tt class="literal">Fn?</tt>.</p></li></ul></div><p>Then the two special cases are:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of an expression of form <tt class="literal">x[i...]</tt> where
    <tt class="literal">x</tt> is of tuple type <tt class="literal">X</tt> and 
    <tt class="literal">n</tt> is an integer literal is <tt class="literal">Xn</tt>.</p></li><li><p>The type of an expression of form <tt class="literal">x[i]</tt> where
    <tt class="literal">x</tt> is of tuple type <tt class="literal">X</tt> and 
    <tt class="literal">n</tt> is an integer literal is <tt class="literal">En</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constructors"></a>6.8.8.&nbsp;Operators for creating objects</h3></div></div><div></div></div><p>These operators simplify the syntax for instantiating certain 
        commonly used built-in types.</p><div class="table"><a name="d0e15049"></a><p class="title"><b>Table&nbsp;6.7.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Range and entry constructors</em></span></td></tr><tr><td align="center"><tt class="literal">lhs..rhs</tt></td><td align="center">spanned range</td><td align="center"><tt class="literal">span(lhs, rhs)</tt></td><td align="center"><tt class="literal">T given T satisfies Enumerable&lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Range&lt;T&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs:rhs</tt></td><td align="center">measured range</td><td align="center"><tt class="literal">measure(lhs,rhs)</tt></td><td align="center"><tt class="literal">T given T satisfies Enumerable&lt;T&gt;</tt></td><td align="center"><tt class="literal">Integer</tt></td><td align="center"><tt class="literal">Range&lt;T&gt;|[]</tt></td></tr><tr><td align="center"><tt class="literal">lhs-&gt;rhs</tt></td><td align="center">entry</td><td align="center"><tt class="literal">Entry(lhs, rhs)</tt></td><td align="center"><tt class="literal">U given U satisfies Object</tt></td><td align="center"><tt class="literal">V</tt></td><td align="center"><tt class="literal">Entry&lt;U,V&gt;</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conditionals"></a>6.8.9.&nbsp;Conditional operators</h3></div></div><div></div></div><p>Two special operators allow emulation of the famous ternary
        operator of C-like languages.</p><div class="table"><a name="d0e15136"></a><p class="title"><b>Table&nbsp;6.8.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Conditionals</em></span></td></tr><tr><td align="center"><tt class="literal">lhs then rhs</tt></td><td align="center">then</td><td align="center"><tt class="literal">if (lhs) then rhs else null</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">T given T satisfies Object</tt></td><td align="center"><tt class="literal">T?</tt></td></tr><tr><td align="center"><tt class="literal">lhs else rhs</tt></td><td align="center">else</td><td align="center"><tt class="literal">if (exists lhs) then lhs else rhs</tt></td><td align="center"><tt class="literal">U</tt> such that <tt class="literal">null is U</tt></td><td align="center"><tt class="literal">V</tt></td><td align="center"><tt class="literal">U&amp;Object|V</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="arithmetic"></a>6.8.10.&nbsp;Arithmetic operators</h3></div></div><div></div></div><p>These are the usual mathematical operations for all kinds of
        numeric values.</p><div class="table"><a name="d0e15207"></a><p class="title"><b>Table&nbsp;6.9.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Increment, decrement</em></span></td></tr><tr><td align="center"><tt class="literal">++rhs</tt></td><td align="center">successor</td><td align="center"><tt class="literal">rhs=rhs.successor</tt></td><td align="center">&nbsp;</td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">--rhs</tt></td><td align="center">predecessor</td><td align="center"><tt class="literal">rhs=rhs.predecessor</tt></td><td align="center">&nbsp;</td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">lhs++</tt></td><td align="center">increment</td><td align="center">&nbsp;</td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">lhs--</tt></td><td align="center">decrement</td><td align="center">&nbsp;</td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">T</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Numeric operators</em></span></td></tr><tr><td align="center"><tt class="literal">+rhs</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">rhs</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Invertible &lt;I&gt;</tt></td><td align="center"><tt class="literal">I</tt></td></tr><tr><td align="center"><tt class="literal">-rhs</tt></td><td align="center">negation</td><td align="center"><tt class="literal">rhs.negated</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Invertible &lt;I&gt;</tt></td><td align="center"><tt class="literal">I</tt></td></tr><tr><td align="center"><tt class="literal">lhs + rhs</tt></td><td align="center">sum</td><td align="center"><tt class="literal">lhs.plus(rhs)</tt></td><td align="center"><tt class="literal">Summable&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs - rhs</tt></td><td align="center">difference</td><td align="center"><tt class="literal">lhs.minus(rhs)</tt></td><td align="center"><tt class="literal">Invertible &lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs * rhs</tt></td><td align="center">product</td><td align="center"><tt class="literal">lhs.times(rhs)</tt></td><td align="center"><tt class="literal">Numeric&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs / rhs</tt></td><td align="center">quotient</td><td align="center"><tt class="literal">lhs.divided(rhs)</tt></td><td align="center"><tt class="literal">Numeric&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs % rhs</tt></td><td align="center">remainder</td><td align="center"><tt class="literal">lhs.remainder(rhs)</tt></td><td align="center"><tt class="literal">Integral&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs ^ rhs</tt></td><td align="center">power</td><td align="center"><tt class="literal">lhs.power(rhs)</tt></td><td align="center"><tt class="literal">Exponentiable &lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">Y</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Numeric assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs += rhs</tt></td><td align="center">add</td><td align="center"><tt class="literal">lhs=lhs.plus(rhs)</tt></td><td align="center">variable of type <tt class="literal">Summable&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs -= rhs</tt></td><td align="center">subtract</td><td align="center"><tt class="literal">lhs=lhs.minus(rhs)</tt></td><td align="center">variable of type <tt class="literal">Invertible &lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs *= rhs</tt></td><td align="center">multiply</td><td align="center"><tt class="literal">lhs=lhs.times(rhs)</tt></td><td align="center">variable of type <tt class="literal">Numeric&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs /= rhs</tt></td><td align="center">divide</td><td align="center"><tt class="literal">lhs=lhs.divided(rhs)</tt></td><td align="center">variable of type <tt class="literal">Numeric&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs %= rhs</tt></td><td align="center">remainder</td><td align="center"><tt class="literal">lhs=lhs.remainder(rhs)</tt></td><td align="center">variable of type <tt class="literal">Integral&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr></tbody></table></div><p>The postfix increment and decrement operators are defined as follows:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">x++</tt> means the value of <tt class="literal">result</tt>
            after executing <tt class="literal">X result=x; ++x;</tt>, and</p></li><li><p><tt class="literal">x--</tt> means the value of <tt class="literal">result</tt>
            after executing <tt class="literal">X result=x; --x;</tt>.</p></li></ul></div><p>Arithmetic operators automatically widen from <tt class="literal">Integer</tt> 
        to <tt class="literal">Float</tt> when necessary. If one operand expression is 
        of static type <tt class="literal">Integer</tt>, and the other is of type 
        <tt class="literal">Float</tt>, the operand of type <tt class="literal">Integer</tt> 
        is widened to a <tt class="literal">Float</tt> in order to make the operator 
        expression well-typed. Widening is performed by evaluating the attribute 
        <tt class="literal">float</tt> defined by <tt class="literal">Integer</tt>.</p><i><span class="comment"><p>Note: this is the only circumstance in the language where 
        implicit type conversion occurs. In fact, it is more correct to view this 
        behavior as an instance of operator overloading than as an implicit type 
        conversion. Implicit widening does not occur when an expression of type 
        <tt class="literal">Integer</tt> is merely assigned to the type 
        <tt class="literal">Float</tt>, since such behavior would result in ambiguities 
        when generics come into play.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sets"></a>6.8.11.&nbsp;Set operators</h3></div></div><div></div></div><p>These operators provide traditional mathematical operations for sets.</p><div class="table"><a name="d0e15610"></a><p class="title"><b>Table&nbsp;6.10.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Set operators</em></span></td></tr><tr><td align="center"><tt class="literal">lhs | rhs</tt></td><td align="center">union</td><td align="center"><tt class="literal">lhs.union(rhs)</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Y&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X|Y&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp; rhs</tt></td><td align="center">intersection</td><td align="center"><tt class="literal">lhs.intersection(rhs)</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Y&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&amp;Y&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs ~ rhs</tt></td><td align="center">complement</td><td align="center"><tt class="literal">lhs.complement(rhs)</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Object&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Set assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs |= rhs</tt></td><td align="center">union</td><td align="center"><tt class="literal">lhs=lhs|rhs</tt></td><td align="center">variable of type <tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp;= rhs</tt></td><td align="center">intersection</td><td align="center"><tt class="literal">lhs=lhs&amp;rhs</tt></td><td align="center">variable of type <tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Object&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs ~= rhs</tt></td><td align="center">complement</td><td align="center"><tt class="literal">lhs=lhs~rhs</tt></td><td align="center">variable of type <tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Object&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr></tbody></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metamodelexpressions"></a>6.9.&nbsp;Metamodel expressions</h2></div></div><div></div></div><p>A <span class="emphasis"><em>metamodel expression</em></span> is a reference to
        a type, a class, a function, or a value. It evaluates to a metamodel 
        object whose static type captures the type itself, the callable type 
        of the class, the callable type of the function, or the type of the 
        value, respectively.</p><pre data-language="bnf">Meta: TypeMeta | BaseMeta | MemberMeta</pre><p>A <span class="emphasis"><em>type metamodel expression</em></span> is a type, as
        defined by <a href="#type" title="3.2.&nbsp;Types">&sect;3.2 Types</a>, surrounded by backticks.</p><pre data-language="bnf">TypeMeta: "`" Type "`"</pre><p>The type may or may not be a reference to a class or interface.</p><pre data-language="ceylon">Class&lt;Person,[Name]&gt; personClass = `Person`;</pre><pre data-language="ceylon">Interface&lt;List&lt;String&gt;&gt; stringListInterface = `List&lt;String&gt;`;</pre><pre data-language="ceylon">UnionType&lt;Integer|Float&gt; numberType = `Number`;</pre><pre data-language="ceylon">Type&lt;Element&gt; elementType = `Element`;</pre><p>A <span class="emphasis"><em>base metamodel expression</em></span> is a member name, 
        with an optional list of type arguments, surrounded by backticks.</p><pre data-language="bnf">BaseMeta: "`" MemberName TypeArguments? "`"</pre><p>A base metamodel expression is a reference to a value or function. 
        The referenced declaration is determined according to
        <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>.</p><p>A <span class="emphasis"><em>member metamodel expression</em></span> is a qualifier, 
        followed by a member name, with an optional list of type arguments, 
        surrounded by backticks.</p><pre data-language="bnf">MemberMeta: "`" MetaQualifier "." MemberName TypeArguments? "`"</pre><p>The member metamodel expression qualifier is a type, as defined by 
        <a href="#type" title="3.2.&nbsp;Types">&sect;3.2 Types</a>, or a base expression referring to an anonymous 
        class declaration.</p><pre data-language="bnf">MetaQualifier: QualifiedType | GroupedType | MemberName</pre><p>A member metamodel expression is a reference to an attribute or 
        method of the type identified by the qualifier. The member is resolved 
        as a member of the type according to 
        <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.</p><pre data-language="ceylon">Function&lt;Float,[{Float+}]&gt; sumFunction = `sum&lt;Float&gt;`;</pre><pre data-language="ceylon">Attribute&lt;Person,String&gt; personNameAttribute = `Person.name`;</pre><pre data-language="ceylon">Method&lt;Person,Anything,[String]&gt; personSayMethod = `Person.say`;</pre><pre data-language="ceylon">Value&lt;Integer&gt; systemMillis = `system.milliseconds`;</pre><p>Type argument inference is impossible in a metamodel expression,
        so type arguments must be explicitly provided for every generic 
        declaration.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeofametamodelexpression"></a>6.9.1.&nbsp;Type of a metamodel expression</h3></div></div><div></div></div><p>The type of a metamodel expression depends upon the kind of 
            declaration referenced:</p><div class="itemizedlist"><ul type="disc"><li><p>for a toplevel value of type <tt class="literal">R</tt>, 
                    the type is <tt class="literal">Value&lt;R&gt;</tt>,</p></li><li><p>for a toplevel function of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Function&lt;R,P&gt;</tt>,</p></li><li><p>for a toplevel class of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Class&lt;R,P&gt;</tt>,</p></li><li><p>for a class nested in a block of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Class&lt;R,Nothing&gt;</tt>, and</p></li><li><p>for a toplevel interface or interface nested 
                    in a block of type <tt class="literal">R</tt>, the type is 
                    <tt class="literal">Interface&lt;R&gt;</tt>.</p></li></ul></div><i><span class="comment"><p>Note: members of anonymous classes are treated as 
            toplevels here.</p></span></i><p>Furthermore, given a member of a type <tt class="literal">T</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>for an attribute of type <tt class="literal">R</tt>, the 
                    type is <tt class="literal">Attribute&lt;T,R&gt;</tt>,</p></li><li><p>for a method of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Method&lt;T,R,P&gt;</tt>,</p></li><li><p>for a member class of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">MemberClass&lt;T,R,P&gt;</tt>, and</p></li><li><p>for a nested interface of type 
                    <tt class="literal">R</tt>, the type is 
                    <tt class="literal">MemberInterface&lt;T,R&gt;</tt>.</p></li></ul></div><p>Finally:</p><div class="itemizedlist"><ul type="disc"><li><p>for a union type <tt class="literal">T</tt>, the type is
                    <tt class="literal">UnionType&lt;T&gt;</tt>,</p></li><li><p>for an intersection type <tt class="literal">T</tt>, the 
                    type is <tt class="literal">IntersectionType&lt;T&gt;</tt>,</p></li><li><p>for the type <tt class="literal">Nothing</tt>, the type is 
                    <tt class="literal">Type&lt;Nothing&gt;</tt>, and</p></li><li><p>for a type parameter <tt class="literal">T</tt>, the type is
                    <tt class="literal">Type&lt;T&gt;</tt>.</p></li></ul></div><p>If a type alias occurs inside a typed metamodel expression, it 
            is replaced by its definition, after substituting type arguments, 
            before determining the type of the metamodel expression.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="referenceexpressions"></a>6.10.&nbsp;Reference expressions</h2></div></div><div></div></div><p>A <span class="emphasis"><em>reference expression</em></span> is a reference to
        a program element and evaluates to a detyped metamodel of the program 
        element. Reference expressions are used primarily in annotations, 
        especially the documentation annotations listed in 
        <a href="#documentation" title="7.4.2.&nbsp;Documentation">&sect;7.4.2 Documentation</a>. A reference expression may refer to:</p><div class="itemizedlist"><ul type="disc"><li><p>a class, interface, type alias, or type parameter,</p></li><li><p>a function or value, or</p></li><li><p>a package or module.</p></li></ul></div><pre data-language="bnf">Dec: TypeDec | MemberDec | PackageDec | ModuleDec</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="declarationreferences"></a>6.10.1.&nbsp;Declaration references</h3></div></div><div></div></div><p>Declaration reference expressions may be qualified by a
            <span class="emphasis"><em>member declaration qualifier</em></span>, a sequence
            of identifiers identifying a class or interface declaration or 
            an anonymous class declaration:</p><pre data-language="bnf">MemberDecQualifier: (TypeName ".")+ | MemberName "."</pre><p>Each identifier in the member declaration qualifier is 
            the name of a class, interface, or anonymous class.</p><p>A <span class="emphasis"><em>class reference expression</em></span>, 
            <span class="emphasis"><em>interface reference expression</em></span>,
            <span class="emphasis"><em>alias reference expression</em></span>, or
            <span class="emphasis"><em>type parameter reference expression</em></span> is an
            optional member declaration qualifier, followed by the name of
            a class or anonymous class, interface, alias, or type parameter,
            with the keyword <tt class="literal">class</tt>, <tt class="literal">interface</tt>, 
            <tt class="literal">alias</tt>, or <tt class="literal">given</tt>, respectively, 
            surrounded by backticks.</p><pre data-language="bnf">TypeKeyword: "class" | "interface" | "alias" | "given"</pre><pre data-language="bnf">TypeDec: "`" TypeKeyword MemberDecQualifier? (TypeName | MemberName) "`"</pre><p>A <span class="emphasis"><em>value reference expression</em></span> or
            <span class="emphasis"><em>function reference expression</em></span> is an optional 
            member declaration qualifier, followed by the name of a function,
            value, or anonymous class, with the keyword <tt class="literal">value</tt> 
            or <tt class="literal">function</tt>, surrounded by backticks.</p><pre data-language="bnf">MemberKeyword: "value" | "function"</pre><pre data-language="bnf">MemberDec: "`" MemberKeyword MemberDecQualifier? MemberName "`"</pre><p>A reference expression is a reference to a declaration. The 
            referenced declaration is determined according to
            <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a> and
            <a href="#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>. The kind of the
            referenced declaration must match the kind of reference indicated
            by the keyword.</p><pre data-language="ceylon">ClassDeclaration personClass = `class Person`;</pre><pre data-language="ceylon">InterfaceDeclaration stringListInterface = `interface List`;</pre><pre data-language="ceylon">AliasDeclaration numberAlias = `alias Number`;</pre><pre data-language="ceylon">TypeParameter elementTypeParameter = `given Element`;</pre><pre data-language="ceylon">ValueDeclaration personNameAttribute = `value Person.name`;</pre><pre data-language="ceylon">FunctionDeclaration personSayMethod = `function Person.say`;</pre><pre data-language="ceylon">FunctionDeclaration processWriteMethod = `function process.write`;</pre><pre data-language="ceylon">ClassDeclaration processClass = `class process`;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="packageandmodulereferences"></a>6.10.2.&nbsp;Package and module references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>package reference expression</em></span> is a package
            name, as defined by <a href="#packages" title="4.1.2.&nbsp;Packages">&sect;4.1.2 Packages</a>, with the keyword
            <tt class="literal">package</tt>, surrounded by backticks.</p><pre data-language="bnf">PackageDec: "`" "package" FullPackageName "`"</pre><p>The package name must refer to a package from which an 
            <tt class="literal">import</tt> statement in the same compilation unit may 
            import declarations, as defined by <a href="#imports" title="4.2.&nbsp;Imports">&sect;4.2 Imports</a>.</p><pre data-language="ceylon">Package modelPackage = `package ceylon.language.meta.model`;</pre><p>A <span class="emphasis"><em>module reference expression</em></span> is a module
            name, as defined by <a href="#modulenamesandversionidentifiers" title="9.3.1.&nbsp;Module names and version identifiers">&sect;9.3.1 Module names and version identifiers</a>, 
            with the keyword <tt class="literal">module</tt>, surrounded by backticks.</p><pre data-language="bnf">ModuleDec: "`" "module" FullPackageName "`"</pre><p>The module name must refer to the module to which the 
            compilation unit belongs, as specified by <a href="#sourcelayout" title="9.2.&nbsp;Source layout">&sect;9.2 Source layout</a>, 
            or to a module imported by the module to which the compilation unit 
            belongs, as defined by <a href="#moduledescriptors" title="9.3.12.&nbsp;Module descriptors">&sect;9.3.12 Module descriptors</a>.</p><pre data-language="ceylon">Module languageModule = `module ceylon.language`;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeofareferenceexpression"></a>6.10.3.&nbsp;Type of a reference expression</h3></div></div><div></div></div><p>The type of a reference expression depends upon the kind of 
            program element referenced:</p><div class="itemizedlist"><ul type="disc"><li><p>for a module, the type is 
                    <tt class="literal">Module</tt>,</p></li><li><p>for a package, the type is 
                    <tt class="literal">Package</tt>,</p></li><li><p>for a value, the type is 
                    <tt class="literal">ValueDeclaration</tt>,</p></li><li><p>for a function, the type is 
                    <tt class="literal">FunctionDeclaration</tt>,</p></li><li><p>for a type parameter, the type is 
                    <tt class="literal">TypeParameter</tt>,</p></li><li><p>for a type alias declared using the keyword
                    <tt class="literal">alias</tt>, the type is 
                    <tt class="literal">AliasDeclaration</tt>,</p></li><li><p>for a class or class alias, the type is 
                    <tt class="literal">ClassDeclaration</tt>, and</p></li><li><p>for an interface or interface alias, the type 
                    is <tt class="literal">InterfaceDeclaration</tt>.</p></li></ul></div><p>For a reference to an anonymous class, the type depends
            upon the keyword, <tt class="literal">class</tt>, or <tt class="literal">value</tt>, 
            specified in the reference expression:</p><div class="itemizedlist"><ul type="disc"><li><p>for a class reference expression, the type is 
                    <tt class="literal">ClassDeclaration</tt>, but</p></li><li><p>for a value reference expression, the type is 
                    <tt class="literal">ValueDeclaration</tt>.</p></li></ul></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="annotations"></a>Chapter&nbsp;7.&nbsp;Annotations</h2></div></div><div></div></div><p><span class="emphasis"><em>Annotations</em></span> allow information to be attached to a
    declaration or assertion, and recovered at runtime via the use of the Ceylon
    metamodel. Annotations are used to specify:</p><div class="itemizedlist"><ul type="disc"><li><p>information used by the compiler while typechecking the program,</p></li><li><p>API documentation for the documentation compiler,</p></li><li><p>serialization of a class, and</p></li><li><p>information needed by generic frameworks and libraries.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="programelementannotations"></a>7.1.&nbsp;Annotations of program elements</h2></div></div><div></div></div><p>Annotations occur at the very beginning of a declaration or assertion, 
        in an <span class="emphasis"><em>annotation list</em></span>.</p><pre data-language="ceylon">"The user login action"
by ("Gavin King",
    "Andrew Haley")
throws (`class DatabaseException`,
        "if database access fails")
see (`function LogoutAction.logout`)
scope (session) 
action { description="Log In"; url="/login"; }
shared deprecated</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="annotationlists"></a>7.1.1.&nbsp;Annotation lists</h3></div></div><div></div></div><p>An annotation is an initial lowercase identifier, optionally 
            followed by an argument list.</p><pre data-language="bnf">Annotation: MemberName Arguments?</pre><p>The annotation name is a reference to an annotation constructor,
            resolved according to <a href="#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>.</p><p>A list of annotations does not require punctuation between the 
            individual annotations in the list. An annotation list may begin with 
            a string literal, in which case it is interpreted as the argument of a 
            <tt class="literal">doc</tt> annotation.</p><pre data-language="bnf">Annotations: StringLiteral? Annotation*</pre><p>Every annotation is an invocation expression, as defined by
            <a href="#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>, of an annotation constructor.
            The annotation name is interpreted as a base expression, as defined in 
            <a href="#baseexpressions" title="6.5.1.&nbsp;Base expressions">&sect;6.5.1 Base expressions</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="annotationargments"></a>7.1.2.&nbsp;Annotation arguments</h3></div></div><div></div></div><p>For an annotation with no arguments, the argument list may be 
            omitted, in which case the annotation is interpreted as having an empty 
            positional argument list. Otherwise, the annotation argument list may be 
            specified using one of two forms:</p><div class="itemizedlist"><ul type="disc"><li><p>Using a positional argument list, as defined in 
                    <a href="#positionalarguments" title="6.6.7.&nbsp;Positional argument lists">&sect;6.6.7 Positional argument lists</a>:</p><pre data-language="ceylon">doc ("the name") String name;</pre></li><li><p>Using a named argument list, as defined in 
                    <a href="#namedarguments" title="6.6.8.&nbsp;Named argument lists">&sect;6.6.8 Named argument lists</a>:</p><pre data-language="ceylon">doc { description="the name"; } String name;</pre></li></ul></div><p>As a special case, the name of the <tt class="literal">doc</tt> annotation
            and the parenthesis around its argument may be ommitted if it is the first 
            annotation in an annotation list.</p><pre data-language="ceylon">"the name" String name;</pre><p>Operator expressions, member expressions, self references, anonymous
            functions, comprehensions, and string templates are not permitted in an 
            annotation argument. Every base expression in an annotation argument must be 
            a value reference to an anonyous class instance of an enumerated type, or 
            must occur in a direct instantiation expression for an annotation type.</p><p>A named argument to an annotation may not be an inline function, value,
            or anonymous class.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="annotationdefinition"></a>7.2.&nbsp;Annotation definition</h2></div></div><div></div></div><p>Annotations are typesafe.</p><div class="itemizedlist"><ul type="disc"><li><p>An <span class="emphasis"><em>annotation constructor</em></span> defines the
                schema of an annotation as it appears at a program element.</p></li><li><p>An <span class="emphasis"><em>annotation type</em></span> defines constraints 
                upon which program elements can bear the annotation, and an API for 
                accessing the information carried by an annotation.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="annotationconstructors"></a>7.2.1.&nbsp;Annotation constructors</h3></div></div><div></div></div><p>An <span class="emphasis"><em>annotation constructor</em></span> is a toplevel function
            that defines an annotation schema. An annotation constructor must be annotated 
            <tt class="literal">annotation</tt>. An annotation constructor may not declare type 
            parameters.</p><p>Each parameter of an annotation constructor must have one of the following
            types:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Integer</tt>, <tt class="literal">Float</tt>,
                    <tt class="literal">Character</tt>, or <tt class="literal">String</tt>,</p></li><li><p>an enumerated type whose cases are all anonymous classes,
                    such as <tt class="literal">Boolean</tt>,</p></li><li><p>a subtype of <tt class="literal">Declaration</tt> in
                    <tt class="literal">ceylon.language.meta.declaration</tt>,</p></li><li><p>an annotation type,</p></li><li><p><tt class="literal">T?</tt> where <tt class="literal">T</tt> is a legal 
                    annotation constructor parameter type,</p></li><li><p><tt class="literal">{T*}</tt> or <tt class="literal">[T*]</tt> where 
                    <tt class="literal">T</tt> is a legal annotation constructor parameter 
                    type, or</p></li><li><p>any tuple type whose element types are legal annotation 
                    constructor parameter types.</p></li></ul></div><p>A parameter of an annotation constructor may be variadic.</p><p>An annotation constructor must simply instantiate and return an instance
            of an annotation type. The body of an annotation constructor may not contain
            multiple statements. Operator expressions, member expressions, self references,
            anonymous functions, comprehensions, and string templates are not permitted in 
            the definition of an annotation constructor. Every base expression in the body 
            of an annotation constructor must be a reference to a parameter of the annotation 
            constructor or to an anonyous class instance of an enumerated type, or must occur 
            in a direct instantiation expression for an annotation type.</p><p>A named argument appearing in the definition of an annotation constructor
            may not be an inline function, value, or anonymous class.</p><pre data-language="ceylon">shared annotation Scope scope(ScopeType s) =&gt; Scope(s);</pre><pre data-language="ceylon">shared annotation Todo todo(String text) =&gt; Todo(text);</pre><p>An annotation constructor parameter may have a default argument, which must
            be a legal annotation argument.</p><p>The return type of an annotation constructor must be a constrained annotation 
            type, as defined below in <a href="#constrainedannotationtypes" title="7.2.3.&nbsp;Constrained annotation types">&sect;7.2.3 Constrained annotation types</a>.</p><p>A user-defined annotation constructor may not return the same annotation 
            type as one of the modifiers listed below in <a href="#declarationmodifiers" title="7.4.1.&nbsp;Declaration modifiers">&sect;7.4.1 Declaration modifiers</a>.</p><i><span class="comment"><p>Note: in future releases of the language we will let an annotation 
            constructor return a sequence or tuple of annotation type instances.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="annotationtypes"></a>7.2.2.&nbsp;Annotation types</h3></div></div><div></div></div><p>Annotation constructors produce instances of <span class="emphasis"><em>annotation 
            types</em></span>. An annotation type is a class annotated <tt class="literal">annotation</tt>. 
            An annotation type may not be a generic type with type parameters. An 
            annotation type must have an empty initializer section.</p><i><span class="comment"><p>Note: currently every annotation type must be a 
            <tt class="literal">final</tt> class which directly extends <tt class="literal">Basic</tt>
            in <tt class="literal">ceylon.language</tt>.</p></span></i><p>Each initializer parameter of an annotation type must have one of the 
            following types:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Integer</tt>, <tt class="literal">Float</tt>,
                    <tt class="literal">Character</tt>, or <tt class="literal">String</tt>,</p></li><li><p>an enumerated type whose cases are all anonymous classes,
                    such as <tt class="literal">Boolean</tt>,</p></li><li><p>a subtype of <tt class="literal">Declaration</tt> in
                    <tt class="literal">ceylon.language.meta.declaration</tt>,</p></li><li><p>an annotation type,</p></li><li><p><tt class="literal">T?</tt> where <tt class="literal">T</tt> is a legal 
                    annotation parameter type,</p></li><li><p><tt class="literal">{T*}</tt> or <tt class="literal">[T*]</tt> where 
                    <tt class="literal">T</tt> is a legal annotation parameter type, or</p></li><li><p>any tuple type whose element types are legal annotation 
                    parameter types.</p></li></ul></div><p>An initializer parameter of an annotation type may be variadic.</p><p>An initializer parameter of an annotation type may have a default argument, 
            which must be a legal annotation argument.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constrainedannotationtypes"></a>7.2.3.&nbsp;Constrained annotation types</h3></div></div><div></div></div><p>A <span class="emphasis"><em>constrained annotation type</em></span> is an annotation type 
            that is a subtype of <tt class="literal">OptionalAnnotation</tt> or 
            <tt class="literal">SequencedAnnotation</tt> defined in the package 
            <tt class="literal">ceylon.language</tt>.</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">A</tt> is a subtype of 
                    <tt class="literal">OptionalAnnotation</tt>, at most one annotation of 
                    annotation type <tt class="literal">A</tt> may occur at a given program 
                    element.</p></li><li><p>If <tt class="literal">A</tt> is a subtype of 
                    <tt class="literal">SequencedAnnotation</tt>, multiple annotations of 
                    annotation type <tt class="literal">A</tt> may occur at a given program 
                    element.</p></li><li><p>If <tt class="literal">A</tt> is a subtype of 
                    <tt class="literal">OptionalAnnotation&lt;A,P&gt;</tt>,
                    or <tt class="literal">SequencedAnnotation&lt;A,P&gt;</tt> then an annotation 
                    of annotation type <tt class="literal">A</tt> may not occur at a program 
                    element whose reference expression type, as defined in
                    <a href="#typeofareferenceexpression" title="6.10.3.&nbsp;Type of a reference expression">&sect;6.10.3 Type of a reference expression</a>, is not assignable to 
                    <tt class="literal">P</tt>.</p></li></ul></div><pre data-language="ceylon">shared final annotation class Scope(shared ScopeType scope)
        satisfies OptionalAnnotation&lt;Scope,ClassOrInterfaceDeclaration&gt; {
    string =&gt; (scope==request then "request")
         else (scope==session then "session")
         else (scope==application then "application")
         else nothing;
}</pre><pre data-language="ceylon">shared final annotation class Todo(String text)
        satisfies SequencedAnnotation&lt;Todo&gt; {
    string =&gt; text;
}</pre><i><span class="comment"><p>Note: it is perfectly acceptable for multiple annotation 
            constructors to return the same annotation type.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="annotationvalues"></a>7.3.&nbsp;Annotation values</h2></div></div><div></div></div><p>An <span class="emphasis"><em>annotation value</em></span> is the value returned when an
        annotation constructor is invoked. We may obtain the annotation values of all 
        annotations of a given annotation type that occur at a given program element by 
        passing the annotation type and program element metamodel reference to the method
        <tt class="literal">annotations()</tt> defined in the package
        <tt class="literal">ceylon.language.model</tt>.</p><pre data-language="ceylon">Scope scope = annotations(`Scope`, `class Person`) else Scope(request);</pre><pre data-language="ceylon">Todo[] todos = annotations(`Todo`, `function method`);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="languageannotations"></a>7.4.&nbsp;Language annotations</h2></div></div><div></div></div><p>Certain important annotations are predefined in the module 
        <tt class="literal">ceylon.language</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="declarationmodifiers"></a>7.4.1.&nbsp;Declaration modifiers</h3></div></div><div></div></div><p>The following annotations, called <span class="emphasis"><em>modifiers</em></span>, 
            are compiler instructions that affect the compilation process:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">shared</tt> specifies that a 
                    declaration is visible outside of the package or body in 
                    which it occurs, or that a package is visible outside the
                    module it belongs to.</p></li><li><p><tt class="literal">abstract</tt> specifies that a class
                    cannot be instantiated.</p></li><li><p><tt class="literal">formal</tt> specifies that a member 
                    does not specify an implementation and must therefore be 
                    refined by every concrete subclass.</p></li><li><p><tt class="literal">default</tt> specifies that a method, 
                    attribute, or member class may be refined by subtypes.</p></li><li><p><tt class="literal">actual</tt> indicates that a method,
                    attribute, or member type refines a method, attribute, 
                    or member type defined by a supertype.</p></li><li><p><tt class="literal">variable</tt> specifies that a value 
                    may be assigned multiple times.</p></li><li><p><tt class="literal">late</tt> disables definite 
                    initialization checking for a reference, allowing the 
                    reference to be initialized after the initializer of
                    the class to which it belongs has already completed.</p></li><li><p><tt class="literal">native</tt> specifies that a program
                    element is actually implemented in a different language, 
                    and that the program element should be ignored by the
                    Ceylon compiler backend.</p></li><li><p><tt class="literal">deprecated</tt> indicates that a value, 
                    function or type is deprecated. It accepts an optional
                    <tt class="literal">String</tt> argument. The compiler produces a
                    warning when compiling code that depends upon a deprecated
                    program element.</p></li><li><p><tt class="literal">final</tt> specifies that a class may not 
                    be extended.</p></li><li><p><tt class="literal">sealed</tt> specifies that a class may not 
                    be extended or instantiated outside the module in which it is
                    defined, or that an interface may not be satisfied by a class
                    or interface outside the module in which it is defined.</p></li><li><p><tt class="literal">annotation</tt> specifies that a class is
                    an annotation type, or that a toplevel function is an annotation
                    constructor.</p></li></ul></div><i><span class="comment"><p>Note: annotation constraints ensure that these annotations 
            do not occur at program elements to which they do not apply.</p></span></i><p>The following annotation is a hint to the compiler that lets the 
            compiler optimize compiled bytecode for non-64 bit architectures:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">small</tt> specifies that a value of type
                    <tt class="literal">Integer</tt>, <tt class="literal">Integer</tt> or
                    <tt class="literal">Float</tt> contains 32-bit values.</p></li></ul></div><p>By default, <tt class="literal">Integer</tt> and <tt class="literal">Float</tt> 
            are assumed to represent 64-bit values, as specified in 
            <a href="#numericoperations" title="8.5.2.&nbsp;Numeric operations">&sect;8.5.2 Numeric operations</a>.</p><i><span class="comment"><p>Note that <tt class="literal">small</tt> is not yet supported 
            in Ceylon 1.1.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="documentation"></a>7.4.2.&nbsp;Documentation</h3></div></div><div></div></div><p>The following annotations are instructions to the documentation
            compiler:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">doc</tt> specifies the description of a 
                    program element, in Markdown format text.</p></li><li><p><tt class="literal">by</tt> specifies the authors of a program 
                    element.</p></li><li><p><tt class="literal">license</tt> specifies the URL of the
                    license under which a module or package is distributed.</p></li><li><p><tt class="literal">see</tt> specifies a related member or 
                    type.</p></li><li><p><tt class="literal">throws</tt> specifies a thrown exception
                    type.</p></li><li><p><tt class="literal">tagged</tt> specifies classifying named 
                    tags.</p></li></ul></div><p>The <tt class="literal">String</tt> arguments to the <tt class="literal">deprecated</tt>, 
            <tt class="literal">doc</tt>, <tt class="literal">throws</tt> and <tt class="literal">by</tt> 
            annotations are parsed by the documentation compiler as Markdown-format
            content.</p><p>These annotations are all defined in the package 
            <tt class="literal">ceylon.language</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="serialization"></a>7.5.&nbsp;Serialization</h2></div></div><div></div></div><i><span class="comment"><p>TODO: Define how serialization works.</p></span></i></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="execution"></a>Chapter&nbsp;8.&nbsp;Execution</h2></div></div><div></div></div><p>A Ceylon program executes in a virtual machine environment, either:</p><div class="itemizedlist"><ul type="disc"><li><p>a Java Virtual Machine (JVM), or</p></li><li><p>a JavaScript virtual machine.</p></li></ul></div><p>In future, other virtual machine architectures may be supported.</p><p>Despite the obvious differences between the respective languages that these 
    virtual machines were designed for, they share very much in common in terms of 
    runtime semantics, including common notions such as object identity, primitive 
    value types, exceptions, garbage collection, dynamic dispatch, and pass by 
    reference.</p><p>Ceylon abstracts away many of the differences between these platforms, and
    reuses what is common between them. Inevitably there are some differences that
    can't reasonably be hidden from the Ceylon program, and the programmer must take 
    these differences into consideration.</p><p>In Ceylon, every value is a reference to an instance of a class, except
    within a <tt class="literal">dynamic</tt> block, where a value with no type may be
    a reference to an object which is not an instance of a class.</p><i><span class="comment"><p>Note: the semantics of objects without classes is platform-dependent
    and outside the scope of this specification.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="objectinstancesidentity"></a>8.1.&nbsp;Object instances, identity, and reference passing</h2></div></div><div></div></div><p>An <span class="emphasis"><em>object</em></span> is a unique identifier, together with a 
        reference to a class, its type arguments, and a persistent value for each 
        reference declared by the class (including inherited references). The object 
        is said to be an <span class="emphasis"><em>instance</em></span> of the class.</p><p>A <span class="emphasis"><em>value</em></span> is a reference to an object (a copy of its 
        unique identifier). At a particular point in the execution of the program, 
        every reference of every object that exists, and every initialized reference 
        of every function, getter, setter, or initializer that is currently executing 
        has a value. Furthermore, every time an expression is executed, it produces a 
        value.</p><p>Two values are said to be <span class="emphasis"><em>identical</em></span> if they are
        references to the same object&#8212;if they hold the same unique identifier. 
        The program may determine if two values of type <tt class="literal">Identifiable</tt> 
        are identical using the <tt class="literal">===</tt> operator defined in
        <a href="#operatordefinition" title="6.8.2.&nbsp;Operator definition">&sect;6.8.2 Operator definition</a>. It may not directly obtain the unique 
        identifier (which is a purely abstract construct). The program has no way of 
        determining the identity of a value which is not of type 
        <tt class="literal">Identifiable</tt>.</p><p>Given a value, the program may determine if the referenced object is
        <span class="emphasis"><em>assignable to a certain type</em></span> using the <tt class="literal">is</tt> 
        operator. The object is assignable to the given type if the applied type formed 
        by its class and type arguments is a subtype of the given type according to the 
        type system defined in <a href="#typesystem" title="Chapter&nbsp;3.&nbsp;Type system">Chapter&nbsp;3, <i>Type system</i></a>. (Therefore, the Ceylon 
        runtime must be capable of reasoning about subtyping.)</p><p>Invocation of a function or instantiation of a class results in execution 
        of the function body or class initializer with parameter values that are copies 
        of the value produced by executing the argument expressions of the invocation, 
        and a reference to the receiving instance that is a copy of the value produced 
        by executing the receiver expression. The value produced by the invocation 
        expression is a copy of the value produced by execution of the 
        <tt class="literal">return</tt> directive expression.</p><pre data-language="ceylon">Person myself(Person me) { return me; }
Person p = ...;
assert (myself(p)===p); //assertion never fails</pre><pre data-language="ceylon">Semaphore s = Semaphore();
this.semaphore = s;
assert (semaphore===s); //assertion never fails</pre><p>A new object is produced by execution of a class instantiation expression.
        The Ceylon compiler guarantees that if execution of a class initializer terminates
        with no uncaught exception, then every reference of the object has been initialized
        with a well-defined persistent value. The value of a reference is initialized for 
        the first time by execution of a specifier or assignment expression. Every class 
        instantiation expression results in an object with a new unique identifier shared 
        by no other existing object. The object exists from the point at which execution 
        of its initializer terminates. <span class="emphasis"><em>Conceptually</em></span>, the object exists 
        until execution of the program terminates.</p><p>In practice, the object exists at least until the point at which it is not 
        reachable by recursively following references from any function, getter, setter, 
        or initializer currently being executed, or from an expression in a statement 
        currently being executed. At this point, its persistent values are no longer 
        accessible to expressions which subsequently execute and the object may be 
        destroyed by the virtual machine. There is no way for the program to determine
        that an object has been destroyed by the virtual machine (Ceylon does not support 
        finalizers).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="valuetypeoptimizations"></a>8.1.1.&nbsp;Value type optimizations</h3></div></div><div></div></div><p>As a special exception to the rules defined above, the compiler is permitted 
            to emit bytecode or compiled JavaScript that produces a new instance of certain 
            types in the module <tt class="literal">ceylon.language</tt> without execution of the 
            initializer of the class, whenever any expression is evaluated. These types are: 
            <tt class="literal">Integer</tt>, <tt class="literal">Float</tt>, <tt class="literal">Character</tt>, 
            <tt class="literal">Range</tt>, <tt class="literal">Entry</tt>, <tt class="literal">String</tt>, 
            <tt class="literal">Array</tt>, and <tt class="literal">Tuple</tt>. Furthermore, it is permitted 
            to use such a newly-produced instance as the value of the expression, as long as the 
            newly-produced instance is equal to the value expected according to the rules above, 
            as determined using the <tt class="literal">==</tt> operator.</p><p>Therefore, the types listed above directly extend <tt class="literal">Object</tt>
            instead of <tt class="literal">Basic</tt>, and are not <tt class="literal">Identifiable</tt>.</p><i><span class="comment"><p>Note: this does no justice at all to our compiler. Actually the 
            compiler infrastructure already supports value type optimization for user-defined 
            types, though we have not yet exposed this functionality as part of the language.
            </p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="reification"></a>8.1.2.&nbsp;Type argument reification</h3></div></div><div></div></div><p>Type arguments, as defined in <a href="#generictypearguments" title="3.6.&nbsp;Generic type arguments">&sect;3.6 Generic type arguments</a>, are 
            <span class="emphasis"><em>reified</em></span> in Ceylon. An instance of a generic type holds a 
            reference to each of its type arguments. Therefore, the following are possible in 
            Ceylon:</p><div class="itemizedlist"><ul type="disc"><li><p>testing the runtime value of a type argument of an instance, for 
                    example, <tt class="literal">objectList is List&lt;Person&gt;</tt> or 
                    <tt class="literal">case (is List&lt;Person&gt;)</tt>,</p></li><li><p>filtering exceptions based on type arguments, for example,
                    <tt class="literal">catch (NotFoundException&lt;Person&gt; pnfe)</tt>, and</p></li><li><p>testing the runtime value of an instance against a type parameter,
                    for example <tt class="literal">x is Key</tt>, or against a type with a type 
                    parameter as an argument, for example, 
                    <tt class="literal">objectList is List&lt;Element&gt;</tt>.</p></li><li><p>obtaining a <tt class="literal">Type</tt> object representing a type with 
                    type arguments, for example, <tt class="literal">`List&lt;Person&gt;`</tt>,</p></li><li><p>obtaining a <tt class="literal">Type</tt> object representing the runtime 
                    value of a type parameter, for example, <tt class="literal">`Element`</tt>, or of 
                    a type with a type parameter as an argument, for example, 
                    <tt class="literal">`List&lt;Element&gt;`</tt>, and</p></li><li><p>obtaining a <tt class="literal">Type</tt> object representing the
                    runtime value of a type argument of an instance using reflection, for 
                    example, <tt class="literal">type(objectList).typeArguments.first</tt>.</p></li></ul></div><p>At runtime, all types are <span class="emphasis"><em>concrete types</em></span> formed by:</p><div class="itemizedlist"><ul type="disc"><li><p>recursively replacing all type aliases, class aliases, and interface
                    aliases with their definitions, which is always possible according to 
                    <a href="#typealiaselimination" title="3.2.10.&nbsp;Type alias elimination">&sect;3.2.10 Type alias elimination</a>, and</p></li><li><p>recursively replacing all type parameters with their type arguments</p></li></ul></div><p>in any type that appears in an expression or condition.</p><p>Therefore, every type parameter refers, at runtime, to a concrete type that
            involves no type aliases or type parameters. In particular, the type arguments
            held by an instance of a generic class are concrete types.</p><p>This program prints <tt class="literal">String[]</tt>.</p><pre data-language="ceylon">class Generic&lt;out T&gt;(T t) { string=&gt;`T`.string; }
Generic&lt;{S*}&gt; gen&lt;S&gt;(S* ss) =&gt; Generic(ss);
void run() {
    print(gen("hello", "world"));
}</pre><p>The runtime is generally permitted, as an optimization, to return a more 
            precise type in place of a less precise type when a type parameter is evaluated.
            This program may print <tt class="literal">String</tt> instead of <tt class="literal">Object</tt>,
            even though <tt class="literal">Object</tt> is the type argument inferred at compile time.</p><pre data-language="ceylon">class Generic&lt;out T&gt;(T t) { string=&gt;`T`.string; }
Generic&lt;Object&gt; gen(Object o) =&gt; Generic(o);
void run() {
    print(gen("hello"));
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sequentialexecutionandclosure"></a>8.2.&nbsp;Sequential execution and closure</h2></div></div><div></div></div><p>Ceylon programs are organized into bodies, as defined in 
        <a href="#blockstructure" title="5.1.&nbsp;Block structure and references">&sect;5.1 Block structure and references</a>, containing statements which are executed 
        sequentially and have access to declarations which occur in the surrounding 
        lexical context and to persistent values held by references, as defined in 
        <a href="#references" title="4.8.1.&nbsp;References">&sect;4.8.1 References</a>, declared in the surrounding lexical context.</p><i><span class="comment"><p>Note: for the purposes of this section, an interface body is, 
        strictly speaking, a trivial case of a body which contains no statements or 
        persistent values, but we're primarily concerned with blocks and class bodies.
        </p></span></i><p>The statements and non-lazy specifiers that directly occur in a body are 
        executed sequentially in the lexical order in which they occcur. Execution of a 
        body begins at the first statement or non-lazy specifier. Execution of a block 
        terminates when the last statement or non-lazy specifier of the body finishes 
        executing, or when a control directive that terminates the block is executed, 
        or when an exception is thrown by an evaluation, assignment, invocation, or 
        instantiation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16982"></a>8.2.1.&nbsp;Frames</h3></div></div><div></div></div><p>When execution of a body begins, a <span class="emphasis"><em>frame</em></span> is created.
            For each reference whose declaration directly occurs in the body, the frame
            has a value, which may or may not be initialized. The value may be initialized
            or assigned during execution of the body.</p><p>We can visualize a frame as a list of reference declarations with optional
            values. For example, a frame with an initialized reference named 
            <tt class="literal">language</tt> and an uninitialized reference named 
            <tt class="literal">count</tt> would be written like this:</p><pre data-language="ceylon">{ String language = "ceylon"; Integer count; }</pre><p>While a body is executing, all values held in the frame are considered 
            accessible. An evaluation, assignment, invocation, or instantiation may result 
            in a pause in execution of the body while the called getter, setter, function, 
            or class is executed or instantiated. However, the frame associated with the 
            calling body is retained and values held in the frame are still considered 
            accessible. When execution of the body resumes, the frame is restored.</p><p>When execution of a body terminates, the frame may or may not become
            inaccessible. In the case of a class body, if the initializer terminates with
            no thrown exception, the frame and its values become a new instance of the 
            class, are associated with the newly created unique identifier, and remain 
            accessible while this object is itself accessible. In the case of any other 
            kind of body, or in the case that an initializer throws an exception, the 
            frame and its values may remain accessible if:</p><div class="itemizedlist"><ul type="disc"><li><p>a reference to a function or class declared within the body is 
                    accessible,</p></li><li><p>an instance of a class declared within the body is accessible, 
                    or</p></li><li><p>an instance of a comprehension declared within the body is 
                    accessible.</p></li></ul></div><p>Otherwise, the frame becomes inaccessible and may be destroyed.</p><p>The principle of <span class="emphasis"><em>closure</em></span> states that a nested body
            always has access to a frame for every containing body. The set of 
            <span class="emphasis"><em>current instances</em></span> of containing classes and 
            <span class="emphasis"><em>current frames</em></span> of containing blocks forms the closure of 
            a nested declaration.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e17027"></a>8.2.2.&nbsp;Current instances and current frames</h3></div></div><div></div></div><p>A frame may be the <span class="emphasis"><em>current frame</em></span> for a body. When the 
            body is executing, the created frame is the current frame. When execution of the 
            body terminates, the created frame is no longer the current frame. Invocation or 
            evaluation of a member of a class or interface, invocation of a callable reference
            or anonymous function, or evaluation of the values produced by a comprehension may 
            result in the frame being restored as the current frame.</p><p>A class instance, callable reference, anonymous function reference, or 
            comprehension instance packages a reference to a frame for each body containing 
            the program element, as specified below. When a member of the class instance is
            invoked or evaluated, when the callable reference or anonymous function is
            invoked, or when the comprehension instance produces a value, these frames are
            restored as the current frames of the associated bodies. When the invocation or
            evaluation terminates, or when the comprehension value has been produced, these
            frames are no longer current frames.</p><p>The value associated with a value reference in the current frame of the
            body to which the value reference belongs is called the <span class="emphasis"><em>current 
            value</em></span> of the value reference.</p><p>If a frame is the current frame for a class or interface body, we call it 
            the <span class="emphasis"><em>current instance</em></span> of the class or interface.</p><i><span class="comment"><p>TODO: in the following two sections, account for callable references,
            anonymous function references, and comprehension instances.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="currentinstanceofaclassorinterface"></a>8.2.3.&nbsp;Current instance of a class or interface</h3></div></div><div></div></div><p>If a statement is occurs directly or indirectly inside a class or interface 
            body, then there is always a current instance of the class or interface when the 
            statement is executed. The current instance is determined as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>For a statement that occurs sequentially, as defined by 
                    <a href="#blockstructure" title="5.1.&nbsp;Block structure and references">&sect;5.1 Block structure and references</a>, in the body of the class, the current 
                    instance is the new instance being initialized.</p></li><li><p>For a statement that occurs sequentially in the body of a member
                    of the class or interface, the current instance is the receiving instance 
                    of the base or member expression that resulted in a reference to the 
                    member.</p></li><li><p>For a statement that occurs sequentially in the body of a nested 
                    class or interface that occurs in the body of the class or interface, 
                    the current instance is the same object that was the current instance 
                    when the initializer of the current instance of the nested class or 
                    interface was executed.</p></li><li><p>Otherwise, for any other statement that occurs sequentially in the 
                    body of a declaration that occurs in the body of the class or interface, 
                    the current instance is the same object that was the current instance when 
                    the base member expression that resulted in a reference to the declaration 
                    was executed.</p></li></ul></div><p>Here, <tt class="literal">innerObject</tt> is the current instance of 
            <tt class="literal">Inner</tt> when <tt class="literal">member()</tt> is executed, and
            <tt class="literal">outerObject</tt> is the current instance of <tt class="literal">Outer</tt>:</p><pre data-language="ceylon">Outer outerObject = Outer();
Inner innerObject = outerObject.Inner();
innerObject.member();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="currentframeofablock"></a>8.2.4.&nbsp;Current frame of a block</h3></div></div><div></div></div><p>If a statement occurs directly or indirectly inside a block, then there 
            is always a current frame of the block when the statement is executed. The current 
            frame is determined as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>If the statement occurs sequentially, as defined by 
                    <a href="#blockstructure" title="5.1.&nbsp;Block structure and references">&sect;5.1 Block structure and references</a>, in the block, the current frame is the
                    frame associated with the current execution of the block.</p></li><li><p>For a statement that occurs sequentially in the body of a nested 
                    class or interface that occurs in the block, the current frame is the same 
                    frame that was the current frame when the initializer of the current 
                    instance of the nested class or interface was executed.</p></li><li><p>Otherwise, for any other statement that occurs sequentially inside 
                    the body of a declaration that occurs in the block, and the current frame 
                    is the frame that was the current frame when the base member expression 
                    that resulted in a reference to the declaration was executed.</p></li></ul></div><p>In each of the following code fragments, <tt class="literal">result</tt> refers 
            to the value <tt class="literal">"hello"</tt>:</p><pre data-language="ceylon">String()() outerMethod(String s) {
    String() middleMethod() {
        String innerMethod() =&gt; s;
        return innerMethod;
    }
    return middleMethod;
}

String middleMethod()() =&gt; outerMethod("hello");
String innerMethod() =&gt; middleMethod();
String result = innerMethod();</pre><pre data-language="ceylon">Object outerMethod(String s) {
    object middleObject {
        shared actual String string =&gt; s;
    }
    return middleObject;
}

Object middleObject = outerMethod("hello");
String result = middleObject.string;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="initialization"></a>8.2.5.&nbsp;Initialization</h3></div></div><div></div></div><p>When an instance is instantiated, its initializer is executed, and the
            initializer for every class it inherits is executed. For a class
            <tt class="literal">C</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>First, the initializer of <tt class="literal">Object</tt> defined in
                    <tt class="literal">ceylon.language</tt> is executed. (This initializer is
                    empty and does no work.)</p></li><li><p>For each superclass <tt class="literal">X</tt> of <tt class="literal">C</tt>, 
                    there is exactly one other superclass <tt class="literal">Y</tt> of 
                    <tt class="literal">C</tt> that directly extends <tt class="literal">X</tt>. When
                    execution of the initializer of <tt class="literal">X</tt> terminates without
                    a thrown exception, execution of the initializer of <tt class="literal">Y</tt>
                    begins.</p></li><li><p>Finally, when execution of the initializer of <tt class="literal">C</tt>
                    terminates without a thrown exception, the new instance of <tt class="literal">C</tt>
                    is fully-initialized and made accessible to the calling code.</p></li></ul></div><p>If any initializer in the class hierarchy terminates with a thrown exception,
            initialization terminates and the incompletely-initialized instance never becomes
            accessible.</p><p>Each initializer produces a frame containing initialized values for each 
            reference declared by the corresponding class. These frames are aggregated together 
            to form the new instance of the class <tt class="literal">C</tt>.</p><i><span class="comment"><p>Note: since interfaces don't have initializers, the issue of 
            "linearization" of supertypes simply never arises in Ceylon. There is a natural,
            well-defined initialization ordering.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classinstanceoptimization"></a>8.2.6.&nbsp;Class instance optimization</h3></div></div><div></div></div><p>As an exception to the above, the compiler is permitted to destroy a 
            persistent value associated with a class instance when the class initializer 
            terminates, potentially rendering inaccessible the instance identified by the 
            value, if it can determine that the persistent value will never be subsequently
            accessed by the program.</p><i><span class="comment"><p>This optimization is the only source of a distinction between a 
            "field" of a class and a "local variable" of its initializer. There is no way
            for a program to observe this distinction.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="executionofexpressionandspecificationstatements"></a>8.2.7.&nbsp;Execution of expression and specification statements</h3></div></div><div></div></div><p>When an expression statement is executed, the expression is evaluated.</p><p>When a non-lazy specification statement is executed, the specified 
            expression is evaluated, and the resulting value assigned to the specified
            reference within the current frame or current instance associated with the 
            body to which the specified reference belongs.</p><p>When a lazy specification statement is executed, the specified
            expression is associated with the specified reference within the current 
            frame or current instance associated with the body to which the specified
            reference belongs. Subsequent evaluation or invocation of the reference
            for this current frame or current instance may result in evaluation of the 
            specified expression, in which case the expression is evaluated within this 
            current frame or current instance.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="executionofcontroldirectives"></a>8.2.8.&nbsp;Execution of control directives</h3></div></div><div></div></div><p>Execution of a control directive, as specified in 
            <a href="#controldirectives" title="5.2.2.&nbsp;Control directives">&sect;5.2.2 Control directives</a>, terminates execution of the body in which it 
            occurs, and possibly of other containing bodies.</p><div class="itemizedlist"><ul type="disc"><li><p>A <tt class="literal">return</tt> directive that occurs sequentially in
                    the body of a function, getter, setter, or class initializer terminates
                    execution of the body of the function, getter, setter, or class initializer 
                    and of all intervening bodies. Optionally, it determines the return value of
                    the function or getter.</p></li><li><p>A <tt class="literal">break</tt> directive terminates execution of the
                    body of the most nested containing loop in which it occurs sequentially,
                    and of all intervening bodies. Additionally, it terminates execution of
                    the loop.</p></li><li><p>A <tt class="literal">continue</tt> directive terminates execution of the
                    body of the most nested containing loop in which it occurs sequentially,
                    and of all intervening bodies. It does not terminate execution of the 
                    loop.</p></li><li><p>A <tt class="literal">throw</tt> directive that occurs sequentially in
                    the body of a function, getter, setter, or class initializer terminates
                    execution of the body of the function, getter, setter, or class 
                    initializer and of all intervening bodies, and, furthermore, the exception 
                    propagates to the caller, as defined below, unless there is an intervening 
                    <tt class="literal">try</tt> with a <tt class="literal">catch</tt> clause matching the 
                    thrown exception, in which case it terminates execution of the body of the 
                    <tt class="literal">try</tt> statement and all intervening bodies, and execution 
                    continues from the body of the <tt class="literal">catch</tt> clause.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="exceptionpropagation"></a>8.2.9.&nbsp;Exception propagation</h3></div></div><div></div></div><p>If execution of an evaluation, assignment, invocation, or instantiation
            terminates with an exception thrown, the exception propagates to the calling 
            code, and terminates execution of the body of the function, getter, setter, or 
            class initializer in which the expression involving the evaluation, assignment, 
            invocation, or instantiation sequentially occurs, and of all intervening bodies, 
            and, furthermore, the exception propagates to the caller unless there is an 
            intervening <tt class="literal">try</tt> with a <tt class="literal">catch</tt> clause 
            matching the thrown exception, in which case it terminates execution of the body 
            of the <tt class="literal">try</tt> statement and all intervening bodies, and execution 
            continues from the body of the <tt class="literal">catch</tt> clause.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="toplevelinitialization"></a>8.2.10.&nbsp;Initialization of toplevel references</h3></div></div><div></div></div><p>A toplevel reference has no associated frame. Instead, the lifecycle of 
            its persistent value is associated with the loading and unloading of a module 
            by the module runtime. The first time a toplevel reference is accessed 
            following the loading of its containing module, its initializer expression is 
            evaluated, and the resulting value is associated with the reference. This 
            association survives until the toplevel reference is reassigned, or until the 
            module is unloaded by the module runtime.</p><p>Initialization of a toplevel reference may result in recursive 
            initialization of other toplevel references. Therefore, it is possible that
            a cycle could occur where evaluation of a toplevel reference occurs while
            evaluating its initializer expression. When this occurs, an 
            <tt class="literal">InitializationError</tt> is thrown.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e17267"></a>8.2.11.&nbsp;Initialization of late references</h3></div></div><div></div></div><p>A reference annotated <tt class="literal">late</tt> may be uninitialized in a 
            given frame. The rules of the language do not guarantee that an uninitialized 
            <tt class="literal">late</tt> reference is never evaluated at runtime. If a
            <tt class="literal">late</tt> reference which is uninitialized in the current frame 
            or current instance is evaluated, an <tt class="literal">InitializationError</tt>
            is thrown.</p><p>Lifewise, if a non-<tt class="literal">variable</tt> <tt class="literal">late</tt> 
            reference which is already initialized in the current frame or current instance
            is assigned, an <tt class="literal">InitializationError</tt> is thrown.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="executionofcontrolstructures"></a>8.3.&nbsp;Execution of control structures and assertions</h2></div></div><div></div></div><p>Control structures, as specified in <a href="#controlstructures" title="5.3.&nbsp;Control structures and assertions">&sect;5.3 Control structures and assertions</a>, are 
        used to organize conditional and repetitive code within a body. Assertions are 
        essentially a sophisticated sort of control directive, but for convenience are 
        categorized together with control structures.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="evaluationofconditions"></a>8.3.1.&nbsp;Evaluation of condition lists</h3></div></div><div></div></div><p>Execution of an <tt class="literal">if</tt>, <tt class="literal">while</tt>, or
            <tt class="literal">assert</tt> requires evaluation of a condition list, as defined
            in <a href="#controlstructureconditions" title="5.3.3.&nbsp;Control structure conditions">&sect;5.3.3 Control structure conditions</a>.</p><p>To determine if a condition list is satisfied, its constituent conditions 
            are evaluated in the lexical order in which they occur in the condition list. 
            If any condition is not satisfied, none of the subsequent conditions in the list 
            are evaluated.</p><div class="itemizedlist"><ul type="disc"><li><p>A boolean condition is satisfied if its expression evaluates to 
                    <tt class="literal">true</tt> when the condition is evaluated.</p></li></ul></div><p>For any other kind of condition, the condition is satisfied if its value 
             reference or expression evaluates to an instance of the required type when the 
             condition is evaluated:</p><div class="itemizedlist"><ul type="disc"><li><p>for an assignability condition, the condition is satisfied if the 
                     expression evaluates to an instance of the specified type when the control 
                     structure is executed,</p></li><li><p>for an existence condition, the condition is satisfied unless the 
                     expression evaluates to <tt class="literal">null</tt> when the control structure 
                     is executed, or</p></li><li><p>for a nonemptiness expression, the condition is satisfied unless the 
                     expression evaluates to an instance of <tt class="literal">[]|Null</tt> when the 
                     control structure is executed.</p></li></ul></div><p>A condition list is satisfied if and only if all of its constituent conditions 
             are satisfied.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationofassertions"></a>8.3.2.&nbsp;Validation of assertions</h3></div></div><div></div></div><p>When an assertion, as specified in <a href="#assertions" title="5.3.11.&nbsp;Assertions">&sect;5.3.11 Assertions</a>, is 
            executed, its condition list is evaluated. If the condition list is not satisfied, 
            an exception of type <tt class="literal">AssertionError</tt> in 
            <tt class="literal">ceylon.language</tt> is thrown.</p><p>The information carried by the <tt class="literal">AssertionError</tt> includes:</p><div class="itemizedlist"><ul type="disc"><li><p>the text of the Ceylon code of the condition that failed,</p></li><li><p>the message specified by the <tt class="literal">doc</tt> annotation of the
                    assertion, if any.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="executionofconditionals"></a>8.3.3.&nbsp;Execution of conditionals</h3></div></div><div></div></div><p>The <tt class="literal">if/else</tt> and <tt class="literal">switch/case/else</tt> 
            constructs control conditional execution.</p><p>When the <tt class="literal">if/else</tt> construct, specified in 
            <a href="#ifelse" title="5.3.6.&nbsp;if/else">&sect;5.3.6 if/else</a>, is executed, its condition list is evaluated. If the 
            condition list is satisfied, the <tt class="literal">if</tt> block is executed. 
            Otherwise, the <tt class="literal">else</tt> block, if any, is executed, or, if the 
            construct has an <tt class="literal">else if</tt>, the child <tt class="literal">if</tt>
            construct is executed.</p><p>When a <tt class="literal">switch/case/else</tt> construct, specified in 
            <a href="#switchcaseelse" title="5.3.7.&nbsp;switch/case/else">&sect;5.3.7 switch/case/else</a>, is executed, its <tt class="literal">switch</tt> 
            expression is evaluated to produce a value. The value is guaranteed to 
            <span class="emphasis"><em>match</em></span> at most one <tt class="literal">case</tt> of the 
            <tt class="literal">switch</tt>. If it matches a certain case, then that 
            <tt class="literal">case</tt> block is executed. Otherwise, <tt class="literal">switch</tt> 
            is guaranteed to have an <tt class="literal">else</tt>, and so the 
            <tt class="literal">else</tt> block is executed.</p><p>The value produced by the <tt class="literal">switch</tt> expression matches
            a case if either:</p><div class="itemizedlist"><ul type="disc"><li><p>the case is a list of literal values and value references the 
                    value is identical to one of the value references in the list or 
                    equal to one of the literal values in the list, or if</p></li><li><p>the case is an assignability condition of form 
                    <tt class="literal">case (is V)</tt> and the value is an instance of
                    <tt class="literal">V</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="executionofloops"></a>8.3.4.&nbsp;Execution of loops</h3></div></div><div></div></div><p>The <tt class="literal">for/else</tt> and <tt class="literal">while</tt> loops control
            repeated execution.</p><p>When a <tt class="literal">while</tt> construct, specified in <a href="#while" title="5.3.9.&nbsp;while">&sect;5.3.9 while</a>, 
            is executed, the loop condition list is evaluated repeatedly until the first time 
            the condition list is not satisfied, or until a <tt class="literal">break</tt>, 
            <tt class="literal">return</tt>, or <tt class="literal">throw</tt> directive that terminates the
            loop is executed. Each time the condition is satisfied, the <tt class="literal">while</tt> 
            block is executed.</p><p>When a <tt class="literal">for/else</tt> construct, specified in <a href="#forelse" title="5.3.8.&nbsp;for/else">&sect;5.3.8 for/else</a>, 
            is executed:</p><div class="itemizedlist"><ul type="disc"><li><p>the iterated expression is evaluated to produce an an instance of
                    <tt class="literal">Iterable</tt>,</p></li><li><p>an <tt class="literal">Iterator</tt> is obtained by calling 
                    <tt class="literal">iterator()</tt> on the iterable object, and then</p></li><li><p>the <tt class="literal">for</tt> block is executed once for each value 
                    of produced by repeatedly invoking the <tt class="literal">next()</tt> method 
                    of the iterator, until the iterator produces the value <tt class="literal">finished</tt>, 
                    or until a <tt class="literal">break</tt>, <tt class="literal">return</tt>, or 
                    <tt class="literal">throw</tt> directive that terminates the loop is executed.</p></li></ul></div><p>Note that:</p><div class="itemizedlist"><ul type="disc"><li><p>if the iterated expression is also of type <tt class="literal">X[]</tt>,
                    the compiler is permitted to optimize away the use of <tt class="literal">Iterator</tt>, 
                    instead using indexed element access.</p></li><li><p>if the iterated expression is a range constructor expression, the 
                    compiler is permitted to optimize away creation of the <tt class="literal">Range</tt>, 
                    and generate the indices using the <tt class="literal">successor</tt> operation.</p></li></ul></div><p>We say that the loop <span class="emphasis"><em>exits early</em></span> if it ends via execution 
            of a <tt class="literal">break</tt>, <tt class="literal">return</tt>, or <tt class="literal">throw</tt>
            directive. Otherwise, we say that the loop <span class="emphasis"><em>completes</em></span> normally.</p><p>If the loop completes normally, the <tt class="literal">else</tt> block is executed. 
            Otherwise, if the loop exits early, the <tt class="literal">else</tt> block is not executed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="exceptionhandling"></a>8.3.5.&nbsp;Exception handling</h3></div></div><div></div></div><p>When a <tt class="literal">try/catch/finally</tt> construct, specified in 
             <a href="#trycatchfinally" title="5.3.10.&nbsp;try/catch/finally">&sect;5.3.10 try/catch/finally</a>, is executed:</p><div class="itemizedlist"><ul type="disc"><li><p>the resource expressions, if any, are evaluated in the order
                     they occur, and then <tt class="literal">obtain()</tt> is called on each 
                     resulting resource instance of type <tt class="literal">Obtainable</tt>, 
                     in the same order, then</p></li><li><p>the <tt class="literal">try</tt> block is executed, then</p></li><li><p><tt class="literal">destroy()</tt> is called on each resource instance
                     of type <tt class="literal">Destroyable</tt>, and <tt class="literal">release()</tt> 
                     is called on each resource instance of type <tt class="literal">Obtainable</tt>, 
                     if any, in the reverse order that the resource expressions occur, 
                     passing the exception that propagated out of the <tt class="literal">try</tt> 
                     block, if any, then</p></li><li><p>if an exception did propagate out of the <tt class="literal">try</tt> 
                     block, the first <tt class="literal">catch</tt> block with a variable 
                     to which the exception is assignable, if any, is executed, and 
                     then</p></li><li><p>the <tt class="literal">finally</tt> block, if any, is executed, 
                     even in the case where an exception propagates out of the whole
                     construct.</p></li></ul></div><i><span class="comment"><p>TODO: Specify what happens if <tt class="literal">close()</tt> 
             throws an exception. (Same semantics as Java with "suppressed" exceptions.)</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamictypechecking"></a>8.3.6.&nbsp;Dynamic type checking</h3></div></div><div></div></div><p>Inside a <tt class="literal">dynamic</tt> block, a situation might occur that 
            requires dynamic type checking, as specified in <a href="#dynamicblocks" title="5.3.12.&nbsp;Dynamic blocks">&sect;5.3.12 Dynamic blocks</a>. 
            It is possible that:</p><div class="itemizedlist"><ul type="disc"><li><p>the value to which an expression with no type evaluates at 
                    execution time might not be an instance of the type required where 
                    the expression occurs,</p></li><li><p>in particular, the value to which a <tt class="literal">switch</tt> 
                    expression with no type evaluates at execution time might be an 
                    instance of a type not covered by the <tt class="literal">case</tt>s of
                    a <tt class="literal">switch</tt> with no <tt class="literal">else</tt>, or</p></li><li><p>a qualified or unqualified reference which does not refer to 
                    a statically typed declaration might not resolve to any declaration
                    at all.</p></li></ul></div><p>Whenever such a condition is encountered at runtime, an 
            <tt class="literal">AssertionError</tt> is immediately thrown.</p><i><span class="comment"><p>Note: in Ceylon 1.0, dynamic type checking is only supported
            on JavaScript virtual machines.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="evaluationinvocationandassignment"></a>8.4.&nbsp;Evaluation, invocation, and assignment</h2></div></div><div></div></div><p>Evaluation of an expression may result in:</p><div class="itemizedlist"><ul type="disc"><li><p>invocation of a function or instantiation of a class,</p></li><li><p>evaluation of a value,</p></li><li><p>instantiation of an instance of <tt class="literal">Callable</tt> 
            that packages a callable reference, or</p></li><li><p>assignment to a variable value.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicdispatch"></a>8.4.1.&nbsp;Dynamic dispatch</h3></div></div><div></div></div><p><span class="emphasis"><em>Dynamic dispatch</em></span> is the process of determing
            at runtime a member declaration based upon the runtime type of an object,
            which, as a result of subtype polymorphism, may be different to its static 
            type known at compile time.</p><p>Any concrete class is guaranteed to have exactly one declaration of
            a member, either declared or inherited by the class, which refines all other 
            declarations of the member declared or inherited by the class. At runtime,
            this member is selected.</p><p>There is one exception to this rule: member expressions where the 
            receiver expression is of form <tt class="literal">super</tt> or
            <tt class="literal">(super of Type)</tt>, as defined in <a href="#super" title="6.3.3.&nbsp;super">&sect;6.3.3 super</a>,
            are dispatched based on the static type of the receiver expression:</p><div class="itemizedlist"><ul type="disc"><li><p>Any invocation of a member of <tt class="literal">super</tt> is 
                    processed by the member defined or inherited by the supertype, 
                    bypassing any member declaration that refines this member 
                    declaration.</p></li><li><p>Any invocation of a member of an expression of form 
                    <tt class="literal">(super of Type)</tt> is processed by the member 
                    defined or inherited by <tt class="literal">Type</tt>, bypassing any 
                    member declaration that refines this member declaration.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="evaluation"></a>8.4.2.&nbsp;Evaluation</h3></div></div><div></div></div><p>Evaluation of a value reference, as defined in <a href="#valuereferences" title="6.5.3.&nbsp;Value references">&sect;6.5.3 Value references</a>, 
            produces its current value. Evaluation of a callable reference, as defined in
            <a href="#callablereferences" title="6.5.4.&nbsp;Callable references">&sect;6.5.4 Callable references</a>, that does not occur as the primary of a 
            direct invocation results in a new instance of <tt class="literal">Callable</tt> that 
            packages the callable reference.</p><pre data-language="ceylon">person.name</pre><pre data-language="ceylon">'/'.equals</pre><p>When a value reference expression is executed:</p><div class="itemizedlist"><ul type="disc"><li><p>first, the receiver expression, if any, is evaluated to obtain a 
                    receiving instance for the evaluation, then</p></li><li><p>the actual declaration to be invoked is determined by considering 
                    the runtime type of the receiving instance, if any, and then</p></li><li><p>if the declaration is a reference, its persistent value is retrieved
                    from the receiving instance, or</p></li><li><p>otherwise, execution of the calling body pauses while the body 
                    of its getter is executed by the receiving instance, then,</p></li><li><p>finally, when execution of the getter ends, execution of the 
                    calling body resumes.</p></li></ul></div><p>The resulting value is the persistent value retrieved, or the return value 
            of the getter, as specified by the <tt class="literal">return</tt> directive.</p><p>When a callable reference expression that does not occur as the primary of
            a direct invocation expression is executed:</p><div class="itemizedlist"><ul type="disc"><li><p>first, the receiver expression, if any, is evaluated to obtain a 
                    receiving instance for the evaluation, then</p></li><li><p>the receiving instance, a reference to the declaration to be
                    invoked, or a reference to the current frame or instance of every body 
                    that contains the referenced declaration are packaged together into an 
                    instance of <tt class="literal">Callable</tt>.</p></li></ul></div><p>The resulting value is the instance of <tt class="literal">Callable</tt>. The 
            concrete class of this instance is not specified here.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assignment"></a>8.4.3.&nbsp;Assignment</h3></div></div><div></div></div><p>Given a value reference, as defined in <a href="#valuereferences" title="6.5.3.&nbsp;Value references">&sect;6.5.3 Value references</a>, 
            to a variable, the assignment operator <tt class="literal">=</tt> assigns it a new 
            value.</p><pre data-language="ceylon">person.name = "Gavin"</pre><p>When an assignment expression is executed:</p><div class="itemizedlist"><ul type="disc"><li><p>first, the receiver expression of the value reference expression 
                    is executed to obtain the receiving instance, then</p></li><li><p>the actual declaration to be assigned is determined by considering 
                    the runtime type of the receiving instance, and then</p></li><li><p>if the member is a reference, its persistent value is updated in 
                    the receiving instance, or</p></li><li><p>otherwise, execution of the calling body pauses while the body 
                    of its setter is executed by the receiving instance with the assigned 
                    value, then,</p></li><li><p>finally, when execution of the setter ends, execution of the calling 
                    body resumes.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="invocation"></a>8.4.4.&nbsp;Invocation</h3></div></div><div></div></div><p>Evaluation of an invocation expression, as defined in 
            <a href="#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>, results in <span class="emphasis"><em>invocation</em></span>
            of a function, or <span class="emphasis"><em>instantiation</em></span> of a class. Every invocation 
            has a callable expression:</p><div class="itemizedlist"><ul type="disc"><li><p>in a direct invocation, the callable expression is a callable 
                    reference, and</p></li><li><p>in an indirect invocation, the callable expression is an instance of
                    <tt class="literal">Callable</tt> that packages an underlying callable reference.</p></li></ul></div><p>In either case, the callable expression determines the instance and member 
            to be invoked.</p><pre data-language="ceylon">print("Hello world!")</pre><pre data-language="ceylon">Entry(person.name, person)</pre><p>When an invocation expression is executed:</p><div class="itemizedlist"><ul type="disc"><li><p>first, the callable expression is evaluated to obtain the receiving
                    instance, then</p></li><li><p>each listed argument or spread argument is evaluated in turn in the 
                    calling body, and</p></li><li><p>if the argument list has a comprehension, a comprehension instance, 
                    as defined in <a href="#comprehensionevaluation" title="8.6.&nbsp;Evaluation of comprehensions">&sect;8.6 Evaluation of comprehensions</a>, is obtained, 
                    and then</p></li><li><p>the actual declaration to be invoked is determined by considering the 
                    runtime type of the receiving instance, if any, and then</p></li><li><p>execution of the calling body pauses while the body of the function 
                    or initializer is executed by the receiving instance with the argument values, 
                    then</p></li><li><p>finally, when execution of the function or initializer ends, execution 
                    of the calling body resumes.</p></li></ul></div><p>A function invocation evaluates to the return value of the function, as specified 
            by the <tt class="literal">return</tt> directive. The argument values are passed to the 
            parameters of the method, and the body of the method is executed.</p><p>A class instantiation evaluates to a new instance of the class. The argument 
            values are passed to the initializer parameters of the class, and the initializer
            is executed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="anonymousfunctionevaluation"></a>8.4.5.&nbsp;Evaluation of anonymous functions</h3></div></div><div></div></div><p>When an anonymous function expression, as defined in 
            <a href="#anonymousfunctions" title="6.4.&nbsp;Anonymous functions">&sect;6.4 Anonymous functions</a>, is evaluated, a reference to the function and a
            reference to the current frame or instance of every containing body are packaged into an 
            instance of <tt class="literal">Callable</tt>. The instance of <tt class="literal">Callable</tt> is
            the resulting value of the expression. The concrete class of this instance is not 
            specified here.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="enumerationevaluation"></a>8.4.6.&nbsp;Evaluation of enumerations</h3></div></div><div></div></div><p>Evaluation of an enumeration expression, as defined in 
            <a href="#enumeration" title="6.6.12.&nbsp;Iterable and tuple enumeration">&sect;6.6.12 Iterable and tuple enumeration</a>, results in creation of an iterable stream or 
            tuple.</p><pre data-language="ceylon">{ "hello", "world" }</pre><pre data-language="ceylon">[ new, *elements ]</pre><p>When an iterable enumeration expression is executed, a reference to the
            enumeration expression, together with a reference to the current frame or 
            instance of every containing body, together with a comprehension instance, 
            as defined in <a href="#comprehensionevaluation" title="8.6.&nbsp;Evaluation of comprehensions">&sect;8.6 Evaluation of comprehensions</a>, in the case that the 
            enumeration expression has a comprehension, are packaged together into a stream. 
            Evaluation of an expression occurring in the enumeration expression occurs in 
            the context of the packaged framed associated with the stream. When the stream 
            is iterated, it produces, in turn:</p><div class="itemizedlist"><ul type="disc"><li><p>one value for each listed argument, by evaluating the listed
                    argument expression, and then</p></li><li><p>if the argument list has a spread argument, each value produced 
                    by the spread argument, or</p></li><li><p>if the argument list has a comprehension, each value produced 
                    by the comprehension instance, or</p></li><li><p>if there are no arguments, and no comprehension, the 
                    stream is empty and produces no values.</p></li></ul></div><p>When a tuple enumeration expression is executed:</p><div class="itemizedlist"><ul type="disc"><li><p>first, each listed argument or spread argument is evaluated in 
                    turn in the calling body, and</p></li><li><p>if the argument list has a comprehension, a comprehension instance, 
                    as defined in <a href="#comprehensionevaluation" title="8.6.&nbsp;Evaluation of comprehensions">&sect;8.6 Evaluation of comprehensions</a>, is obtained, 
                    and then</p></li><li><p>the resulting argument values are packaged into an instance of 
                    <tt class="literal">Iterable</tt> or <tt class="literal">Sequence</tt>, and this 
                    object is the resulting value of the enumeration expression, unless</p></li><li><p>there are no  arguments, and no comprehension, in which case 
                    the resulting value of the enumeration expression is the object 
                    <tt class="literal">empty</tt>.</p></li></ul></div><p>In the case of an iterable enumeration, the concrete class of the resulting
            value is not specified here. In the case of a tuple enumeration it is always
            <tt class="literal">Tuple</tt>, <tt class="literal">Empty</tt>, or <tt class="literal">Sequence</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spreadevaluation"></a>8.4.7.&nbsp;Evaluation of spread arguments and comprehensions</h3></div></div><div></div></div><p>A spread argument, as defined in <a href="#spreadarguments" title="6.6.5.&nbsp;Spread arguments">&sect;6.6.5 Spread arguments</a>, produces 
            multiple values by iterating the iterable object to which the spread operator 
            is applied.</p><p>When a spread argument expression type is a subtype of <tt class="literal">Sequential</tt>,
            the behavior does not depend upon where the spread argument occurs:</p><div class="itemizedlist"><ul type="disc"><li><p>If it occurs as an argument, the sequence produced by evaluating 
                    the expression is passed directly to the parameter.</p></li><li><p>If it occurs in an enumeration expression, the sequence produced 
                    by evaluating the expression is appended directly to the resulting
                    iterable object or tuple.</p></li></ul></div><p>On the other hand, when a spread argument expression type is not a subtype of 
            <tt class="literal">Sequential</tt>, the behavior depends upon where the spread argument
            occurs:</p><div class="itemizedlist"><ul type="disc"><li><p>If it occurs as an argument to a variadic parameter in a positional
                    argument list, the values produced by a spread argument are evaluated 
                    immediately and packaged into an instance of <tt class="literal">Sequence</tt>
                    and passed to the variadic parameter, unless there are no values, in 
                    which case the object <tt class="literal">empty</tt> is passed to the variadic 
                    parameter.</p></li><li><p>If it occurs as an argument to a parameter of type 
                    <tt class="literal">Iterable</tt> at the end of a named argument list, the
                    iterable object produced by evaluating the expression is passed directly 
                    to the parameter.</p></li><li><p>If it occurs in a tuple enumeration, the values produced by a 
                    spread argument are evaluated immediately and packaged into an instance 
                    of <tt class="literal">Sequence</tt> and appended to the resulting tuple.</p></li><li><p>If it occurs in an iterable enumeration, the iterable object 
                    produced by evaluating the expression is chained directly to the 
                    resulting iterable object.</p></li></ul></div><p>Likewise, a comprehension, as defined in <a href="#comprehensions" title="6.6.6.&nbsp;Comprehensions">&sect;6.6.6 Comprehensions</a>, 
            produces multiple values, as specified by <a href="#comprehensionevaluation" title="8.6.&nbsp;Evaluation of comprehensions">&sect;8.6 Evaluation of comprehensions</a>. 
            The behavior depends upon where the comprehension occurs:</p><div class="itemizedlist"><ul type="disc"><li><p>If it occurs as an argument to a variadic parameter in a positional
                    argument list, the values produced by the comprehension instance are 
                    evaluated immediately, packaged into an instance of <tt class="literal">Sequence</tt>,
                    and passed to the variadic parameter, unless there are no values, in 
                    which case the object <tt class="literal">empty</tt> is passed to the variadic 
                    parameter.</p></li><li><p>If it occurs as an argument to a parameter of type 
                    <tt class="literal">Iterable</tt> at the end of a named argument list, the 
                    comprehension instance is packaged into an iterable object that produces 
                    the values of the comprehension on demand, and this iterable object is 
                    passed directly to the parameter. The concrete class of this object is 
                    not specified here.</p></li><li><p>If it occurs in a tuple enumeration, the values produced by the 
                    comprehension instance are evaluated immediately, packaged into an instance 
                    of <tt class="literal">Sequence</tt>, and appended to the resulting tuple.</p></li><li><p>If it occurs in an iterable enumeration, the comprehension instance
                    is packaged into an iterable object that produces the values of the 
                    comprehension on demand, and this iterable object is chained directly to 
                    the resulting iterable object. The concrete class of this object is not 
                    specified here.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="operatorexpressions"></a>8.5.&nbsp;Operator expressions</h2></div></div><div></div></div><p>Most operator expression are defined in terms of function invocation, value 
        evaluation, or a combination of invocations and evaluations, as specified in
        <a href="#operators" title="6.8.&nbsp;Operators">&sect;6.8 Operators</a>. The semantics of evaluation of an operator expression 
        therefore follows from the above definitions of evaluation and invocation and from 
        its definition in terms of evaluation and invocation.</p><p>However, this specification allows the compiler to take advantage of the
        optimized support for primitive value types provided by the virtual machine
        environment.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="operatorexpressionoptimization"></a>8.5.1.&nbsp;Operator expression optimization</h3></div></div><div></div></div><p>As a special exception to the rules, the compiler is permitted to optimize 
            certain operations upon certain types in the module <tt class="literal">ceylon.language</tt>. 
            These types are: <tt class="literal">Integer</tt>, <tt class="literal">Float</tt>, 
            <tt class="literal">Character</tt>, <tt class="literal">Range</tt>, <tt class="literal">Entry</tt>, 
            <tt class="literal">String</tt>, <tt class="literal">Array</tt>, and <tt class="literal">Tuple</tt>.</p><p>Thus, the tables in the previous chapter define semantics only. The compiler 
            may emit bytecode or compiled JavaScript that produces the same value at runtime as 
            the pseudo-code that defines the operator, without actually executing any invocation, 
            for the following operators:</p><div class="itemizedlist"><ul type="disc"><li><p>all arithmetic operators,</p></li><li><p>the comparison and equality operators <tt class="literal">==</tt>,
                    <tt class="literal">!=</tt>, <tt class="literal">&lt;=&gt;</tt>, <tt class="literal">&lt;</tt>,
                    <tt class="literal">&gt;</tt>, <tt class="literal">&lt;=</tt>, <tt class="literal">&gt;=</tt>
                    when the argument expression types are built-in numeric types, and</p></li><li><p>the <tt class="literal">Range</tt> and <tt class="literal">Entry</tt> construction 
                    operators <tt class="literal">..</tt>, <tt class="literal">:</tt>, and 
                    <tt class="literal">-&gt;</tt>.</p></li></ul></div><p>In all operator expressions, the arguments of the operator must be evaluated 
            from left to right when the expression is executed. In certain cases, depending upon 
            the definition of the operator, evaluation of the leftmost argument expression results 
            in a value that causes the final value of the operator expression to be produced 
            immediately without evaluation of the remaining argument expressions. Optimizations 
            performed by the Ceylon compiler must not alter these behaviours.</p><i><span class="comment"><p>Note: this restriction exists to ensure that any effects are not 
            changed by the optimizations.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="numericoperations"></a>8.5.2.&nbsp;Numeric operations</h3></div></div><div></div></div><p>The arithmetic operations defined in <a href="#arithmetic" title="6.8.10.&nbsp;Arithmetic operators">&sect;6.8.10 Arithmetic operators</a> for
            values of type <tt class="literal">Integer</tt> and <tt class="literal">Float</tt> are
            defined in terms of methods of the interface <tt class="literal">Numeric</tt>. 
            However, these methods themselves make use of the native operations of the 
            underlying virtual machine. Likewise, values of type <tt class="literal">Integer</tt> 
            and <tt class="literal">Float</tt> are actually represented in terms of a format 
            native to the virtual machine.</p><p>It follows that the precise behavior of numeric operations depends 
            upon the virtual machine upon which the program executes. However, certain 
            behaviours are common to supported virtual machines:</p><div class="itemizedlist"><ul type="disc"><li><p>Values of type <tt class="literal">Float</tt> are represented 
                    according to the IEEE 754 specification, <span class="emphasis"><em>IEEE Standard 
                    for Binary Floating-Point Arithmetic</em></span>, and floating point
                    numeric operations conform to this specification. Where possible,
                    a double-precision 64-bit representation is used. It is possible on 
                    both Java and JavaScript virtual machines.</p></li><li><p>Where possible, values of type <tt class="literal">Integer</tt> are 
                    represented in two's complement form using a fixed bit length. Where 
                    possible, a 64-bit representation is used. Overflow and underflow 
                    wrap silently. This is the case for the Java Virtual Machine.</p></li><li><p>Otherwise, values of type <tt class="literal">Integer</tt> are 
                    represented according to the IEEE 754 specification. This is the 
                    case for JavaScript virtual machines.</p></li></ul></div><p>Platform-dependent behavior of numeric operations is defined in the
            Java Language Specification, and the ECMAScript Language Specification.</p><i><span class="comment"><p>It might be argued that having platform-dependent behavior 
            for numeric operations opens up the same portability concerns that affected
            languages like C in the past. However, the cross-platform virtual machines
            supported by Ceylon already provide a layer of indirection that substantially
            eases portability concerns. Of course, numeric code is not guaranteed to be
            completely portable between the Java and JavaScript virtual machines, but
            it's difficult to imagine how such a level of portability could reasonably 
            be achieved.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="comprehensionevaluation"></a>8.6.&nbsp;Evaluation of comprehensions</h2></div></div><div></div></div><p>When a comprehension, as specified in <a href="#comprehensions" title="6.6.6.&nbsp;Comprehensions">&sect;6.6.6 Comprehensions</a>, 
        is evaluated, a reference to the comprehension, together with a reference to 
        the current frame or instance of every containing body, are packaged together 
        into a <span class="emphasis"><em>comprehension instance</em></span>. A comprehension instance 
        is not considered a value in the sense of <a href="#objectinstancesidentity" title="8.1.&nbsp;Object instances, identity, and reference passing">&sect;8.1 Object instances, identity, and reference passing</a>. 
        Instead, it is a stream of values, each produced by evaluating the expression 
        clause of the comprehension.</p><p>A comprehension consists of a series of clauses. Each clause of a 
        comprehension, except for the expression clause that terminates the list of 
        clauses, produces a stream of <span class="emphasis"><em>frames</em></span>. A frame is a set 
        of values for iteration variables and condition variables declared by the 
        clause and its parent clauses.</p><i><span class="comment"><p>Note: each child clause can be viewed as a body nested inside 
        the parent clause. The lifecycle of comprehension frames reflects this model.
        </p></span></i><p>Evaluation of an expression occurring in a comprehension clause occurs
        in the context of the packaged frames associated with the comprehension
        instance together with a comprehension frame associated with the clause.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="forclause"></a>8.6.1.&nbsp;<tt class="literal">for</tt> clause</h3></div></div><div></div></div><p>The expression which produces the source stream for a child 
            <tt class="literal">for</tt> clause may refer to an iteration variable of a
            parent <tt class="literal">for</tt> clause. In this case the child clause is 
            considered <span class="emphasis"><em>correlated</em></span>. Otherwise it is considered 
            <span class="emphasis"><em>uncorrelated</em></span>.</p><p>In either case, the child clause produces a stream of frames. 
            For each frame produced by the parent clause, and for each value
            produced by the source stream of the child clause, the child clause
            produces a frame consisting of the parent clause frame extended
            by the iteration variable value defined by the child clause.</p><p>This comprehension has a correlated <tt class="literal">for</tt> clause. 
            For each character <tt class="literal">c</tt> in each string <tt class="literal">w</tt> 
            in <tt class="literal">words</tt>, the child <tt class="literal">for</tt> clause 
            produces the frame <tt class="literal">{ String word=w; Character char=c; }</tt>.</p><pre data-language="ceylon">for (word in words) for (char in word) char</pre><p>This comprehension has an uncorrelated <tt class="literal">for</tt> clause. 
            For each string <tt class="literal">n</tt> in <tt class="literal">nouns</tt>, and each 
            string <tt class="literal">a</tt> in <tt class="literal">adjectives</tt>, the child 
            <tt class="literal">for</tt> clause produces the frame 
            <tt class="literal">{ String noun=n; String adj=a; }</tt>.</p><pre data-language="ceylon">for (noun in nouns) for (adj in adjectives) adj + " " + noun</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ifclause"></a>8.6.2.&nbsp;<tt class="literal">if</tt> clause</h3></div></div><div></div></div><p>A child <tt class="literal">if</tt> clause filters its parent clause frames. 
            For every frame produced by the parent clause which satisfies the condition 
            list of the child clause, the child clause produces that frame, extended by 
            any condition variable defined by the child clause.</p><p>This comprehension has an <tt class="literal">if</tt> clause. For
            each object <tt class="literal">o</tt> in <tt class="literal">objects</tt> that
            is a nonempty <tt class="literal">String</tt>, the <tt class="literal">if</tt> clause 
            produces the frame <tt class="literal">{ Object obj=o; String str=o; }</tt>.</p><pre data-language="ceylon">for (obj in objects) if (is String str=obj, !str.empty) str</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="expressionclause"></a>8.6.3.&nbsp;Expression clause</h3></div></div><div></div></div><p>As specified in <a href="#comprehensions" title="6.6.6.&nbsp;Comprehensions">&sect;6.6.6 Comprehensions</a>, every comprehension ends 
            in an expression clause. An expression clause produces a single value for each 
            frame produced by its parent clause, by evaluating the expression in the frame. 
            These resulting values are the values returned by the whole comprehension.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="concurrency"></a>8.7.&nbsp;Concurrency</h2></div></div><div></div></div><p>Neither this specification nor the module <tt class="literal">ceylon.language</tt>
        provide any facility to initiate or control concurrent execution of a program
        written in Ceylon. However, a Ceylon program executing on the Java Virtual Machine
        may interact with Java libraries (and other Ceyon modules) that make use of 
        concurrency.</p><p>In this scenario, the execution of a Ceylon program is governed by the rules 
        laid out by the Java programming language's execution model (Chapter 17 of the Java 
        Language Specification). Ceylon references belonging to a class or interface are 
        considered <span class="emphasis"><em>fields</em></span> in the sense of the JLS. Any such refence
        not explicitly declared <tt class="literal">variable</tt> is considered a 
        <span class="emphasis"><em>final field</em></span>. Evaluation of a reference is considered a 
        <span class="emphasis"><em>use</em></span> operation, and assignment to or specification of a variable
        reference is considered an <span class="emphasis"><em>assign</em></span> operation, again in terms of 
        the JLS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="modulesystem"></a>Chapter&nbsp;9.&nbsp;Module system</h2></div></div><div></div></div><p>The Ceylon module architecture enables a toolset which relieves 
    developers of many mundane tasks. The module system specifies:</p><div class="itemizedlist"><ul type="disc"><li><p>the format of packaged deployable module archives (for
            the Java platform), module scripts (for the JavaScript platform), 
            and source archives,</p></li><li><p>the layout of a module repository</p></li><li><p>the format of the package descriptor files which contain
            information about the packages contained in a module, including
            whether a package is visible to other modules, and</p></li><li><p>the format of the module descriptor file which contains
            information about a module, along with a list of its
            versioned dependencies.</p></li></ul></div><p>Thus, developers are never exposed to individual <tt class="literal">.class</tt>
    files, and are not required to manually manage module archives using the 
    operating system file manager. Instead, the toolset helps automate the 
    management of modules within module repositories.</p><p>Circular dependencies between modules are not supported. The
    Ceylon compiler detects such dependencies and produces an error.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="moduleruntime"></a>9.1.&nbsp;The module runtime and module isolation</h2></div></div><div></div></div><p>At any time, there may be multiple versions of a certain module 
        available in the virtual machine. Modules execute under the control of 
        the <span class="emphasis"><em>module runtime</em></span>. The module runtime:</p><div class="itemizedlist"><ul type="disc"><li><p>obtains modules from module repositories,</p></li><li><p>reads module metadata and recursively loads 
                dependencies, and</p></li><li><p>isolates modules that belong to different
                assemblies.</p></li></ul></div><p>Execution of a module begins with a specified toplevel method or 
        class, or with an entry point specified in the module descriptor, and 
        imported modules are loaded lazily as classes they contain are needed. 
        The name and version id of the imported module containing the needed 
        class are determined from the imported package name specified by the 
        compilation unit and the imported module version specified by the 
        module descriptor.</p><p>The mechanism behind this is platform-dependent.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="classloaders"></a>9.1.1.&nbsp;Module isolation for the Java platform</h3></div></div><div></div></div><p>In the JVM environment, each version of each module is loaded 
            using a different class loader. Classes inside a module have access 
            to other classes in the same module and to classes belonging to 
            modules that are explicitly imported in the module descriptor. 
            Classes in other modules are not accessible.</p><p>Ceylon supports a simplified class loader architecture:</p><div class="itemizedlist"><ul type="disc"><li><p>The <span class="emphasis"><em>bootstrap</em></span> class loader owns
                    classes required to bootstrap the module runtime. It is the
                    direct parent of all module class loaders, and its classes
                    are visible to all module class loaders.</p></li><li><p>A <span class="emphasis"><em>module</em></span> class loader owns classes
                    belonging to a given version of a certain module. Its classes
                    are visible only to classes belonging to the module class 
                    loader of a module which declares an explicit dependency on 
                    the given version of the first module.</p></li></ul></div><i><span class="comment"><p>The Ceylon module runtime for the JVM is implemented
            using JBoss Modules. It is included in the Ceylon SDK.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="requirejs"></a>9.1.2.&nbsp;Module isolation for the JavaScript platform</h3></div></div><div></div></div><p>In the JavaScript environment, modules are loaded using
            the <tt class="literal">require()</tt> function defined by CommonJS 
            Modules.</p><i><span class="comment"><p>There are various implementations of the CommonJS-style 
            <tt class="literal">require()</tt> function, and Ceylon module scripts should
            work with any of them.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assemblies"></a>9.1.3.&nbsp;Assemblies</h3></div></div><div></div></div><i><span class="comment"><p>A future release of the language will add support for
            assemblies, that is, the ability to:</p>
            <div class="itemizedlist"><ul type="disc"><li><p>package together several interdependent versioned modules 
                    into a single archive for deployment as a single well-defined 
                    application or service,</p></li><li><p>specify the name and version of the application or 
                    service, and</p></li><li><p>override the versions of imported modules declared in 
                    <tt class="literal">modules.ceylon</tt>, as defined in 
                    <a href="#moduledescriptors" title="9.3.12.&nbsp;Module descriptors">&sect;9.3.12 Module descriptors</a>, with assembly-specific
                    module versions.</p></li></ul></div>
            <p>An assembly archive will probably just be an archived module
            repository with an assembly descriptor.</p>
            </span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sourcelayout"></a>9.2.&nbsp;Source layout</h2></div></div><div></div></div><p>A <span class="emphasis"><em>source directory</em></span> contains Ceylon source 
        code in files with the extension <tt class="literal">.ceylon</tt> and Java 
        source code in files with the extension <tt class="literal">.java</tt>. 
        The module and package to which a compilation unit belongs is 
        determined by the subdirectory in which the source file is found.</p><p>The name of the package to which a compilation unit belongs is 
        formed by replacing every path directory separator character with a 
        period in the relative path from the root source directory to the 
        subdirectory containing the source file. In the case of a Java source 
        file, the subdirectory must agree with the package specified by the 
        Java <tt class="literal">package</tt> declaration.</p><p>The name of the module to which a compilation unit belongs is 
        determined by searching all containing directories for a module 
        descriptor. The name of the module is formed by replacing every path
        directory separator character with a period in the relative path 
        from the source directory to the subdirectory containing the module 
        descriptor. If no module descriptor is found, the code belongs to
        the <span class="emphasis"><em>default module</em></span>.</p><i><span class="comment"><p>Note: the default module is intended only as a 
        convenience for experimental code.</p></span></i><p>A package or compilation unit may belong to only one module.
        No more than one module descriptor may occur in the containing
        directories of a compilation unit.</p><p>Thus, the structure of the source directory containing the 
        module <tt class="literal">org.hello</tt> might be the following:</p><pre class="screen">source/
    org/
        hello/
            module.ceylon      //the module descriptor
            main/
                hello.ceylon
            default/
                DefaultHello.ceylon
            personalized/
                PersonalizedHello.ceylon</pre><p>The source code for multiple modules may be contained in a
        single source directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="modules"></a>9.3.&nbsp;Module architecture</h2></div></div><div></div></div><p>Compiled code is automatically packaged into <span class="emphasis"><em>module
        archives</em></span> and <span class="emphasis"><em>module scripts</em></span> by the 
        Ceylon compiler. A <span class="emphasis"><em>module repository</em></span> is a 
        repository containing module archives, module scripts, and other
        miscellaneous artifacts. A module archive or module script is 
        automatically obtained from a module repository when code belonging 
        to the module is needed by the compiler or module runtime.</p><p>Modules that form part of the Ceylon SDK are found in the
        module repository in the <tt class="literal">modules</tt> directory of 
        the Ceylon distribution.</p><p>Red Hat maintains a central module repository at 
        <tt class="literal">http://modules.ceylon-lang.org</tt>. Read access to 
        this site is free of registration and free of charge. Ceylon projects 
        may apply for a user account which provides write access to the central 
        module repository.</p><p>A module belonging to the central module repository must
        satisfy the following regulations:</p><div class="itemizedlist"><ul type="disc"><li><p>the first element of the module name must be a top-level
                internet domain name, and the second element of the module name 
                must be a second-level domain of the given top-level domain 
                owned by the organization distributing the module, and.</p></li><li><p>the module must be made available under a royalty-free 
                license.</p></li></ul></div><p>For example, a module developed by Red Hat might be named
        <tt class="literal">org.jboss.server</tt>.</p><i><span class="comment"><p>TODO: should we require that module archives be signed 
        using the Java <tt class="literal">jarsigner</tt> tool?</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modulenamesandversionidentifiers"></a>9.3.1.&nbsp;Module names and version identifiers</h3></div></div><div></div></div><p>A module <span class="emphasis"><em>name</em></span> is a period-separated
            list of initial lowercase identifiers, for example:</p><pre class="screen">ceylon.language</pre><pre class="screen">org.hibernate</pre><p>It is recommended that module names follow the Java package
            naming convention embedding the organization's domain name (in
            this case, <tt class="literal">hibernate.org</tt>). The namespace
            <tt class="literal">ceylon</tt> is reserved for Ceylon SDK modules. The 
            namespace <tt class="literal">java</tt> is reserved for modules 
            belonging to the Java SDK. The namespace <tt class="literal">default</tt>
            is reserved for the default module.</p><p>It is highly recommended, but not required, that every 
            user-written module have at least three identifiers in its name. 
            Therefore, <tt class="literal">org.hibernate.orm</tt> is strongly
            preferred to <tt class="literal">org.hibernate</tt>.</p><p>Modules may not be "nested". That is, the list of identifiers 
            forming the name of a module may not be a prefix of the list of 
            identifiers forming the name of another module.</p><p>A package belongs to a module if the list of identifiers 
            forming the name of the module is a prefix of the list of 
            identifiers forming the name of the package. For example, the 
            packages:</p><pre class="screen">ceylon.language</pre><pre class="screen">ceylon.language.assertion</pre><pre class="screen">ceylon.language.meta</pre><pre class="screen">ceylon.language.meta.declaration</pre><p>belong to the module <tt class="literal">ceylon.language</tt>. The 
            packages:</p><pre class="screen">org.hibernate</pre><pre class="screen">org.hibernate.impl</pre><pre class="screen">org.hibernate.cache</pre><p>belong to the module <tt class="literal">org.hibernate</tt>.</p><i><span class="comment"><p>TODO: This might not work out all that well in practice, 
            unless we introduce some additional convention for "extras" modules,
            for example, modules containing examples. It could be 
            <tt class="literal">org.hibernate</tt> vs <tt class="literal">org.hibernate_example</tt>
            or <tt class="literal">org.hibernate.core</tt> vs 
            <tt class="literal">org.hibernate.example</tt>.</p></span></i><p>The name of the default module is <tt class="literal">default</tt>. The 
            default module has no version and cannot be published to a remote repository 
            nor to the local repository cache under <tt class="filename">~/.ceylon/repo</tt>.</p><p>A module <span class="emphasis"><em>version identifier</em></span> is a character 
            string containing digits, periods, and lowercase letters, for example:</p><pre class="screen">1.0.1</pre><pre class="screen">3.0.0.beta</pre><i><span class="comment"><p>TODO: at some stage we will probably need to add a format
            for specifying version ranges.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modulearchivenamesjava"></a>9.3.2.&nbsp;Module archive names for the Java platform</h3></div></div><div></div></div><p>A <span class="emphasis"><em>module archive name</em></span> is constructed from 
            the module name and version identifier. A module archive name is of 
            the following standard form:</p><pre class="screen"><span class="emphasis"><em>&lt;module&gt;</em></span>-<span class="emphasis"><em>&lt;version&gt;</em></span>.car</pre><p>where <tt class="literal"><span class="emphasis"><em>&lt;module&gt;</em></span></tt> 
            is the full name of the module, and 
            <tt class="literal"><span class="emphasis"><em>&lt;version&gt;</em></span></tt> is the module 
            version identifier. For example:</p><pre class="screen">ceylon.language-1.0.1.car</pre><pre class="screen">org.hibernate-3.0.0.beta.car</pre><p>The default module has no version, its module archive name is <tt class="literal">default.car</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modulescriptnamesjs"></a>9.3.3.&nbsp;Module script names for the JavaScript platform</h3></div></div><div></div></div><p>A <span class="emphasis"><em>module script name</em></span> is likewise constructed 
            from the module name and version identifier. A module script name is of 
            the following standard form:</p><pre class="screen"><span class="emphasis"><em>&lt;module&gt;</em></span>-<span class="emphasis"><em>&lt;version&gt;</em></span>.js</pre><p>where <tt class="literal"><span class="emphasis"><em>&lt;module&gt;</em></span></tt> 
            is the full name of the module, and 
            <tt class="literal"><span class="emphasis"><em>&lt;version&gt;</em></span></tt> is the module 
            version identifier. For example:</p><pre class="screen">ceylon.language-1.0.1.js</pre><pre class="screen">org.hibernate-3.0.0.beta.js</pre><p>The default module has no version, its module archive name is <tt class="literal">default.js</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sourcearchivenames"></a>9.3.4.&nbsp;Source archive names</h3></div></div><div></div></div><p>A <span class="emphasis"><em>source archive name</em></span> is of the following 
            standard form:</p><pre class="screen"><span class="emphasis"><em>&lt;module&gt;</em></span>-<span class="emphasis"><em>&lt;version&gt;</em></span>.src</pre><p>For example:</p><pre class="screen">ceylon.language-1.0.1.src</pre><pre class="screen">org.hibernate-3.0.0.beta.src</pre><p>The default module has no version, its source archive name is <tt class="literal">default.src</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="docarchivenames"></a>9.3.5.&nbsp;Documentation archive names</h3></div></div><div></div></div><p>A <span class="emphasis"><em>documentation archive name</em></span> is of the following 
            standard form:</p><pre class="screen"><span class="emphasis"><em>&lt;module&gt;</em></span>-<span class="emphasis"><em>&lt;version&gt;</em></span>.doc.zip</pre><p>For example:</p><pre class="screen">ceylon.language-1.0.1.doc.zip</pre><pre class="screen">org.hibernate-3.0.0.beta.doc.zip</pre><p>The default module has no version, its documentation archive name is <tt class="literal">default.doc.zip</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modulearchives"></a>9.3.6.&nbsp;Module archives</h3></div></div><div></div></div><p>A Ceylon module archive is a Java <tt class="literal">jar</tt>
            archive which:</p><div class="itemizedlist"><ul type="disc"><li><p>contains a Ceylon module descriptor in the
                    <span class="emphasis"><em>module directory</em></span>,</p></li><li><p>contains the compiled <tt class="literal">.class</tt>
                    files for all compilation units belonging to the module, 
                    and</p></li><li><p>has a filename which adheres to the standard for
                    module archive names.</p></li></ul></div><p>The <span class="emphasis"><em>module directory</em></span> of the module archive 
            is formed by replacing each period in the fully qualified package name 
            with the directory separator character. For example, the module directory 
            for the module <tt class="literal">ceylon.language</tt> is:</p><pre class="screen">/ceylon/language</pre><p>The module directory for the module <tt class="literal">org.hibernate</tt> 
            is:</p><pre class="screen">/org/hibernate</pre><p>The <span class="emphasis"><em>package directory</em></span> for a package 
            belonging to the module archive is formed by replacing each period 
            in the fully qualified package name with the directory separator 
            character. For example, the package directory for the package 
            <tt class="literal">org.hibernate.impl</tt> is:</p><pre class="screen">/org/hibernate/impl</pre><p>Inside a module archive, a <tt class="literal">.class</tt> file is
            found in the package directory of the package to which it belongs.</p><p>Thus, the structure of the module archive for the module
            <tt class="literal">org.hello</tt> might be the following:</p><pre class="screen">org.hello-1.0.0.car
    META-INF/
        MANIFEST.MF
    org/
        hello/
            module.class       //the module descriptor
            main/
                package.class  //a package descriptor
                hello.class
            default/
                DefaultHello.class
            personalized/
                PersonalizedHello.class</pre><p>A module archive may not contain multiple modules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modulescripts"></a>9.3.7.&nbsp;Module scripts</h3></div></div><div></div></div><p>A Ceylon module script is a JavaScript source file which:</p><div class="itemizedlist"><ul type="disc"><li><p>complies with the CommonJS Modules specification, 
                    and</p></li><li><p>has a filename which adheres to the standard for
                    module script names.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sourcearchives"></a>9.3.8.&nbsp;Source archives</h3></div></div><div></div></div><p>A <span class="emphasis"><em>source archive</em></span> is a <tt class="literal">zip</tt> 
            archive which:</p><div class="itemizedlist"><ul type="disc"><li><p>contains the source code (<tt class="literal">.ceylon</tt>
                    and <tt class="literal">.java</tt> files) for all compilation units 
                    belonging to the module, and</p></li><li><p>has a filename which adheres to the standard for
                    source archive names.</p></li></ul></div><p>Inside a source archive, a Ceylon or Java source file is located in 
            the <span class="emphasis"><em>package directory</em></span> of the package to which the 
            compilation unit belongs. The package directory for a package belonging 
            to the source archive is formed by replacing each period in the fully 
            qualified package name with the directory separator character.</p><p>Thus, the structure of the source archive for the module
            <tt class="literal">org.hello</tt> might be the following:</p><pre class="screen">org.hello-1.0.0.src
    org/
        hello/
            module.ceylon       //the module descriptor
            main/
                package.ceylon  //a package descriptor
                hello.ceylon
            default/
                DefaultHello.ceylon
            personalized/
                PersonalizedHello.ceylon</pre><p>A source archive may not contain the source of multiple modules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="docarchives"></a>9.3.9.&nbsp;Documentation archives</h3></div></div><div></div></div><p>A <span class="emphasis"><em>documentation archive</em></span> is a <tt class="literal">zip</tt> 
            archive which:</p><div class="itemizedlist"><ul type="disc"><li><p>contains the module documentation generated by the documentation
                    compiler (<tt class="literal">.html</tt> and resources files), and</p></li><li><p>has a filename which adheres to the standard for
                    documentation archive names.</p></li></ul></div><p>Inside a documentation archive, HTML source is located in the 
            <tt class="literal">module-doc</tt> directory.</p><p>Thus, the structure of the documentation archive for the module
            <tt class="literal">org.hello</tt> might be the following:</p><pre class="screen">org.hello-1.0.0.doc.zip
    module-doc/
        .resources/
            ...
        index.html
        search.html
        module.ceylon.html
        main/
            index.html
            package.ceylon.html
            hello.ceylon.html
        default/
            index.html
            DefaultHello.html
            DefaultHello.ceylon.html
        personalized/
            index.html
            PersonalizedHello.html
            PersonalizedHello.ceylon.html</pre><p>A documentation archive may not contain the documentation of multiple 
            modules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modulerepositories"></a>9.3.10.&nbsp;Module repositories</h3></div></div><div></div></div><p>A module repository is a directory structure on the local
            filesystem or a remote HTTP server.</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>local</em></span> module repository is 
                    identified by a filesystem path.</p></li><li><p>A <span class="emphasis"><em>remote</em></span> module repository is 
                    identified by a URL with protocol <tt class="literal">http:</tt> 
                    or <tt class="literal">https:</tt>.</p></li></ul></div><p>A <span class="emphasis"><em>publishable</em></span> module repository is a local
            module repository, or a WebDAV-enabled remote module repository.</p><p>For example:</p><pre class="screen">modules</pre><pre class="screen">/usr/bin/ceylon/modules</pre><pre class="screen">http://jboss.org/ceylon/modules</pre><pre class="screen">https://gavin:secret@modules.ceylon-lang.org</pre><p>A module repository contains module archives, module scripts, 
            source archives, and documentation archives. The address of an artifact 
            belonging to the repository adheres to the following standard form:</p><pre class="screen"><span class="emphasis"><em>&lt;repository&gt;</em></span>/<span class="emphasis"><em>&lt;module-path&gt;</em></span>/<span class="emphasis"><em>&lt;version&gt;</em></span>/<span class="emphasis"><em>&lt;artifact&gt;</em></span></pre><p>where <tt class="literal"><span class="emphasis"><em>&lt;repository&gt;</em></span></tt> 
            is the filesystem path or URL of the repository,
            <tt class="literal"><span class="emphasis"><em>&lt;artifact&gt;</em></span></tt> is the name
            of the artifact, <tt class="literal"><span class="emphasis"><em>&lt;version&gt;</em></span></tt>
            is the module version, and <tt class="literal"><span class="emphasis"><em>&lt;module-path&gt;</em></span></tt> 
            is formed by replacing every period with a slash in the module name.</p><p>The default module having no version, its access path does not 
            contain the version.</p><pre class="screen"><span class="emphasis"><em>&lt;repository&gt;</em></span>/default/<span class="emphasis"><em>&lt;archive&gt;</em></span></pre><p>For example, the module archive <tt class="literal">ceylon.language-1.0.1.car</tt>,
            module script, source archive <tt class="literal">ceylon.language-1.0.1.src</tt>,
            and documentation archive belonging to the repository included in the Ceylon SDK are
            obtained from the following addresses:</p><pre class="screen">modules/ceylon/language/1.0.1/ceylon.language-1.0.1.car</pre><pre class="screen">modules/ceylon/language/1.0.1/ceylon.language-1.0.1.js</pre><pre class="screen">modules/ceylon/language/1.0.1/ceylon.language-1.0.1.src</pre><pre class="screen">modules/ceylon/language/1.0.1/ceylon.language-1.0.1.doc.zip</pre><p>The module archive <tt class="literal">org.hibernate-3.0.0.beta.car</tt>,
            source archive <tt class="literal">org.hibernate-3.0.0.beta.src</tt>, and 
            documentation archive belonging to the repository 
            <tt class="literal">http://jboss.org/ceylon/modules</tt> are obtained from the 
            following addresses:</p><pre class="screen">http://jboss.org/ceylon/modules/org/hibernate/3.0.0.beta/org.hibernate-3.0.0.beta.car</pre><pre class="screen">http://jboss.org/ceylon/modules/org/hibernate/3.0.0.beta/org.hibernate-3.0.0.beta.src</pre><pre class="screen">http://jboss.org/ceylon/modules/org/hibernate/3.0.0.beta/org.hibernate-3.0.0.beta.doc.zip</pre><p>The module archive <tt class="literal">org.h2-1.2.141.car</tt> and legacy 
            archive <tt class="literal">org.h2-1.2.141.jar</tt> belonging to the repository 
            <tt class="literal">/usr/bin/ceylon/modules</tt> are obtained from the following 
            addresses:</p><pre class="screen">/usr/bin/ceylon/modules/org/h2/1.2.141/org.h2-1.2.141.car</pre><pre class="screen">/usr/bin/ceylon/modules/org/h2/1.2.141/org.h2-1.2.141.jar</pre><p>For each archive, the module repository may contain a SHA-1 checksum 
            file. The checksum file is a plain text file containing just the SHA-1 checksum
            of the archive. The address of a checksum file adheres to the following standard 
            form:</p><pre class="screen"><span class="emphasis"><em>&lt;repository&gt;</em></span>/<span class="emphasis"><em>&lt;module-path&gt;</em></span>/<span class="emphasis"><em>&lt;version&gt;</em></span>/<span class="emphasis"><em>&lt;archive&gt;</em></span>.sha1</pre><p>The compiler or module runtime verifies the checksum after downloading
            the archive from the module repository.</p><p>A module repository may contain documentation generated by the Ceylon
            documentation compiler in exploded form. A module's documentation resides in the
            <span class="emphasis"><em>module documentation directory</em></span>, a directory with address 
            adhering to the following standard form:</p><pre class="screen"><span class="emphasis"><em>&lt;repository&gt;</em></span>/<span class="emphasis"><em>&lt;module-path&gt;</em></span>/<span class="emphasis"><em>&lt;version&gt;</em></span>/module-doc/</pre><p>For example, the home page for the documentation of the module
            <tt class="literal">org.hibernate</tt> is:</p><pre class="screen">http://jboss.org/ceylon/modules/org/hibernate/module-doc/index.html</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="packagedescriptors"></a>9.3.11.&nbsp;Package descriptors</h3></div></div><div></div></div><p>A <span class="emphasis"><em>package descriptor</em></span> is defined in a source file
            named <tt class="literal">package.ceylon</tt> in the package it describes.</p><pre data-language="bnf">PackageDescriptor: Annotations "package" FullPackageName ";"</pre><p>A <tt class="literal">package</tt> may be annotated <tt class="literal">shared</tt>. 
            A <tt class="literal">shared</tt> package is visible outside the containing module,
            that is, in any module which imports the containing module.</p><p>The package descriptor is optional for unshared packages.</p><pre data-language="ceylon">"The typesafe query API."
license ("http://www.gnu.org/licenses/lgpl.html")
shared package org.hibernate.query;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="moduledescriptors"></a>9.3.12.&nbsp;Module descriptors</h3></div></div><div></div></div><p>A <span class="emphasis"><em>module descriptor</em></span> is defined in a source file
            named <tt class="literal">module.ceylon</tt> in the root package of the module it
            describes (the package with the same name as the module).</p><pre data-language="bnf">ModuleDescriptor: Annotations "module" FullPackageName StringLiteral ModuleBody</pre><p>The literal string after the module name specifies the version of the
            module.</p><p>A module may import other modules.</p><pre data-language="bnf">ModuleBody: "{" ModuleImport* "}"</pre><pre data-language="bnf">ModuleImport: Annotations "import" (FullPackageName|StringLiteral) StringLiteral ";"</pre><p>The name of the imported module may be specified using the usual syntax
            for a module name, or as a literal string, to allow interoperation with
            legacy module repositories existing outside the Ceylon ecosystem.</p><i><span class="comment"><p>Note: this enables interoperation with Maven.</p></span></i><i><span class="comment"><p>Note: in Ceylon 1.0 it is illegal to explicitly import the
            module <tt class="literal">ceylon.language</tt>. The language module is always
            implicitly imported.</p></span></i><p>The string literal after the imported module name specifies the version 
            of the imported module.</p><p>An imported module may be annotated <tt class="literal">optional</tt> and/or
            <tt class="literal">shared</tt>.</p><div class="itemizedlist"><ul type="disc"><li><p>If module <tt class="literal">x</tt> has a <tt class="literal">shared</tt> 
                    import of module <tt class="literal">y</tt>, then any module that imports
                    <tt class="literal">x</tt> implicitly imports <tt class="literal">y</tt>.</p></li><li><p>If module <tt class="literal">x</tt> has an <tt class="literal">optional</tt>
                    import of module <tt class="literal">y</tt>, then <tt class="literal">x</tt> may
                    be executed even if <tt class="literal">y</tt> is not available at runtime.</p></li></ul></div><p>If a declaration belonging to module <tt class="literal">x</tt> is visible 
            outside the module and involves types imported from a different module
            <tt class="literal">y</tt>, then the module import of <tt class="literal">y</tt> in the
            module descriptor for <tt class="literal">x</tt> must be <tt class="literal">shared</tt>.</p><pre data-language="ceylon">"The best-ever ORM solution!"
license ("http://www.gnu.org/licenses/lgpl.html")
module org.hibernate "3.0.0.beta" {
    shared import ceylon.language "1.0.1";
    import javax.sql "4.0";
}</pre><pre data-language="ceylon">"The test suite for Hibernate"
license ("http://www.gnu.org/licenses/lgpl.html")
module org.hibernate.test "3.0.0.beta" {
    import org.hibernate "3.0.0.beta";
    TestSuite().run();
}</pre><i><span class="comment"><p>TODO: do we allow procedural code in the body of a 
            <tt class="literal">module</tt>?</p></span></i></div></div></div></div></body></html>