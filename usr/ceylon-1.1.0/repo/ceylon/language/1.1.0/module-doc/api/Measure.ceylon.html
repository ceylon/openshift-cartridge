<!DOCTYPE html><html xmlns='http://www.w3.org/1999/xhtml'><head><meta charset='UTF-8'/>
<title>Measure.ceylon</title><link href='.resources/favicon.ico' rel='shortcut icon'/>
<link href='.resources/ceylon.css' rel='stylesheet' type='text/css'/>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'/>
<script type='text/javascript'>var resourceBaseUrl = '.resources/'</script><script src='.resources/jquery-1.8.2.min.js' type='text/javascript'></script><script src='.resources/rainbow.min.js' type='text/javascript'></script><script src='.resources/ceylon.js' type='text/javascript'></script><script src='.resources/ceylondoc.js' type='text/javascript'></script></head><body><pre data-language='ceylon' style='font-family: Inconsolata, Monaco, Courier, monospace'>&quot;A [[Range]] of adjacent [[Enumerable]] values generated by 
 a [[first]] element, and a strictly positive [[size]]. The 
 range includes all values whose offset from `first` is 
 non-negative and less than the `size`.&quot;
see (`class Span`, 
    `interface Enumerable`)
final class Measure&lt;Element&gt;(first, size)
        extends Range&lt;Element&gt;()
        given Element satisfies Enumerable&lt;Element&gt; {

    &quot;The start of the range.&quot;
    shared actual Element first;
    
    &quot;The size of the range.&quot;
    shared actual Integer size;
    
    &quot;Can&apos;t be used for empty segments&quot;
    assert (size &gt; 0);
    
    shared actual String string 
            =&gt; first.string + &quot;:&quot; + size.string;
    
    shared actual Element last =&gt; first.neighbour(size-1);
    
    &quot;Determines if this sized range has more elements than 
     the given [[length]].&quot;
    shared actual Boolean longerThan(Integer length)
            =&gt; size &gt; length;
    
    &quot;Determines if this sized range has fewer elements than 
     the given [[length]].&quot;
    shared actual Boolean shorterThan(Integer length)
            =&gt; size &lt; length;
    
    &quot;The index of the end of the sized range.&quot;
    shared actual Integer lastIndex =&gt; size-1; 
    
    &quot;The rest of the range, without its first element.&quot;
    shared actual Element[] rest 
            =&gt; size==1 then [] 
                       else Measure(first.successor,size-1);
    
    &quot;The element of the range that occurs [[index]] values
     after the start of the range.&quot;
    shared actual Element? getFromFirst(Integer index) {
        if (index&lt;0 || index &gt;= size) {
            return null;
        }
        return first.neighbour(index);
    }
    
    shared actual Boolean increasing =&gt; true;
    shared actual Boolean decreasing =&gt; false;
    
    &quot;An iterator for the elements of the sized range.&quot;
    shared actual Iterator&lt;Element&gt; iterator() {
        object iterator
                satisfies Iterator&lt;Element&gt; {
            variable value count = 0;
            variable value current = first;
            shared actual Element|Finished next() {
                if (++count&gt;size) {
                    return finished;
                }
                else {
                    return current++;
                } 
            }
            string =&gt; &quot;(``outer.string``).iterator()&quot;;
        }
        return iterator;
    }
    
    shared actual {Element+} by(Integer step) {
        &quot;step size must be greater than zero&quot;
        assert (step &gt; 0);
        return step == 1 then this else By(step);
    }
    
    class By(Integer step)
            satisfies {Element+} {
        
        size =&gt; 1 + (outer.size - 1) / step;
        
        first =&gt; outer.first;
        
        string =&gt; &quot;(``outer.string`` by ``step``)&quot;;
        
        shared actual Iterator&lt;Element&gt; iterator() {
            object iterator
                    satisfies Iterator&lt;Element&gt; {
                variable value count = 0;
                variable value current = first;
                shared actual Element|Finished next() {
                    if (++count&gt;size) {
                        return finished;
                    }
                    else {
                        value result = current;
                        current = current.neighbour(step);
                        return result;
                    } 
                }
                string =&gt; &quot;``outer.string``.iterator()&quot;;
            }
            return iterator;
        }
    }
    
    shared actual Measure&lt;Element&gt; shifted(Integer shift) {
        if (shift==0) {
            return this;
        }
        else {
            return Measure(first.neighbour(shift),size);
        }
    }
    
    &quot;Determines if this range includes the given object.&quot;
    shared actual Boolean contains(Object element) {
        if (is Element element) {
            return containsElement(element);
        }
        else {
            return false;
        }
    }
    
    &quot;Determines if this range includes the given value.&quot;
    shared actual Boolean occurs(Anything element) {
        if (is Element element) {
            return containsElement(element);
        }
        else {
            return false;
        }
    }
    
    shared actual Boolean containsElement(Element x)
            =&gt; 0 &lt;= x.offset(first) &lt; size;
    
    shared actual Boolean includes(List&lt;Anything&gt; sublist) {
        if (sublist.empty) {
            return true;
        }
        else if (is Range&lt;Element&gt; sublist) {
            return includesRange(sublist);
        }
        else {
            return super.includes(sublist);
        }
    }
    
    shared actual Boolean includesRange(Range&lt;Element&gt; sublist) {
        switch (sublist)
        case (is Measure&lt;Element&gt;) {
            value offset = sublist.first.offset(first);
            return offset &gt;= 0 &amp;&amp; offset + sublist.size &lt;= size;
        }
        case (is Span&lt;Element&gt;) {
            if (sublist.decreasing) {
                return false;
            }
            else {
                value offset = sublist.first.offset(first);
                return offset &gt;= 0 &amp;&amp; offset + sublist.size &lt;= size;
            }
        }
    }
    
    shared actual Boolean equals(Object that) {
        if (is Measure&lt;Object&gt; that) {
            //optimize for another Measure
            return that.size==size &amp;&amp; that.first==first;
        }
        else if (is Span&lt;Object&gt; that) {
            return that.increasing &amp;&amp; 
                    that.first == first &amp;&amp; that.size == size; 
        }
        else {
            //it might be another sort of List
            return super.equals(that);
        }
    }
    
    shared actual Element[] measure(Integer from, Integer length) {
        if (length&lt;=0) {
             return []; 
        }
        else {
            value len = from+length &lt; size then length 
                                           else size-from;
            return Measure(first.neighbour(from),len);
        }
    }
    
    shared actual Element[] span(Integer from, Integer to) {
        if (from&lt;=to) {
            if (to&lt;0 || from&gt;=size) {
                return [];
            }
            else {
                value len = to &lt; size then to-from+1
                                      else size-from;
                return Measure(first.neighbour(from),len);
            }
        }
        else {
            if (from&lt;0 || to&gt;=size) {
                return [];
            }
            else {
                value len = from &lt; size then from-to+1 
                                        else size-to;
                return Measure(first.neighbour(to),len).reversed;
            }
        }
    }
    
    shared actual Element[] spanFrom(Integer from) {
        if (from &lt;= 0) {
            return this;
        }
        else if (from &lt; size) {
            return Measure(first.neighbour(from),size-from);
        }
        else {
            return [];
        }
    }
    
    shared actual Element[] spanTo(Integer to) {
        if (to&lt;0) {
            return [];
        }
        else if (to &lt; size-1) {
            return Measure(first,to);
        }
        else {
            return this;
        }
    }
}

&quot;Produces a [[Range]] of adjacent [[Enumerable]] values 
 generated by a [[first]] element, and a strictly positive 
 [[size]], or returns the [[empty sequence|empty]] if 
 `size &lt;= 0`. The range includes all values whose offset 
 from `first` is non-negative and less than the `size`.
 
 More precisely, if `x` and `first` are of `Enumerable` 
 type `X`, and `size` is an integer, then `x in first:size` 
 if and only if `0 &lt;= x.offset(first) &lt; size`.
 
 The _measure operator_ `:` is an abbreviation for
 `measure()`:
 
     for (i in start:size) { ... }
     for (char in &apos;0&apos;:10) { ... }
 
 The measure operator accepts the first index and size of 
 the range:
 
     0:5     // [0, 1, 2, 3, 4]
 
 If the size is nonpositive, the range is empty:
 
     0:0     // []
     5:0     // []
     0:-5    // []&quot;
shared Range&lt;Element&gt;|[] measure&lt;Element&gt;
            (Element first, Integer size) 
        given Element satisfies Enumerable&lt;Element&gt; 
        =&gt; size &lt;= 0 then [] else Measure(first, size);
</pre></body></html>