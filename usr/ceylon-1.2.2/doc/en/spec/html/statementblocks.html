<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Statements, blocks, and control structures</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css">
<link type='text/css' href='../shared/css/ceylon.css' rel='stylesheet'/>
<link type='text/css' href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet'/>
<script src='../shared/css/rainbow.min.js' type='text/javascript'></script>
<script src='../shared/css/ceylon.js' type='text/javascript'></script>
<script src='../shared/css/bnf.js' type='text/javascript'></script><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="The Ceylon Language"><link rel="up" href="index.html" title="The Ceylon Language"><link rel="previous" href="declarations.html" title="Chapter&nbsp;4.&nbsp;Declarations"><link rel="next" href="expressions.html" title="Chapter&nbsp;6.&nbsp;Expressions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The Ceylon Language &mdash; 5.&nbsp;Statements, blocks, and control structures</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="declarations.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="expressions.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="statementblocks"></a>Chapter&nbsp;5.&nbsp;Statements, blocks, and control structures</h2></div></div><div></div></div><p>Function, value, and class bodies contain procedural code that is executed 
    when the function is invoked, the value evaluated, or the class instantiated. The 
    code contains expressions and control directives and is organized using blocks 
    and control structures.</p><i><span class="comment"><p>Note: the Ceylon language has a recursive block structure&#8212;statements 
    and declarations that are syntactically valid in the body of a toplevel declaration 
    are, in general, also syntactically valid in the body of a nested declaration or 
    of a control structure, and vice-versa.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blockstructure"></a>5.1.&nbsp;Block structure and references</h2></div></div><div></div></div><p>A <span class="emphasis"><em>body</em></span> is a block, defined in 
        <a href="statementblocks.html#blocksandstatements" title="5.3.&nbsp;Blocks and statements">&sect;5.3 Blocks and statements</a>, class body, defined in 
        <a href="declarations.html#classes" title="4.5.&nbsp;Classes">&sect;4.5 Classes</a>, interface body, defined in 
        <a href="declarations.html#interfaces" title="4.4.&nbsp;Interfaces">&sect;4.4 Interfaces</a>, or comprehension clause, defined in
        <a href="expressions.html#comprehensions" title="6.6.6.&nbsp;Comprehensions">&sect;6.6.6 Comprehensions</a>. Every body (except for a comprehension clause) 
        is list of semicolon-delimited statements, control structures, and declarations, 
        surrounded by braces. Some bodies end in a control directive. Every program 
        element in the list is said to <span class="emphasis"><em>directly occur</em></span> in the body. 
        A program element <span class="emphasis"><em>directly occurs earlier</em></span> than a second 
        program element if both program elements directly occur in a body and the first 
        program element occurs (lexically) earlier in the list than the second program 
        element.</p><p>A program element <span class="emphasis"><em>(indirectly) occurs</em></span> in a body if:</p><div class="itemizedlist"><ul type="disc"><li><p>the program element directly occurs in the body, or</p></li><li><p>the program element indirectly occurs inside the body of a 
                declaration or control structure that occurs directly in the body.</p></li></ul></div><p>We sometimes say that the body <span class="emphasis"><em>contains</em></span> the program 
        element if the program element (indirectly) occurs in the body.</p><p>A program element <span class="emphasis"><em>(indirectly) occurs earlier</em></span> than a 
        second program element if:</p><div class="itemizedlist"><ul type="disc"><li><p>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</p></li><li><p>the second program element indirectly occurs inside the body of a 
                declaration or control structure, and the first program element directly 
                occurs earlier than the declaration or control structure.</p></li></ul></div><p>Then we also say that the second program element <span class="emphasis"><em>(indirectly) occurs 
        later</em></span> than the first. The set of program elements that occur later than a 
        program element is sometimes called the <span class="emphasis"><em>lexical scope</em></span> of the 
        program element.</p><p>A program element <span class="emphasis"><em>sequentially occurs</em></span> in a body if:</p><div class="itemizedlist"><ul type="disc"><li><p>the program element directly occurs in the body, or</p></li><li><p>the program element sequentially occurs inside the body of a control 
                structure or constructor that occurs directly in the body.</p></li></ul></div><p>A program element <span class="emphasis"><em>sequentially occurs earlier</em></span> than a 
        second program element if:</p><div class="itemizedlist"><ul type="disc"><li><p>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</p></li><li><p>the second program element sequentially occurs inside the body of a 
                control structure or constructor, and the first program element directly 
                occurs earlier than the control structure or constructor.</p></li></ul></div><p>If a program element sequentially occurs earlier than a second program element, 
        the <span class="emphasis"><em>sequence of statements</em></span> from the first program element to the
        second program element comprises:</p><div class="itemizedlist"><ul type="disc"><li><p>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the second program element, if the second program 
                element occurs directly in the same body as the first program element, or</p></li><li><p>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the control structure or constructor in whose body 
                the second program element sequentially occurs, followed by the sequence of 
                statements from the first statement of the declaration whose body contains 
                the second program element to the second program element itself, otherwise.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="declarationnameuniqueness"></a>5.1.1.&nbsp;Declaration name uniqueness</h3></div></div><div></div></div><p>A program element is contained within the <span class="emphasis"><em>namespace</em></span> 
            of a declaration if either:</p><div class="itemizedlist"><ul type="disc"><li><p>the declaration is a toplevel declaration, and the program 
                    element is a toplevel declaration of the same package,</p></li><li><p>the declaration directly occurs in a body, the program 
                    element occurs in the same body, and the declaration sequentially 
                    occurs earlier than the program element,</p></li><li><p>the declaration is a parameter or type parameter, and the
                    program element sequentially occurs in the body of the parameterized 
                    declaration, or</p></li><li><p>the program element is a control structure variable or 
                    iteration variable of a control structure that sequentially occurs 
                    in the namespace of the declaration.</p></li></ul></div><p>The namespace of a declaration may not contain a second declaration with 
            the same name. For example, the following is illegal:</p><pre data-language="ceylon">function fun(Float number) {
    if (number&lt;0.0) {
        Float number = 1.0; //error
        ...
    }
    ...
}</pre><p>As an exception to this rule, the namespace of a declaration annotated
            <tt class="literal">native</tt> may contain a second declaration with the same name
            if:</p><div class="itemizedlist"><ul type="disc"><li><p>the second declaration has exactly the same schema, as defined
                    in <a href="typesystem.html#type" title="3.2.&nbsp;Types">&sect;3.2 Types</a>,</p></li><li><p>the second declaration is also annotated <tt class="literal">native</tt>,
                    and</p></li><li><p>the two <tt class="literal">native</tt> annotations have distinct 
                    arguments for the <tt class="literal">backend</tt> parameter.</p></li></ul></div><p>A class or interface may not inherit a declaration with the same name as 
            a declaration it contains unless either:</p><div class="itemizedlist"><ul type="disc"><li><p>the contained declaration directly or indirectly refines the 
                    inherited declaration,</p></li><li><p>the contained declaration is not <tt class="literal">shared</tt>, or</p></li><li><p>the inherited declaration is not <tt class="literal">shared</tt>.</p></li></ul></div><p>A class or interface may not inherit two declarations with the same name 
            unless either:</p><div class="itemizedlist"><ul type="disc"><li><p>the class or interface contains a declaration that directly or 
                    indirectly refines both the inherited declarations (in which case both 
                    the inherited declarations directly or indirectly refine some member 
                    of a common supertype, as required by <a href="declarations.html#classrefinement" title="4.5.6.&nbsp;Member class refinement">&sect;4.5.6 Member class refinement</a>,
                    <a href="declarations.html#attributerefinement" title="4.8.7.&nbsp;Attribute refinement">&sect;4.8.7 Attribute refinement</a>, and 
                    <a href="declarations.html#methodrefinement" title="4.7.8.&nbsp;Method refinement">&sect;4.7.8 Method refinement</a>),</p></li><li><p>one of the inherited declarations directly or indirectly refines 
                    the other inherited declaration, or</p></li><li><p>at least one of the inherited declarations is not 
                    <tt class="literal">shared</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scopeofdeclaration"></a>5.1.2.&nbsp;Scope of a declaration</h3></div></div><div></div></div><p>The scope of a declaration is governed by the body or package in which it 
            occurs. A declaration is <span class="emphasis"><em>in scope</em></span> at a program element if
            and only if either:</p><div class="itemizedlist"><ul type="disc"><li><p>the declaration is a parameter or type parameter of a declaration 
                    whose body contains the program element,</p></li><li><p>the declaration is a control structure variable or iteration 
                    variable belonging to a block of a control structure that contains the 
                    program element,</p></li><li><p>the program element belongs to or is contained in the body of the 
                    declaration itself,</p></li><li><p>the program element belongs to or is contained in the body of a 
                    class or interface which inherits the declaration,</p></li><li><p>the declaration directly occurs in a body containing the program
                    element,</p></li><li><p>the declaration is imported by the compilation unit containing the 
                    program element and is visible to the program element, or</p></li><li><p>the declaration is a toplevel declaration in the package containing 
                    the program element.</p></li></ul></div><p>Where:</p><div class="itemizedlist"><ul type="disc"><li><p>A control structure variable or iteration variable <span class="emphasis"><em>belongs</em></span> 
                    to a block of a control structure if the block immediately follows the declaration 
                    of the variable.</p></li><li><p>A program element <span class="emphasis"><em>belongs</em></span> to a declaration if it occurs
                    in the <tt class="literal">extends</tt>, <tt class="literal">satisfies</tt>, <tt class="literal">of</tt>,
                    or <tt class="literal">given</tt> clause of the declaration.</p></li></ul></div><p>Furthermore:</p><div class="itemizedlist"><ul type="disc"><li><p>A condition variable of a condition belonging to a condition list is 
                    in scope in any condition of the same condition list that occurs lexically 
                    later.</p></li><li><p>A resource expression variable of a <tt class="literal">try</tt> statement 
                    is in scope in any resource expression of the same resource expression list 
                    that occurs lexically later.</p></li><li><p>An iteration variable or condition variable of a comprehension is in 
                    scope in any clause of the comprehension that occurs lexically later, since
                    comprehension clauses are viewed as nested bodies.</p></li></ul></div><p>And finally, there are special rules for annotation lists, defined in 
            <a href="annotations.html#annotationlists" title="7.1.1.&nbsp;Annotation lists">&sect;7.1.1 Annotation lists</a>:</p><div class="itemizedlist"><ul type="disc"><li><p>An annotation argument list belongs to the annotated declaration.</p></li><li><p>An annotation name is considered to occur directly in the compilation 
                    unit containing the program element.</p></li></ul></div><i><span class="comment"><p>Note: if no reference to an un-<tt class="literal">shared</tt> declaration 
            occurs within the scope of the declaration, a compiler warning is produced.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="visibility"></a>5.1.3.&nbsp;Visibility</h3></div></div><div></div></div><p>Classes, interfaces, functions, values, aliases, and type parameters 
            have names. Occurrence of a name in code implies a hard dependency from the 
            code in which the name occurs to the schema of the named declaration. We say 
            that a class, interface, value, function, alias, or type parameter is 
            <span class="emphasis"><em>visible</em></span> to a certain program element if its name may 
            occur in the code that belongs to that program element.</p><p>The visibility of a declaration depends upon where it occurs, and upon 
            whether it is annotated <tt class="literal">shared</tt>. A toplevel or member 
            declaration may be annotated <tt class="literal">shared</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>If a toplevel declaration is annotated <tt class="literal">shared</tt>, 
                    it is visible wherever the package that contains it is visible.
                    Otherwise, a toplevel declaration is visible only to code in the 
                    package containing its compilation unit.</p></li><li><p>If a member declaration is annotated <tt class="literal">shared</tt>, 
                    it is visible wherever the class or interface that contains it is 
                    visible. Otherwise, a declaration that occurs directly inside a class 
                    or interface body is visible only inside the class or interface 
                    declaration.</p></li></ul></div><i><span class="comment"><p>Note: the Ceylon compiler enforces additional visibility
            restrictions for members of Java classes, since Java's visibility modifiers
            can express restrictions that cannot be reproduced within Ceylon's visibility
            model. These restrictions are outside the scope of this specification.</p></span></i><p>A type parameter or a declaration that occurs directly inside a block 
            (the body of a function, getter, setter, or control structure) may not be 
            annotated <tt class="literal">shared</tt>.</p><div class="itemizedlist"><ul type="disc"><li><p>A type parameter is visible only inside the declaration to which 
                    it belongs.</p></li><li><p>A declaration that occurs directly inside a block is visible 
                    only inside the block.</p></li></ul></div><i><span class="comment"><p>TODO: Should we allow you to limit the effect of the 
            <tt class="literal">shared</tt> annotation by specifying a containing program 
            element or package?</p></span></i><p>We say that a type is <span class="emphasis"><em>visible</em></span> to a certain 
            program element if it is formed from references to classes, interfaces,
            type parameters, and type aliases whose declarations are visible to the 
            program element. For <tt class="literal">shared</tt> declarations:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of a value must be visible everywhere the value 
                    itself is visible.</p></li><li><p>The return type of a function must be visible everywhere 
                    the function itself is visible.</p></li><li><p>The satisfied interfaces of a class or interface must be 
                    visible everywhere the class or interface itself is visible.</p></li><li><p>The superclass of a class must be visible everywhere the 
                    class itself is visible.</p></li><li><p>The aliased type of a class alias, interface alias, or 
                    type alias must be visible everywhere the alias itself is 
                    visible.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="hiddendeclarations"></a>5.1.4.&nbsp;Hidden declarations</h3></div></div><div></div></div><p>If two declarations with the same name or imported name, as defined in 
            <a href="declarations.html#importedname" title="4.2.6.&nbsp;Imported name">&sect;4.2.6 Imported name</a>, are both in scope at a certain program element, then 
            one declaration may <span class="emphasis"><em>hide</em></span> the other declaration.</p><div class="itemizedlist"><ul type="disc"><li><p>If an inner body is contained (directly or indirectly) in an outer 
                    body, a declaration that is in scope in the inner body but is not in 
                    scope in the outer body hides a declaration that is in scope in the outer 
                    body. (In particular, a declaration inherited by a nested class or 
                    interface hides a declaration of the containing body.)</p></li><li><p>An un-<tt class="literal">shared</tt> declaration occurring directly in 
                    the body of a class containing the program element hides a declaration 
                    inherited by the class.</p></li><li><p>An <tt class="literal">actual</tt> declaration hides the declaration it
                    refines.</p></li><li><p>A declaration occurring in a body containing the program element 
                    hides a declaration imported by the compilation unit containing the body
                    or implicitly imported from the module <tt class="literal">ceylon.language</tt>.</p></li><li><p>A toplevel declaration of the package containing the program element 
                    hides a declaration implicitly imported from the module 
                    <tt class="literal">ceylon.language</tt>.</p></li><li><p>A declaration explicitly imported by the compilation unit containing
                    the program element hides a declaration implicitly imported from the module 
                    <tt class="literal">ceylon.language</tt>.</p></li><li><p>A declaration explicitly imported by the compilation unit containing 
                    the program element hides a toplevel declaration of  the package containing the compilation unit.</p></li><li><p>A declaration explicity imported by name in the compilation unit 
                    containing the program element hides a declaration explicitly imported 
                    by wildcard in the compilation unit.</p></li></ul></div><p>For example, the following code is legal:</p><pre data-language="ceylon">class Person(name) {
    String name;
    shared String lowerCaseName {
        String name = this.name.lowercased;
        return name;
    }
}</pre><p>As is this code:</p><pre data-language="ceylon">class Point(x, y) {
    shared Float x; 
    shared Float y;
}

class Complex(Float x, Float y=0.0) 
        extends Point(x, y) {}</pre><p>When a member of a class is hidden by a nested declaration, the member 
            may be accessed via the self reference <tt class="literal">this</tt>, defined in
            <a href="expressions.html#this" title="6.3.1.&nbsp;this">&sect;6.3.1 this</a>, or via the outer instance reference <tt class="literal">outer</tt>,
            defined in <a href="expressions.html#outer" title="6.3.2.&nbsp;outer">&sect;6.3.2 outer</a>.</p><pre data-language="ceylon">shared class Item(name) {
    variable String name;
    shared void changeName(String name) {
        this.name = name;
    }
}</pre><pre data-language="ceylon">class Catalog(name) {
    shared String name;
    class Schema(name) {
        shared String name;
        Catalog catalog =&gt; outer;
        String catalogName =&gt; outer.name;
        class Table(name) {
            shared String name;
            Schema schema =&gt; outer;
            String schemaName =&gt; outer.name;
            String catalogName =&gt; catalog.name;
        }
    }
}</pre><p>When a toplevel declaration of a package is hidden by another declaration, 
            the toplevel declaration may be accessed via the containing package reference 
            <tt class="literal">package</tt>, as defined in 
            <a href="statementblocks.html#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>.</p><pre data-language="ceylon">Integer n =&gt; 0;
Integer f(Integer n) =&gt; n+package.n;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="referenceabilityofdeclaration"></a>5.1.5.&nbsp;References and block structure</h3></div></div><div></div></div><p>A declaration may be in scope at a program element, but not 
            <span class="emphasis"><em>referenceable</em></span> at the program element. A declaration 
            is referenceable at a program element if the declaration is in scope at 
            the program element and either:</p><div class="itemizedlist"><ul type="disc"><li><p>the program element occurs within the lexical scope of the 
                    declaration,</p></li><li><p>the declaration is a parameter and the program element occurs 
                    within the <tt class="literal">extends</tt> clause of the declaration it
                    parameterizes, or</p></li><li><p>the declaration does not directly occur in a block, nor in 
                    the initializer section of a class body.</p></li></ul></div><p>Note that these rules have very different consequences for:</p><div class="itemizedlist"><ul type="disc"><li><p>a declaration that occurs in a block, as specified in 
                    <a href="statementblocks.html#blocksandstatements" title="5.3.&nbsp;Blocks and statements">&sect;5.3 Blocks and statements</a>, or in an class initializer section, as
                    specified in <a href="declarations.html#initializersection" title="4.5.2.&nbsp;Initializer section">&sect;4.5.2 Initializer section</a>, and
                    </p></li><li><p>a toplevel declaration, as specified in 
                    <a href="declarations.html#topleveldeclarations" title="4.1.1.&nbsp;Toplevel and nested declarations">&sect;4.1.1 Toplevel and nested declarations</a>, or a declaration that occurs in a 
                    class declaration sectiony, as specified in <a href="declarations.html#declarationsection" title="4.5.3.&nbsp;Declaration section">&sect;4.5.3 Declaration section</a>, 
                    or interface body, as specified in <a href="declarations.html#interfacebodies" title="4.4.1.&nbsp;Interface bodies">&sect;4.4.1 Interface bodies</a>.</p></li></ul></div><p>Declarations that occurs in a block or class initializer section are interspersed
            with procedural code that initializes references. Therefore, a program element in a 
            block or initializer may not refer to a declaration that occurs later in the block or 
            class body. This restriction does not apply to declarations that occur in an interface 
            body or class declaration section. Nor does it apply to toplevel declarations, which
            are not considered to have a well-defined order.</p><p>The following toplevel function declarations, belonging to the same package, 
            are legal:</p><pre data-language="ceylon">Float x =&gt; y;</pre><pre data-language="ceylon">Float y =&gt; x;</pre><p>This code is not legal, since the body of a function is an ordinary block:</p><pre data-language="ceylon">Float-&gt;Float xy() {
    Float x =&gt; y;  //error: y is not referenceable
    Float y =&gt; x;
    return x-&gt;y;
}</pre><p>This code is not legal, since all three statements occur in the initializer 
            section of the class body:</p><pre data-language="ceylon">class Point() {
    Float x =&gt; y;  //error: y is not referenceable
    Float y =&gt; x;
    Float-&gt;Float xy = x-&gt;y;
}</pre><p>However, this code <span class="emphasis"><em>is</em></span> legal, since the statements occur 
            in the declaration section of the class body:</p><pre data-language="ceylon">class Point() {
    Float x =&gt; y;
    Float y =&gt; x;
}</pre><p>Likewise, this code is legal, since the statements occur in an interface 
            body:</p><pre data-language="ceylon">interface Point {
    Float x =&gt; y;
    Float y =&gt; x;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeinferenceandblockstructure"></a>5.1.6.&nbsp;Type inference and block structure</h3></div></div><div></div></div><p>A value declared using the keyword <tt class="literal">value</tt> or a
            function declared using the keyword <tt class="literal">function</tt> may be 
            in scope at a program element, but its type may not be 
            <span class="emphasis"><em>inferable</em></span>, as defined by 
            <a href="typesystem.html#typeinference" title="3.2.9.&nbsp;Type inference">&sect;3.2.9 Type inference</a>, from the point of view of that program 
            element.</p><p>The type of a value or function declared using the keyword 
            <tt class="literal">value</tt> or <tt class="literal">function</tt> is inferable 
            to a program element if the declaration is in scope at the program 
            element and the program element occurs within the lexical scope of the 
            declaration.</p><i><span class="comment"><p>Note: the type of a value or function declared using
            the keyword <tt class="literal">value</tt> or <tt class="literal">function</tt> is
            not inferable within the body of the value or function 
            itself.</p></span></i><p>For any other declaration, including any declaration which 
            explicitly specifies its type, the type is considered inferable to a 
            program element if the declaration is in scope at the program 
            element.</p><p>The following code is not legal:</p><pre data-language="ceylon">interface Point {
    value x =&gt; y;  //error: type of y is not inferable
    value y =&gt; x;
}</pre><p>However, this code is legal:</p><pre data-language="ceylon">interface Point {
    value x =&gt; y;
    Float y =&gt; x;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="unqualifiedreferenceresolution"></a>5.1.7.&nbsp;Unqualified reference resolution</h3></div></div><div></div></div><p>An <span class="emphasis"><em>unqualified reference</em></span> is:</p><div class="itemizedlist"><ul type="disc"><li><p>the type name in an unqualified type declaration or type 
                    argument, as defined by <a href="typesystem.html#typeexpressions" title="3.2.7.&nbsp;Type expressions">&sect;3.2.7 Type expressions</a>, for 
                    example <tt class="literal">String</tt> and <tt class="literal">Sequence</tt> 
                    in <tt class="literal">Sequence&lt;String&gt;</tt>,</p></li><li><p>the value, function, constructor, or type name in a base 
                    expression, as defined by <a href="expressions.html#baseexpressions" title="6.5.1.&nbsp;Base expressions">&sect;6.5.1 Base expressions</a>, 
                    for example 
                    <tt class="literal">counter</tt> in <tt class="literal">counter.count</tt>, 
                    <tt class="literal">entries</tt> and <tt class="literal">people</tt> in 
                    <tt class="literal">entries(people*.name)</tt>, or 
                    <tt class="literal">Entry</tt>, <tt class="literal">name</tt>, and
                    <tt class="literal">item</tt> in <tt class="literal">Entry(name,item)</tt>, 
                    or</p></li><li><p>the type name in an unqualified type in a static expression, 
                    as defined by <a href="expressions.html#staticexpressions" title="6.5.6.&nbsp;Static expressions">&sect;6.5.6 Static expressions</a>, or constructor
                    expression, as defined by <a href="expressions.html#constructorexpressions" title="6.5.3.&nbsp;Constructor expressions">&sect;6.5.3 Constructor expressions</a>, 
                    for example <tt class="literal">Sequence</tt> in 
                    <tt class="literal">Sequence.iterator</tt>.</p></li></ul></div><p>If a program element contains an unqualified reference:</p><div class="itemizedlist"><ul type="disc"><li><p>there must be at least one declaration with the given name or 
                    imported into the toplevel namespace of the compilation unit, as
                    defined in <a href="declarations.html#imports" title="4.2.&nbsp;Imports">&sect;4.2 Imports</a>, and aliased to the given 
                    imported name, as defined in <a href="declarations.html#importedname" title="4.2.6.&nbsp;Imported name">&sect;4.2.6 Imported name</a>, in scope 
                    at the program element, and</p></li><li><p>if multiple declarations with the given name or imported name 
                    are in scope at the program element where the given name occurs, then 
                    it is guaranteed by the type system and 
                    <a href="statementblocks.html#declarationnameuniqueness" title="5.1.1.&nbsp;Declaration name uniqueness">&sect;5.1.1 Declaration name uniqueness</a> that there is exactly one 
                    such declaration which is not hidden by any other declaration.</p></li></ul></div><p>As an exception to this, if the expression or type expression begins
            with the qualifier keyword <tt class="literal">package</tt>, then there must be a
            toplevel declaration with the given name defined in the package to which the
            compilation unit belongs.</p><p>Then the reference is to this unique unhidden declaration, and:</p><div class="itemizedlist"><ul type="disc"><li><p>the declaration must be referenceable at the program element,</p></li><li><p>the type of the declaration must be inferable to the program 
                    element, and</p></li><li><p>if the declaration is forward-declared, it must be definitely
                    initialized at the program element.</p></li></ul></div><p>As a special exception to the above, if there is no declaration with the 
            given name or imported name in scope at the program element and the program element 
            occurs inside a <tt class="literal">dynamic</tt> block, then the unqualified reference 
            does not refer to any statically typed declaration.</p><p>If an unqualified reference refers to a member declaration of a type, then
            there is a unique <span class="emphasis"><em>inheriting or declaring class or interface</em></span> 
            for the unqualified reference, that is, the unique class or interface in whose 
            body the unqualified reference occurs, and which declares or inherits the member
            declaration, and for which the member is not hidden at the program element where
            the unqualified reference occurs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="qualifiedreferenceresolution"></a>5.1.8.&nbsp;Qualified reference resolution</h3></div></div><div></div></div><p>A <span class="emphasis"><em>qualified reference</em></span> is:</p><div class="itemizedlist"><ul type="disc"><li><p>the type name in a qualified type declaration or type argument, 
                    as defined by <a href="typesystem.html#typeexpressions" title="3.2.7.&nbsp;Type expressions">&sect;3.2.7 Type expressions</a>, for example 
                    <tt class="literal">Buffer</tt> in
                    <tt class="literal">BufferedReader.Buffer</tt>,</p></li><li><p>the value, function, or type name in a member expression, as 
                    defined by <a href="expressions.html#memberexpressions" title="6.5.2.&nbsp;Member expressions">&sect;6.5.2 Member expressions</a>, for example 
                    <tt class="literal">count</tt> in <tt class="literal">counter.count</tt>,
                    <tt class="literal">split</tt> in <tt class="literal">text.split()</tt>, or 
                    <tt class="literal">Buffer</tt> in <tt class="literal">br.Buffer()</tt>,</p></li><li><p>the constructor name in a constructor expression, as 
                    defined by <a href="expressions.html#constructorexpressions" title="6.5.3.&nbsp;Constructor expressions">&sect;6.5.3 Constructor expressions</a>, or</p></li><li><p>the type name in a qualified type in a static expression, as 
                    defined by <a href="expressions.html#staticexpressions" title="6.5.6.&nbsp;Static expressions">&sect;6.5.6 Static expressions</a>, for example 
                    <tt class="literal">Buffer</tt> in
                    <tt class="literal">BufferedReader.Buffer.size</tt>, or the member name 
                    in a static expression, for example <tt class="literal">iterator</tt> in 
                    <tt class="literal">Sequence.iterator</tt>, or <tt class="literal">size</tt> in 
                    <tt class="literal">BufferedReader.Buffer.size</tt>.</p></li></ul></div><p>Every qualified reference has a qualifying type:</p><div class="itemizedlist"><ul type="disc"><li><p>For a type declaration, the qualifying type is the full
                    qualified type the qualifies the type name.</p></li><li><p>For a value reference or callable reference, the 
                    qualifying type is the type of the receiver expression.</p></li><li><p>For a constructor reference, the qualifying type is the 
                    type of the qualifying base or member expression.</p></li><li><p>For a static reference, the qualifying type is the full 
                    qualified type the qualifies the type or member name.</p></li></ul></div><p>A qualified reference may not have <tt class="literal">Nothing</tt> as the
            qualifying type.</p><p>If a program element contains a qualified reference:</p><div class="itemizedlist"><ul type="disc"><li><p>the qualifying type must have or inherit at least one member 
                    or nested type with the given name or aliased to the given imported 
                    name, as defined in <a href="declarations.html#importedname" title="4.2.6.&nbsp;Imported name">&sect;4.2.6 Imported name</a>, which is visible 
                    at the program element, and</p></li><li><p>if there are multiple visible members with the given name or 
                    imported name, then it is guaranteed by the type system and
                    <a href="statementblocks.html#declarationnameuniqueness" title="5.1.1.&nbsp;Declaration name uniqueness">&sect;5.1.1 Declaration name uniqueness</a> that there is exactly 
                    one such member which is not refined by another member, except</p></li><li><p>if the qualifying type inherits a class or interface that
                    contains the program element, and an un-<tt class="literal">shared</tt>
                    declaration contained directly in the body of this class or 
                    interface has the same name as a <tt class="literal">shared</tt> member 
                    of the qualifying type, in which case the un-<tt class="literal">shared</tt>
                    declaration hides the <tt class="literal">shared</tt> member, or</p></li><li><p>if the qualifying type is an intersection type, in which case 
                    there may be multiple members which are not refined by another 
                    member, but where there is exactly one such member that is refined 
                    by each of these members, but is not refined by another member that 
                    is refined by all of these members, except</p></li><li><p>in the case of certain pathological intersection types, where 
                    two of the intersected types declare distinct members with the same 
                    name, that do not refine any member of a common supertype (in which 
                    case what we actually have are disjoint types that are nevertheless 
                    not considered provably disjoint within the rules of the typesystem), 
                    and in this case the qualified reference is considered illegal.</p></li></ul></div><p>Then the reference is to the unique member or nested class. If the 
            program element is contained in the body of a class or interface, and the 
            member declaration directly occurs in the body of the class or interface, 
            and the qualified reference is a value reference or callable reference, and 
            the receiver expression is a self reference to the instance being 
            initialized, then:</p><div class="itemizedlist"><ul type="disc"><li><p>the member declaration must be referenceable at the program
                    element,</p></li><li><p>the type of the member must be inferable to the program 
                    element, and</p></li><li><p>if the member declaration is forward-declared, it must be 
                    definitely initialized at the program element.</p></li></ul></div><p>As a special exception to the above, if the program element occurs inside 
            a <tt class="literal">dynamic</tt> block, and the the receiver expression has no type, 
            then the qualified reference does not refer to any statically typed declaration.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="patternsandvariables"></a>5.2.&nbsp;Patterns and variables</h2></div></div><div></div></div><p>Destructuring statements, assertions, and some control structures allow inline 
        declaration of a <span class="emphasis"><em>variables</em></span>, which often occur as part of a more
        complex <span class="emphasis"><em>pattern</em></span>.</p><i><span class="comment"><p>Note: the use of the term variable here does not imply any connection
        to the <tt class="literal">variable</tt> annotation for values. A variable in a destructuring
        statement, assertion, or control structure may not be assigned using a specification
        or assignment statement.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="controlstructurevariables"></a>5.2.1.&nbsp;Variables</h3></div></div><div></div></div><p>A variable is a streamlined form of reference declaration, as defined by 
            <a href="declarations.html#references" title="4.8.1.&nbsp;References">&sect;4.8.1 References</a>.</p><pre data-language="bnf">TypedVariable: Type MemberName</pre><p>In most cases, the explicit type be omitted.</p><pre data-language="bnf">Variable: (Type | "value")? MemberName</pre><p>If the explicit type is missing from the declaration, the type of the variable 
            is inferred, according to rules that depend upon the control structure to which 
            the variable belongs.</p><p>A variable declared by a destructuring statement is a reference scoped to the 
            body in which the destructuring statement occurs.</p><p>A variable declared by an assertion is a reference scoped to the body in which 
            the <tt class="literal">assert</tt> statement occurs.</p><p>A variable declared by a control structure is a reference scoped to the block 
            that immediately follows the variable declaration:</p><div class="itemizedlist"><ul type="disc"><li><p>For a variable in an <tt class="literal">if</tt> condition, the scope of the
                    variable is the <tt class="literal">if</tt> block.</p></li><li><p>For a variable in a <tt class="literal">while</tt> condition, the scope of the
                    variable is the <tt class="literal">while</tt> block.</p></li><li><p>For a variable in a <tt class="literal">for</tt> iterator, the scope of the
                    variable is the <tt class="literal">for</tt> block.</p></li><li><p>For a variable in a <tt class="literal">try</tt> clause, the scope of the 
                    variable is the <tt class="literal">try</tt> block.</p></li><li><p>For a variable in a <tt class="literal">catch</tt> clause, the scope of the 
                    variable is the <tt class="literal">catch</tt> block.</p></li><li><p>For a variable in an <tt class="literal">assert</tt> statement, the scope of the 
                    variable is the body containing the <tt class="literal">assert</tt> statement.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="patterns"></a>5.2.2.&nbsp;Patterns</h3></div></div><div></div></div><p>An expression whose type is an instantiation of <tt class="literal">Sequential</tt>, 
            <tt class="literal">Sequence</tt>, <tt class="literal">Tuple</tt>, or <tt class="literal">Entry</tt> 
            may be assigned to a <span class="emphasis"><em>pattern</em></span>. The type of an expression 
            assigned to a pattern is called the <span class="emphasis"><em>patterned type</em></span>.</p><i><span class="comment"><p>TODO: actually, the following section does not do justice to 
            the compiler, which can actually handle subtypes of these types, including
            type parameters upper bounded by these types.</p></span></i><p>Patterns are formed from:</p><div class="itemizedlist"><ul type="disc"><li><p>pattern variables,</p></li><li><p>tuple patterns, and</p></li><li><p>entry patterns.</p></li></ul></div><pre data-language="bnf">Pattern: Variable | TuplePattern | EntryPattern</pre><i><span class="comment"><p>Note: in a future release of the language, we might introduce
            a more general pattern matching system, allowing pattern matching against
            arbitrary classes.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="patternvariables"></a>5.2.3.&nbsp;Pattern variables</h3></div></div><div></div></div><p>A <span class="emphasis"><em>pattern variable</em></span> is just a variable, as 
            defined above, that occurs as in a pattern.</p><p>If the variable has an explicit type, then the patterned type
            must be assignable to this type. Otherwise, the type of the variable
            is inferred to be the patterned type.</p><p>A <span class="emphasis"><em>variadic pattern variable</em></span> is indicated
            with an asterisk.</p><pre data-language="bnf">VariadicVariable: UnionType? "*" MemberName</pre><p>Variadic pattern variables only occur in tuple patterns.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tuplepatterns"></a>5.2.4.&nbsp;Tuple patterns</h3></div></div><div></div></div><p>A tuple pattern comprises a list of <span class="emphasis"><em>element 
            patterns</em></span>, ending in, optionally, a variadic pattern 
            variable called a <span class="emphasis"><em>variadic</em></span> element pattern. 
            Tuple patterns are enclosed in brackets.</p><pre data-language="bnf">TuplePattern: "[" (Pattern ",")* (Pattern | VariadicVariable) "]"</pre><p>The patterned type must be an instantiation of the type
            <tt class="literal">Tuple</tt>, <tt class="literal">Sequential</tt>, or 
            <tt class="literal">Sequence</tt> in <tt class="literal">ceylon.language</tt>.
            Then:</p><div class="itemizedlist"><ul type="disc"><li><p>If the tuple pattern has only one element pattern, 
                    and it is variadic, then the patterned type of this variadic 
                    element pattern is just the patterned type of the surrounding 
                    tuple pattern.</p></li><li><p>Or, if the tuple pattern has only one element pattern, 
                    and it is not variadic, then the patterned type must be a 
                    single-element instantiation <tt class="literal">[T]</tt> of 
                    <tt class="literal">Tuple</tt>, and the patterned type of the
                    element pattern is <tt class="literal">T</tt>.</p></li><li><p>Otherwise, if the patterned type is an instantiation 
                    <tt class="literal">Tuple&lt;T,F,R&gt;</tt> of <tt class="literal">Tuple</tt>,
                    then the patterned type of the first element pattern is 
                    <tt class="literal">F</tt>, and the patterned types of the 
                    remaining element patterns, if any, are determined by 
                    forming a new tuple pattern with patterned type 
                    <tt class="literal">R</tt> by removing the first element pattern 
                    from the list of element patterns.</p></li><li><p>Or, if the patterned type is an instantiation 
                    <tt class="literal">[T+]</tt> of <tt class="literal">Sequence</tt>, 
                    then there must be exactly two element patterns, and the 
                    second element pattern must be variadic. Then the patterned 
                    type of the first element pattern is <tt class="literal">T</tt>, 
                    and the patterned type of the second element pattern is 
                    <tt class="literal">[T*]</tt>.</p></li></ul></div><pre data-language="ceylon">value [x, y, z] = [1.0, 2.0, 0.0];</pre><pre data-language="ceylon">value [first, *rest] = sequence;</pre><i><span class="comment"><p>Note: Ceylon does not support parallel assignment 
            statements of form <tt class="literal">value x, y, z = 1.0, 2.0, 0.0;</tt>
            since the infix <tt class="literal">=</tt> symbol has a higher precedence 
            than the comma <tt class="literal">,</tt> throughout the language.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="entrypatterns"></a>5.2.5.&nbsp;Entry patterns</h3></div></div><div></div></div><p>An entry pattern comprises a <span class="emphasis"><em>key pattern</em></span>,
            followed by an <span class="emphasis"><em>item pattern</em></span>.</p><pre data-language="bnf">EntryPattern: KeyOrItemPattern "-&gt;" KeyOrItemPattern</pre><pre data-language="bnf">KeyOrItemPattern: Variable | TuplePattern</pre><p>The patterned type must be an instantiation 
            <tt class="literal">K-&gt;V</tt> of the type <tt class="literal">Entry</tt> in 
            <tt class="literal">ceylon.language</tt>. Then:</p><div class="itemizedlist"><ul type="disc"><li><p>the patterned type of the key pattern is 
                    <tt class="literal">K</tt>, and</p></li><li><p>the patterned type of the item pattern is 
                    <tt class="literal">V</tt>.</p></li></ul></div><pre data-language="ceylon">value name-&gt;[lat,long] = observatory;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blocksandstatements"></a>5.3.&nbsp;Blocks and statements</h2></div></div><div></div></div><p>A <span class="emphasis"><em>block</em></span> is list of semicolon-delimited statements, 
        control structures, and declarations, surrounded by braces.</p><pre data-language="bnf">Block: "{" (Declaration | Statement)* "}"</pre><p>A <span class="emphasis"><em>statement</em></span> is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a destructuring statement,
        a control structure, a control directive, or an assertion.</p><pre data-language="bnf">Statement: ExpressionStatement | Specification | Destructure | Directive | ControlStructure | Dynamic</pre><p>A statement or declaration contained in a block may not evaluate a value, 
        invoke a function, instantiate a class, or extend a class whose declaration 
        occurs later in the block.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="expressionstatements"></a>5.3.1.&nbsp;Expression statements</h3></div></div><div></div></div><p>Only certain expressions are valid statements:</p><div class="itemizedlist"><ul type="disc"><li><p>assignment,</p></li><li><p>prefix or postfix increment or decrement,</p></li><li><p>invocation of a method,</p></li><li><p>instantiation of a class.</p></li></ul></div><pre data-language="bnf">ExpressionStatement: ( Assignment | IncrementOrDecrement | Invocation ) ";"</pre><p>For example:</p><pre data-language="ceylon">x += 1;</pre><pre data-language="ceylon">x++;</pre><pre data-language="ceylon">print("Hello");</pre><pre data-language="ceylon">Main(process.arguments);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="controldirectives"></a>5.3.2.&nbsp;Control directives</h3></div></div><div></div></div><p>A <span class="emphasis"><em>control directive</em></span> statement ends execution of the 
            current block and forces the flow of execution to resume in some outer scope. 
            They may only occur as the lexically last statement of a block.</p><p>There are four control directives:</p><div class="itemizedlist"><ul type="disc"><li>the <tt class="literal">return</tt> directive&#8212;to return a value from 
                a getter or non-<tt class="literal">void</tt> function or terminate execution of a 
                setter, class initializer, or <tt class="literal">void</tt> method,</li><li>the <tt class="literal">break</tt> directive&#8212;to terminate a loop,</li><li>the <tt class="literal">continue</tt> directive&#8212;to jump to the next 
                iteration of a loop, and</li><li>the <tt class="literal">throw</tt> directive&#8212;to raise an exception.</li></ul></div><pre data-language="bnf">Directive: (Return | Throw | Break | Continue) ";"</pre><p>For example:</p><pre data-language="ceylon">throw Exception();</pre><pre data-language="ceylon">return x+y;</pre><pre data-language="ceylon">break;</pre><pre data-language="ceylon">continue;</pre><p>The <tt class="literal">return</tt> directive must sequentially occur in the body 
            of a function, getter, setter, or class initializer. In the case of a 
            setter, class initializer, or <tt class="literal">void</tt> function, no expression may 
            be specified. In the case of a getter or non-<tt class="literal">void</tt> function, an 
            expression must be specified. The expression type must be assignable to the return 
            type of the function or the type of the value. When the directive is executed, the 
            expression is evaluated to determine the return value of the function or getter.</p><pre data-language="bnf">Return: "return" Expression?</pre><p>If the specified expression has no type, or if the function or getter has
            no type, and the directive occurs within a <tt class="literal">dynamic</tt> block, then 
            the directive is not type-checked at compile time.</p><i><span class="comment"><p>Note: a <tt class="literal">return</tt> statement returns only from the
            innermost function, getter, setter, or class initializer, even in the case of a
            nested or anonymous function. There are no "non-local returns" in the language.</p></span></i><p>The <tt class="literal">break</tt> directive must sequentially occur in the body 
            of a loop.</p><pre data-language="bnf">Break: "break"</pre><p>The <tt class="literal">continue</tt> directive must sequentially occur in the body 
            of a loop.</p><pre data-language="bnf">Continue: "continue"</pre><p>A <tt class="literal">throw</tt> directive may appear anywhere and may specify an 
            expression, whose type must be a subtype of type <tt class="literal">Throwable</tt> 
            defined in <tt class="literal">ceylon.language</tt>. When the directive is executed, the 
            expression is evaluated and the resulting exception is thrown. If no expression is 
            specified, the directive is equivalent to <tt class="literal">throw Exception()</tt>.</p><pre data-language="bnf">Throw: "throw" Expression?</pre><p>If the specified expression has no type, and the directive occurs within a 
            <tt class="literal">dynamic</tt> block, then the directive is not type-checked at compile 
            time.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="specificationstatements"></a>5.3.3.&nbsp;Specification statements</h3></div></div><div></div></div><p>A <span class="emphasis"><em>specification</em></span> statement may specify or initialize the 
            persistent value of a forward-declared reference, or specify the implementation of 
            a forward-declared getter or function.</p><pre data-language="bnf">Specification: ValueSpecification | LazySpecification</pre><p>The persistent value of a forward-declared reference or the implementation 
            of a forward-declared function may be specified by a <span class="emphasis"><em>value specification 
            statement</em></span>. The value specification statement consists of an unqualified 
            value reference, or a qualified value reference where the receiver expression is
            <tt class="literal">this</tt>, and an ordinary <tt class="literal">=</tt> specifier. The value 
            reference must refer to a declaration which sequentially occurs earlier in the body 
            in which the specification statement occurs.</p><pre data-language="bnf">ValueSpecification: ("this" ".")? MemberName Specifier ";"</pre><p>The type of the specified expression must be assignable to the type of the 
            reference, or to the callable type of the function.</p><p>If the specified expression has no type, or if the reference or function has 
            no type, and the specification occurs within a <tt class="literal">dynamic</tt> block, 
            then the specification is not type-checked at compile time.</p><pre data-language="ceylon">String greeting;
if (exists name) {
    greeting = "hello ``name``";
}
else {
    greeting = "hello world";
}</pre><pre data-language="ceylon">String process(String input);
if (normalize) {
    process = String.normalized;
}
else {
    process = (String s) =&gt; s;
}</pre><i><span class="comment"><p>Note: there is an apparent ambiguity here. Is the statement
            <tt class="literal">x=1;</tt> a value specification statement, or an assignment 
            expression statement? The language resolves this ambiguity by favoring the
            interpretation as a specification statement whenever that interpretation is
            viable. This is a transparent solution, since it accepts strictly more code 
            than the alternative interpretation, and for ambiguous cases the actual 
            semantics are identical between the two interpretations.</p></span></i><p>The implementation of forward-declared getter or function may be
            specified using a <span class="emphasis"><em>lazy specification statement</em></span>. The 
            specification statement consists of either:</p><div class="itemizedlist"><ul type="disc"><li><p>an unqualified value reference, or a qualified value reference 
                    where the receiver expression is `this`, and a lazy 
                    <tt class="literal">=&gt;</tt> specifier, or</p></li><li><p>a unqualified callable reference, or a qualified value reference 
                    where the receiver expression is `this`, one or more parameter lists, 
                    and a lazy specifier.</p></li></ul></div><p>The value reference or callable reference must refer to a declaration 
            which sequentially occurs earlier in the body in which the specification 
            statement occurs.</p><p>A callable reference followed by a parameter list is itself considered 
            a callable reference, called a <span class="emphasis"><em>parameterized reference</em></span>. 
            If the parameter list has type <tt class="literal">P</tt> then the callable reference 
            must have the exact type <tt class="literal">R(*P)</tt> for some type 
            <tt class="literal">R</tt>. Then the type of the parameterized reference is
            <tt class="literal">R</tt>.</p><pre data-language="bnf">ParameterizedReference: ("this" ".")? MemberName Parameters+</pre><p>Thus, the specification statement consists of a parameterized reference
            followed by a lazy specifier.</p><pre data-language="bnf">LazySpecification: (MemberName | ParameterizedReference) LazySpecifier ";"</pre><p>The type of the specified expression must be assignable to the type of 
            the parameterized reference, or to the type of the value reference.</p><pre data-language="ceylon">String greeting;
if (exists name) {
    greeting =&gt; "hello ``name``";
}
else {
    greeting =&gt; "hello world";
}</pre><pre data-language="ceylon">String process(String input);
if (normalize) {
    process(String input) =&gt; input.normalized;
}
else {
    process(String s) =&gt; s;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="destructuringstatements"></a>5.3.4.&nbsp;Destructuring statements</h3></div></div><div></div></div><p>A <span class="emphasis"><em>destructuring statement</em></span> assigns an expression 
            to a pattern, as defined above in <a href="statementblocks.html#patterns" title="5.2.2.&nbsp;Patterns">&sect;5.2.2 Patterns</a>.</p><pre data-language="bnf">Destructure: "value" (TuplePattern | EntryPattern) Specifier ";"</pre><p>The type of the specified expression is the patterned type of the
            tuple or entry pattern.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicblocks"></a>5.3.5.&nbsp;Dynamic blocks</h3></div></div><div></div></div><p>A <tt class="literal">dynamic</tt> block allows interoperation with 
            dynamically typed native code.</p><pre data-language="bnf">Dynamic: "dynamic" Block</pre><p>Inside a <tt class="literal">dynamic</tt> block an expression may have 
            no type, as specified in <a href="expressions.html" title="Chapter&nbsp;6.&nbsp;Expressions">Chapter&nbsp;6, <i>Expressions</i></a>.</p><p>An expression with no type:</p><div class="itemizedlist"><ul type="disc"><li><p>may be specified or assigned to a typed value, as defined
                    in <a href="statementblocks.html#specificationstatements" title="5.3.3.&nbsp;Specification statements">&sect;5.3.3 Specification statements</a>,</p></li><li><p>may be passed as the argument of a typed parameter in an
                    invocation expression, as defined in 
                    <a href="expressions.html#directinvocations" title="6.6.1.&nbsp;Direct invocations">&sect;6.6.1 Direct invocations</a>,</p></li><li><p>may be the invoked expression of an invocation, as defined
                    in <a href="expressions.html#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>,</p></li><li><p>may be returned by a typed function or getter, or
                    thrown as an exception, as defined in 
                    <a href="statementblocks.html#controldirectives" title="5.3.2.&nbsp;Control directives">&sect;5.3.2 Control directives</a>,</p></li><li><p>may be the operand of an operator expression, as defined in
                    <a href="expressions.html#compoundexpressions" title="6.5.&nbsp;Compound expressions">&sect;6.5 Compound expressions</a>, or</p></li><li><p>may be the subject of a control structure condition, as 
                    defined in <a href="statementblocks.html#controlstructureconditions" title="5.4.&nbsp;Conditions">&sect;5.4 Conditions</a>, a 
                    <tt class="literal">switch</tt>, as defined in <a href="statementblocks.html#switchcaseelse" title="5.5.2.&nbsp;switch/case/else">&sect;5.5.2 switch/case/else</a>, 
                    or a <tt class="literal">for</tt> iterator, as defined in <a href="statementblocks.html#forelse" title="5.5.3.&nbsp;for/else">&sect;5.5.3 for/else</a>.
                    </p></li></ul></div><p>Furthermore:</p><div class="itemizedlist"><ul type="disc"><li><p>a qualified or unqualified reference may not refer to a
                    statically typed declaration, as defined by 
                    <a href="statementblocks.html#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a> and
                    <a href="statementblocks.html#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.</p></li></ul></div><p>These situations result in <span class="emphasis"><em>dynamic type checking</em></span>,
            as defined in <a href="execution.html#dynamictypechecking" title="8.3.6.&nbsp;Dynamic type checking">&sect;8.3.6 Dynamic type checking</a>, since the usual static
            type checks are impossible.</p><i><span class="comment"><p>Note: within a <tt class="literal">dynamic</tt> block, Ceylon behaves like
            a language with optional static typing, performing static type checks where possible,
            and dynamic type checking where necessary.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="definitereturn"></a>5.3.6.&nbsp;Definite return</h3></div></div><div></div></div><p>A sequence of statements may <span class="emphasis"><em>definitely return.</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>A sequence of statements definitely returns if it ends in a 
                    <tt class="literal">return</tt> or <tt class="literal">throw</tt> directive, or 
                    in a control structure that definitely returns, or contains an
                    assertion with a condition list that is never satisfied.</p></li><li><p>A body definitely returns if it contains a list of statements
                    that definitely returns.</p></li><li><p>An <tt class="literal">if</tt> conditional definitely returns if it has
                    an <tt class="literal">else</tt> block and both the <tt class="literal">if</tt>
                    and <tt class="literal">else</tt> blocks definitely return, or if its 
                    condition list is always satisfied and the <tt class="literal">if</tt> block
                    definitely returns, or if its condition list is never satisfied and it 
                    has an <tt class="literal">else</tt> block that definitely returns.</p></li><li><p>A <tt class="literal">switch</tt> conditional definitely returns if all
                    <tt class="literal">case</tt> blocks definitely return and the <tt class="literal">else</tt> 
                    block, if any, definitely returns.</p></li><li><p>A <tt class="literal">for</tt> loop definitely returns if it has an
                    <tt class="literal">else</tt> block that definitely returns, and there is
                    no <tt class="literal">break</tt> directive in the <tt class="literal">for</tt>
                    block, or if the iterated expression type is a nonempty type, and
                    the <tt class="literal">for</tt> block definitely returns.</p></li><li><p>A <tt class="literal">while</tt> loop definitely returns if its
                    condition list is always satisfied and the <tt class="literal">while</tt> 
                    block definitely returns.</p></li><li><p>A <tt class="literal">try/catch</tt> exception manager definitely 
                    returns if the <tt class="literal">try</tt> block definitely returns and
                    all <tt class="literal">catch</tt> blocks definitely return or if the
                    <tt class="literal">finally</tt> block definitely returns.</p></li></ul></div><p>The body of a non-<tt class="literal">void</tt> method or getter must definitely 
            return.</p><p>A body may not contain an additional statement, control structure, or
            declaration following a sequence of statements that definitely returns. Such a 
            statement, control structure, or declaration is considered 
            <span class="emphasis"><em>unreachable</em></span>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="definiteinitialization"></a>5.3.7.&nbsp;Definite initialization</h3></div></div><div></div></div><p>A sequence of statements may <span class="emphasis"><em>definitely initialize</em></span> a
            forward-declared declaration.</p><div class="itemizedlist"><ul type="disc"><li><p>A sequence of statements definitely initializes a declaration if 
                    one of the statements is a specification statement or assigment 
                    expression for the declaration or a control structure that definitely 
                    initializes the declaration, or if the sequence of statements ends in 
                    a <tt class="literal">return</tt> or <tt class="literal">throw</tt> directive, or 
                    contains an assertion with a condition list that is never satisfied.</p></li><li><p>An <tt class="literal">if</tt> conditional definitely initializes a 
                    declaration if it has an <tt class="literal">else</tt> block and both the 
                    <tt class="literal">if</tt> and <tt class="literal">else</tt> blocks definitely
                    initialize the declaration, of if its condition list is always satisfied
                    and the <tt class="literal">if</tt> block definitely initializes the declaration,
                    of if its condition list is never satisfied and it has an 
                    <tt class="literal">else</tt> block that definitely initializes the 
                    declaration.</p></li><li><p>A <tt class="literal">switch</tt> conditional definitely initializes a
                    declaration if all <tt class="literal">case</tt> blocks definitely initialize 
                    the declaration and the <tt class="literal">else</tt> block, if any, definitely 
                    initializes the declaration.</p></li><li><p>A <tt class="literal">for</tt> loop definitely initializes a declaration 
                    if it has an <tt class="literal">else</tt> block that definitely initializes 
                    the declaration, and there is no <tt class="literal">break</tt> directive in 
                    the <tt class="literal">for</tt> block, or if the iterated expression type is 
                    a nonempty type, and the <tt class="literal">for</tt> block definitely 
                    initializes the declaration.</p></li><li><p>A <tt class="literal">while</tt> loop definitely initializes a declaration
                    if its condition list is always satisfied and the <tt class="literal">while</tt>
                    block definitely initializes the declaration.</p></li><li><p>A <tt class="literal">try/catch</tt> exception manager definitely initializes 
                    a declaration if the <tt class="literal">try</tt> block definitely initializes the 
                    declaration and all <tt class="literal">catch</tt> blocks definitely initialize the 
                    declaration or if the <tt class="literal">finally</tt> block definitely initializes 
                    the declaration.</p></li><li><p>A constructor of a class definitely initializes a declaration if the 
                    body of the constructor definitely initializes the declaration, or if the 
                    constructor delegates to a constructor which definitely initializes the 
                    declaration.</p></li><li><p>The constructors of a class definitely initialize a declaration if
                    every non-partial constructor of the class definitely initializes the 
                    declaration.</p></li></ul></div><i><span class="comment"><p>TODO: an assignment expression occurring within a containing expression
            may or may not definitely initialize a value. Specify this!</p></span></i><p>If a function or value declaration is referenceable at a certain statement or 
            declaration, it may additionally be considered <span class="emphasis"><em>definitely initialized</em></span> 
            at that statement or declaration.</p><p>If a function declaration is definitely initialized at a certain statement or 
            declaration if it is referenceable at that statement or declaration and:</p><div class="itemizedlist"><ul type="disc"><li><p>it is a parameter,</p></li><li><p>it is not forward-declared, or</p></li><li><p>it is forward-declared and is definitely initialized by the sequence of 
                    statements from its declaration to the given statement or declaration.</p></li></ul></div><p>As an exception, a member of a class is not considered definitely initialized
            within the <tt class="literal">extends</tt> clause of the class or of any of its 
            constructors.</p><p>If a value declaration is definitely initialized at a certain statement or 
            declaration if it is referenceable at that statement or declaration and:</p><div class="itemizedlist"><ul type="disc"><li><p>it is a parameter,</p></li><li><p>it is not forward-declared and the given statement or declaration is not 
                    the value declaration itself, and does not occur within the body of the value 
                    declaration, or</p></li><li><p>it is forward-declared and is definitely initialized by the sequence of 
                    statements from its declaration to the given statement or declaration.</p></li></ul></div><p>A function or value declaration must be definitely initialized wherever any 
            value reference or callable reference to it occurs as an expression within the body 
            in which it is declared.</p><p>A <tt class="literal">shared</tt> forward-declared declaration belonging to a class 
            and not annotated <tt class="literal">late</tt> must be definitely initialized:</p><div class="itemizedlist"><ul type="disc"><li><p>at every <tt class="literal">return</tt> statement of the initializer of the 
                    containing class, and</p></li><li><p>at the end of the very last expression statement, directive statement, 
                    constructor, or specification statement of the initializer of the containing 
                    class.</p></li></ul></div><p>A specification statement for a method or non-<tt class="literal">variable</tt> 
            reference, getter, or function may not (indirectly) occur in a <tt class="literal">for</tt> 
            or <tt class="literal">while</tt> block unless the declaration itself occurs within the same
            <tt class="literal">for</tt> or <tt class="literal">while</tt> block.</p><i><span class="comment"><p>TODO: Furthermore, the typechecker does some tricky analysis to
            determine that code like the following can be accepted:</p>
            <pre data-language="ceylon">Boolean minors;
for (p in people) {
    if (p.age&lt;18) {
        minors = true;
        break;
    }
}
else {
    minors = false;
}</pre></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="definiteuninitialization"></a>5.3.8.&nbsp;Definite uninitialization</h3></div></div><div></div></div><p>A sequence of statements may <span class="emphasis"><em>possibly initialize</em></span> a 
            forward-declared declaration.</p><div class="itemizedlist"><ul type="disc"><li><p>A sequence of statements possibly initializes a declaration if one of 
                    the statements is a specification statement for the declaration or a control 
                    structure that possibly initializes the declaration.</p></li><li><p>An <tt class="literal">if</tt> conditional possibly initializes a declaration 
                    if either the <tt class="literal">if</tt> block possibly initializes the declaration 
                    and the condition list is not never satisfied, or if the <tt class="literal">else</tt> 
                    block, if any, possibly initializes the declaration and the condition list is 
                    not always satisfied.</p></li><li><p>A <tt class="literal">switch</tt> conditional possibly initializes a declaration 
                    if one of the <tt class="literal">case</tt> blocks possibly initializes the declaration 
                    or the <tt class="literal">else</tt> block, if any, possibly initializes the 
                    declaration.</p></li><li><p>A <tt class="literal">for</tt> loop possibly initializes a declaration if the 
                    <tt class="literal">for</tt> block possibly initializes the declaration or if it has 
                    an <tt class="literal">else</tt> block that possibly initializes the declaration.</p></li><li><p>A <tt class="literal">while</tt> loop possibly initializes a declaration if the 
                    <tt class="literal">while</tt> block possibly initializes the declaration and the
                    condition list is not never satisfied.</p></li><li><p>A <tt class="literal">try/catch</tt> exception manager possibly initializes a 
                    declaration if the <tt class="literal">try</tt> block possibly initializes the 
                    declaration, if one of the <tt class="literal">catch</tt> blocks possibly initializes 
                    the declaration, or if the <tt class="literal">finally</tt> block possibly initializes 
                    the declaration.</p></li><li><p>A constructor of a class possibly initializes a declaration if the body 
                    of the constructor possibly initializes the declaration, or if the constructor 
                    delegates to a constructor which possibly initializes the declaration.</p></li><li><p>The constructors of a class possibly initialize a declaration if at least 
                    one constructor of the class possibly initializes the declaration.</p></li></ul></div><p>A forward-declared declaration is considered <span class="emphasis"><em>definitely uninitialized</em></span> 
            at a certain statement or declaration if:</p><div class="itemizedlist"><ul type="disc"><li><p>it is not possibly initialized by the sequence of statements from its declaration 
                    to the given statement or declaration,</p></li><li><p>the statement does not (indirectly) occur in the <tt class="literal">for</tt> block or
                    <tt class="literal">else</tt> block of a <tt class="literal">for</tt> loop with a <tt class="literal">for</tt> 
                    block that possibly initializes it,</p></li><li><p>the statement does not (indirectly) occur in the <tt class="literal">while</tt> block of 
                    a <tt class="literal">while</tt> loop with a <tt class="literal">while</tt> block that possibly 
                    initializes it,</p></li><li><p>the statement does not (indirectly) occur in a <tt class="literal">catch</tt> block 
                    of a <tt class="literal">try/catch</tt> exception manager with a <tt class="literal">try</tt> block 
                    that possibly initializes it, and</p></li><li><p>the statement does not (indirectly) occur in the <tt class="literal">finally</tt> block 
                    of a <tt class="literal">try/catch</tt> exception manager with a <tt class="literal">try</tt> block 
                    or <tt class="literal">catch</tt> block that possibly initializes it.</p></li></ul></div><p>A function or non-<tt class="literal">variable</tt> value declaration must be definitely 
            uninitialized wherever any value reference or callable reference to it occurs as a specification 
            statement within the body in which it is declared.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="controlstructureconditions"></a>5.4.&nbsp;Conditions</h2></div></div><div></div></div><p>Assertions and certain control structures have a <span class="emphasis"><em>condition list</em></span>. 
        A condition list has one or more <span class="emphasis"><em>conditions</em></span>.</p><pre data-language="bnf">ConditionList: "(" Condition ("," Condition)* ")"</pre><p>Any condition in the list may refer to a variable defined in a condition that occurs
        earlier in the list.</p><p>A condition list is considered to be <span class="emphasis"><em>always satisfied</em></span> if
        every condition in the list is always satisfied. A condition list is considered to be 
        <span class="emphasis"><em>never satisfied</em></span> if some condition in the list is never satisfied.</p><p>There are four kinds of condition:</p><div class="itemizedlist"><ul type="disc"><li><p>a <span class="emphasis"><em>boolean condition</em></span> is satisfied when a boolean expression
                evaluates to <tt class="literal">true</tt>,</p></li><li><p>an <span class="emphasis"><em>assignabilty condition</em></span> is satisfied when an expression
                 evaluates to an instance of a specified type,</p></li><li><p>an <span class="emphasis"><em>existence condition</em></span> is satisfied when an expression 
                evaluates to a non-null value, and</p></li><li><p>a <span class="emphasis"><em>nonemptiness condition</em></span> is satisfied when an expression 
                evaluates to a non-null, non-empty value.</p></li></ul></div><pre data-language="bnf">Condition: BooleanCondition | IsCondition | ExistsOrNonemptyCondition</pre><i><span class="comment"><p>TODO: are we going to support <tt class="literal">satisfies</tt> conditions on 
        type parameters, for example, <tt class="literal">if (Element satisfies Object)</tt>, to allow
        refinement of its upper bounds?</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="booleanconditions"></a>5.4.1.&nbsp;Boolean conditions</h3></div></div><div></div></div><p>A boolean condition is just an expression.</p><pre data-language="bnf">BooleanCondition: Expression</pre><p>The expression must be of type <tt class="literal">Boolean</tt>.</p><p>A boolean condition is considered to be <span class="emphasis"><em>always satisfied</em></span>
            if it is a value reference to <tt class="literal">true</tt>. A boolean condition is 
            considered to be <span class="emphasis"><em>never satisfied</em></span> if it is a value reference 
            to <tt class="literal">false</tt>.</p><i><span class="comment"><p>TODO: Should we do some more sophisticated static analysis to 
            determine if a condition is always/never satisfied?</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assignabilityconditions"></a>5.4.2.&nbsp;Assignability conditions</h3></div></div><div></div></div><p>An assignability condition may contain either:</p><div class="itemizedlist"><ul type="disc"><li><p>an unqualified value reference to a non-<tt class="literal">variable</tt>,
                    non-<tt class="literal">default</tt> reference, or</p></li><li><p>an inline variable declaration together with an expression.</p></li></ul></div><pre data-language="bnf">IsCondition: "!"? "is" (TypedVariable Specifier | Type MemberName)</pre><p>A <span class="emphasis"><em>negated</em></span> assignability condition is one which starts 
            with <tt class="literal">!</tt>.</p><i><span class="comment"><p>Note: the prefix form <tt class="literal">is Type val</tt> reads a 
            little unnaturally in English. But for a condition with a specifier, the 
            form <tt class="literal">is Type val = expression</tt> is much less ambiguous than
            <tt class="literal">val = expression is Type</tt>, which looks like an assignment
            of a boolean value.</p></span></i><i><span class="comment"><p>TODO: are we going to allow <tt class="literal">is Type this</tt> and 
            <tt class="literal">is Type outer</tt> to narrow the type of a self reference?</p></span></i><p>The type of the value reference or expression in an assignability condition 
            must be:</p><div class="itemizedlist"><ul type="disc"><li><p>in the case of a condition which is not negated, a type which is not 
                    a subtype of the specified type, but whose intersection with the specified 
                    type is not exactly <tt class="literal">Nothing</tt>, except</p></li><li><p>in the case of a negated condition, a type whose intersection with the 
                    specified type is not exactly <tt class="literal">Nothing</tt>, and which is not a 
                    supertype of the specified type, or</p></li></ul></div><i><span class="comment"><p>Note: an assignability condition may narrow to an intersection or union 
            type.</p>
            <pre data-language="ceylon">if (is Printable&amp;Identifiable obj) { ... }</pre>
            <pre data-language="ceylon">if (is Integer|Float num) { ... }</pre></span></i><p>For an assignability condition with a conditional expression of type 
            <tt class="literal">T</tt> and specified type <tt class="literal">X</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition contains a value reference, the value will be treated 
                    by the compiler as having type <tt class="literal">T&amp;X</tt> inside the block or 
                    expression that immediately follows the condition, and, if this is the only 
                    condition in the condition list, as having type <tt class="literal">T~X</tt> inside 
                    the following <tt class="literal">else</tt> block or expression if any, unless</p></li><li><p>it is a <tt class="literal">!is</tt> negated assignability condition, in which 
                    case the value will be treated by the compiler as having type <tt class="literal">T~X</tt> 
                    inside the block or expression that immediately follows the condition, and, if 
                    this is the only condition in the condition list, as having type 
                    <tt class="literal">T&amp;X</tt> inside the following <tt class="literal">else</tt> block 
                    or expression if any.</p></li></ul></div><p>Where, for any given types <tt class="literal">T</tt> and <tt class="literal">X</tt>, the type
            <tt class="literal">T~X</tt> is determined as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if <tt class="literal">X</tt> covers <tt class="literal">T</tt>, as defined by
                    <a href="typesystem.html#coverage" title="3.4.1.&nbsp;Coverage">&sect;3.4.1 Coverage</a>, then <tt class="literal">T~X</tt> is 
                    <tt class="literal">Nothing</tt>,</p></li><li><p>if <tt class="literal">T</tt> is an intersection type, then <tt class="literal">T~X</tt> 
                    is the intersection of all <tt class="literal">U~X</tt> for every type <tt class="literal">U</tt> 
                    in the intersection,</p></li><li><p>if <tt class="literal">T</tt> is a union type, then <tt class="literal">T~X</tt> is 
                    the union of all <tt class="literal">U~X</tt> for every type <tt class="literal">U</tt> in 
                    the union,</p></li><li><p>if <tt class="literal">T</tt> is a type parameter, then <tt class="literal">T~X</tt> 
                    is <tt class="literal">T&amp;&lt;U~X&gt;</tt> when <tt class="literal">U</tt> is the 
                    intersection of all upper bounds on <tt class="literal">T</tt>, or <tt class="literal">Anything</tt> 
                    if <tt class="literal">T</tt> has no declared upper bounds,</p></li><li><p>if <tt class="literal">T</tt> is an enumerated type or an instantiation of a 
                    generic enumerated type, then <tt class="literal">T~X</tt> is the union of all 
                    <tt class="literal">C~X</tt> for every case <tt class="literal">C</tt> of 
                    <tt class="literal">T</tt>, or,</p></li><li><p>otherwise, <tt class="literal">T~X</tt> is <tt class="literal">T</tt>.</p></li></ul></div><p>If you prefer, you can think of the following:</p><pre data-language="ceylon">Transaction tx = ...
if (is Usable tx) { ... }</pre><p>As an abbreviation of:</p><pre data-language="ceylon">if (is Transaction&amp;Usable tx = tx) { ... }</pre><p>Where the <tt class="literal">tx</tt> declared by the condition hides the outer 
            declaration of <tt class="literal">tx</tt> inside the block that follows.</p><p>As a special exception to the above, if a condition occurs in a 
            <tt class="literal">dynamic</tt> block, and the conditional expression has no type, 
            and the condition contains a value reference, 
            then:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition is not negated, the value will be treated by the 
                    compiler as having type <tt class="literal">X</tt> where <tt class="literal">X</tt> 
                    is the specified type, inside the block or expression that immediately 
                    follows the condition, or, otherwise</p></li><li><p>if the condition is negated, the value will be treated by the compiler 
                    as having no type.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="existencenonemptinessconditions"></a>5.4.3.&nbsp;Existence and nonemptiness conditions</h3></div></div><div></div></div><p>An existence or nonemptiness condition may contain either:</p><div class="itemizedlist"><ul type="disc"><li><p>an unqualified value reference to a non-<tt class="literal">variable</tt>,
                    non-<tt class="literal">default</tt> reference, or</p></li><li><p>a pattern together with an expression.</p></li></ul></div><pre data-language="bnf">ExistsOrNonemptyCondition: "!"? ("exists" | "nonempty") (Pattern Specifier | MemberName)</pre><p>A <span class="emphasis"><em>negated</em></span> condition is one which starts with 
            <tt class="literal">!</tt>.</p><p>The type of the value reference or expression must be:</p><div class="itemizedlist"><ul type="disc"><li><p>in the case of an existence condition or negated existence condition, 
                    a type whose intersection with <tt class="literal">Null</tt> is not exactly 
                    <tt class="literal">Nothing</tt> and whose intersection with <tt class="literal">Object</tt> 
                    is not exactly <tt class="literal">Nothing</tt>, or</p></li><li><p>in the case of a nonemptiness condition or a negated nonemptiness 
                    condition, a subtype of <tt class="literal">Anything[]?</tt> whose intersection with 
                    <tt class="literal">[]</tt> is not exactly <tt class="literal">Nothing</tt>, and whose 
                    intersection with <tt class="literal">[Nothing+]</tt> is not exactly 
                    <tt class="literal">Nothing</tt>.</p></li></ul></div><p>Every existence or nonemptiness condition is equivalent to&#8212;and may be 
            considered an abbreviation of&#8212;an assignability condition:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">exists x</tt> is equivalent to <tt class="literal">is Object x</tt>, 
                    and</p></li><li><p><tt class="literal">!exists x</tt> is equivalent to <tt class="literal">is Null x</tt>,</p></li><li><p><tt class="literal">nonempty x</tt> is equivalent to <tt class="literal">is [E+] x</tt>
                    where <tt class="literal">x</tt> is an expression whose type has the principal 
                    instantiation <tt class="literal">E[]?</tt>, and</p></li><li><p><tt class="literal">!nonempty x</tt> is equivalent to <tt class="literal">is [] x</tt>.</p></li></ul></div><p>For an existence condition which is not negated:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition has a pattern, the patterned type is 
                    <tt class="literal">T&amp;Object</tt>, where the specifier expression is of type 
                    <tt class="literal">T</tt>, and, if the pattern is a pattern variable, the declared 
                    type of the variable, if any, must be a subtype of <tt class="literal">Object</tt>, 
                    or</p></li><li><p>if the condition contains a value reference, the value will be treated 
                    by the compiler as having type <tt class="literal">T&amp;Object</tt> inside the block 
                    or expression that immediately follows the condition, where the conditional 
                    expression is of type <tt class="literal">T</tt>, and, if this is the only condition 
                    in the condition list, as having the type <tt class="literal">T&amp;Null</tt> inside 
                    the following <tt class="literal">else</tt> block or expression if any.</p></li></ul></div><p>For a negated existence condition:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition has a pattern, it must be a pattern variable, and the
                    patterned type is <tt class="literal">T&amp;Null</tt>, where the specifier expression 
                    is of type <tt class="literal">T</tt>, and the declared type of the variable, if any, 
                    must be <tt class="literal">Null</tt>, or</p></li><li><p>if the condition contains a value reference, the value will be treated 
                    by the compiler as having type <tt class="literal">T&amp;Null</tt> inside the block 
                    or expression that immediately follows the condition, where the conditional 
                    expression is of type <tt class="literal">T</tt>, and, if this is the only condition 
                    in the condition list, as having the type <tt class="literal">T&amp;Object</tt> 
                    inside the following <tt class="literal">else</tt> block or expression if any.</p></li></ul></div><p>For a nonemptiness condition which is not negated:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition has a pattern, the patterned type is
                    <tt class="literal">T&amp;[E+]</tt>, where the specifier expression is of type 
                    <tt class="literal">T</tt> and <tt class="literal">T</tt> has the principal instantiation 
                    <tt class="literal">E[]?</tt>, and, if the pattern is a pattern variable, the declared 
                    type of the variable, if any, must be a subtype of <tt class="literal">[Anything+]</tt>, 
                    or</p></li><li><p>if the condition contains a value reference, the value will be treated 
                    by the compiler as having type <tt class="literal">T&amp;[E+]</tt> inside the block 
                    or expression that immediately follows the condition, where the conditional 
                    expression is of type <tt class="literal">T</tt> and <tt class="literal">T</tt> has the 
                    principal instantiation <tt class="literal">E[]?</tt>, and, if this is the only 
                    condition in the condition list, as having the type <tt class="literal">T&amp;[]</tt> 
                    inside the following <tt class="literal">else</tt> block or expression if any.</p></li></ul></div><p>For a negated nonemptiness condition:</p><div class="itemizedlist"><ul type="disc"><li><p>if the condition has a pattern, it must be a pattern variable, and the
                    patterned type is <tt class="literal">T&amp;[]</tt>, where the specifier expression is 
                    of type <tt class="literal">T</tt> and <tt class="literal">T</tt> has the principal 
                    instantiation <tt class="literal">E[]?</tt>, and the declared type of the variable,
                    if any, must be <tt class="literal">[]</tt>, or</p></li><li><p>if the condition contains a value reference, the value will be treated 
                    by the compiler as having type <tt class="literal">T&amp;[]</tt> inside the block or 
                    expression that immediately follows the condition, where the conditional 
                    expression is of type <tt class="literal">T</tt> and <tt class="literal">T</tt> has the 
                    principal instantiation <tt class="literal">E[]?</tt>, and, if this is the only 
                    condition in the condition list, as having the type <tt class="literal">T&amp;[E+]</tt> 
                    inside the following <tt class="literal">else</tt> block or expression if any.</p></li></ul></div><p>If you prefer, you can think of the following:</p><pre data-language="ceylon">if (exists name) { ... }</pre><p>As an abbreviation of:</p><pre data-language="ceylon">if (exists String name = name) { ... }</pre><p>Where the <tt class="literal">name</tt> declared by the condition hides the outer 
            declaration of <tt class="literal">name</tt> inside the block that follows.</p><p>As a special exception to the above, if a condition occurs in a <tt class="literal">dynamic</tt> 
            block, and the conditional expression has no type, and the condition contains a value reference, 
            then the value will be treated by the compiler as having no type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="caseconditions"></a>5.4.4.&nbsp;Case conditions</h3></div></div><div></div></div><p>The branches of a <tt class="literal">switch</tt> conditional each belong to a 
            <span class="emphasis"><em>case condition</em></span>. There are two kinds of case condition:</p><div class="itemizedlist"><ul type="disc"><li><p>a <span class="emphasis"><em>value case</em></span>&#8212;a list of string literals, 
                    character literals, integer literals, negated integer literals, value 
                    references to value constructors, and/or value references to anonymous 
                    classes, or</p></li><li><p>a <span class="emphasis"><em>type case</em></span>&#8212;an assignability condition 
                    of form <tt class="literal">is V</tt> for some type <tt class="literal">V</tt>.</p></li></ul></div><p>For a value case, each value reference must be to:</p><div class="itemizedlist"><ul type="disc"><li><p>a toplevel anonymous class that is a subtype of 
                    <tt class="literal">Identifiable|Null</tt>, or</p></li><li><p>a value constructor of a toplevel class that is a subtype of 
                    <tt class="literal">Identifiable</tt>.</p></li></ul></div><pre data-language="bnf">CaseCondition: "(" (ValueCase | TypeCase) ")"</pre><pre data-language="bnf">ValueCase: CaseValue ("|" CaseValue)*</pre><pre data-language="bnf">TypeCase: "is" Type</pre><pre data-language="bnf">CaseValue: LiteralCase | BaseExpression | ConstructorExpression</pre><pre data-language="bnf">LiteralCase: "-"? IntegerLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral</pre><p>Every case condition has a type:</p><div class="itemizedlist"><ul type="disc"><li><p>for a value case, the type is the union of the types of the values, 
                    and</p></li><li><p>for a type case, the type is the specified type.</p></li></ul></div><i><span class="comment"><p>Note: to each value constructor, the compiler assigns an internal
            type which is a subtype of the type of the class to which the constructor belongs.
            The union of all internal value constructor types for value constructors listed 
            in the <tt class="literal">of</tt> clause of the class declaration covers the class 
            type.</p></span></i><p>For a case of type <tt class="literal">U</tt> of a <tt class="literal">switch</tt> with 
            switched type <tt class="literal">V</tt>, as defined below in 
            <a href="statementblocks.html#switchcaseelse" title="5.5.2.&nbsp;switch/case/else">&sect;5.5.2 switch/case/else</a>:</p><div class="itemizedlist"><ul type="disc"><li><p>the intersection type <tt class="literal">V&amp;U</tt> must not be exactly 
                    <tt class="literal">Nothing</tt>, and</p></li><li><p>if the case is a type case, the <tt class="literal">switch</tt> variable, 
                    or, if there is no inline variable declared by the <tt class="literal">switch</tt>, 
                    the value referred by the <tt class="literal">switch</tt> expression, will be 
                    treated by the compiler as having the type <tt class="literal">V&amp;U</tt> inside 
                    the <tt class="literal">case</tt> block.</p></li></ul></div><p>As a special exception to the above, if a <tt class="literal">switch</tt> occurs 
            in a <tt class="literal">dynamic</tt> block, and there is no switched type, the 
            <tt class="literal">switch</tt> variable, or the value referred by the 
            <tt class="literal">switch</tt> expression will be treated by the compiler as having 
            the type <tt class="literal">V</tt> inside the <tt class="literal">case</tt> block.</p><i><span class="comment"><p>Note: a type case may narrow to an intersection or union type.</p>
            <pre data-language="ceylon">case (is Persistent &amp; Serializable) { ... }</pre>
            <pre data-language="ceylon">case (is Integer | Float) { ... }</pre></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="controlstructures"></a>5.5.&nbsp;Control structures and assertions</h2></div></div><div></div></div><p>Control of execution flow may be achieved using control directives and 
        <span class="emphasis"><em>control structures</em></span>. Control structures include conditionals, 
        loops, and exception management.</p><p>Ceylon provides the following control structures:</p><div class="itemizedlist"><ul type="disc"><li><p>the <tt class="literal">if/else</tt> conditional&#8212;for controlling 
                execution based on a boolean condition, type condition, or check for a 
                non-null or non-empty value,</p></li><li><p>the <tt class="literal">switch/case/else</tt> conditional&#8212;for 
                controlling execution using an enumerated list of values or types,</p></li><li><p>the <tt class="literal">while</tt> loop&#8212;for loops which terminate 
                based on a boolean condition, type condition, or check for a non-null or 
                non-empty value,</p></li><li><p>the <tt class="literal">for/else</tt> loop&#8212;for looping over elements 
                of an iterable object, and</p></li><li><p>the <tt class="literal">try/catch/finally</tt> exception manager&#8212;for 
                managing exceptions and controlling the lifecycle of objects which require 
                explicit destruction.</p></li></ul></div><pre data-language="bnf">ControlStructure: IfElse | SwitchCaseElse | While | ForFail | TryCatchFinally | Assertion</pre><i><span class="comment"><p>Control structures are not considered to be expressions, and therefore 
        do not evaluate to a value. However, comprehensions, specified in 
        <a href="expressions.html#comprehensions" title="6.6.6.&nbsp;Comprehensions">&sect;6.6.6 Comprehensions</a>, and conditional expressions, specified in 
        <a href="expressions.html#miscexpressions" title="6.7.&nbsp;Conditional expressions, let expressions, and anonymous class expressions">&sect;6.7 Conditional expressions, let expressions, and anonymous class expressions</a> are part of the expression syntax and share much of 
        the syntax and semantics of the control structures they resemble.</p></span></i><p><span class="emphasis"><em>Assertions</em></span> are runtime checks upon program invariants, or 
        function preconditions and postconditions. An assertion failure represents a bug in
        the program, and is not considered recoverable. Therefore, assertions should not be 
        used to control "normal" execution flow.</p><i><span class="comment"><p>Note: of course, in certain circumstances, it is appropriate to handle
        the exception that results from an assertion failure, for example, to display a message
        to the user, or in a testing framework to aggregate and report the failures that occurred
        in test assertions. A test failure may be considered "normal" occurrence from the point 
        of view of a testing framework, but it's not "normal" in the sense intended above.
        </p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ifelse"></a>5.5.1.&nbsp;<tt class="literal">if/else</tt></h3></div></div><div></div></div><p>The <tt class="literal">if/else</tt> conditional has the following form:</p><pre data-language="bnf">IfElse: If Else?</pre><pre data-language="bnf">If: "if" ConditionList Block</pre><pre data-language="bnf">Else: "else" (Block | IfElse)</pre><p>Every <tt class="literal">if/else</tt> conditional construct has an 
            <tt class="literal">if</tt> clause. The construct may optionally include:</p><div class="itemizedlist"><ul type="disc"><li><p>a chain of an arbitrary number of child 
                    <tt class="literal">else if</tt> clauses, and/or</p></li><li><p>an <tt class="literal">else</tt> clause.</p></li></ul></div><pre data-language="ceylon">if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid = true;
}
else {
    throw NotEnoughMoneyException();
}</pre><pre data-language="ceylon">shared void welcome(User? user) {
    if (exists user) {
        print("Welcome back, ``user.name``!");
    }
    else {
        print("Welcome to Ceylon!");
    }
}</pre><pre data-language="ceylon">if (is CardPayment p = order.payment, 
        !p.paid) {
    p.card.charge(total);
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="switchcaseelse"></a>5.5.2.&nbsp;<tt class="literal">switch/case/else</tt></h3></div></div><div></div></div><p>The <tt class="literal">switch/case/else</tt> conditional has the following 
            form:</p><pre data-language="bnf">SwitchCaseElse: Switch Case+ Else?</pre><p>Every <tt class="literal">switch</tt> conditional has a
            <tt class="literal">switch</tt> clause.</p><pre data-language="bnf">Switch: "switch" "(" SwitchVariableOrExpression ")"</pre><p>The <tt class="literal">switch</tt> clause has a <span class="emphasis"><em>switched
            expression</em></span>, either:</p><div class="itemizedlist"><ul type="disc"><li><p>an expression, or</p></li><li><p>an inline variable declaration together with a specified 
                    expression.</p></li></ul></div><pre data-language="bnf">SwitchVariableOrExpression: Expression | Variable Specifier</pre><p>The <span class="emphasis"><em>switched type</em></span> is the type of the expression or 
            inline variable.</p><i><span class="comment"><p>Note: there is an ambiguity here between assignment expressions
            and inline variable declarations. This ambiguity is resolved in favor of 
            interpreting the switched expression as a variable declaration. Therefore, a
            switched expression in a <tt class="literal">switch</tt> clause may not be an 
            assignment expression.</p></span></i><p>If a <tt class="literal">switch</tt> has a type case condition, and does not
            declare an inline variable, then the switched expression must be an unqualified 
            value reference to a non-<tt class="literal">variable</tt>, non-<tt class="literal">default</tt> 
            reference.</p><p>In addition, every <tt class="literal">switch</tt> conditional must include:</p><div class="itemizedlist"><ul type="disc"><li><p>a chain of one or more child <tt class="literal">case</tt> clauses, 
                    and,</p></li><li><p>optionally, a chain of an arbitrary number of child 
                    <tt class="literal">else if</tt> clauses, and/or</p></li><li><p>optionally, an <tt class="literal">else</tt> clause.</p></li></ul></div><pre data-language="bnf">Case: "case" CaseCondition Block</pre><p>Two <tt class="literal">case</tt>s are said to be <span class="emphasis"><em>disjoint</em></span> 
            if:</p><div class="itemizedlist"><ul type="disc"><li><p>the intersection of the types of their case conditions is 
                    exactly <tt class="literal">Nothing</tt>, as defined by 
                    <a href="typesystem.html#disjointtypes" title="3.4.4.&nbsp;Disjoint types">&sect;3.4.4 Disjoint types</a>, or</p></li><li><p>if they are both value cases with no literal value or 
                    anonymous class value reference in common.</p></li></ul></div><p>In every <tt class="literal">switch</tt> statement, all <tt class="literal">case</tt>s 
            must be mutually disjoint.</p><p>A <tt class="literal">switch</tt> is <span class="emphasis"><em>exhaustive</em></span> if there 
            are no literal values in its <tt class="literal">case</tt>s, and the union type formed 
            by the types of the case conditions of the <tt class="literal">switch</tt> covers the 
            switched type, as defined by <a href="typesystem.html#coverage" title="3.4.1.&nbsp;Coverage">&sect;3.4.1 Coverage</a>. If no <tt class="literal">else</tt> 
            block is specified, the <tt class="literal">switch</tt> must be exhaustive.</p><i><span class="comment"><p>Note: On the other hand, even if the <tt class="literal">switch</tt> 
            <span class="emphasis"><em>is</em></span> exhaustive, an <tt class="literal">else</tt> block may be 
            specified, in order to allow a <tt class="literal">switch</tt> that accommodates 
            additional cases without resulting in a compilation error.</p></span></i><p>As a special exception to the above, if a <tt class="literal">switch</tt> occurs 
            in a <tt class="literal">dynamic</tt> block, and the switched expression has no type, 
            the cases are not statically type-checked for exhaustion.</p><p>If an <tt class="literal">else</tt> block is specified, then the <tt class="literal">switch</tt> 
            variable or, if there is no inline variable declared by the <tt class="literal">switch</tt>, 
            the value referred by the <tt class="literal">switch</tt> expression, will be treated 
            by the compiler as having the type <tt class="literal">V~U</tt> inside the 
            <tt class="literal">else</tt> block, where <tt class="literal">V</tt> is the switched type, 
            and <tt class="literal">U</tt> is the union type formed by the types of the case 
            conditions of the <tt class="literal">switch</tt>.</p><pre data-language="ceylon">Boolean? maybe = ... ;
switch (maybe) 
case (null | false) {
    return false;
}
case (true) { 
    return true;
}</pre><pre data-language="ceylon">Integer|Float number = ... ;
switch (number)
case (is Integer) { 
    return sqrt(number.float);
} 
case (is Float) { 
    return sqrt(number);
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="forelse"></a>5.5.3.&nbsp;<tt class="literal">for/else</tt></h3></div></div><div></div></div><p>The <tt class="literal">for/else</tt> loop has the following form:</p><pre data-language="bnf">ForFail: For Fail?</pre><pre data-language="bnf">For: "for" ForIterator Block</pre><pre data-language="bnf">Fail: "else" Block</pre><p>Every <tt class="literal">for/else</tt> conditional construct has an 
            <tt class="literal">for</tt> clause. The construct may optionally include an 
            <tt class="literal">else</tt> clause, as specified in 
            <a href="execution.html#executionofloops" title="8.3.4.&nbsp;Execution of loops">&sect;8.3.4 Execution of loops</a>.</p><p>The <tt class="literal">for</tt> iterator has an <span class="emphasis"><em>iterator 
            pattern</em></span> and an <span class="emphasis"><em>iterated expression</em></span> 
            that contains the range of values to be iterated.</p><pre data-language="bnf">ForIterator: "(" Pattern "in" Expression ")"</pre><p>The type of the iterated expression must have some principal 
            supertype instantiation <tt class="literal">{T*}</tt> or <tt class="literal">{T+}</tt> 
            of <tt class="literal">Iterable</tt> in <tt class="literal">ceylon.language</tt>. 
            Then the patterned type of the iterator pattern is <tt class="literal">T</tt>.</p><p>As a special exception to the above, if a <tt class="literal">for</tt> 
            occurs in a <tt class="literal">dynamic</tt> block, and the iterated expression 
            has no type, the iterator is not statically type-checked. If the iteration 
            variable does not declare an explicit type, the iteration variable has no 
            type.</p><pre data-language="ceylon">for (p in people) { 
    print(p.name);
}</pre><pre data-language="ceylon">variable Float sum = 0.0;
for (i in -10..10) {
    sum += x[i] else 0.0;
}</pre><pre data-language="ceylon">for (word -&gt; freq in wordFrequencyMap) { 
    print("The frequency of ``word`` is ``freq``."); 
}</pre><pre data-language="ceylon">for (p in group) {
    if (p.age &gt;= 18) {
        log.info("Found an adult: ``p.name``.");
        break;
    }
}
else {
    log.info("No adult in group.");
}
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="while"></a>5.5.4.&nbsp;<tt class="literal">while</tt></h3></div></div><div></div></div><p>The <tt class="literal">while</tt> loop has the form:</p><pre data-language="bnf">While: LoopCondition Block</pre><p>The loop condition list determines when the loop terminates.</p><pre data-language="bnf">LoopCondition: "while" ConditionList</pre><i><span class="comment"><p>TODO: does <tt class="literal">while</tt> need an <tt class="literal">else</tt> 
            block? Python has it, but what is the real usecase?</p></span></i><pre data-language="ceylon">variable Integer n=0;
variable [Integer*] seq = [];
while (n&lt;=max) {
    seq=seq.withTrailing(n);
    n+=step(n);
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="trycatchfinally"></a>5.5.5.&nbsp;<tt class="literal">try/catch/finally</tt></h3></div></div><div></div></div><p>The <tt class="literal">try/catch/finally</tt> exception manager has the 
            form:</p><pre data-language="bnf">TryCatchFinally: Try Catch* Finally?</pre><pre data-language="bnf">Try: "try" ResourceList? Block</pre><pre data-language="bnf">ResourceList: "(" Resource ("," Resource)* ")"</pre><pre data-language="bnf">Catch: "catch" "(" Variable ")" Block</pre><pre data-language="bnf">Finally: "finally" Block</pre><p>Every <tt class="literal">try</tt> conditional construct has a
            <tt class="literal">try</tt> clause. The construct may optionally include:</p><div class="itemizedlist"><ul type="disc"><li><p>a chain of an arbitrary number of child 
                    <tt class="literal">catch</tt> clauses, and/or</p></li><li><p>a <tt class="literal">finally</tt> clause, as 
                    specified in <a href="execution.html#exceptionhandling" title="8.3.5.&nbsp;Exception handling">&sect;8.3.5 Exception handling</a>.</p></li></ul></div><p>Each <tt class="literal">catch</tt> block defines a variable. The type 
            of the variable must be assignable to <tt class="literal">Throwable</tt> in
            <tt class="literal">ceylon.language</tt>. If no type is explicitly specified, 
            the type is inferred to be <tt class="literal">Exception</tt>.</p><i><span class="comment"><p>Note: a <tt class="literal">catch</tt> block type may be a union 
            or intersection type:</p>
            <pre data-language="ceylon">catch (NotFoundException|DeletedException e) { ... }</pre></span></i><p>If there are multiple <tt class="literal">catch</tt> blocks in a certain
            control structure, then:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of a <tt class="literal">catch</tt> variable may not be 
                    a subtype of any catch variable of an earlier <tt class="literal">catch</tt> 
                    block belonging to the same control structure.</p></li><li><p>If the type of a <tt class="literal">catch</tt> variable is a union
                    type <tt class="literal">E1|E2|...|En</tt> then no member <tt class="literal">Ei</tt>
                    of the union may be a subtype of any catch variable of an earlier 
                    <tt class="literal">catch</tt> block belonging to the same control 
                    structure.</p></li></ul></div><p>The <tt class="literal">try</tt> block may have a list of <span class="emphasis"><em>resource
            expressions</em></span>, each of which may produce either:</p><div class="itemizedlist"><ul type="disc"><li><p>a <span class="emphasis"><em>destroyable resource</em></span>, or</p></li><li><p>an <span class="emphasis"><em>obtainable resource</em></span>.</p></li></ul></div><pre data-language="bnf">Resource: Expression | Variable Specifier</pre><i><span class="comment"><p>Note: there is an ambiguity here between assignment expressions
            and inline variable declarations. This ambiguity is resolved in favor of 
            interpreting the resource expression as a variable declaration. Therefore, a
            resource expression in a <tt class="literal">try</tt> clause may not be an 
            assignment expression.</p></span></i><p>A destroyable resource expression is:</p><div class="itemizedlist"><ul type="disc"><li><p>an instantiation expression, or</p></li><li><p>an inline variable declaration together with 
                an instantiation expression.</p></li></ul></div><p>The instantiation expression must be of type assignable to
            <tt class="literal">Destroyable</tt> in <tt class="literal">ceylon.language</tt>.</p><p>An obtainable resource expression is:</p><div class="itemizedlist"><ul type="disc"><li><p>an expression, or</p></li><li><p>an inline variable declaration together with 
                an expression.</p></li></ul></div><p>The expression must be of type assignable to 
            <tt class="literal">Obtainable</tt> in <tt class="literal">ceylon.language</tt>.</p><p>If no type is explicitly specified for a resource variable, the 
            type of the variable is inferred to be the type of the expression.</p><pre data-language="ceylon">try (File(path).lock) {
    file.open(write);
    ...
}
catch (FileNotFoundException fnfe) {
    print("file not found: ``path``");
}
catch (FileReadException fre) {
    print("could not read from file: ``path``");
}
finally {
    assert (file.closed);
}</pre><pre data-language="ceylon">try (Transaction()) {
    try (s = Session()) {
        return s.get(Person, id);
    }
    catch (NotFoundException|DeletedException e) {
        return null;
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="assertions"></a>5.5.6.&nbsp;Assertions</h3></div></div><div></div></div><p>An assertion has an asserted condition list and, optionally, 
            an annotation list.</p><pre data-language="bnf">Assertion: Annotations "assert" ConditionList ";"</pre><p>The message carried by the assertion failure may be specified
            using a <tt class="literal">doc</tt> annotation.</p><pre data-language="ceylon">"total must be less than well-defined bound"
assert (exists bound, total&lt;bound);</pre><p>If the assertion contains an assignability, existence, or 
            nonemptiness condition containing a value reference then the compiler 
            treats the referenced value as having a narrowed type at program 
            elements that occur in the lexical scope of the assertion.</p><pre data-language="ceylon">{Element*} elements = ... ;
assert (nonempty elements);
Element first = elements.first;</pre><i><span class="comment"><p>TODO: how can we support interpolation in the assertion
            failure message?</p>
            <pre data-language="ceylon">assert (total&lt;bound) 
else "total must be less than ``bound``";</pre>
            </span></i></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="declarations.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="expressions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Declarations&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Expressions</td></tr></table></div></body></html>