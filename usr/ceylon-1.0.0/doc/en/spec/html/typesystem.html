<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;Type system</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css">
<link type='text/css' href='../shared/css/shCore.css' rel='stylesheet'/>
<link type='text/css' href='../shared/css/shThemeDefault.css' rel='stylesheet'/>
<script src='../shared/css/shCore.js' type='text/javascript'></script>
<script src='../shared/css/shBrushCeylon.js' type='text/javascript'></script>
    	    <script type='text/javascript'>
    	        SyntaxHighlighter.defaults['gutter'] = false;
    	        SyntaxHighlighter.defaults['toolbar'] = false;
    	        // register a listener for when the highlighter is done with replacing elements
    	        var hl = SyntaxHighlighter.highlight;
    	        SyntaxHighlighter.highlight = function(params, element){
    	          hl(params, element);
    	          postSyntaxHighlighting();
    	        };
    	        SyntaxHighlighter.all();
    	    </script><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="The Ceylon Language"><link rel="up" href="index.html" title="The Ceylon Language"><link rel="previous" href="lexical.html" title="Chapter&nbsp;2.&nbsp;Lexical structure"><link rel="next" href="declarations.html" title="Chapter&nbsp;4.&nbsp;Declarations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The Ceylon Language &mdash; 3.&nbsp;Type system</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="lexical.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="declarations.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="typesystem"></a>Chapter&nbsp;3.&nbsp;Type system</h2></div></div><div></div></div><p>Every value in a Ceylon program is an instance of a type that can be expressed 
    within the Ceylon language as a <span class="emphasis"><em>class</em></span>. The language does not 
    define any primitive or compound types that cannot, in principle, be expressed within 
    the language itself.</p><p>A class, fully defined in <a href="declarations.html#classes" title="4.5.&nbsp;Classes">&sect;4.5 Classes</a>, is a recipe for producing 
    new values, called <span class="emphasis"><em>instances</em></span>
    of the class (or simply <span class="emphasis"><em>objects</em></span>), and defines the operations and 
    attributes of the resulting values. A class instance may hold references to other 
    objects, and has an identity distinct from these references.</p><p>Each class declaration defines a type. However, not all types are classes. It 
    is often advantageous to write generic code that abstracts the concrete class of a 
    value. This technique is called <span class="emphasis"><em>polymorphism</em></span>. Ceylon features 
    two different kinds of polymorphism:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>subtype polymorphism</em></span>, where a subtype <tt class="literal">B</tt>
            inherits a supertype <tt class="literal">A</tt>, and</p></li><li><p><span class="emphasis"><em>parametric polymorphism</em></span>, where a type definition 
            <tt class="literal">A&lt;T&gt;</tt> is parameterized by a <span class="emphasis"><em>generic type 
            parameter</em></span> <tt class="literal">T</tt>.</p></li></ul></div><p>Ceylon, like Java and many other object-oriented languages, features a single
    inheritance model for classes. A class may directly inherit at most one other class, 
    and all classes eventually inherit, directly or indirectly, the class 
    <tt class="literal">Anything</tt> defined in the module <tt class="literal">ceylon.language</tt>, 
    which acts as the root of the class hierarchy.</p><p>A truly hierarchical type system is much too restrictive for more abstract 
    programming tasks. Therefore, in addition to classes, Ceylon recognizes the following 
    kinds of type:</p><div class="itemizedlist"><ul type="disc"><li><p>An <span class="emphasis"><em>interface</em></span>, defined in <a href="declarations.html#interfaces" title="4.4.&nbsp;Interfaces">&sect;4.4 Interfaces</a>, 
            is an abstract type schema that cannot itself be directly instantiated. An 
            interface may define concrete members, but these members may not hold references 
            to other objects. A class may inherit one or more interfaces. An instance of a 
            class that inherits an interface is also considered an instance of the interface.</p></li><li><p>A <span class="emphasis"><em>generic type parameter</em></span>, defined in 
            <a href="typesystem.html#generictypeparameters" title="3.5.&nbsp;Generic type parameters">&sect;3.5 Generic type parameters</a>, is considered a type within the 
            declaration that it parameterizes. In fact, it is an abstraction over many types: 
            it generalizes the declaration to all types which could be assigned to the 
            parameter.</p></li><li><p>An <span class="emphasis"><em>applied type</em></span>, defined in 
            <a href="typesystem.html#generictypearguments" title="3.6.&nbsp;Generic type arguments">&sect;3.6 Generic type arguments</a>, is formed by specifying arguments for the 
            generic type parameters of a parameterized type.</p></li><li><p>A <span class="emphasis"><em>union type</em></span>, defined in <a href="typesystem.html#uniontypes" title="3.2.3.&nbsp;Union types">&sect;3.2.3 Union types</a>, 
            is a type to which each of an enumerated list of types is assignable.</p></li><li><p>An <span class="emphasis"><em>intersection type</em></span>, defined in 
            <a href="typesystem.html#intersectiontypes" title="3.2.4.&nbsp;Intersection types">&sect;3.2.4 Intersection types</a>, is a type which is assignable to each of an 
            enumerated list of types.</p></li></ul></div><p>Although we often use the term <span class="emphasis"><em>parameterized type</em></span> or even
    <span class="emphasis"><em>generic type</em></span> to refer to a parameterized type definition, it is
    important to keep in mind that a parameterized type definition is not itself a type.
    Rather, it is a <span class="emphasis"><em>type constructor</em></span>, a function that maps types 
    to types. Given a list of type arguments, the function yields an applied type.</p><p>In light of the fact that Ceylon makes it so easy to construct new types from
    existing types <span class="emphasis"><em>without the use of inheritance</em></span>, by forming unions, 
    intersections, and applied types, it's often useful to assign a name to such a type.</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>type alias</em></span>, defined in 
            <a href="declarations.html#typealiasedeclarations" title="4.6.&nbsp;Type aliases">&sect;4.6 Type aliases</a>, <a href="declarations.html#classaliases" title="4.5.9.&nbsp;Class aliases">&sect;4.5.9 Class aliases</a>, 
            and <a href="declarations.html#interfacealiases" title="4.4.4.&nbsp;Interface aliases">&sect;4.4.4 Interface aliases</a>, is a synonym for an expression 
            involving other types or generic types. A type alias may itself be 
            generic.</p></li></ul></div><p>The Ceylon type system is much more complete than most other object oriented
    languages. In Ceylon, it's possible to answer questions that might at first sound
    almost nonsensical if you're used to languages with more traditional type systems. 
    For example:</p><div class="itemizedlist"><ul type="disc"><li><p>What is the type of a variable that may or may not hold a value of 
            type <tt class="literal">Element</tt>?</p></li><li><p>What is the type of a parameter that accepts either an 
            <tt class="literal">Integer</tt> or a <tt class="literal">Float</tt>?</p></li><li><p>What is the type of a parameter that accepts values which are instances 
            of both <tt class="literal">Persistent</tt> and <tt class="literal">Printable</tt>?</p></li><li><p>What is the type of a function which accepts any non-null value and 
            returns a <tt class="literal">String</tt>?</p></li><li><p>What is the type of a function that accepts one or more
            <tt class="literal">String</tt>s and returns an iterable object producing at least 
            one <tt class="literal">String</tt>?</p></li><li><p>What is the type of a sequence consisting of a <tt class="literal">String</tt>
            followed by two <tt class="literal">Float</tt>s?</p></li><li><p>What is the type of a list with no elements?</p></li></ul></div><p>The answers, as we shall see, are: <tt class="literal">Element?</tt>, 
    <tt class="literal">Integer|Float</tt>, <tt class="literal">Persistent&amp;Printable</tt>, 
    <tt class="literal">String(Object)</tt>, <tt class="literal">{String+}(String+)</tt>,   
    <tt class="literal">[String,Float,Float]</tt>, and <tt class="literal">List&lt;Nothing&gt;</tt>.</p><p>It's important that there is always a unique "best" answer to questions
    like these in Ceylon. The "best" answer is called the <span class="emphasis"><em>principal type
    of an expression</em></span>. Every other type to which the expression is 
    assignable is a supertype of the principal type.</p><p>Thus, every legal Ceylon expression has a unique, well-defined type, 
    representable within the type system, without reference to how the expression 
    is used or to what type it is assigned. This is the case even when type inference 
    or type argument inference comes into play.</p><p>Neither this specification nor the internal implementation of the Ceylon 
    compiler itself use any kind of "non-denotable" types. Every type mentioned 
    here or inferred internally by the compiler has a representation within the 
    language itself. Thus, the programmer is never exposed to confusing error 
    messages referring to mysterious types that are not part of the syntax of the 
    language.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="identifiernaming"></a>3.1.&nbsp;Identifier naming</h2></div></div><div></div></div><p>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase letter. Methods, attributes, parameters, 
        and locals must be named with an initial lowercase letter or underscore.
        The grammar for identifiers is defined by 
        <a href="lexical.html#identifiersandkeywords" title="2.3.&nbsp;Identifiers and keywords">&sect;2.3 Identifiers and keywords</a>.</p><pre class="synopsis">TypeName: UIdentifier</pre><pre class="synopsis">MemberName: LIdentifier</pre><p>A package or module name is a sequence of identifiers, each with an 
        initial lowercase letter or underscore.</p><pre class="synopsis">PackageName: LIdentifier</pre><p>Ceylon defines three identifier namespaces:</p><div class="itemizedlist"><ul type="disc"><li><p>classes, interfaces, type aliases, and type parameters share 
                a single namespace,</p></li><li><p>functions, values, and parameters share a single namespace, 
                and</p></li><li><p>packages have their own dedicated namespace.</p></li></ul></div><p>The Ceylon parser is able to unambiguously identify which namespace an 
        identifier belongs to.</p><p>An identifier that begins with an initial lowercase letter may be 
        <span class="emphasis"><em>forced</em></span> into the namespace of types by prefixing the
        identifier <tt class="literal">\I</tt>. An identifier that begins with an initial
        uppercase letter may be forced into the namespace of methods and attributes
        by prefixing the identifier <tt class="literal">\i</tt>. A keyword may be used as 
        an identifier by prefixing the keyword with either <tt class="literal">\i</tt> or 
        <tt class="literal">\I</tt>. This allows interoperation with languages like Java 
        which do not enforce these naming conventions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="type"></a>3.2.&nbsp;Types</h2></div></div><div></div></div><p>A <span class="emphasis"><em>type</em></span> or <span class="emphasis"><em>type schema</em></span> is a name 
        (an initial uppercase identifier) and an optional list of type parameters, with 
        a set of:</p><div class="itemizedlist"><ul type="disc"><li><p>value schemas,</p></li><li><p>function schemas, and</p></li><li><p>class schemas.</p></li></ul></div><p>The value, function, and class schemas are called the <span class="emphasis"><em>members</em></span> 
        of the type.</p><p>Speaking formally:</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>value schema</em></span> is a name (an initial 
                lowercase identifier) with a type and mutability.</p></li><li><p>A <span class="emphasis"><em>function schema</em></span> is a name (an initial 
                lowercase identifier) and an optional list of type parameters, with a 
                type (often called the <span class="emphasis"><em>return type</em></span>) and a sequence 
                of one or more parameter lists.</p></li><li><p>A <span class="emphasis"><em>class schema</em></span> is a type schema with exactly
                one parameter list.</p></li><li><p>A <span class="emphasis"><em>parameter list</em></span> is a list of names (initial 
                lowercase identifiers) with types. The <span class="emphasis"><em>signature</em></span> of 
                a parameter list is formed by discarding the names, leaving the list of 
                types.</p></li></ul></div><p>Speaking slightly less formally, we usually refer to an <span class="emphasis"><em>attribute</em></span>, 
        <span class="emphasis"><em>method</em></span>, or <span class="emphasis"><em>member class</em></span> of a type, meaning 
        a value schema, function schema, or class schema that is a member of the type.</p><p>A function or value schema may occur outside of a type schema. If it occurs 
        directly in a compilation unit, we often call it a <span class="emphasis"><em>toplevel function</em></span> 
        or <span class="emphasis"><em>toplevel value</em></span>.</p><p>A value schema, function schema, or parameter list with a missing type or types 
        may be defined. A value schema, function schema, or parameter list with a missing type 
        is called <span class="emphasis"><em>partially typed</em></span>.</p><p>Two signatures are considered identical if they have exactly the same types, at
        exactly the same positions, and missing types at exactly the same positions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="memberdistinctness"></a>3.2.1.&nbsp;Member distinctness</h3></div></div><div></div></div><p>Overloading is illegal in Ceylon. A type may not have:</p><div class="itemizedlist"><ul type="disc"><li><p>two attributes with the same name,</p></li><li><p>a method and an attribute with the same name,</p></li><li><p>two methods with the same name, or</p></li><li><p>two member classes with the same name.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="subtyping"></a>3.2.2.&nbsp;Subtyping</h3></div></div><div></div></div><p>A type may be a <span class="emphasis"><em>subtype</em></span> of another type. Subtyping obeys 
            the following rules:</p><div class="itemizedlist"><ul type="disc"><li><p>Identity: <tt class="literal">X</tt> is a subtype of <tt class="literal">X</tt>.</p></li><li><p>Transitivity: if <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>
                    and <tt class="literal">Y</tt> is a subtype of <tt class="literal">Z</tt> then
                    <tt class="literal">X</tt> is a subtype of <tt class="literal">Z</tt>.</p></li><li><p>Noncircularity: if <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>
                    and <tt class="literal">Y</tt> is a subtype of <tt class="literal">X</tt> then
                    <tt class="literal">Y</tt> and <tt class="literal">X</tt> are the same type.</p></li><li><p>Single root: all types are subtypes of the class <tt class="literal">Anything</tt>
                    defined in the module <tt class="literal">ceylon.language</tt>.</p></li></ul></div><p>Every interface type is a subtype of the class <tt class="literal">Object</tt> 
            defined in <tt class="literal">ceylon.language</tt>.</p><p>If <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>, then:</p><div class="itemizedlist"><ul type="disc"><li><p>For each non-<tt class="literal">variable</tt> attribute of <tt class="literal">Y</tt>, 
                    <tt class="literal">X</tt> has an attribute with the same name, whose type is 
                    assignable to the type of the attribute of <tt class="literal">Y</tt>.</p></li><li><p>For each <tt class="literal">variable</tt> attribute of <tt class="literal">Y</tt>, 
                    <tt class="literal">X</tt> has a <tt class="literal">variable</tt> attribute with the 
                    same name and the same type.</p></li><li><p>For each method of <tt class="literal">Y</tt>, <tt class="literal">X</tt> has a 
                    method with the same name, with the same number of parameter lists, with 
                    the same signatures, and whose return type is assignable to the return type 
                    of the method of <tt class="literal">Y</tt>.</p></li><li><p>For each member class of <tt class="literal">Y</tt>, <tt class="literal">X</tt>
                    has a member class of the same name, with a parameter list with the same 
                    signature, that is a subtype of the member class of <tt class="literal">Y</tt>.</p></li></ul></div><p>Furthermore, we say that <tt class="literal">X</tt> is <span class="emphasis"><em>assignable</em></span>
            to <tt class="literal">Y</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="uniontypes"></a>3.2.3.&nbsp;Union types</h3></div></div><div></div></div><p>For any types <tt class="literal">X</tt> and <tt class="literal">Y</tt>, the 
            <span class="emphasis"><em>union</em></span>, or <span class="emphasis"><em>disjunction</em></span>, <tt class="literal">X|Y</tt>, 
            of the types may be formed. A union type is a supertype of both of the given types 
            <tt class="literal">X</tt> and <tt class="literal">Y</tt>, and an instance of either type is an 
            instance of the union type.</p><p>The union type constructor <tt class="literal">|</tt> is associative, so the union 
            of three types, <tt class="literal">X</tt>, <tt class="literal">Y</tt>, and <tt class="literal">Z</tt>, 
            may be written <tt class="literal">X|Y|Z</tt>.</p><pre class="synopsis">UnionType: IntersectionType ("|" IntersectionType)*</pre><p>If <tt class="literal">X</tt> and <tt class="literal">Y</tt> are both subtypes of a third type 
            <tt class="literal">Z</tt>, then <tt class="literal">X|Y</tt> inherits all members of <tt class="literal">Z</tt>.</p><pre class="brush: ceylon">void write(String|Integer|Float printable) { ... }</pre><p>Union types satisfy the following rules, for any types <tt class="literal">X</tt>,
            <tt class="literal">Y</tt>, and <tt class="literal">Z</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        Commutativity: <tt class="literal">X|Y</tt> is the same 
                        type as <tt class="literal">Y|X</tt>.
                    </p></li><li><p>
                        Associativity: <tt class="literal">X|(Y|Z)</tt> is the same 
                        type as <tt class="literal">(X|Y)|Z</tt>.
                    </p></li><li><p>
                        Simplification: if <tt class="literal">X</tt> is a subtype 
                        of <tt class="literal">Y</tt>, then <tt class="literal">X|Y</tt> 
                        is the same type as <tt class="literal">Y</tt>.
                    </p></li><li><p>
                        Subtypes: <tt class="literal">X</tt> is a subtype of 
                        <tt class="literal">X|Y</tt>.
                    </p></li><li><p>
                        Supertypes: if both <tt class="literal">X</tt> and 
                        <tt class="literal">Y</tt> are subtypes of <tt class="literal">Z</tt>, 
                        then <tt class="literal">X|Y</tt> is also a subtype of
                        <tt class="literal">Z</tt>.
                    </p></li></ul></div><p>The following results follow from these rules:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">X|Nothing</tt> is the same  type as <tt class="literal">X</tt> 
                        for any type <tt class="literal">X</tt>, and
                    </p></li><li><p>
                        <tt class="literal">X|Anything</tt> is the same type as <tt class="literal">Anything</tt>
                        for any type <tt class="literal">X</tt>.
                    </p></li></ul></div><p>Finally:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">X&lt;T&gt;</tt> is covariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;|X&lt;V&gt;</tt> is a
                    subtype of <tt class="literal">X&lt;U|V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">X&lt;T&gt;</tt> is contravariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;|X&lt;V&gt;</tt> is a
                    subtype of <tt class="literal">X&lt;U&amp;V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="intersectiontypes"></a>3.2.4.&nbsp;Intersection types</h3></div></div><div></div></div><p>For any types <tt class="literal">X</tt> and <tt class="literal">Y</tt>, the 
            <span class="emphasis"><em>intersection</em></span>, or <span class="emphasis"><em>conjunction</em></span>,
            <tt class="literal">X&amp;Y</tt>, of the types may be formed. An intersection type is a 
            subtype of both of the given types <tt class="literal">X</tt> and <tt class="literal">Y</tt>, 
            and any object which is an instance of both types is an instance of the intersection 
            type.</p><p>The intersection type constructor <tt class="literal">&amp;</tt> is associative, 
            so the intersection of three types, <tt class="literal">X</tt>, <tt class="literal">Y</tt>, 
            and <tt class="literal">Z</tt>, may be written <tt class="literal">X&amp;Y&amp;Z</tt>.</p><pre class="synopsis">IntersectionType: PrimaryType ("&amp;" PrimaryType)*</pre><p>The intersection <tt class="literal">X&amp;Y</tt> inherits all members of both
            <tt class="literal">X</tt> and <tt class="literal">Y</tt>.</p><pre class="brush: ceylon">void store(Persistent&amp;Printable&amp;Identifiable storable) { ... }</pre><p>Intersection types satisfy the following rules, for any types <tt class="literal">X</tt>,
            <tt class="literal">Y</tt>, and <tt class="literal">Z</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        Commutativity: <tt class="literal">X&amp;Y</tt> is the same 
                        type as <tt class="literal">Y&amp;X</tt>.
                    </p></li><li><p>
                        Associativity: <tt class="literal">X&amp;(Y&amp;Z)</tt> is the same 
                        type as <tt class="literal">(X&amp;Y)&amp;Z</tt>.
                    </p></li><li><p>
                        Simplification: if <tt class="literal">X</tt> is a subtype 
                        of <tt class="literal">Y</tt>, then <tt class="literal">X&amp;Y</tt> 
                        is the same type as <tt class="literal">X</tt>.
                    </p></li><li><p>
                        Supertypes: <tt class="literal">X</tt> is a supertype of 
                        <tt class="literal">X&amp;Y</tt>.
                    </p></li><li><p>
                        Subtypes: if both <tt class="literal">X</tt> and 
                        <tt class="literal">Y</tt> are supertypes of <tt class="literal">Z</tt>, 
                        then <tt class="literal">X&amp;Y</tt> is also a supertype of
                        <tt class="literal">Z</tt>.
                    </p></li><li><p>
                        Distributivity over union: <tt class="literal">X&amp;(Y|Z)</tt> is the same 
                        type as <tt class="literal">(X&amp;Y)|(X&amp;Z)</tt>.
                    </p></li></ul></div><p>The following results follow from these rules:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">X&amp;Nothing</tt> is the same type as <tt class="literal">Nothing</tt> 
                        for any type <tt class="literal">X</tt>, and
                    </p></li><li><p>
                        <tt class="literal">X&amp;Anything</tt> is the same type as <tt class="literal">X</tt>
                        for any type <tt class="literal">X</tt>.
                    </p></li></ul></div><p>Finally:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">X&lt;T&gt;</tt> is covariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;&amp;X&lt;V&gt;</tt> is a
                    supertype of <tt class="literal">X&lt;U&amp;V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">X&lt;T&gt;</tt> is contravariant in the type parameter 
                    <tt class="literal">T</tt>, then <tt class="literal">X&lt;U&gt;&amp;X&lt;V&gt;</tt> is a
                    supertype of <tt class="literal">X&lt;U|V&gt;</tt> for any types <tt class="literal">U</tt>
                    and <tt class="literal">V</tt> that satisfy the type constraints on <tt class="literal">T</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bottomtype"></a>3.2.5.&nbsp;The bottom type</h3></div></div><div></div></div><p>The special type <tt class="literal">Nothing</tt>, sometimes called the
            <span class="emphasis"><em>bottom type</em></span>, represents:</p><div class="itemizedlist"><ul type="disc"><li><p>the intersection of all types, or, equivalently</p></li><li><p>the empty set.</p></li></ul></div><p><tt class="literal">Nothing</tt> is assignable to all other types, but has
            no instances.</p><p>The type schema for <tt class="literal">Nothing</tt> is empty, that is, it
            is considered to have no members.</p><p><tt class="literal">Nothing</tt> is considered to belong to the module
            <tt class="literal">ceylon.language</tt>. However, it cannot be defined within
            the language.</p><p>Because of the restrictions imposed by Ceylon's mixin inheritance 
            model:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">X</tt> and <tt class="literal">Y</tt> are classes, and
                <tt class="literal">X</tt> is not a subclass of <tt class="literal">Y</tt>, and 
                <tt class="literal">Y</tt> is not a subclass of <tt class="literal">X</tt>, then
                the intersection type <tt class="literal">X&amp;Y</tt> is equivalent to 
                <tt class="literal">Nothing</tt>.</p></li><li><p>If <tt class="literal">X</tt> is an interface, the intersection type 
                <tt class="literal">X&amp;Null</tt> is equivalent to <tt class="literal">Nothing</tt>.</p></li><li><p>If <tt class="literal">X</tt> is an interface, and <tt class="literal">Y</tt>
                is a <tt class="literal">final</tt> class, and <tt class="literal">Y</tt> is not a
                subtype of <tt class="literal">X</tt>, then the intersection type 
                <tt class="literal">X&amp;Y</tt> is equivalent to <tt class="literal">Nothing</tt>.</p></li><li><p>If <tt class="literal">X&lt;T&gt;</tt> is invariant in its type parameter
                <tt class="literal">T</tt>, and the distinct types <tt class="literal">A</tt> and 
                <tt class="literal">B</tt> do not involve type parameters, then 
                <tt class="literal">X&lt;A&gt;&amp;X&lt;B&gt;</tt> is equivalent to 
                <tt class="literal">Nothing</tt>.</p></li></ul></div><i><span class="comment"><p>TODO: Should the name of this type be a keyword, perhaps
            <tt class="literal">nothing</tt>, to emphasize that it is defined primitively?</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="principaltyping"></a>3.2.6.&nbsp;Principal typing</h3></div></div><div></div></div><p>An expression, as defined in <a href="expressions.html" title="Chapter&nbsp;6.&nbsp;Expressions">Chapter&nbsp;6, <i>Expressions</i></a>, occurring at a 
            certain location, may be <span class="emphasis"><em>assignable</em></span> to a type. In this case, 
            every evaluation of the expression at runtime produces an instance of a class that 
            is a subtype of the type, or results in a thrown exception, as defined in 
            <a href="execution.html" title="Chapter&nbsp;8.&nbsp;Execution">Chapter&nbsp;8, <i>Execution</i></a>.</p><p>Given an expression occurring at a certain location, a type <tt class="literal">T</tt>
            is the <span class="emphasis"><em>principal type</em></span> of the expression if, given any type
            <tt class="literal">U</tt> to which the expression is assignable, <tt class="literal">T</tt> 
            is a subtype of <tt class="literal">U</tt>. Thus, the principal type is the "most precise"
            type for the expression. The type system guarantees that every expression has a 
            principal type. Thus, we refer uniquely to <span class="emphasis"><em>the type of an expression</em></span>, 
            meaning its principal type at the location at which it occurs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeexpressions"></a>3.2.7.&nbsp;Type expressions</h3></div></div><div></div></div><p>Function and value declarations usually declare a type, by specifying
            a <span class="emphasis"><em>type expression</em></span>.</p><pre class="synopsis">Type: UnionType | EntryType</pre><p>Type expressions are formed by combining types using union, intersection, 
            and type abbreviations.</p><p>Type expressions support grouping using angle brackets:</p><pre class="synopsis">GroupedType: "&lt;" Type "&gt;"</pre><p>Applied types are identified by the name of the type (a class, interface, 
            type alias, or type parameter), together with a list of type arguments if the 
            type declaration is generic.</p><pre class="synopsis">TypeNameWithArguments: TypeName TypeArguments?</pre><p>Type names are resolved to type declarations according to 
            <a href="statementblocks.html#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a> and 
            <a href="statementblocks.html#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="typesystem.html#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list of the 
            realization of the type declaration, as defined by 
            <a href="typesystem.html#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><i><span class="comment"><p>Note: this is too heavy-handed. There is no reason to enforce 
            types constraint in any place other than generic class instantiations, generic 
            function invocations, <tt class="literal">extends</tt>, and <tt class="literal">satisfies</tt>. 
            However, this restriction makes interoperation with Java generics more 
            straightforward.</p></span></i><p>If the type is a class, interface, or type alias nested inside a containing 
            class or interface, the type must be fully qualified by its containing types, 
            except when used inside the body of a containing type.</p><pre class="synopsis">QualifiedType: TypeNameWithArguments ("." TypeNameWithArguments)*</pre><p>If a type declaration is generic, a type argument list must be specified. 
            If a type declaration is not generic, no type argument list may be specified.</p><pre class="brush: ceylon">BufferedReader.Buffer</pre><pre class="brush: ceylon">Entry&lt;Integer,Element&gt;</pre><i><span class="comment"><p>Note: the name of a type may not be qualified by its package name.
            Alias imports, as defined in <a href="declarations.html#aliasimports" title="4.2.3.&nbsp;Alias imports">&sect;4.2.3 Alias imports</a> may be used to 
            disambiguate type names.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typenameabbreviations"></a>3.2.8.&nbsp;Type abbreviations</h3></div></div><div></div></div><p>Certain important types may be written using an abbreviated syntax.</p><pre class="synopsis">PrimaryType: AtomicType | OptionalType | SequenceType | CallableType</pre><pre class="synopsis">AtomicType: QualifiedType | EmptyType | TupleType | IterableType | GroupedType</pre><p>First, there are postfix-style abbreviations for <span class="emphasis"><em>optional types</em></span>, 
            <span class="emphasis"><em>sequence types</em></span>, and <span class="emphasis"><em>callable types</em></span>.</p><pre class="synopsis">OptionalType: PrimaryType "?"</pre><pre class="synopsis">SequenceType: PrimaryType "[" "]"</pre><pre class="synopsis">CallableType: PrimaryType "(" TypeList? ")"</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X?</tt> means <tt class="literal">Null|X</tt> for any 
                    type <tt class="literal">X</tt>,</p></li><li><p><tt class="literal">X[]</tt> means <tt class="literal">Sequential&lt;X&gt;</tt> 
                    for any type <tt class="literal">X</tt>, and</p></li><li><p><tt class="literal">X(Y,Z)</tt> means <tt class="literal">Callable&lt;X,[Y,Z]&gt;</tt>
                    where <tt class="literal">Y,Z</tt> is a list of types of any length.</p></li></ul></div><p>More precisely, the type meant by a callable type abbreviation is
            <tt class="literal">Callable&lt;X,T&gt;</tt> where <tt class="literal">X</tt> is the type 
            outside the parentheses in the the callable type abbreviation, and 
            <tt class="literal">T</tt> is the tuple type formed by the types listed inside the 
            parentheses.</p><p>Next, abbreviations for <span class="emphasis"><em>iterable types</em></span> are written
            using braces.</p><pre class="synopsis">IterableType: "{" UnionType ("*"|"+") "}"</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">{X*}</tt> means <tt class="literal">Iterable&lt;X,Null&gt;</tt> 
                    for any type <tt class="literal">X</tt>, and</p></li><li><p><tt class="literal">{X+}</tt> means <tt class="literal">Iterable&lt;X,Nothing&gt;</tt> 
                    for any type <tt class="literal">X</tt>.</p></li></ul></div><p>Next, abbreviations for <span class="emphasis"><em>sequence types</em></span> and 
            <span class="emphasis"><em>tuple types</em></span> may be written using brackets.</p><pre class="synopsis">EmptyType: "[" "]"</pre><pre class="synopsis">TupleType: "[" TypeList "]"</pre><pre class="synopsis">TypeList: (EntryType ",")* UnionType ("*"|"+")?</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">[X*]</tt> means <tt class="literal">Sequential&lt;X&gt;</tt> 
                    for any type <tt class="literal">X</tt>,</p></li><li><p><tt class="literal">[]</tt> means <tt class="literal">Empty</tt>,</p></li><li><p><tt class="literal">[X+]</tt> means <tt class="literal">Sequence&lt;X&gt;</tt> 
                    for any type <tt class="literal">X</tt>, and</p></li><li><p><tt class="literal">[X,Y]</tt> means 
                    <tt class="literal">Tuple&lt;X|Y,X,Tuple&lt;Y,Y,[]&gt;&gt;</tt> where 
                    <tt class="literal">X,Y</tt> is a list of types of any length.</p></li></ul></div><p>More precisely:</p><div class="itemizedlist"><ul type="disc"><li><p>A tuple type abbreviation of form <tt class="literal">[X, ... ]</tt>
                    means the type <tt class="literal">Tuple&lt;X|Y,X,T&gt;</tt> where 
                    <tt class="literal">T</tt> is the type meant by the type abbreviation formed 
                    by removing the first type <tt class="literal">X</tt> from the list of types 
                    in the original tuple type abbreviation, and <tt class="literal">T</tt> has 
                    the principal instantiation <tt class="literal">Y[]</tt>, as defined in
                    <a href="typesystem.html#principalinstantiations" title="3.7.&nbsp;Principal instantiations and polymorphism">&sect;3.7 Principal instantiations and polymorphism</a>.</p></li></ul></div><p>Finally, an <span class="emphasis"><em>entry type</em></span> may be abbreviated using
            an arrow.</p><pre class="synopsis">EntryType: UnionType "-&gt;" UnionType</pre><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X-&gt;Y</tt> means <tt class="literal">Entry&lt;X,Y&gt;</tt>, 
                    for any types <tt class="literal">X</tt>, <tt class="literal">Y</tt>.</p></li></ul></div><i><span class="comment"><p>Note: the abbreviations <tt class="literal">T[]</tt> and 
            <tt class="literal">[T*]</tt> are synonyms. The syntax <tt class="literal">T[]</tt> is
            supported for reasons of nostalgia.</p></span></i><p>Abbreviations may be combined:</p><pre class="brush: ceylon">String?[] words = { "hello", "world", null };
String? firstWord = words[0];

String-&gt;[Integer,Integer] onetwo = "onetwo"-&gt;[1, 2];

[Float+](Float x, Float[] xs) add = (Float x, Float[] xs) =&gt; [x, *xs];</pre><p>When a type appears in a value expression, these abbreviations cannot be used 
            (they cannot be disambiguated from operator expressions).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeinference"></a>3.2.9.&nbsp;Type inference</h3></div></div><div></div></div><p>Certain declarations which usually require an explicit type may omit the type, 
            forcing the compiler to infer it, by specifying the keyword <tt class="literal">value</tt>,
            as defined in <a href="declarations.html#valuetypeinference" title="4.8.4.&nbsp;Value type inference">&sect;4.8.4 Value type inference</a>, or <tt class="literal">function</tt>,
            as defined in <a href="declarations.html#returntypeinference" title="4.7.4.&nbsp;Function return type inference">&sect;4.7.4 Function return type inference</a>, where the type usually appears.</p><pre class="brush: ceylon">value names = people*.name;</pre><pre class="brush: ceylon">function parse(String text) =&gt; text.split(" .!?,:;()\n\f\r\t".contains);</pre><p>Type inference is only allowed for declarations which are referred to only by 
            statements and declarations that occur within the lexical scope of the declaration, 
            as specified by <a href="statementblocks.html#typeinferenceandblockstructure" title="5.1.6.&nbsp;Type inference and block structure">&sect;5.1.6 Type inference and block structure</a>. A 
            <tt class="literal">value</tt> or <tt class="literal">function</tt> declaration may not:</p><div class="itemizedlist"><ul type="disc"><li><p>be annotated <tt class="literal">shared</tt>, as defined in
                    <a href="statementblocks.html#visibility" title="5.1.3.&nbsp;Visibility">&sect;5.1.3 Visibility</a>,</p></li><li><p>occur as a toplevel declaration in a compilation unit, as 
                    defined in <a href="declarations.html#topleveldeclarations" title="4.1.1.&nbsp;Toplevel and nested declarations">&sect;4.1.1 Toplevel and nested declarations</a>, or</p></li><li><p>be referred to by statements or declarations that occur earlier in 
                    the body containing of the declaration, as defined in 
                    <a href="statementblocks.html#blockstructure" title="5.1.&nbsp;Block structure and references">&sect;5.1 Block structure and references</a>.</p></li></ul></div><p>Nor may a parameter or forward-declared value, as defined in 
            <a href="declarations.html#valueforwarddeclaration" title="4.8.5.&nbsp;Forward declaration of values">&sect;4.8.5 Forward declaration of values</a>, or of a forward-declared function, as 
            defined in <a href="declarations.html#functionforwarddeclaration" title="4.7.5.&nbsp;Forward declaration of functions">&sect;4.7.5 Forward declaration of functions</a>, have an inferred type.</p><p>These restrictions allow the compiler to infer undeclared types in a single 
            pass of the code.</p><i><span class="comment"><p>Note: in future releases of the language, the inferred type will
            be context-dependent, that is, in program elements immediately following an
            assignment or specification, the inferred type will be the type just assigned.
            When conditional execution results in definite assignment, the inferred type
            will be the union of the conditionally assigned types. This will allow us to to
            relax the restriction that forward-declared functions and values can't have their
            type inferred. For example:</p>
            <pre class="brush: ceylon">value one;
if (float) {
    one = 1.0;
    Float float = one;
}
else {
    one = 1;
    Integer int = one;
}
Float|Integer num = one;</pre></span></i><p>An inferred type never involves an anonymous class, as defined in
            <a href="declarations.html#anonymousclasses" title="4.5.7.&nbsp;Anonymous classes">&sect;4.5.7 Anonymous classes</a>. When an inferred type would involve an 
            anonymous class type, the anonymous class is replaced by the intersection 
            of the class type it extends with all interface types it satisfies.</p><i><span class="comment"><p>TODO: properly define how expressions with no type occurring 
            in a <tt class="literal">dynamic</tt> block affect type inference.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typealiaselimination"></a>3.2.10.&nbsp;Type alias elimination</h3></div></div><div></div></div><p>A <span class="emphasis"><em>type alias</em></span> is a synonym for another type. A
            generic type alias is a type constructor that produces a type alias, given 
            a list of type arguments.</p><p>Every type alias must be reducible to an equivalent type that does
            not involve any type aliases by recursive replacement of type aliases with
            the types they alias. Thus, circular type alias definitions, as in the 
            following example, are illegal:</p><pre class="brush: ceylon">alias X =&gt; List&lt;Y&gt;;
alias Y =&gt; List&lt;X&gt;;</pre><p>Replacement of type aliases with the types they alias occurs at 
            compile time, so type aliases are not reified types, as specified in 
            <a href="execution.html#reification" title="8.1.2.&nbsp;Type argument reification">&sect;8.1.2 Type argument reification</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inheritance"></a>3.3.&nbsp;Inheritance</h2></div></div><div></div></div><p>Inheritance is a static relationship between classes, interfaces, and type 
        parameters:</p><div class="itemizedlist"><ul type="disc"><li><p>a class may <span class="emphasis"><em>extend</em></span> another class, as defined
                by <a href="declarations.html#classinheritance" title="4.5.4.&nbsp;Class inheritance">&sect;4.5.4 Class inheritance</a>,</p></li><li><p>a class may <span class="emphasis"><em>satisfy</em></span> one or more interfaces, 
                as defined by <a href="declarations.html#classinheritance" title="4.5.4.&nbsp;Class inheritance">&sect;4.5.4 Class inheritance</a>,</p></li><li><p>an interface may <span class="emphasis"><em>satisfy</em></span> one or more other 
                interfaces, as defined by <a href="declarations.html#interfaceinheritance" title="4.4.2.&nbsp;Interface inheritance">&sect;4.4.2 Interface inheritance</a>, or</p></li><li><p>a type parameter may <span class="emphasis"><em>satisfy</em></span> a class and/or 
                one or more interfaces or type parameters, as defined by 
                <a href="typesystem.html#generictypeconstraints" title="3.5.3.&nbsp;Generic type constraints">&sect;3.5.3 Generic type constraints</a>.</p></li></ul></div><p>If a type declaration extends or satisfies a type, we say it 
        <span class="emphasis"><em>inherits</em></span> the type.</p><p>Inheritance relationships may not produce cycles, since that would violate
        the noncircularity rule for subtyping. Thus, a class, interface, or type parameter
        may not, directly or indirectly, inherit itself.</p><i><span class="comment">
        <p>Note: when a type declaration specifies a relationship to other types, 
        Ceylon visually distinguishes between a list of types which conceptually 
        represents a combination of (intersection of) the types, and a list of types 
        which represents a choice between (union of) the types. For example, when a 
        class <tt class="literal">C</tt> satisfies multiple interfaces, they are written as 
        <tt class="literal">X&amp;Y&amp;Z</tt>. On the other hand, the cases of an 
        enumerated class <tt class="literal">E</tt> are written as <tt class="literal">X|Y|Z</tt>.
        This syntax emphasizes that <tt class="literal">C</tt> is also a subtype of the 
        intersection type <tt class="literal">X&amp;Y&amp;Z</tt>, and that <tt class="literal">E</tt> 
        may be narrowed to the union type <tt class="literal">X|Y|Z</tt> using a 
        <tt class="literal">switch</tt> statement or the <tt class="literal">of</tt> operator.</p>
        </span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritanceandsubtyping"></a>3.3.1.&nbsp;Inheritance and subtyping</h3></div></div><div></div></div><p>Inheritance relationships between classes, interfaces, and type parameters
            result in subtyping relationships between types.</p><div class="itemizedlist"><ul type="disc"><li><p>If a type <tt class="literal">X</tt> inherits a type <tt class="literal">Y</tt>, 
                then <tt class="literal">X</tt> is a subtype of <tt class="literal">Y</tt>.</p></li><li><p>If a generic type <tt class="literal">X</tt> inherits a type <tt class="literal">Y</tt> 
                that might involve the type parameters of <tt class="literal">X</tt>, then for any 
                instantiation <tt class="literal">U</tt> of <tt class="literal">X</tt> we can construct 
                a type <tt class="literal">V</tt> by, for every type parameter <tt class="literal">T</tt> 
                of <tt class="literal">X</tt>, substituting the corresponding type argument of 
                <tt class="literal">T</tt> given in <tt class="literal">U</tt> everywhere <tt class="literal">T</tt> 
                occurs in <tt class="literal">Y</tt>, and then <tt class="literal">U</tt> is a subtype of
                <tt class="literal">V</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="extendedclass"></a>3.3.2.&nbsp;Extension</h3></div></div><div></div></div><p>A class may extend another class, in which case the first class is a subtype
            of the second class and inherits its members.</p><pre class="synopsis">ExtendedType: "extends" ("super" ".")? TypeNameWithArguments PositionalArguments</pre><p>The <tt class="literal">extends</tt> clause must specify exactly one superclass.</p><div class="itemizedlist"><ul type="disc"><li><p>If the superclass is a parameterized type, the <tt class="literal">extends</tt> 
                    clause must also explicitly specify type arguments.</p></li><li><p>The <tt class="literal">extends</tt> clause must specify arguments for the 
                    initializer parameters of the superclass.</p></li></ul></div><p>The type arguments may <span class="emphasis"><em>not</em></span> be inferred from the 
            initializer arguments.</p><pre class="brush: ceylon">extends Person(name, org)</pre><p>A member class annotated <tt class="literal">actual</tt> may use the qualifier 
            <tt class="literal">super</tt> in the <tt class="literal">extends</tt> clause to refer to the 
            member class it refines. When the qualifier <tt class="literal">super</tt> appears, the
            following class name refers to a member class of the superclass of the class that
            contains the member class annotated <tt class="literal">actual</tt>.</p><pre class="brush: ceylon">extends super.Buffer()</pre><p>
            The root class <tt class="literal">Anything</tt> defined in <tt class="literal">ceylon.language</tt> 
            does not have a superclass.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="satisfiedinterfaces"></a>3.3.3.&nbsp;Satisfaction</h3></div></div><div></div></div><p>The <tt class="literal">satisfies</tt> clause does double duty. It's used to 
            specify that a class or interface is a direct subtype of one or more interfaces, 
            and to specify upper bound type constraints applying to a type parameter.</p><i><span class="comment"><p>Note: for this reason the keyword is not named 
            "<tt class="literal">implements</tt>". It can't reasonably be said that a type 
            parameter "implements" its upper bounds. Nor can it be reasonably said that
            an interface "implements" its super-interfaces.</p></span></i><div class="itemizedlist"><ul type="disc"><li><p>A class or interface may satisfy one or more interfaces, in which case
                the class or interface is a subtype of the satisfied interfaces, and inherits 
                their members.</p></li><li><p>A type parameter may satisfy one or more interfaces, optionally, a class,
                and optionally, another type parameter. In this case, the satisfied types are 
                interpreted as upper bound type constraints on arguments to the type 
                parameter.</p></li></ul></div><i><span class="comment"><p>Note: currently, a type parameter upper bound may not be specified
            in combination with other upper bounds. This restriction will likely be removed in
            future.</p></span></i><pre class="synopsis">SatisfiedTypes: "satisfies" PrimaryType ("&amp;" PrimaryType)*</pre><p>The <tt class="literal">satisfies</tt> clause may specify multiple types. If a 
            satisfied type is a parameterized type, the <tt class="literal">satisfies</tt> clause 
            must specify type arguments.</p><pre class="brush: ceylon">satisfies Sequence&lt;Element&gt; &amp; Collection&lt;Element&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="casesandcoverage"></a>3.4.&nbsp;Case enumeration and coverage</h2></div></div><div></div></div><p><span class="emphasis"><em>Coverage</em></span> is a static relationship between classes, 
        interfaces, and type parameters, produced through the use of <span class="emphasis"><em>case 
        enumeration</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>An <tt class="literal">abstract</tt> class or interface may be an 
            <span class="emphasis"><em>enumerated type</em></span>, with an enumerated list of 
            disjoint subtypes called <span class="emphasis"><em>cases</em></span>, as defined by
            <a href="declarations.html#classeswithcases" title="4.5.8.&nbsp;Classes with enumerated cases">&sect;4.5.8 Classes with enumerated cases</a> and 
            <a href="declarations.html#interfaceswithcases" title="4.4.3.&nbsp;Interfaces with enumerated cases">&sect;4.4.3 Interfaces with enumerated cases</a>.</p></li><li><p>A type parameter may have an <span class="emphasis"><em>enumerated bound</em></span>,
            with an enumerated list possible type arguments, as defined by
            <a href="typesystem.html#generictypeconstraints" title="3.5.3.&nbsp;Generic type constraints">&sect;3.5.3 Generic type constraints</a>.</p></li><li><p>An <tt class="literal">abstract</tt> class or interface may have a 
            <span class="emphasis"><em>self type</em></span>, a type parameter representing the
            concrete type of an instance.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="coverage"></a>3.4.1.&nbsp;Coverage</h3></div></div><div></div></div><p>Coverage is a strictly weaker relationship than assignability:</p><div class="itemizedlist"><ul type="disc"><li><p>If a type is a subtype of a second type, then the second type
                covers the first type.</p></li><li><p>If a type has a self type, then its self type covers the type.</p></li><li><p>If a type <tt class="literal">X</tt> enumerates its cases 
                <tt class="literal">X1</tt>, <tt class="literal">X2</tt>, etc, then the union 
                <tt class="literal">X1|X2|...</tt> of its cases covers the type.</p></li><li><p>If a generic type <tt class="literal">X</tt> enumerates its cases, 
                <tt class="literal">X1</tt>, <tt class="literal">X2</tt>, etc, which might involve
                the type parameters of <tt class="literal">X</tt>, then for any instantiation 
                <tt class="literal">U</tt> of <tt class="literal">X</tt>, and for each case 
                <tt class="literal">Xi</tt>, we can construct a type <tt class="literal">Ui</tt> by,
                for every type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt>,
                substituting the corresponding type argument of <tt class="literal">T</tt> 
                given in <tt class="literal">U</tt> everywhere <tt class="literal">T</tt> occurs in 
                <tt class="literal">Xi</tt>, and then the union type <tt class="literal">U1|U2|...</tt>
                of all the resulting types <tt class="literal">Ui</tt> covers 
                <tt class="literal">Y</tt>.</p></li><li><p>If a type <tt class="literal">X</tt> covers two types <tt class="literal">A</tt> 
                and <tt class="literal">B</tt>, then <tt class="literal">X</tt> also covers their
                union <tt class="literal">A|B</tt>.</p></li><li><p>Coverage is transitive. If <tt class="literal">X</tt> covers
                <tt class="literal">Y</tt> and <tt class="literal">Y</tt> covers <tt class="literal">Z</tt>,
                then <tt class="literal">X</tt> covers <tt class="literal">Z</tt>.</p></li></ul></div><p>It follows that coverage obeys the identity property of assignability:
            a type covers itself. However, coverage does not obey the noncircularity property 
            of assignability. It is possible to have distinct types <tt class="literal">A</tt> and 
            <tt class="literal">B</tt> where <tt class="literal">A</tt> covers <tt class="literal">B</tt> and 
            <tt class="literal">B</tt> covers <tt class="literal">A</tt>.</p><p>Case enumeration allows safe use of a type in a <tt class="literal">switch</tt> 
            statement, or as the subject of the <tt class="literal">of</tt> operator. The 
            compiler is able to statically validate that the <tt class="literal">switch</tt> 
            contains an exhaustive list of all cases of the type, by checking that the
            union of cases enumerated in the <tt class="literal">switch</tt> covers the type,
            or that the second operand of <tt class="literal">of</tt> covers the type.</p><i><span class="comment">
            <p>Note: however, a type is <span class="emphasis"><em>not</em></span> considered automatically 
            assignable to the union of its cases, or to its self type. Instead, the type
            must be <span class="emphasis"><em>explicitly</em></span> narrowed to the union of its cases, 
            or to its self type, using either the <tt class="literal">of</tt> operator or the
            <tt class="literal">switch</tt> construct. This narrowing type conversion can be
            statically checked&#8212;if <tt class="literal">X</tt> covers <tt class="literal">Y</tt>
            then <tt class="literal">Y of X</tt> is guaranteed to succeed at runtime.
            Unfortunately, and quite unintuitively, the compiler is not able to analyse 
            coverage implicitly at the same time as assignability, because that results in 
            undecidability!</p>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cases"></a>3.4.2.&nbsp;Cases</h3></div></div><div></div></div><p>The <tt class="literal">of</tt> clause does triple duty. It's used to define
            self types and type families, enumerated types, and enumerated type 
            constraints. The <tt class="literal">of</tt> clause may specify multiple types, 
            called <span class="emphasis"><em>cases</em></span>.</p><pre class="synopsis">CaseTypes: "of" CaseType ("|" CaseType)*</pre><pre class="synopsis">CaseType: MemberName | PrimaryType</pre><p>If an interface or <tt class="literal">abstract</tt> class with an 
            <tt class="literal">of</tt> clause has exactly one case, and it is a type parameter 
            of the interface or <tt class="literal">abstract</tt> class, or of the immediately 
            containing type, if any, then that type parameter is a 
            <span class="emphasis"><em>self type</em></span> of the interface or <tt class="literal">abstract</tt> 
            class, and:</p><div class="itemizedlist"><ul type="disc"><li><p>the self type parameter covers the declared type within the 
                    body of the declaration,</p></li><li><p>the type argument to the self type parameter in an 
                    instantiation of the declared type covers the instantiation, 
                    and</p></li><li><p>every type which extends or satisfies an instantiation of the 
                    declared type must also be covered by the type argument to the self
                    type parameter in the instantiation.</p></li></ul></div><pre class="brush: ceylon">shared abstract class Comparable&lt;Other&gt;() of Other 
        given Other satisfies Comparable&lt;Other&gt; {
    
    shared formal Integer compare(Other that);
    
    shared Integer reverseCompare(Other that) =&gt; that.compare(this) of Other;
    
}</pre><pre class="brush: ceylon">Comparable&lt;Item&gt; comp = ... ;
Item item = comp of Item;</pre><p>Otherwise, an interface or <tt class="literal">abstract</tt> class with an 
            <tt class="literal">of</tt> clause may have multiple cases, but each case must be 
            either:</p><div class="itemizedlist"><ul type="disc"><li><p>a subtype of the interface or <tt class="literal">abstract</tt> 
                    class, or</p></li><li><p>a value reference to a toplevel anonymous class that is a 
                    subtype of the interface or <tt class="literal">abstract</tt> class.</p></li></ul></div><p>Then the interface or <tt class="literal">abstract</tt> class is an
            <span class="emphasis"><em>enumerated type</em></span>, and every subtype of the interface 
            or <tt class="literal">abstract</tt> class must be a subtype of exactly one of 
            the enumerated subtypes. A class or interface may not be a subtype of more 
            than one case of an enumerated type.</p><pre class="brush: ceylon">of larger | smaller | equal</pre><pre class="brush: ceylon">of Root&lt;Element&gt; | Leaf&lt;Element&gt; | Branch&lt;Element&gt;</pre><p>A type parameter with an <tt class="literal">of</tt> clause may specify 
            multiple cases, as defined in <a href="typesystem.html#generictypeconstraints" title="3.5.3.&nbsp;Generic type constraints">&sect;3.5.3 Generic type constraints</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="genericenumeratedtypes"></a>3.4.3.&nbsp;Generic enumerated types</h3></div></div><div></div></div><p>If a generic enumerated type <tt class="literal">X</tt> has a case type 
            <tt class="literal">C</tt>, then <tt class="literal">C</tt> must directly extend or 
            satisfy an instantiation <tt class="literal">Y</tt> of <tt class="literal">X</tt>, and 
            for each type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt> and 
            corresponding argument <tt class="literal">A</tt> of <tt class="literal">T</tt> given 
            in <tt class="literal">Y</tt>, either:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X</tt> is covariant in <tt class="literal">T</tt> and 
                    <tt class="literal">A</tt> is exactly <tt class="literal">Nothing</tt>,</p></li><li><p><tt class="literal">X</tt> is contravariant in <tt class="literal">T</tt> 
                    and <tt class="literal">A</tt> is exactly the intersection of all upper 
                    bounds on <tt class="literal">T</tt>, or <tt class="literal">Anything</tt> if 
                    <tt class="literal">T</tt> has no upper bounds, or</p></li><li><p><tt class="literal">C</tt> is an instantiation of a generic type 
                    <tt class="literal">G</tt> and <tt class="literal">A</tt> is exactly 
                    <tt class="literal">S</tt> for some type parameter <tt class="literal">S</tt> 
                    of <tt class="literal">G</tt>, and <tt class="literal">S</tt> must have the same 
                    variance as <tt class="literal">T</tt>.</p></li></ul></div><p>For example, the following covariant enumerated type is legal:</p><pre class="brush: ceylon">interface List&lt;out Element&gt; 
        of Cons&lt;Element&gt; | nil { ... }

class Cons&lt;out Element&gt;(Element element) 
        satisfies List&lt;Element&gt; { ... }

object nil 
        satisfies List&lt;Nothing&gt; { ... }</pre><p>As is the following contravariant enumerated type:</p><pre class="brush: ceylon">interface Consumer&lt;in Event&gt; 
        of Logger | Handler&lt;Event&gt; 
        given Event satisfies AbstractEvent { ... }

interface Logger 
        satisfies Consumer&lt;AbstractEvent&gt; { ... }

interface Handler&lt;in Event&gt; 
        satisfies Consumer&lt;AbstractEvent&gt; 
        given Event satisfies AbstractEvent { ... }</pre><p>But the following enumerated type is not legal, since it is possible 
            to choose a legal argument <tt class="literal">T</tt> of the type parameter 
            <tt class="literal">Type</tt> of <tt class="literal">Expression</tt>, such that the case 
            types <tt class="literal">StringExpression</tt> and <tt class="literal">NumericExpression</tt> 
            aren't subtypes of the instantiation <tt class="literal">Expression&lt;T&gt;</tt>:</p><pre class="brush: ceylon">interface Expression&lt;out Type&gt;
        of Function&lt;Type&gt; | String | Number { ... }

interface Function&lt;out Type&gt; 
        satisfies Expression&lt;Type&gt; { ... }

interface String 
        satisfies Expression&lt;String&gt; { ... }

interface Number 
        satisfies Expression&lt;Integer|Float&gt; { ... }</pre><i><span class="comment"><p>Note: these rules could be relaxed to allow the definition of
            generic enumerated types where the list of cases of an instantiation of a 
            generic type depends upon the given type arguments (a "generalized" algebraic
            type).</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="disjointtypes"></a>3.4.4.&nbsp;Disjoint types</h3></div></div><div></div></div><p>Two types are said to be <span class="emphasis"><em>disjoint</em></span> if it is impossible
            to have a value that is an instance of both types. If <tt class="literal">X</tt> and 
            <tt class="literal">Y</tt> are disjoint, then their intersection <tt class="literal">X&amp;Y</tt>
            is the bottom type <tt class="literal">Nothing</tt>.</p><p>Two types <tt class="literal">X</tt> and <tt class="literal">Y</tt> are disjoint if
            either:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X</tt> and <tt class="literal">Y</tt> are both classes and
                    <tt class="literal">X</tt> is not a subclass of <tt class="literal">Y</tt> and 
                    <tt class="literal">Y</tt> is not a subclass of <tt class="literal">X</tt>,</p></li><li><p><tt class="literal">X</tt> is the class <tt class="literal">Null</tt> and 
                    <tt class="literal">Y</tt> is an interface,</p></li><li><p><tt class="literal">X</tt> is an anonymous class or an instantiation 
                    of a <tt class="literal">final</tt> class and <tt class="literal">Y</tt> is an 
                    instantiation of a class of interface, and <tt class="literal">X</tt> 
                    does not inherit <tt class="literal">Y</tt>,</p></li><li><p><tt class="literal">X</tt> is an anonymous class or a <tt class="literal">final</tt> 
                    class with no type parameters and <tt class="literal">Y</tt> is a type in 
                    which no type parameter reference occurs, and <tt class="literal">X</tt> 
                    is not a suptype of <tt class="literal">Y</tt>,</p></li><li><p><tt class="literal">X</tt> is a type parameter and <tt class="literal">Y</tt> 
                    and the intersection of the upper bounds of <tt class="literal">X</tt> are 
                    disjoint,</p></li><li><p><tt class="literal">X</tt> is an union type <tt class="literal">A|B</tt> and 
                    both <tt class="literal">Y</tt> and <tt class="literal">A</tt> are disjoint and 
                    <tt class="literal">Y</tt> and <tt class="literal">B</tt> are disjoint,</p></li><li><p><tt class="literal">X</tt> is an intersection type <tt class="literal">A&amp;B</tt> 
                    and either <tt class="literal">Y</tt> and <tt class="literal">A</tt> are disjoint or
                    <tt class="literal">Y</tt> and <tt class="literal">B</tt> are disjoint, or</p></li><li><p><tt class="literal">X</tt> and <tt class="literal">Y</tt> inherit disjoint
                    instantiations of a generic type <tt class="literal">Z</tt>, that is, two 
                    instantiations of <tt class="literal">Z</tt> that have the intersection
                    <tt class="literal">Nothing</tt>, as defined below, in <a href="typesystem.html#principalinstantiationinheritance" title="3.7.2.&nbsp;Principal instantiation inheritance">&sect;3.7.2 Principal instantiation inheritance</a>.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generictypeparameters"></a>3.5.&nbsp;Generic type parameters</h2></div></div><div></div></div><p>Function, class, and interface schemas may be parameterized by one or more 
        generic type parameters. A parameterized type schema defines a type constructor, 
        a function that produces a type given a tuple of compatible type arguments. A 
        parameterized class or function schema defines a function that produces the 
        signature of an invokable operation given a tuple of compatible type arguments.</p><pre class="synopsis">TypeParameters: "&lt;" (TypeParameter ",")* TypeParameter "&gt;"</pre><p>A declaration with type parameters is called <span class="emphasis"><em>generic</em></span> or
        <span class="emphasis"><em>parameterized</em></span>.</p><div class="itemizedlist"><ul type="disc"><li><p>A type schema with no type parameters defines exactly one type. A 
            parameterized type schema defines a template for producing types: one type 
            for each possible combination of type arguments that satisfy the type constraints 
            specified by the type. The types of members of the this type are determined by 
            replacing every appearance of each type parameter in the schema of the 
            parameterized type definition with its type argument.</p></li><li><p>A function schema with no type parameters defines exactly one operation 
            per type. A parameterized function declaration defines a template for producing
            overloaded operations: one operation for each possible combination of type 
            arguments that satisfy the type constraints specified by the method declaration.</p></li><li><p>A class schema with no type parameters defines exactly one instantiation 
            operation. A parameterized class schema defines a template for producing 
            overloaded instantiation operations: one instantiation operation for each possible 
            combination of type arguments that satisfy the type constraints specified by the 
            class declaration. The type of the object produced by an instantiation operation is 
            determined by substituting the same combination of type arguments for the type 
            parameters of the parameterized class schema.</p></li></ul></div><i><span class="comment"><p>Note: by convention, type parameter names should be constructed from
        meaningful words. The use of single-letter type parameter names is discouraged. The 
        name of a type parameter should be chosen so that declarations within the body of 
        the parameterized declaration read naturally. For example, 
        <tt class="literal">class Entry&lt;Key,Item&gt;</tt> is reasonable, since
        <tt class="literal">Key key</tt> and <tt class="literal">Item item</tt> read naturally within 
        the body of the <tt class="literal">Entry</tt> class. The following identifier names 
        usually refer to a type parameter: <tt class="literal">Element</tt>, <tt class="literal">Other</tt>,
        <tt class="literal">This</tt>, <tt class="literal">Value</tt>, <tt class="literal">Key</tt>, 
        <tt class="literal">Item</tt>, <tt class="literal">Argument</tt>, <tt class="literal">Args</tt> and 
        <tt class="literal">Result</tt>. Avoid, where reasonable, using these names for interfaces 
        and classes.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeparametersandvariance"></a>3.5.1.&nbsp;Type parameters and variance</h3></div></div><div></div></div><p>A <span class="emphasis"><em>type parameter</em></span> allows a declaration to be abstracted 
            over a constrained set of types.</p><pre class="synopsis">TypeParameter: Variance? TypeName ("=" Type)</pre><p>Every type parameter has a name and a <span class="emphasis"><em>variance</em></span>.</p><pre class="synopsis">Variance: "out" | "in"</pre><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>covariant</em></span> type parameter is indicated using the
                    keyword <tt class="literal">out</tt>.</p></li><li><p>A <span class="emphasis"><em>contravariant</em></span> type parameter is indicated using 
                    the keyword <tt class="literal">in</tt>.</p></li><li><p>By default, a type parameter is <span class="emphasis"><em>invariant</em></span>.</p></li></ul></div><p>A type parameter may, optionally, have a <span class="emphasis"><em>default type argument</em></span>. 
            A type parameter with a default type argument must occur after all type parameters 
            without default type arguments in the type parameter list. The default type argument 
            must satisfy the constraints on the type parameter.</p><p>A default type argument may not involve the parameter for which it is the 
            default argument, nor any type parameter of the declaration that occurs later in 
            the list of type parameters.</p><p>Within the body of the schema it parameterizes, a type parameter is itself a 
            type. The type parameter is a subtype of every upper bound of the type parameter. 
            However, a class or interface may not extend or satisfy a type parameter.</p><pre class="brush: ceylon">&lt;Key, out Item&gt;</pre><pre class="brush: ceylon">&lt;in Message&gt;</pre><pre class="brush: ceylon">&lt;out Element=Object&gt;</pre><pre class="brush: ceylon">&lt;in Left, in Right, out Result&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="variancevalidation"></a>3.5.2.&nbsp;Variance validation</h3></div></div><div></div></div><p>A covariant type parameter may only appear in <span class="emphasis"><em>covariant positions</em></span> 
            of the parameterized schema. A contravariant type parameter may only appear in 
            <span class="emphasis"><em>contravariant positions</em></span> of the parameterized schema. An 
            invariant type parameter may appear in any position.</p><p>Furthermore, a type with a contravariant type parameter may only appear in a
            covariant position in an extended type, satisfied type, case type, or upper bound
            type constraint.</p><i><span class="comment"><p>Note: this restriction exists to eliminate certain undecidable cases
            described in the paper Taming Wildcards in Java's Type System, by Tate et al.</p></span></i><p>To determine if a type expression occurs in a covariant or contravariant 
            position, we first consider how the type occurs syntactically.</p><p>For a generic function we examine the return type of the function, which
            is a covariant position.</p><p>For a generic type schema we examine each <tt class="literal">shared</tt> 
            member, along with extended/satisfied types and case types.</p><i><span class="comment"><p>Note: since the visibility rules are purely lexical in nature, it is 
            legal for a member expression occurring in the body of a class or interface to have 
            a receiver expression other that is not a self-reference, as defined in 
            <a href="expressions.html#selfreferences" title="6.3.&nbsp;Self references and the current package reference">&sect;6.3 Self references and the current package reference</a>, and refer to an un-<tt class="literal">shared</tt> member 
            of the class or interface. In this special case, the member is treated as if it were 
            <tt class="literal">shared</tt> for the purposes of the following variance validation 
            rules.</p></span></i><div class="itemizedlist"><ul type="disc"><li><p>An extended type, satisfied type, or case type of the type schema 
                    itself is a covariant position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> method declaration of the parameterized 
            type schema:</p><div class="itemizedlist"><ul type="disc"><li><p>The return type of the method is a covariant position.</p></li><li><p>Any parameter type of the method is a contravariant position.</p></li><li><p>Any upper bound of a type parameter of the method is a contravariant 
                    position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> attribute declaration that is not
            variable:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of the attribute is a covariant position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> reference declaration that is 
            variable:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of the attribute is an invariant position.</p></li></ul></div><p>In a <tt class="literal">shared</tt> nested class declaration of the 
            parameterized type schema:</p><div class="itemizedlist"><ul type="disc"><li><p>Any initializer parameter type of the class is a contravariant 
                    position.</p></li><li><p>Any upper bound of a type parameter of the class is a contravariant 
                    position.</p></li><li><p>An extended type, satisfied type, or case type of the nested class
                    is a covariant position.</p></li><li><p>Every covariant position of the nested class schema is a covariant
                    position of the containing type schema. Every contravariant position of 
                    the nested class schema is a contravariant position of the containing type 
                    schema.</p></li></ul></div><p>In a <tt class="literal">shared</tt> nested interface declaration of the 
            parameterized type schema:</p><div class="itemizedlist"><ul type="disc"><li><p>An extended type, satisfied type, or case type of the nested interface 
                    is a covariant position.</p></li><li><p>Every covariant position of the nested interface schema is a covariant
                    position of the containing type schema. Every contravariant position of 
                    the nested interface schema is a contravariant position of the containing 
                    type schema.</p></li></ul></div><p>For parameters of callable parameters, we first determine if the callable
            parameter itself is covariant or contravariant:</p><div class="itemizedlist"><ul type="disc"><li><p>A callable parameter of a method or nested class is contravariant.</p></li><li><p>A callable parameter of a covariant parameter is contravariant.</p></li><li><p>A callable parameter of a contravariant parameter is covariant.</p></li></ul></div><p>Then:</p><div class="itemizedlist"><ul type="disc"><li><p>The return type of a covariant callable parameter is a covariant 
                    position.</p></li><li><p>The return type of a contravariant callable parameter is a 
                    contravariant position.</p></li><li><p>The type of a parameter of a covariant callable parameter is a 
                    contravariant position.</p></li><li><p>The type of a parameter of a contravariant callable parameter is a 
                    covariant position.</p></li></ul></div><p>Finally, to determine if a type parameter that occurs as a type argument occurs
            in a covariant or contravariant position, we must consider the declared variance
            of the corresponding type parameter:</p><div class="itemizedlist"><ul type="disc"><li><p>A type argument of a covariant type parameter of a type in a covariant 
                    position is a covariant position.</p></li><li><p>A type argument of a contravariant type parameter of a type in a 
                    covariant position is a contravariant position.</p></li><li><p>A type argument of a covariant type parameter of a type in a 
                    contravariant position is a contravariant position.</p></li><li><p>A type argument of a contravariant type parameter of a type in a 
                    contravariant position is a covariant position.</p></li><li><p>A type argument of an invariant type parameter of a type in any position 
                    is an invariant position.</p></li><li><p>A type argument of any type parameter of a type in an invariant position 
                    is an invariant position.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="generictypeconstraints"></a>3.5.3.&nbsp;Generic type constraints</h3></div></div><div></div></div><p>A parameterized method, class, or interface declaration may declare constraints 
            upon ordinary type parameters using the <tt class="literal">given</tt> clause.</p><pre class="synopsis">TypeConstraints: TypeConstraint+</pre><p>There may be at most one <tt class="literal">given</tt> clause per type parameter.</p><pre class="synopsis">TypeConstraint: "given" TypeName TypeConstraintInheritance</pre><pre class="synopsis">TypeConstraintInheritance: CaseTypes? SatisfiedTypes?</pre><i><span class="comment">
            <p>Note that the syntax for a type constraint is essentially the same syntax 
            used for other type declarations such as class and interface declarations.</p>
            </span></i><p>There are two different kinds of type constraint:</p><div class="itemizedlist"><ul type="disc"><li><p>An <span class="emphasis"><em>upper bound</em></span>, <tt class="literal">given X satisfies T</tt>, 
                    specifies that the type parameter <tt class="literal">X</tt> is a subtype of 
                    a given type <tt class="literal">T</tt>.</p></li><li><p>An <span class="emphasis"><em>enumerated bound</em></span>, <tt class="literal">given X of T|U|V</tt>
                    specifies that the type parameter <tt class="literal">X</tt> represents one 
                    of the enumerated types.</p></li></ul></div><p>The types listed in an enumerated bound must be mutually disjoint, and each
            type must be a class or interface type.</p><i><span class="comment"><p>TODO: Should we allow unions in upper bounds? Should we allow 
            intersections in enumerated bounds?</p></span></i><p>A single <tt class="literal">given</tt> clause may specify multiple constraints on 
            a certain type parameter. In particular, it may specify multiple upper bounds
            together with an enumerated bound. If multiple upper bounds are specified, at most
            one upper bound may be a class, and at most one upper bound may be a type parameter.</p><i><span class="comment"><p>Note: in Ceylon 1.0, a type parameter with multiple upper bounds may 
            not have an upper bound which is another type parameter.</p></span></i><pre class="brush: ceylon">given Value satisfies Ordinal &amp; Comparable&lt;Value&gt;</pre><pre class="brush: ceylon">given Quantities satisfies Correspondence&lt;Key,Decimal&gt;</pre><pre class="brush: ceylon">given Argument of String | Integer | Float</pre><p>A type parameter is a subtype of its upper bounds.</p><pre class="brush: ceylon">class Holder&lt;Value&gt;(shared Value value) 
        extends Object
        given Value satisfies Object {
    shared actual Boolean equals(Object that) {
        if (is Holder&lt;Value&gt; that) {
            return value==that.value;
        }
        else {
            return false;
        }
    }
    shared actual Integer hash =&gt;  value.hash;
}</pre><p>Every type parameter has an implicit upper bound of type 
            <tt class="literal">Anything</tt>.</p><p>An enumerated bound allows the use of an exhaustive <tt class="literal">switch</tt>
            with expressions of the parameter type.</p><pre class="brush: ceylon">Characters uppercase&lt;Characters&gt;(Characters chars) 
       given Characters of String | Range&lt;Character&gt; { 
    switch (Characters)
    case (satisfies String) { 
        return chars.uppercased;
    }
    case (satisfies Range&lt;Character&gt;) { 
        return chars.first.uppercased..chars.last.uppercased;
    }
}</pre><i><span class="comment"><p>TODO: Do we need lower bound type constraints? The syntax would be:</p>
            <pre class="brush: ceylon">given T abstracts One|Two</pre><p>With union types
            they don't appear to be anywhere near as useful. However, perhaps they are useful
            when combined with contravariant types. (A lower bound on a parameter which occurs 
            as the argument of a contravariant type is more like an upper bound).</p></span></i><i><span class="comment"><p>Note: since we have reified types, it would be possible to support
            a type constraint that allows instantiation of the type parameter.</p>
            <pre class="brush: ceylon">given T(Object arg)</pre>
            <p>The problem with this is that then inferring <tt class="literal">T</tt> is fragile.
            And if we don't let it be inferred, we may as well pass <tt class="literal">T</tt> as an
            ordinary parameter. So Ceylon, unlike C#, doesn't support this.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generictypearguments"></a>3.6.&nbsp;Generic type arguments</h2></div></div><div></div></div><p>A list of <span class="emphasis"><em>type arguments</em></span> produces a new type schema 
        from a parameterized type schema, or a new function schema from a from a
        parameterized function schema. In the case of a type schema, this new schema is
        the schema of an applied type.</p><p>A type argument list is a list of types.</p><pre class="synopsis">TypeArguments: "&lt;" (Type ",")* Type "&gt;"</pre><p>A type argument may itself be an applied type, or type parameter,
        or may involve unions and intersections.</p><pre class="brush: ceylon">&lt;Key, List&lt;Item&gt;&gt;</pre><pre class="brush: ceylon">&lt;String, Person?&gt;</pre><pre class="brush: ceylon">&lt;String[], [{Object*}]&gt;</pre><p>Type arguments are assigned to type parameters according to the positions
        they occur in the list.</p><p>Given the schema of a generic declaration, we form the new schema by 
        <span class="emphasis"><em>type argument substitution</em></span>. Each type argument is substituted 
        for every appearance of the corresponding type parameter in the schema of the 
        generic declaration, including:</p><div class="itemizedlist"><ul type="disc"><li><p>attribute types,</p></li><li><p>method return types,</p></li><li><p>method parameter types,</p></li><li><p>initializer parameter types, and</p></li><li><p>type arguments of extended classes and satisfied interfaces.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeargumentsandconstraints"></a>3.6.1.&nbsp;Type arguments and type constraints</h3></div></div><div></div></div><p>A generic type constraint affects the type arguments that can be assigned 
            to a type parameter:</p><div class="itemizedlist"><ul type="disc"><li><p>A type argument to a type parameter <tt class="literal">T</tt> with an 
                    upper bound must be a type which is a subtype of all upper bounds of
                    <tt class="literal">T</tt>.</p></li><li><p>A type argument to a type parameter <tt class="literal">T</tt> with an 
                    enumerated type bound must be a subtype of one of the enumerated types
                    of <tt class="literal">T</tt>, or it must be a type parameter <tt class="literal">A</tt> 
                    with an enumerated type bound where every enumerated type of 
                    <tt class="literal">A</tt> is also an enumerated type of <tt class="literal">T</tt>.</p></li></ul></div><p>A type argument list <span class="emphasis"><em>conforms</em></span> to a type parameter list 
            if, for every type parameter in the list, either:</p><div class="itemizedlist"><ul type="disc"><li><p>there is a type argument that satisfies the constraints of the type 
                    parameter, or</p></li><li><p>there is no explicit type argument but the type parameter has a 
                    default type argument, in which case the type argument is defaulted by
                    substituting the arguments of all type parameters that occur earlier in
                    the list of type parameters of the declaration into this default type
                    argument.</p></li></ul></div><p>There must be at least as many type parameters as type arguments. There must 
            be at least as many type arguments as type parameters without default values.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="producedtypes"></a>3.6.2.&nbsp;Applied types and and variance</h3></div></div><div></div></div><p>If a type argument list conforms to a type parameter list, the combination
            of the parameterized type together with the type argument list is itself a type,
            called an <span class="emphasis"><em>applied type</em></span>. We also call the applied type an 
            <span class="emphasis"><em>instantiation</em></span> of the generic type.</p><p>For a generic type <tt class="literal">X</tt>, the instantiations <tt class="literal">Y</tt> 
            and <tt class="literal">Z</tt> of <tt class="literal">X</tt> represent the same type if and 
            only if for every <tt class="literal">A</tt> in the list of type arguments specified
            in <tt class="literal">Y</tt> and corresponding <tt class="literal">B</tt> in the list of type 
            arguments specified in <tt class="literal">Z</tt>, <tt class="literal">A</tt> is exactly the 
            same type as <tt class="literal">B</tt>.</p><p>For a generic type <tt class="literal">X</tt>, and instantiations 
            <tt class="literal">Y</tt> and <tt class="literal">Z</tt> of <tt class="literal">X</tt>, 
            <tt class="literal">Y</tt> is a subtype of <tt class="literal">Z</tt> if and only if, for 
            every type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt>, and 
            corresponding arguments <tt class="literal">A</tt> specified in <tt class="literal">Y</tt> 
            and <tt class="literal">B</tt> specified in <tt class="literal">Z</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>
                        <tt class="literal">T</tt> is a covariant type parameter, and
                        <tt class="literal">A</tt> is a subtype of <tt class="literal">B</tt>, or
                    </p></li><li><p>
                        <tt class="literal">T</tt> is a contravariant type parameter, and
                        <tt class="literal">B</tt> is a subtype of <tt class="literal">A</tt>, or
                    </p></li><li><p>
                        <tt class="literal">T</tt> is an invariant type parameter (neither 
                        covariant nor contravariant), and <tt class="literal">A</tt> and
                        <tt class="literal">B</tt> are exactly the same type.
                    </p></li></ul></div><i><span class="comment"><p>Note that if <tt class="literal">T</tt> is an invariant type parameter
            of <tt class="literal">X&lt;T&gt;</tt>, then a type <tt class="literal">Z</tt> is a subtype 
            of <tt class="literal">X&lt;A&gt;</tt> if and only if <tt class="literal">Z</tt> has the 
            principal instantiation <tt class="literal">X&lt;A&gt;</tt>.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeargumentinference"></a>3.6.3.&nbsp;Type argument inference</h3></div></div><div></div></div><p>When a direct invocation expression, as defined by 
            <a href="expressions.html#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>, for a generic function or a direct 
            instantiation expression for a generic class does not explicitly specify type 
            arguments, the type arguments are inferred from the argument expression types. 
            The types of the argument expressions and the declared types of the corresponding 
            parameters determine an <span class="emphasis"><em>inferred lower bound</em></span> or 
            <span class="emphasis"><em>inferred upper bound</em></span> for each type parameter.</p><p>If a list of argument expressions has types <tt class="literal">A1,A2,...</tt> 
            and the corresponding list of parameters has declared types <tt class="literal">P1,P2,...</tt>, 
            the inferred lower bound for a type parameter <tt class="literal">T</tt> of the generic
            declaration is the conjunction of:</p><div class="itemizedlist"><ul type="disc"><li><p>all inferred lower bounds <tt class="literal">Ai</tt> on <tt class="literal">Pi</tt> 
                    for <tt class="literal">T</tt>.</p></li></ul></div><p>The inferred upper bound for a type parameter <tt class="literal">T</tt> of the generic
            declaration is the conjunction of:</p><div class="itemizedlist"><ul type="disc"><li><p>all upper bounds <tt class="literal">Xi</tt> explicitly declared by a type 
                    constraint on <tt class="literal">T</tt> of form <tt class="literal">given T satisfies Xi</tt>, 
                    if any, with</p></li><li><p>all inferred upper bounds <tt class="literal">Ai</tt> on <tt class="literal">Pi</tt> 
                    for <tt class="literal">T</tt>.</p></li></ul></div><i><span class="comment"><p>TODO: What should we do about upper bound constraints that involve
            other type parameters? Currently the typechecker simply ignores any upper bound 
            that involves any type parameter.</p></span></i><p>Given types <tt class="literal">A</tt> and <tt class="literal">P</tt>, we determine 
            the <span class="emphasis"><em>inferred lower bound</em></span> <tt class="literal">A</tt> on 
            <tt class="literal">P</tt> for <tt class="literal">T</tt> according to the nature of 
            <tt class="literal">A</tt> and <tt class="literal">P</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">P</tt> is exactly <tt class="literal">T</tt>, the 
                    inferred lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is <tt class="literal">T abstracts A</tt>.</p></li><li><p>If <tt class="literal">P</tt> is a union type <tt class="literal">Q|R</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the lower bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the lower bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>. <span class="emphasis"><em>Note: this case is special.</em></span></p></li><li><p>If <tt class="literal">P</tt> is an intersection type <tt class="literal">Q&amp;R</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the lower bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the lower bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is a union type <tt class="literal">B|C</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the lower bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the lower bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is an intersection type <tt class="literal">B&amp;C</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the lower bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the lower bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">P</tt> is an applied type <tt class="literal">Q&lt;P1,P2,...&gt;</tt> 
                    of a parameterized type <tt class="literal">Q</tt>, and <tt class="literal">A</tt> 
                    is a subtype of an applied type <tt class="literal">Q&lt;A1,A2,..&gt;</tt>, 
                    the lower bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of all lower bounds <tt class="literal">Ai</tt> 
                    on <tt class="literal">Pi</tt> for <tt class="literal">T</tt>.</p></li><li><p>Otherwise, if <tt class="literal">A</tt> is not a union or intersection, 
                    and if <tt class="literal">P</tt> is neither an applied type, a union, or an
                    intersection, nor exactly <tt class="literal">T</tt>, the lower bound 
                    <tt class="literal">A</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>
                    is <span class="emphasis"><em>null</em></span>.</p></li></ul></div><p>Where:</p><div class="itemizedlist"><ul type="disc"><li><p>the conjunction of a lower bound <tt class="literal">T abstracts A</tt>
                    with a lower bound <tt class="literal">T abstracts B</tt> is the lower bound 
                    <tt class="literal">T abstracts A|B</tt>,</p></li><li><p>the disjunction of a lower bound <tt class="literal">T abstracts A</tt>
                    with a lower bound <tt class="literal">T abstracts B</tt> is the lower bound 
                    <tt class="literal">T abstracts A&amp;B</tt>,</p></li><li><p>the conjunction or disjunction of a lower bound <tt class="literal">T abstracts A</tt>
                    with a null lower bound is <tt class="literal">T abstracts A</tt>, and</p></li><li><p>the conjunction or disjunction of two null lower bounds is null.</p></li></ul></div><p>Given types <tt class="literal">A</tt> and <tt class="literal">P</tt>, we determine 
            the <span class="emphasis"><em>inferred upper bound</em></span> <tt class="literal">A</tt> on 
            <tt class="literal">P</tt> for <tt class="literal">T</tt> according to the nature of 
            <tt class="literal">A</tt> and <tt class="literal">P</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>If <tt class="literal">P</tt> is exactly <tt class="literal">T</tt>, the 
                    inferred upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is <tt class="literal">T satisfies A</tt>.</p></li><li><p>If <tt class="literal">P</tt> is a union type <tt class="literal">Q|R</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the upper bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the upper bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>. <span class="emphasis"><em>Note: this case is special.</em></span></p></li><li><p>If <tt class="literal">P</tt> is an intersection type <tt class="literal">Q&amp;R</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the upper bound 
                    <tt class="literal">A</tt> on <tt class="literal">Q</tt> for <tt class="literal">T</tt> 
                    with the upper bound <tt class="literal">A</tt> on <tt class="literal">R</tt> 
                    for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is a union type <tt class="literal">B|C</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the disjunction of the upper bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the upper bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">A</tt> is an intersection type <tt class="literal">B&amp;C</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of the upper bound <tt class="literal">B</tt> 
                    on <tt class="literal">P</tt> for <tt class="literal">T</tt> with the upper bound 
                    <tt class="literal">C</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>.</p></li><li><p>If <tt class="literal">P</tt> is an applied type <tt class="literal">Q&lt;P1,P2,...&gt;</tt> 
                    of a parameterized type <tt class="literal">Q</tt>, and <tt class="literal">A</tt> 
                    is a subtype of an applied type <tt class="literal">Q&lt;A1,A2,..&gt;</tt>, 
                    the upper bound <tt class="literal">A</tt> on <tt class="literal">P</tt> for 
                    <tt class="literal">T</tt> is the conjunction of all upper bounds <tt class="literal">Ai</tt> 
                    on <tt class="literal">Pi</tt> for <tt class="literal">T</tt>.</p></li><li><p>Otherwise, if <tt class="literal">A</tt> is not a union or intersection, 
                    and if <tt class="literal">P</tt> is neither an applied type, a union, or an
                    intersection, nor exactly <tt class="literal">T</tt>, the upper bound 
                    <tt class="literal">A</tt> on <tt class="literal">P</tt> for <tt class="literal">T</tt>
                    is <span class="emphasis"><em>null</em></span>.</p></li></ul></div><p>Where:</p><div class="itemizedlist"><ul type="disc"><li><p>the conjunction of an upper bound <tt class="literal">T satisfies A</tt>
                    with an upper bound <tt class="literal">T satisfies B</tt> is the upper bound 
                    <tt class="literal">T satisfies A&amp;B</tt>,</p></li><li><p>the disjunction of an upper bound <tt class="literal">T satisfies A</tt>
                    with an upper bound <tt class="literal">T satisfies B</tt> is the upper bound 
                    <tt class="literal">T satisfies A|B</tt>,</p></li><li><p>the conjunction or disjunction of an upper bound <tt class="literal">T satisfies A</tt>
                    with a null upper bound is <tt class="literal">T satisfies A</tt>, and</p></li><li><p>the conjunction or disjunction of two null upper bounds is null.</p></li></ul></div><p>The inferred type argument to a covariant or invariant type parameter 
            <tt class="literal">T</tt> of the generic declaration is:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Nothing</tt>, if the inferred lower bound for 
                    <tt class="literal">T</tt> is null, or, otherwise,</p></li><li><p>the type <tt class="literal">A</tt>, where the inferred lower bound for 
                    <tt class="literal">T</tt> is <tt class="literal">T abstracts A</tt>.</p></li></ul></div><p>The inferred type argument to a contravariant type parameter 
            <tt class="literal">T</tt> of the generic declaration is:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Anything</tt>, if the inferred upper bound for 
                    <tt class="literal">T</tt> is null, or, otherwise,</p></li><li><p>the type <tt class="literal">A</tt>, where the inferred upper bound for 
                    <tt class="literal">T</tt> is <tt class="literal">T satisfies A</tt>.</p></li></ul></div><p>An argument expression with no type occurring in a <tt class="literal">dynamic</tt>
            block, as defined in <a href="statementblocks.html#dynamicblocks" title="5.3.12.&nbsp;Dynamic blocks">&sect;5.3.12 Dynamic blocks</a>, may cause type argument inference 
            to fail. When combining bounds using union, any constituent bound with no type results 
            in a bound with no type. When combining bounds using intersection, any constituent 
            bound with no type is eliminated. If the resulting inferred upper or lower bound has no 
            type, type argument inference is impossible for the type argument, and type arguments 
            must be specified explicitly.</p><p>If the inferred type argument does not satisfy the generic type 
            constraints on <tt class="literal">T</tt>, a compilation error results.</p><p>Consider the following invocation:</p><pre class="brush: ceylon">[Element+] prepend&lt;Element&gt;(Element head, Element[] sequence) { ... }
value result = prepend(null, {"hello", "world"});</pre><p>The inferred type of <tt class="literal">Element</tt> is the union type 
            <tt class="literal">String?</tt>.</p><p>Now consider:</p><pre class="brush: ceylon">class Bag&lt;out Element&gt;(Element* elements) {
    shared Bag&lt;ExtraElement&gt; with&lt;ExtraElement&gt;(ExtraElement* elements) 
            given ExtraElement abstracts Element { ... }
}
Bag&lt;String&gt; bag = Bag("hello", "world");
value biggerBag = bag.with(1, 2, 5.0);</pre><p>The inferred type of <tt class="literal">ExtraElement</tt> is the union 
            type <tt class="literal">Integer|Float|String</tt>.</p><p>Finally consider:</p><pre class="brush: ceylon">interface Delegate&lt;in Value&gt; { ... }
class Consumer&lt;in Value&gt;(Delegate&lt;Value&gt;* delegates) { ... }
Delegate&lt;String&gt; delegate1 = ... ;
Delegate&lt;Object&gt; delegate2 = ... ; 
value consumer = Consumer(delegate1, delegate2);</pre><p>The inferred type of <tt class="literal">Value</tt> is 
            <tt class="literal">Consumer&lt;String&gt;</tt>.</p><i><span class="comment"><p>TODO: What about upper bounds in which the type parameter 
            itself appears (the infamous self-type problem with
            <tt class="literal">Comparable</tt> and <tt class="literal">Numeric</tt>) or in which 
            another type parameter appears?</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="principalinstantiations"></a>3.7.&nbsp;Principal instantiations and polymorphism</h2></div></div><div></div></div><p>Inheritance interacts with type parameterization to produce subtyping 
        relationships between instantiations of generic types. The notion of an
        <span class="emphasis"><em>inherited instantiation</em></span> and the notion of a 
        <span class="emphasis"><em>principal instantation</em></span> help us reason about these 
        relationships.</p><i><span class="comment"><p>Warning: this section is not for the faint of heart. Feel 
        free to skip to <a href="declarations.html" title="Chapter&nbsp;4.&nbsp;Declarations">Chapter&nbsp;4, <i>Declarations</i></a>, unless you're really, really 
        interested in precisely how the compiler reasons about inheritance of generic 
        types.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inheritedinstantiations"></a>3.7.1.&nbsp;Inherited instantiations</h3></div></div><div></div></div><p>For a generic type <tt class="literal">Y</tt>, inheritance produces subtypes 
            with <span class="emphasis"><em>inherited instantiations</em></span> of the generic type.</p><div class="itemizedlist"><ul type="disc"><li><p>If a type <tt class="literal">X</tt> directly extends or satisfies an 
                instantiation <tt class="literal">V</tt> of <tt class="literal">Y</tt>, then 
                <tt class="literal">X</tt> has the inherited instantiation <tt class="literal">V</tt> 
                of <tt class="literal">Y</tt>.</p></li><li><p>If a generic type <tt class="literal">X</tt> extends or satisfies an 
                instantiation <tt class="literal">V</tt> of <tt class="literal">Y</tt>, that may 
                involve the type parameters of <tt class="literal">X</tt>, then for any 
                instantiation <tt class="literal">U</tt> of <tt class="literal">X</tt>, we can 
                construct an instantiation <tt class="literal">W</tt> of <tt class="literal">Y</tt> 
                by, for every type parameter <tt class="literal">T</tt> of <tt class="literal">X</tt>, 
                substituting the type argument of <tt class="literal">T</tt> given in 
                <tt class="literal">U</tt> everywhere <tt class="literal">T</tt> occurs in 
                <tt class="literal">V</tt>, and then <tt class="literal">U</tt> has the inherited 
                instantiation <tt class="literal">W</tt> of <tt class="literal">Y</tt>.</p></li><li><p>If a type <tt class="literal">X</tt> is a subtype of a type 
                <tt class="literal">Y</tt>, and <tt class="literal">Y</tt> has an inherited 
                instantiation <tt class="literal">W</tt> of a generic type <tt class="literal">Z</tt>, 
                then <tt class="literal">X</tt> also has this inherited instantiation.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="principalinstantiationinheritance"></a>3.7.2.&nbsp;Principal instantiation inheritance</h3></div></div><div></div></div><p>If a class or interface type <tt class="literal">X</tt> has the inherited 
            instantiations <tt class="literal">V</tt> and <tt class="literal">W</tt> of some 
            generic type <tt class="literal">Y</tt>, then:</p><div class="itemizedlist"><ul type="disc"><li><p>for every invariant type parameter <tt class="literal">T</tt> of 
                    <tt class="literal">Y</tt>, the type argument <tt class="literal">A</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt> and the type 
                    argument <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt> must be exactly the same type, and,
                    furthermore,</p></li><li><p><tt class="literal">X</tt> is a subtype of an instantiation 
                     <tt class="literal">U</tt> of <tt class="literal">Y</tt> such that 
                     <tt class="literal">U</tt> is a subtype of 
                     <tt class="literal">V&amp;W</tt>.</p></li></ul></div><p>Therefore, if a type <tt class="literal">X</tt> is a subtype of the 
            instantiations <tt class="literal">V</tt> and <tt class="literal">W</tt> of some generic 
            type <tt class="literal">Y</tt>, then either:</p><div class="itemizedlist"><ul type="disc"><li><p>for some invariant type parameter <tt class="literal">T</tt> of 
                    <tt class="literal">Y</tt>, the argument of <tt class="literal">A</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt> and the argument
                    <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt> are distinct types, and either <tt class="literal">A</tt>
                    or <tt class="literal">B</tt> involves a type parameter, or</p></li><li><p>if, for some invariant type parameter <tt class="literal">T</tt> 
                    of <tt class="literal">Y</tt>, the argument of <tt class="literal">A</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt> and the argument
                    <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt> are distinct types, and neither <tt class="literal">A</tt>
                    nor <tt class="literal">B</tt> involve a type parameter, then the type 
                    <tt class="literal">V&amp;W</tt> is the bottom type <tt class="literal">Nothing</tt>, 
                    and we say that <tt class="literal">V</tt> and <tt class="literal">W</tt> are 
                    <span class="emphasis"><em>disjoint instantiations</em></span> of <tt class="literal">Y</tt>, 
                    or, otherwise,</p></li><li><p><tt class="literal">X</tt> must be a subtype of an instantiation 
                    <tt class="literal">P</tt> of <tt class="literal">Y</tt> formed by taking each
                    type parameter <tt class="literal">T</tt> of <tt class="literal">Y</tt>, and 
                    constructing a type argument <tt class="literal">C</tt> for 
                    <tt class="literal">T</tt> from the type arguments <tt class="literal">A</tt> 
                    of <tt class="literal">T</tt> given in <tt class="literal">V</tt> and 
                    <tt class="literal">B</tt> of <tt class="literal">T</tt> given in 
                    <tt class="literal">W</tt>:</p><div class="itemizedlist"><ul type="circle"><li><p>if <tt class="literal">Y</tt> is invariant in <tt class="literal">T</tt>, 
                            then <tt class="literal">C</tt> is the same type as <tt class="literal">A</tt>
                            and <tt class="literal">B</tt>,</p></li><li><p>if <tt class="literal">Y</tt> is covariant in <tt class="literal">T</tt>, 
                            then <tt class="literal">C</tt> is <tt class="literal">A&amp;B</tt>, or</p></li><li><p>if <tt class="literal">Y</tt> is contravariant in <tt class="literal">T</tt>,
                            then <tt class="literal">C</tt> is <tt class="literal">A|B</tt>.</p></li></ul></div></li></ul></div><p>The following identities result from principal instantiation inheritance, 
            for any generic type <tt class="literal">X&lt;T&gt;</tt>, and for any types 
            <tt class="literal">A</tt> and <tt class="literal">B</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">X&lt;A&gt;&amp;X&lt;B&gt;</tt> is exactly equivalent 
                    to <tt class="literal">X&lt;A&amp;B&gt;</tt> if <tt class="literal">X&lt;T&gt;</tt>
                    is covariant in <tt class="literal">T</tt>, unless either <tt class="literal">A</tt>
                    or <tt class="literal">B</tt> involves type parameters, and</p></li><li><p><tt class="literal">X&lt;A&gt;&amp;X&lt;B&gt;</tt> is exactly equivalent
                    to <tt class="literal">X&lt;A|B&gt;</tt> if <tt class="literal">X&lt;T&gt;</tt> is 
                    contravariant in <tt class="literal">T</tt>, unless either <tt class="literal">A</tt>
                    or <tt class="literal">B</tt> involves type parameters.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="principalinstantiationofasupertype"></a>3.7.3.&nbsp;Principal instantiation of a supertype</h3></div></div><div></div></div><p>If a type <tt class="literal">X</tt> is a subtype of some instantiation 
            <tt class="literal">V</tt> of a generic type <tt class="literal">Y</tt>, then, as a 
            result of the principal instantiation inheritance restriction, we can 
            form a unique instantiation of <tt class="literal">Y</tt> that is a subtype of 
            every instantiation of <tt class="literal">Y</tt> to which <tt class="literal">X</tt> 
            is assignable. We call this type the <span class="emphasis"><em>principal instantiation of 
            <tt class="literal">Y</tt> for <tt class="literal">X</tt></em></span>.</p><p>We compute principal instantiations by making use of the identities
            observed above in <a href="typesystem.html#uniontypes" title="3.2.3.&nbsp;Union types">&sect;3.2.3 Union types</a>, <a href="typesystem.html#intersectiontypes" title="3.2.4.&nbsp;Intersection types">&sect;3.2.4 Intersection types</a>,
            and <a href="typesystem.html#principalinstantiationinheritance" title="3.7.2.&nbsp;Principal instantiation inheritance">&sect;3.7.2 Principal instantiation inheritance</a>. 
            For any generic type <tt class="literal">X</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>The principal instantiation of the union <tt class="literal">U|V</tt>
                    of two instantiations of <tt class="literal">X</tt>, <tt class="literal">U</tt> 
                    and <tt class="literal">V</tt>, is an instantiation <tt class="literal">P</tt> 
                    of <tt class="literal">X</tt> formed by taking each type parameter 
                    <tt class="literal">T</tt> of <tt class="literal">X</tt> and constructing a
                    type argument <tt class="literal">C</tt> for <tt class="literal">T</tt> from
                    the type arguments <tt class="literal">A</tt> of <tt class="literal">T</tt> 
                    given in <tt class="literal">U</tt> and <tt class="literal">B</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt>:</p><div class="itemizedlist"><ul type="circle"><li><p>if <tt class="literal">X</tt> is covariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A|B</tt>,</p></li><li><p>if <tt class="literal">X</tt> is contravariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A&amp;B</tt>, or</p></li><li><p>if <tt class="literal">X</tt> is invariant in <tt class="literal">T</tt>, 
                            and <tt class="literal">A</tt> and <tt class="literal">B</tt> are exactly 
                            the same type, then <tt class="literal">C</tt> is this type.</p></li></ul></div></li><li><p>The principal instantiation of the intersection <tt class="literal">U&amp;V</tt>
                    of two instantiations of <tt class="literal">X</tt>, <tt class="literal">U</tt> 
                    and <tt class="literal">V</tt>, is an instantiation <tt class="literal">P</tt> of
                    <tt class="literal">X</tt> formed by taking each type parameter 
                    <tt class="literal">T</tt> of <tt class="literal">X</tt> and constructing a
                    type argument <tt class="literal">C</tt> for <tt class="literal">T</tt> from
                    the type arguments <tt class="literal">A</tt> of <tt class="literal">T</tt> 
                    given in <tt class="literal">U</tt> and <tt class="literal">B</tt> of 
                    <tt class="literal">T</tt> given in <tt class="literal">V</tt>:</p><div class="itemizedlist"><ul type="circle"><li><p>if <tt class="literal">X</tt> is covariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A&amp;B</tt>,</p></li><li><p>if <tt class="literal">X</tt> is contravariant in 
                            <tt class="literal">T</tt>, then <tt class="literal">C</tt>
                            is <tt class="literal">A|B</tt>, or</p></li><li><p>if <tt class="literal">X</tt> is invariant in <tt class="literal">T</tt>, 
                            and <tt class="literal">A</tt> and <tt class="literal">B</tt> are exactly 
                            the same type, then <tt class="literal">C</tt> is this type.</p></li></ul></div></li><li><p>Finally, the principal instantiation of a generic type 
                    <tt class="literal">X</tt> for a type <tt class="literal">Y</tt> which
                    has one or more inherited instantiations of <tt class="literal">X</tt> 
                    is the principal instantiation of the intersection of all the
                    inherited instantiations of <tt class="literal">X</tt>.</p></li></ul></div><i><span class="comment"><p>Note: an intersection <tt class="literal">X&lt;A&gt;&amp;X&lt;P&gt;</tt> 
            of two instantiations of an invariant type, <tt class="literal">X&lt;T&gt;</tt> where 
            one type argument <tt class="literal">P</tt> is a type parameter introduces a known 
            hole in our type system. It is impossible to form a principal instantiation of 
            <tt class="literal">X</tt> for this intersection type without resorting to use-site 
            covariance, so we don't allow references to members of the intersection type.
            </p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="refinement"></a>3.7.4.&nbsp;Refinement</h3></div></div><div></div></div><p>A class or interface may declare an <tt class="literal">actual</tt> member 
            with the same name as a member that it inherits from a supertype if the supertype
            member is declared <tt class="literal">formal</tt> or <tt class="literal">default</tt>.
            Then we say that the first member <span class="emphasis"><em>refines</em></span> the second
            member, and it must obey restrictions defined in 
            <a href="declarations.html#classrefinement" title="4.5.6.&nbsp;Member class refinement">&sect;4.5.6 Member class refinement</a>, <a href="declarations.html#methodrefinement" title="4.7.8.&nbsp;Method refinement">&sect;4.7.8 Method refinement</a>, or
            <a href="declarations.html#attributerefinement" title="4.8.7.&nbsp;Attribute refinement">&sect;4.8.7 Attribute refinement</a>.</p><p>A declaration may not be annotated both <tt class="literal">formal</tt> 
            and <tt class="literal">default</tt>.</p><p>If a declaration is annotated <tt class="literal">formal</tt>, 
            <tt class="literal">default</tt>, or <tt class="literal">actual</tt> then it must 
            also be annotated <tt class="literal">shared</tt>.</p><p>For any class or interface <tt class="literal">X</tt>, and for every declared
            or inherited member of <tt class="literal">X</tt> that is not refined by some other
            declared or inherited member of <tt class="literal">X</tt>, and for every other member 
            declared or inherited by <tt class="literal">X</tt> that directly or indirectly refines 
            a declaration that the first member itself directly or indirectly refines, the 
            principal instantiation for <tt class="literal">X</tt> of the type that declares the 
            first member must be a subtype of the principal instantiation for <tt class="literal">X</tt> 
            of the type that declares the second member.</p><i><span class="comment"><p>Note: a related restriction is defined in 
            <a href="statementblocks.html#declarationnameuniqueness" title="5.1.1.&nbsp;Declaration name uniqueness">&sect;5.1.1 Declaration name uniqueness</a>.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="qualifiedtypes"></a>3.7.5.&nbsp;Qualified types</h3></div></div><div></div></div><p>A type declaration that directly occurs in the body of another type
            is called a <span class="emphasis"><em>nested type</em></span>. If a nested type is annotated 
            <tt class="literal">shared</tt>, it may be used in a type expression outside the 
            body in which it is declared, if and only if it occurs as a 
            <span class="emphasis"><em>qualified type</em></span>, as specified in 
            <a href="typesystem.html#typeexpressions" title="3.2.7.&nbsp;Type expressions">&sect;3.2.7 Type expressions</a>.</p><p>The qualified types <tt class="literal">X.U</tt> and <tt class="literal">Y.V</tt> 
            are exactly the same types if and only if <tt class="literal">U</tt> is exactly 
            the same type as <tt class="literal">V</tt>, and in the case that this type is
            a member of a generic type <tt class="literal">Z</tt>, then the principal 
            instantiation of <tt class="literal">Z</tt> for <tt class="literal">X</tt> is exactly
            the same type as the principal instantiation of <tt class="literal">Z</tt> for
            <tt class="literal">Y</tt>.</p><p>A qualified type <tt class="literal">X.U</tt> is a subtype of a qualified
            type <tt class="literal">Y.V</tt> if <tt class="literal">U</tt> is a subtype of 
            <tt class="literal">V</tt>, and in the case that <tt class="literal">V</tt> is a member 
            of a generic type <tt class="literal">Z</tt>, then <tt class="literal">X</tt> is a 
            subtype of the principal instantiation of <tt class="literal">Z</tt> for 
            <tt class="literal">Y</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="realizations"></a>3.7.6.&nbsp;Realizations</h3></div></div><div></div></div><p>Given a member declared by <tt class="literal">Y</tt>, and a declaration that 
            refines it, we can construct a <span class="emphasis"><em>refined realization</em></span> of 
            the member or nested type:</p><div class="itemizedlist"><ul type="disc"><li><p>first determine the principal instantiation of <tt class="literal">Y</tt>
                    for the class or interface which refines the member, and then</p></li><li><p>substitute the type arguments in this principal instantiation 
                    into the member schema.</p></li></ul></div><p>Given an unqualified reference, as defined in 
            <a href="statementblocks.html#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>, to a declaration, and, in 
            the case of a generic declaration, a list of type arguments for the type 
            parameters of the declaration, we can construct an <span class="emphasis"><em>unqualified 
            realization</em></span> of the declaration:</p><div class="itemizedlist"><ul type="disc"><li><p>if the declaration is a member declared by a type 
                    <tt class="literal">Y</tt>, first determine the principal instantiation 
                    of <tt class="literal">Y</tt> for the inheriting or declaring class or 
                    interface, and then</p></li><li><p>again, only if the declaration is a member declared by a 
                    type, substitute the type arguments in this principal 
                    instantiation into the declaration schema, and, finally,</p></li><li><p>substitute the type arguments into the declaration schema.</p></li></ul></div><p>Given a qualified reference, as defined in 
            <a href="statementblocks.html#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>, with a qualifying type 
            <tt class="literal">X</tt>, to a member or nested type declared by <tt class="literal">Y</tt>, 
            and, in the case of a generic member or generic nested type, a list of 
            type arguments for the type parameters of the member, we can construct a 
            <span class="emphasis"><em>qualified realization</em></span> of the member or nested type:</p><div class="itemizedlist"><ul type="disc"><li><p>first determining the principal instantiation of 
                    <tt class="literal">Y</tt> for <tt class="literal">X</tt>, and then</p></li><li><p>substituting the type arguments in this principal 
                    instantiation into the declaration schema, and, finally,</p></li><li><p>in the case of a generic member or generic nested type, 
                    substituting the type arguments into the declaration schema.</p></li></ul></div><p>If, for any given qualified or unqualified reference, it is impossible 
            to form the principal instantiation of the type that declares the referenced 
            declaration, due to the hole described above in 
            <a href="typesystem.html#principalinstantiationofasupertype" title="3.7.3.&nbsp;Principal instantiation of a supertype">&sect;3.7.3 Principal instantiation of a supertype</a>, it is impossible to 
            form a realization, and the reference to the declaration is illegal.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="lexical.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="declarations.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Lexical structure&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Declarations</td></tr></table></div></body></html>