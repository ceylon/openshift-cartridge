<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;6.&nbsp;Expressions</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css">
<link type='text/css' href='../shared/css/shCore.css' rel='stylesheet'/>
<link type='text/css' href='../shared/css/shThemeDefault.css' rel='stylesheet'/>
<script src='../shared/css/shCore.js' type='text/javascript'></script>
<script src='../shared/css/shBrushCeylon.js' type='text/javascript'></script>
    	    <script type='text/javascript'>
    	        SyntaxHighlighter.defaults['gutter'] = false;
    	        SyntaxHighlighter.defaults['toolbar'] = false;
    	        // register a listener for when the highlighter is done with replacing elements
    	        var hl = SyntaxHighlighter.highlight;
    	        SyntaxHighlighter.highlight = function(params, element){
    	          hl(params, element);
    	          postSyntaxHighlighting();
    	        };
    	        SyntaxHighlighter.all();
    	    </script><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="The Ceylon Language"><link rel="up" href="index.html" title="The Ceylon Language"><link rel="previous" href="statementblocks.html" title="Chapter&nbsp;5.&nbsp;Statements, blocks, and control structures"><link rel="next" href="annotations.html" title="Chapter&nbsp;7.&nbsp;Annotations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">The Ceylon Language &mdash; 6.&nbsp;Expressions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="statementblocks.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="annotations.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="expressions"></a>Chapter&nbsp;6.&nbsp;Expressions</h2></div></div><div></div></div><p>An <span class="emphasis"><em>expression</em></span> produces a value when executed. An 
    algorithm expressed using functions and expressions, rather than sequences 
    of statements is often easier to understand and refactor. Therefore, Ceylon
    has a highly flexible expressions syntax. Expressions are formed from:</p><div class="itemizedlist"><ul type="disc"><li><p>literal values, string templates, and self references,</p></li><li><p>evaluation and assignment of values,</p></li><li><p>invocation of functions and instantiation of classes,</p></li><li><p>callable references, static references, and anonymous functions,</p></li><li><p>comprehensions,</p></li><li><p>metamodel references,</p></li><li><p>enumeration of iterables and tuples, and</p></li><li><p>operators.</p></li></ul></div><p>Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    a value or parameter, Ceylon considers the <span class="emphasis"><em>type</em></span> of the 
    expression (the type of the objects that are produced when the expression 
    is evaluated). An expression is assignable to a program element if the type 
    of the expression is assignable to the declared type of the program 
    element.</p><p>Within a <tt class="literal">dynamic</tt> block, an expression may have no 
    type, in the sense that its type can not be determined using static analysis
    of the code.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="literalvalues"></a>6.1.&nbsp;Literal values</h2></div></div><div></div></div><p>Ceylon supports literal values of the following types:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Integer</tt> and <tt class="literal">Float</tt>,</p></li><li><p><tt class="literal">Character</tt>, and</p></li><li><p><tt class="literal">String</tt>.</p></li></ul></div><p>The types <tt class="literal">Integer</tt>, <tt class="literal">Float</tt>, 
        <tt class="literal">Character</tt>, and <tt class="literal">String</tt> are defined in the 
        module <tt class="literal">ceylon.language</tt>.</p><i><span class="comment"><p>Note: Ceylon does not need a special syntax for <tt class="literal">Boolean</tt> 
        literal values, since <tt class="literal">Boolean</tt> is just a class with the cases 
        <tt class="literal">true</tt> and <tt class="literal">false</tt>. Likewise, <tt class="literal">null</tt> 
        is just the singleton value of an anonymous class.</p></span></i><pre class="synopsis">Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral</pre><p>All literal values are instances of immutable types. The value of a literal 
        expression is an instance of the type. How this instance is produced is not specified 
        here.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="naturalnumber"></a>6.1.1.&nbsp;Integer number literals</h3></div></div><div></div></div><p>An integer literal, as defined in 
            <a href="lexical.html#numericliterals" title="2.4.1.&nbsp;Numeric literals">&sect;2.4.1 Numeric literals</a>, is an expression of type 
            <tt class="literal">Integer</tt>, representing a numeric integer.</p><pre class="brush: ceylon">Integer five = 5;</pre><pre class="brush: ceylon">Integer mask = $1111_0000;</pre><pre class="brush: ceylon">Integer white = #FFFF;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="floatnumber"></a>6.1.2.&nbsp;Floating point number literals</h3></div></div><div></div></div><p>A floating point literal, as defined in 
            <a href="lexical.html#numericliterals" title="2.4.1.&nbsp;Numeric literals">&sect;2.4.1 Numeric literals</a>, is an expression of type 
            <tt class="literal">Float</tt>, a floating-point representation of 
            a numeric value.</p><pre class="brush: ceylon">shared Float pi = 3.14159;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="character"></a>6.1.3.&nbsp;Character literals</h3></div></div><div></div></div><p>A single character literal, as defined in 
            <a href="lexical.html#characterliterals" title="2.4.2.&nbsp;Character literals">&sect;2.4.2 Character literals</a>, is an expression of type 
            <tt class="literal">Character</tt>, representing a single 32-bit
            Unicode character.</p><pre class="brush: ceylon">if (exists ch=string[i], ch == '+') { ... }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="string"></a>6.1.4.&nbsp;Character string literals</h3></div></div><div></div></div><p>A character string literal or verbatim string, as defined 
            in <a href="lexical.html#stringliterals" title="2.4.3.&nbsp;String literals">&sect;2.4.3 String literals</a>, is an expression of type
            <tt class="literal">String</tt>, representing a sequence of Unicode
            characters.</p><pre class="brush: ceylon">person.name = "Gavin King";</pre><pre class="brush: ceylon">print("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</pre><pre class="brush: ceylon">String verbatim = """A verbatim string can have \ or a " in it."""";</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stringtemplates"></a>6.2.&nbsp;String templates</h2></div></div><div></div></div><p>A character <span class="emphasis"><em>string template</em></span> contains interpolated 
        expressions, surrounded by character string fragments.</p><pre class="synopsis">StringTemplate: StringStart (ValueExpression StringMid)* ValueExpression StringEnd</pre><p>Each interpolated expression contained in the string template must have 
        a type assignable to <tt class="literal">Object</tt> defined in 
        <tt class="literal">ceylon.language</tt>.</p><pre class="brush: ceylon">print("Hello, ``person.firstName`` ``person.lastName``, the time is ``Time()``.");</pre><pre class="brush: ceylon">print("1 + 1 = ``1 + 1``");</pre><p>A string template is an expression of type <tt class="literal">String</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="selfreferences"></a>6.3.&nbsp;Self references and the current package reference</h2></div></div><div></div></div><p>The type of the following expressions depends upon the context in which 
        they appear.</p><pre class="synopsis">SelfReference: "this" | "super" | "outer" | "package"</pre><p>A self reference expression may not occur outside of a class or 
        interface body.</p><p>The <span class="emphasis"><em>immediately containing class or interface</em></span> for
        a program element is the class or interface in which the program element 
        occurs, and which contains no other class or interface in which the program 
        element occurs. If there is no such class or interface, the program element
        has no immediately containing class or interface.</p><p>A <tt class="literal">this</tt>, <tt class="literal">outer</tt>, or 
        <tt class="literal">super</tt> self reference must have an immediately containing 
        class or interface. An <tt class="literal">outer</tt> self reference must have
        an immediately containing class or interface for its immediately containing 
        class or interface.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="this"></a>6.3.1.&nbsp;<tt class="literal">this</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">this</tt> refers to the current instance,
            as defined in <a href="execution.html#currentinstanceofaclassorinterface" title="8.2.3.&nbsp;Current instance of a class or interface">&sect;8.2.3 Current instance of a class or interface</a>, of the 
            immediately containing class or interface (the class or interface in which 
            the expression appears). Its type is the type of the immediately containing 
            class or interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outer"></a>6.3.2.&nbsp;<tt class="literal">outer</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">outer</tt> refers to the current instance,
            as defined in <a href="execution.html#currentinstanceofaclassorinterface" title="8.2.3.&nbsp;Current instance of a class or interface">&sect;8.2.3 Current instance of a class or interface</a>, of the 
            class or interface which immediately contains the immediately containing 
            class or interface. Its type is assignable to the type of this class or 
            interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="super"></a>6.3.3.&nbsp;<tt class="literal">super</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">super</tt> refers to the current instance 
            of the immediately containing class or interface. Its type is the 
            intersection of the immediate superclass and all immediate superinterfaces 
            of the class. A member reference such as <tt class="literal">super.x</tt> may not 
            resolve to a <tt class="literal">formal</tt> declaration, nor to any member 
            inherited from more than one supertype of the intersection type.</p><p>The keyword <tt class="literal">super</tt> may occur as the first operand
            of an <tt class="literal">of</tt> operator, in which case the second operand is
            any supertype of the class. The expression <tt class="literal">(super of Type)</tt>
            has type <tt class="literal">Type</tt>. A member reference such as 
            <tt class="literal">(super of Type).x</tt> may not resolve to a <tt class="literal">formal</tt> 
            member, nor to any member inherited from more than one supertype of 
            <tt class="literal">Type</tt>, nor to any member that is refined by the class or 
            any intermediate supertype of the class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="thispackage"></a>6.3.4.&nbsp;<tt class="literal">package</tt></h3></div></div><div></div></div><p>The keyword <tt class="literal">package</tt> is not an expression, and
            does not have a well-defined type. However, it may be used to qualify 
            and disambiguate a value reference or callable reference. A value
            reference or callable reference qualified by the keyword 
            <tt class="literal">package</tt> always refers to a toplevel member of the
            containing package, never to an imported declaration or nested 
            declaration.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="anonymousfunctions"></a>6.4.&nbsp;Anonymous functions</h2></div></div><div></div></div><p>An anonymous function is a function, as specified in 
            <a href="declarations.html#functions" title="4.7.&nbsp;Functions">&sect;4.7 Functions</a>, with no name, defined within an expression. 
            It comprises one or more parameter lists, followed by an expression.</p><pre class="synopsis">FunctionExpression: ("function" | "void")? Parameters+ (LazySpecifier | Block)</pre><p>The parameters are the parameters of the function. The lazy 
            specifier or block of code is the implementation of the function. If 
            the <tt class="literal">void</tt> keyword is specified, the function is a 
            <tt class="literal">void</tt> function. Otherwise, it is a 
            non-<tt class="literal">void</tt> function, and its return type is 
            inferred.</p><p>The type of an anonymous function expression is the callable 
            type of the function, as specified in 
            <a href="declarations.html#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>.</p><pre class="brush: ceylon">(Value x, Value y) =&gt; x&lt;=&gt;y</pre><pre class="brush: ceylon">void (String name) =&gt; print(name)</pre><pre class="brush: ceylon">(String string) {
    value mid = string.size % 2;
    return [string[0..mid],string[mid+1...]];
}</pre><p>An anonymous function occurring in an <tt class="literal">extends</tt>
            clause may not contain a reference to a variable value.</p><i><span class="comment"><p>Note: evaluation of an anonymous function expression,
            as defined in <a href="execution.html#anonymousfunctionevaluation" title="8.4.5.&nbsp;Evaluation of anonymous functions">&sect;8.4.5 Evaluation of anonymous functions</a> results
            in instantiation of an object of type <tt class="literal">Callable</tt>.
            However, the members of this object are never in scope, do not hide
            other declarations, and are not referenceable from within the 
            anonymous function.</p></span></i><i><span class="comment"><p>Note: there is almost no semantic difference between the
            following function declarations:</p>
            <pre class="brush: ceylon">Float f(Float x)(Float y) =&gt; x*y;</pre>
            <pre class="brush: ceylon">Float(Float) f(Float x) =&gt; (Float y) =&gt; x*y;</pre>
            <p>The first form is strongly preferred.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compoundexpressions"></a>6.5.&nbsp;Compound expressions</h2></div></div><div></div></div><p>An <span class="emphasis"><em>atom</em></span> is a literal or self reference, a
        string template, an iterable or tuple enumeration, or a parenthesized 
        expression.</p><pre class="synopsis">Atom: Literal | StringTemplate | SelfReference | GroupedExpression | Iterable | Tuple | DynamicValue</pre><p>A <span class="emphasis"><em>primary</em></span> is formed by recursively forming 
        member expressions and invocation expressions from an atom, base 
        expression, or static expression.</p><pre class="synopsis">Primary: Atom | BaseExpression | MemberExpression | StaticExpression | Invocation | Meta | Dec</pre><p>More complex expressions are formed by combining expressions using 
        operators, including assignment operators, and anonymous functions.</p><pre class="synopsis">ValueExpression: Primary | OperatorExpression</pre><pre class="synopsis">Expression: ValueExpression | FunctionExpression | OperatorInvocation | OperatorMemberExpression</pre><p>Parentheses are used for grouping:</p><pre class="synopsis">GroupedExpression: "(" Expression ")"</pre><p>A compound expression occurring in a <tt class="literal">dynamic</tt> 
        block, and involving a qualified or unqualified reference with no type,
        or a reference to a declaration with no type, may also have no type.</p><p>In particular, if an operand expression has no type, and the type 
        of the operator expression depends upon the type of the operand, and the 
        operator expression occurs within a <tt class="literal">dynamic</tt> block, 
        then the whole operator expression has no type.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="baseexpressions"></a>6.5.1.&nbsp;Base expressions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>base expression</em></span> is an unqualified 
            identifier, with an optional list of type arguments:</p><pre class="synopsis">BaseExpression: (MemberName | TypeName) TypeArguments?</pre><p>A base expression is either:</p><div class="itemizedlist"><ul type="disc"><li><p>a reference to a toplevel function, toplevel value, or 
                    toplevel class,</p></li><li><p>a reference within the lexical scope of the referenced 
                    function, value, or class, or</p></li><li><p>a reference within the body of the referenced function,
                    value, or class.</p></li></ul></div><p>The referenced declaration is determined by resolving the unqualified 
            reference as defined by <a href="statementblocks.html#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>.
            The unqualified realization for the unqualified reference is determined
            according to <a href="typesystem.html#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="typesystem.html#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list
            of the unqualified realization.</p><p>If a base expression is a reference to an attribute, method, or 
            member class of a class, the receiving instance is the current instance of 
            that class, as defined by <a href="execution.html#currentinstanceofaclassorinterface" title="8.2.3.&nbsp;Current instance of a class or interface">&sect;8.2.3 Current instance of a class or interface</a>.
            Otherwise, there is no receiving instance.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="memberexpressions"></a>6.5.2.&nbsp;Member expressions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>member expression</em></span> is a <span class="emphasis"><em>receiver
            expression</em></span>, followed by an identifier, with an optional list 
            of type arguments.</p><pre class="synopsis">MemberExpression: (Primary ".") (MemberName | TypeName) TypeArguments?</pre><p>A member expression is a reference to a member of a type: an
            attribute, method, or member class.</p><p>The referenced member is determined by resolving the qualified 
            reference as defined by <a href="statementblocks.html#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.
            The qualified realization for the qualified reference is determined
            according to <a href="typesystem.html#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="typesystem.html#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list
            of the qualified realization.</p><p>The receiver expression produces the instance upon which the member 
            is invoked or evaluated. When a member expression is executed, the receiver 
            expresson is evaluated to produce the receiving instance which is held 
            until the member is invoked or evaluated, as defined in 
            <a href="execution.html#evaluationinvocationandassignment" title="8.4.&nbsp;Evaluation, invocation, and assignment">&sect;8.4 Evaluation, invocation, and assignment</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="valuereferences"></a>6.5.3.&nbsp;Value references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>value reference</em></span> is a base expression or 
            member expression that references a value declaration.</p><p>The type of a value reference expression is the type of the 
            realization of the referenced value.</p><p>A value declaration is never generic, so a value reference never
            has a type argument list.</p><p>A value reference that does not occur within any <tt class="literal">dynamic</tt>
            block may not refer to a value declaration or value parameter with no type.</p><p>A value reference which occurs within a <tt class="literal">dynamic</tt> 
            block and which does not reference any statically typed declaration, or
            which references a value declaration or value parameter with no type, 
            has no type.</p><p>If a base expression or member expression does not reference any 
            statically typed declaration, and occurs within a <tt class="literal">dynamic</tt> 
            block, then it is considered a value reference.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="callablereferences"></a>6.5.4.&nbsp;Callable references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>callable reference</em></span> is a base expression or
            member expression that references something&#8212;a function or 
            class&#8212;that can be <span class="emphasis"><em>invoked</em></span> or 
            <span class="emphasis"><em>instantiated</em></span> by specifying a list of arguments.</p><p>A callable reference may be invoked immediately, or it may be passed 
            to other code which may invoke the reference. A callable reference captures 
            the return type and parameter list types of the function or class it refers 
            to, allowing compile-time validation of argument types when the callable 
            reference is invoked.</p><p>The type of a callable reference expression is the callable type of
            the realization of the referenced function or class.</p><p>If a callable reference expression refers to a generic declaration, 
            either:</p><div class="itemizedlist"><ul type="disc"><li><p>it must be immediately followed by an argument list, 
                    allowing the compiler to infer the type arguments, or</p></li><li><p>it must have an explicit type argument list.</p></li></ul></div><p>A callable reference may not appear as the receiver expression of
            a member expression.</p><i><span class="comment"><p>Note: this restriction exists to eliminate an ambiguity in
            the interpretation of static expressions such as <tt class="literal">Person.string</tt>
            and <tt class="literal">Person.equals</tt>.</p></span></i><p>A callable reference that does not occur within any <tt class="literal">dynamic</tt>
            block may not refer to a function declaration with no return type.</p><p>A callable reference which occurs within a <tt class="literal">dynamic</tt> 
            block and which references a function declaration with no return type, has 
            no type.</p><i><span class="comment"><p>Note: in a future release of the language, we would like to 
            add a syntax for obtaining a callable reference to an attribute, something
            like <tt class="literal">person.@name</tt>, to allow attributes to be passed by 
            reference. This would also allow static references like
            <tt class="literal">Person.@name</tt>.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="staticexpressions"></a>6.5.5.&nbsp;Static expressions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>static expression</em></span> is a type, followed by an identifier, 
            with an optional list of type arguments.</p><pre class="synopsis">StaticExpression: (TypeName TypeArguments? ".")+ (MemberName | TypeName) TypeArguments?</pre><p>A static expression is a reference to a member of a type: an attribute, method, 
            or member class.</p><p>The referenced member is determined by resolving the qualified reference as defined 
            by <a href="statementblocks.html#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>. The qualified realization for the 
            qualified reference is determined according to <a href="typesystem.html#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>The type argument list, if any, must conform, as defined by
            <a href="typesystem.html#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, to the type parameter list of the 
            qualified realization.</p><p>Unlike member expressions, a static expression does not have a receiver expression. 
            All static expressions are callable expressions which accept an argument of the specified 
            type.</p><p>A static expression must reference a statically typed declaration with no missing 
            types, even within a <tt class="literal">dynamic</tt> block.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="staticvaluereferences"></a>6.5.6.&nbsp;Static value references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>static value reference</em></span> is a static 
            expression that references an attribute declaration.</p><pre class="brush: ceylon">List&lt;Anything&gt;.size</pre><p>The type of a static value reference expression for an attribute 
            whose realization is of type <tt class="literal">X</tt>, and with qualifying 
            type <tt class="literal">T</tt>, is <tt class="literal">X(T)</tt>.</p><p>A value declaration is never generic, so a static value reference 
            never ends in a type argument list.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="staticcallablereferences"></a>6.5.7.&nbsp;Static callable references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>static callable reference</em></span> is a static 
            expression that references something&#8212;a method or member 
            class&#8212;that can be <span class="emphasis"><em>invoked</em></span> or 
            <span class="emphasis"><em>instantiated</em></span>.</p><pre class="brush: ceylon">List&lt;String&gt;.filter</pre><pre class="brush: ceylon">Iterable&lt;Integer&gt;.map&lt;String&gt;</pre><p>The type of a static callable reference expression for a method
            or member class whose realization has callable type <tt class="literal">C</tt>, 
            and with qualifying type <tt class="literal">T</tt>, is <tt class="literal">C(T)</tt>.</p><p>If a callable reference expression refers to a generic declaration, 
            it must end in an explicit type argument list.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="invocationexpressions"></a>6.6.&nbsp;Invocation expressions</h2></div></div><div></div></div><p>A callable expression&#8212;any expression of type 
        <tt class="literal">Callable</tt>&#8212;is <span class="emphasis"><em>invokable</em></span>. An 
        <span class="emphasis"><em>invocation</em></span> consists of an <span class="emphasis"><em>invoked expression</em></span>, 
        together with an argument list and, optionally, an explicit type argument list.</p><pre class="synopsis">Invocation: Primary Arguments</pre><p>The invoked expression must be of type <tt class="literal">Callable&lt;R,P&gt;</tt>
        for some types <tt class="literal">R</tt> and <tt class="literal">P</tt>. Then the type of the 
        invocation expression is simply <tt class="literal">R</tt>.</p><p>If the invoked expression has no type, and occurs within a <tt class="literal">dynamic</tt> 
        block, then the whole invocation expression has no type, and the argument list is 
        not type-checked at compile time, unless it is a direct invocation expression.</p><p>An invocation expression must specify arguments for parameters of the callable 
        object, either as a positional argument list, or as a named argument list.</p><pre class="synopsis">Arguments: PositionalArguments | NamedArguments</pre><p>Every argument list has a type, as specified below in 
        <a href="expressions.html#positionalarguments" title="6.6.7.&nbsp;Positional argument lists">&sect;6.6.7 Positional argument lists</a> and <a href="expressions.html#namedarguments" title="6.6.8.&nbsp;Named argument lists">&sect;6.6.8 Named argument lists</a>. If an 
        invocation is formed from a callable expression of type exactly 
        <tt class="literal">Callable&lt;R,P&gt;</tt> and an argument list of type 
        <tt class="literal">A</tt>, then <tt class="literal">A</tt> must be a subtype of 
        <tt class="literal">P</tt>.</p><i><span class="comment"><p>TODO: should we support an infix-operator-style syntax for method 
        invocation like <tt class="literal">string split ",;".contains</tt>? This is especially 
        nice for conceptually symmetric operations like <tt class="literal">a xor b</tt>, or when 
        the argument is an anonymous function like 
        <tt class="literal">people map (Person p)=&gt;p.firstName+p.lastName</tt>.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="directinvocations"></a>6.6.1.&nbsp;Direct invocations</h3></div></div><div></div></div><p>Any invocation expression where the invoked expression is a callable 
            reference expression is called a <span class="emphasis"><em>direct invocation expression</em></span> 
            of the function or class to which the callable reference refers.</p><i><span class="comment"><p>TODO: Should we consider <tt class="literal">x{y=1;}{z=2;}</tt> a legal
            direct invocation if <tt class="literal">x</tt> has multiple parameter lists?</p></span></i><p>In a direct invocation expression:</p><div class="itemizedlist"><ul type="disc"><li><p>the compiler has one item of additional information about the schema 
                    of the method or class that is not reified by the <tt class="literal">Callable</tt> 
                    interface: the names of the parameters of the function or class, and
                    therefore named arguments may be used, and</p></li><li><p>type argument inference is possible, as defined in 
                    <a href="typesystem.html#typeargumentinference" title="3.6.3.&nbsp;Type argument inference">&sect;3.6.3 Type argument inference</a>, since the compiler has access to 
                    the type parameters and constraints of the function or class.</p></li></ul></div><p>If an invocation expression has a named argument list, it must be a direct
            invocation.</p><p>The type of a direct invocation expression is the return type of the 
            realization of the function, or the type of the realization of the class, as 
            defined in <a href="typesystem.html#realizations" title="3.7.6.&nbsp;Realizations">&sect;3.7.6 Realizations</a>.</p><p>If the function has no return type, and occurs within a <tt class="literal">dynamic</tt> 
            block, then the whole direct invocation expression has no type.</p><p>In a direct invocation expression of a function or class, the restriction
            above on the argument list type is equivalent to the following requirements. Given
            the parameter list of the realization of the function or class, and the arguments 
            of the direct invocation:</p><div class="itemizedlist"><ul type="disc"><li><p>for each required parameter, an argument must be given,</p></li><li><p>for each defaulted parameter, an argument may optionally be 
                    given,</p></li><li><p>if the parameter list has a variadic parameter of type 
                    <tt class="literal">T+</tt>, one or more arguments must be given,</p></li><li><p>if the parameter list has a variadic parameter of type 
                    <tt class="literal">T*</tt>, one or more arguments may optionally be 
                    given,</p></li><li><p>no additional arguments may be given,</p></li><li><p>for a required or defaulted parameter of type <tt class="literal">T</tt>, 
                    the type of the corresponding argument expression must be assignable to 
                    <tt class="literal">T</tt>, and</p></li><li><p>for a variadic parameter of type <tt class="literal">T*</tt> or 
                    <tt class="literal">T+</tt>, the type of every corresponding argument 
                    expression must be assignable to <tt class="literal">T</tt>.</p></li></ul></div><p>Furthermore, if type argument are inferred, then the inferred type 
            arguments must conform, as defined by <a href="typesystem.html#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, 
            to the type parameter list of the realization of the function or class.</p><p>If an argument expression has no type, or if its parameter has no type, 
            and the invocation occurs within a <tt class="literal">dynamic</tt> block, then the 
            argument is not type-checked at compile time.</p><p>An invocation expression that does not occur within any <tt class="literal">dynamic</tt>
            block may not assign an argument to a value parameter with no type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="defaultarguments"></a>6.6.2.&nbsp;Default arguments</h3></div></div><div></div></div><p>When no argument is assigned to a defaulted parameter by the caller, 
            the default argument defined by the parameter declaration of the realization,
            as defined by <a href="typesystem.html#typeargumentsandconstraints" title="3.6.1.&nbsp;Type arguments and type constraints">&sect;3.6.1 Type arguments and type constraints</a>, of the function 
            or class is used. The default argument expression is evaluated every time the 
            method is invoked with no argument specified for the defaulted parameter.</p><p>This class:</p><pre class="brush: ceylon">shared class Counter(Integer initialCount=0) { ... }</pre><p>May be instantiated using any of the following invocations:</p><pre class="brush: ceylon">Counter()</pre><pre class="brush: ceylon">Counter(1)</pre><pre class="brush: ceylon">Counter {}</pre><pre class="brush: ceylon">Counter { initialCount=10; }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tupletypeofarglist"></a>6.6.3.&nbsp;The type of a list of arguments</h3></div></div><div></div></div><p>A list of arguments may be formed from:</p><div class="itemizedlist"><ul type="disc"><li><p>any number of <span class="emphasis"><em>listed arguments</em></span>,
                    optionally followed by either</p></li><li><p>a <span class="emphasis"><em>spread argument</em></span>, or</p></li><li><p>a <span class="emphasis"><em>comprehension</em></span>.</p></li></ul></div><pre class="synopsis">ArgumentList: ((ListedArgument ",")* (ListedArgument | SpreadArgument | Comprehension))?</pre><p>Every such list of arguments has a type, which captures the types of 
            the individual arguments in the list. This type is always a subtype of 
            <tt class="literal">Anything[]</tt>. The type of an empty list of arguments is 
            <tt class="literal">[]</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="listedarguments"></a>6.6.4.&nbsp;Listed arguments</h3></div></div><div></div></div><p>A listed argument is an expression.</p><pre class="synopsis">ListedArgument: Expression</pre><p>If a listed argument is an expression of type <tt class="literal">T</tt>, and 
            a list of arguments has type <tt class="literal">P</tt> with principal instantiation 
            <tt class="literal">Sequential&lt;Y&gt;</tt>, then the type of a new argument list 
            formed by prepending the expression to the first parameter list is 
            <tt class="literal">Tuple&lt;T|Y,T,P&gt;</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="spreadarguments"></a>6.6.5.&nbsp;Spread arguments</h3></div></div><div></div></div><p>A spread argument is an expression prefixed by the 
            <span class="emphasis"><em>spread operator</em></span> <tt class="literal">*</tt>.</p><pre class="synopsis">SpreadArgument: "* "Expression</pre><p>The expression type <tt class="literal">T</tt> must have the principal 
            instantiation <tt class="literal">{X*}</tt> for some type <tt class="literal">X</tt>. We 
            form the <span class="emphasis"><em>sequential type of a spread argument</em></span> as 
            follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if the expression type <tt class="literal">T</tt> is an invariant 
                    subtype of <tt class="literal">X[]</tt>, for some type <tt class="literal">X</tt> 
                    then the sequential type of the spread argument is 
                    <tt class="literal">T</tt>, or, if not,</p></li><li><p>if the expression type <tt class="literal">T</tt> is an invariant 
                    subtype of <tt class="literal">{X+}</tt>, for some type <tt class="literal">X</tt> 
                    then the sequential type of the spread argument is 
                    <tt class="literal">[X+]</tt>, or, otherwise,</p></li><li><p>the expression type <tt class="literal">T</tt> is an invariant 
                    subtype of <tt class="literal">{X*}</tt>, for some type <tt class="literal">X</tt>
                    and the sequential type of the spread argument is 
                    <tt class="literal">X[]</tt>,</p></li></ul></div><p>When a spread argument with an expression type not assignable to 
            <tt class="literal">Anything[]</tt> is evaluated, the elements of the iterable
            automatically are packaged into a sequence.</p><i><span class="comment"><p>Note: the spread "operator" is not truly an operator in the
            sense of <a href="expressions.html#operators" title="6.8.&nbsp;Operators">&sect;6.8 Operators</a>, and so a spread argument is not an 
            expresson. An expression, when evaluated, produces a single value. The
            spread operator produces multiple values. It is therefore more correct to 
            view the spread operator as simply part of the syntax of an argument list.
            </p></span></i><p>The type of a list of arguments containing only a spread argument of 
            sequential type <tt class="literal">S</tt> is simply <tt class="literal">S</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="comprehensions"></a>6.6.6.&nbsp;Comprehensions</h3></div></div><div></div></div><p>A <span class="emphasis"><em>comprehension</em></span> accepts one or more streams of values 
            and produces a new stream of values. Any instance of <tt class="literal">Iterable</tt>
            is considered a stream of values. The comprehension has two or more
            <span class="emphasis"><em>clauses</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>A <tt class="literal">for</tt> clause specifies a source stream and an 
                    iteration variable, as defined in <a href="statementblocks.html#iterationvariables" title="5.3.2.&nbsp;Iteration variables">&sect;5.3.2 Iteration variables</a>, 
                    representing the values produced by the stream.</p></li><li><p>An <tt class="literal">if</tt> clause specifies a condition list, as
                    defined in <a href="statementblocks.html#controlstructureconditions" title="5.3.3.&nbsp;Control structure conditions">&sect;5.3.3 Control structure conditions</a>, used to filter
                    the values produced by the source stream or streams.</p></li><li><p>An expression clause produces the values of the resulting stream.</p></li></ul></div><p>Every comprehension begins with a <tt class="literal">for</tt> clause, and 
            ends with an expression clause. There may be any number of intervening 
            <tt class="literal">for</tt> or <tt class="literal">if</tt> clauses. Each clause in the
            comprehension is considered a child of the clause that immediately precedes 
            it.</p><pre class="synopsis">Comprehension: ForComprehensionClause</pre><pre class="synopsis">ForComprehensionClause: "for" ForIterator ComprehensionClause</pre><pre class="synopsis">IfComprehensionClause: "if" ConditionList ComprehensionClause</pre><pre class="synopsis">ComprehensionClause: ForComprehensionClause | IfComprehensionClause | Expression</pre><p>An expression that occurs in a child clause may refer to iteration 
            variables and condition variables declared by parent clauses. The types
            of such variables are specified in <a href="statementblocks.html#controlstructures" title="5.3.&nbsp;Control structures and assertions">&sect;5.3 Control structures and assertions</a>.</p><i><span class="comment"><p>Note: each child clause can be viewed as a body nested inside 
            the parent clause. The scoping rules for variables declared by comprehension
            clauses reflects this model.</p></span></i><p>The type of a list of arguments containing only a comprehension is 
            <tt class="literal">[T*]</tt> where <tt class="literal">T</tt> is the type of the
            expression which terminates the comprehension, or <tt class="literal">[T+]</tt>
            if there are no <tt class="literal">if</tt> clauses, and if every 
            <tt class="literal">for</tt> clause has an iterated expression of nonempty
            type.</p><p>An comprehension occurring in an <tt class="literal">extends</tt> clause may 
            not contain a reference to a variable value.</p><i><span class="comment"><p>Note: a comprehension, like a spread argument, is not considered an 
            expression. An expression, when evaluated, produces a single value. A comprehension,
            produces multiple values, like a spread argument, or like a series of listed 
            arguments. Therefore, a comprehension may only appear in an argument list or an 
            enumeration expression. This is however, no limitation; we can simply wrap the
            comprehension in braces in order to get an expression of type <tt class="literal">{T*}</tt>,
            or in brackets to get an expression of type <tt class="literal">[T*]</tt>.</p></span></i><i><span class="comment"><p>TODO: properly define how expressions with no type occurring in a
            <tt class="literal">dynamic</tt> block affect comprehensions.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="positionalarguments"></a>6.6.7.&nbsp;Positional argument lists</h3></div></div><div></div></div><p>When invocation arguments are listed positionally, the argument list is 
            enclosed in parentheses.</p><pre class="synopsis">PositionalArguments: "(" ArgumentList ")"</pre><p>The type of the positional argument list is the type of the list of arguments 
            it contains.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="namedarguments"></a>6.6.8.&nbsp;Named argument lists</h3></div></div><div></div></div><p>When invocation arguments are listed by name, the argument list is enclosed 
            in braces.</p><pre class="synopsis">NamedArguments: "{" NamedArgument* ArgumentList "}"</pre><p>Named arguments may be listed in a different order to the corresponding
            parameters.</p><p>Each named argument in a named argument list is either:</p><div class="itemizedlist"><ul type="disc"><li><p>an <span class="emphasis"><em>anonymous argument</em></span>&#8212;an expression, with
                    no parameter name explicitly specified,</p></li><li><p>a <span class="emphasis"><em>specified argument</em></span>&#8212;a specification 
                    statement where name of the value of function being specified is interpreted
                    as the name of a parameter, or</p></li><li><p>an inline getter, function, or anonymous class declaration, whose name 
                    is interpreted as the name of a parameter.</p></li></ul></div><pre class="synopsis">NamedArgument: AnonymousArgument | SpecifiedArgument | InlineDeclarationArgument</pre><p>Additionally, a named argument list has an ordinary list of arguments, which 
            may be empty. This argument list is interpreted as a single argument to a parameter 
            of type <tt class="literal">Iterable</tt>.</p><pre class="brush: ceylon">{ initialCapacity=2; "hello", "world" }</pre><pre class="brush: ceylon">{ initialCapacity=people.size; loadFactor=0.8; for (p in people) p.name-&gt;p }</pre><i><span class="comment"><p>Note: in a future release of the language, we would like to be able 
            to assign a local name to an anonymous argument or listed argument, allowing it to 
            be referenced later in the argument list. We might consider this a kind of "let"
            expression, perhaps.</p></span></i><p>Given a parameter list, and a named argument list, we may attempt to construct 
            an <span class="emphasis"><em>equivalent positional argument list</em></span> as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>Taking each argument in the named argument list in turn, on the order 
                    they occur lexically:</p><div class="itemizedlist"><ul type="circle"><li><p>if the argument is anonymous, assign it to the first unassigned
                            parameter of the parameter list, or</p></li><li><p>if the argument is named, assign it to the parameter with that
                            name in the parameter list.</p></li></ul></div><p>If for any argument, there is no unassigned parameter, no parameter with
                    the given name, or the parameter with the given name has already been assigned
                    an argument, construction of the positional argument list fails, and the 
                    invocation is not well-typed.</p></li><li><p>Next, if the parameter list has an unassigned parameter of type exactly
                    <tt class="literal">Iterable&lt;T,N&gt;</tt> for some types <tt class="literal">T</tt> and
                    <tt class="literal">N</tt>, then an iterable enumeration expression, as defined in
                    <a href="expressions.html#enumeration" title="6.6.12.&nbsp;Iterable and tuple enumeration">&sect;6.6.12 Iterable and tuple enumeration</a>, is formed from the ordinary list of arguments, 
                    and assigned to that parameter.</p><p>If there is no such parameter, and the the ordinary list of arguments is
                    nonempty, then construction of the positional argument list fails, and the 
                    invocation is not well-typed.</p></li><li><p>Finally, we assign each unassigned defaulted parameter its default 
                    argument.</p></li></ul></div><p>The resulting equivalent positional argument list is formed by ordering
            the arguments according to the position of their corresponding parameters in
            the parameter list, and then replacing any inline value, function, or object
            declarations with a reference to the declaration.</p><p>The type of a named argument list is the type of the equivalent positional 
            argument list.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="anonymousarguments"></a>6.6.9.&nbsp;Anonymous arguments</h3></div></div><div></div></div><p>An anonymous argument is just an expression followed by a semicolon.</p><pre class="synopsis">AnonymousArgument: Expression ";"</pre><p>The type of the argument is the type of the expression.</p><pre class="brush: ceylon">{
    Head { title="Hello"; };
    Body {
        Div { "Hello " name "!" };
    };
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="specifiedarguments"></a>6.6.10.&nbsp;Specified arguments</h3></div></div><div></div></div><p>A specified argument is a value specification statement or lazy specification 
            statement, as defined in <a href="statementblocks.html#specificationstatements" title="5.2.3.&nbsp;Specification statements">&sect;5.2.3 Specification statements</a>, where the value
            reference or callable reference is treated as the name of a parameter of the invoked 
            function or class instead of using the usual rules for resolving unqualified names.</p><pre class="synopsis">SpecifiedArgument: Specification</pre><div class="itemizedlist"><ul type="disc"><li><p>If a specified argument is a value specification statement, its type 
                    is the type of the specified expression.</p></li><li><p>If a specified argument is a lazy specification statement with no 
                    parameter lists, its type is the type of the specified expression.</p></li><li><p>Otherwise, if it is a lazy specification statement with a parameter 
                    list, its type is the callable type formed from the type of the expression,
                    interpreted as a function return type, and the types of its parameter lists, 
                    according to <a href="declarations.html#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>.</p></li></ul></div><i><span class="comment"><p>Note: there is an ambiguity here between assignment expressions 
            and specified arguments. This ambiguity is resolved in favor of interpreting the
            argument as a specified argument. Therefore an anonymous argument in a named 
            argument list may not be an assignment expression.</p></span></i><pre class="brush: ceylon">{ 
    product = getProduct(id); 
    quantity = 1; 
}</pre><pre class="brush: ceylon">{ 
    by(Value x, Value y) =&gt; x&lt;=&gt;y;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inlinedeclarationarguments"></a>6.6.11.&nbsp;Inline declaration arguments</h3></div></div><div></div></div><p>An <span class="emphasis"><em>inline declaration argument</em></span> defines a getter,
            function, or anonymous class, and assigns it to a parameter.</p><pre class="synopsis">ValueArgument | FunctionArgument | ObjectArgument</pre><p>An inline getter argument is a streamlined getter declaration, as defined
            in <a href="declarations.html#getters" title="4.8.2.&nbsp;Getters">&sect;4.8.2 Getters</a>. The type of the argument is the declared or inferred 
            type of the getter.</p><pre class="synopsis">ValueArgument: ValueHeader (Block | (Specifier | LazySpecifier) ";")</pre><p>An inline function argument is a streamlined function declaration, as
            defined in <a href="declarations.html#functions" title="4.7.&nbsp;Functions">&sect;4.7 Functions</a>. The type of the argument is the callable 
            type of the function, as defined by <a href="declarations.html#callabletypeoffunction" title="4.7.1.&nbsp;Callable type of a function">&sect;4.7.1 Callable type of a function</a>.</p><pre class="synopsis">FunctionArgument: FunctionHeader (Block | LazySpecifier ";")</pre><p>An inline anonymous class argument is a streamlined anonymous class 
            declaration, as defined in <a href="declarations.html#anonymousclasses" title="4.5.7.&nbsp;Anonymous classes">&sect;4.5.7 Anonymous classes</a>. The type of the 
            argument is the anonymous class type.</p><pre class="synopsis">ObjectArgument: ObjectHeader ClassBody</pre><p>A named argument may not have type parameters or annotations.</p><pre class="brush: ceylon">{
    description = "Total";
    value amount { 
        variable Float total = 0.0;
        for (Item item in items) {
            sum += item.amount;
        }
        return total;
    }
}</pre><pre class="brush: ceylon">{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello!"); 
    } 
}</pre><pre class="brush: ceylon">{ 
    function by(Value x, Value y) =&gt; x&lt;=&gt;y;
}</pre><pre class="brush: ceylon">{
    object iterator 
            satisfies Iterator&lt;Order&gt; {
        variable value done = false;
        shared actual Order|Finished next() {
            if (done) {
                return finished;
            }
            else {
                done=true;
                return order; 
            }
        }
    }   
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="enumeration"></a>6.6.12.&nbsp;Iterable and tuple enumeration</h3></div></div><div></div></div><p>An <span class="emphasis"><em>enumeration expression</em></span> is an abbreviation for
            tuple and iterable object instantiation. Iterable enumerations are delimited
            using braces. Tuple enumerations are delimited by brackets.</p><pre class="synopsis">Iterable: "{" ArgumentList "}"</pre><pre class="synopsis">Tuple: "[" ArgumentList "]"</pre><p>The type of an iterable enumeration expression is:</p><div class="itemizedlist"><ul type="disc"><li><tt class="literal">Empty</tt> if there are no argument expressions, or
                </li><li><tt class="literal">Iterable&lt;U,Nothing&gt;</tt> where <tt class="literal">U</tt>,
                    the argument expression list is an invariant suptype of <tt class="literal">U[]</tt>.
                </li></ul></div><p>The type of a tuple enumeration expression is the type of the list of
            arguments it contains.</p><pre class="brush: ceylon">{String+} = { "hello", "world" };</pre><pre class="brush: ceylon">[] none = [];</pre><pre class="brush: ceylon">[Float,Float] xy = [x, y];</pre><pre class="brush: ceylon">[Float,Float, String*] xy = [x, y, *labels];</pre><p>Every argument expression must have a type, even if the enumeration expression
            occurs in a <tt class="literal">dynamic</tt> block.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamicenumerations"></a>6.6.13.&nbsp;Dynamic enumerations</h3></div></div><div></div></div><p>A <span class="emphasis"><em>dynamic enumeration expression</em></span> creates a new 
            object with no class by enumerating its members, allowing interoperation 
            with dynamically typed native code.</p><pre class="synopsis">DynamicValue: "value" NamedArguments</pre><p>A dynamic enumeration expression has no type.</p><p>Any argument names may be specified in the named argument list.</p><p>A dynamic enumeration expression must occur inside a
            <tt class="literal">dynamic</tt> block.</p><i><span class="comment"><p>The semantics of this construct are platform-dependent and
            beyond the scope of this specification.</p></span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="miscexpressions"></a>6.7.&nbsp;Conditional expressions and anonymous class expressions</h2></div></div><div></div></div><p>A <span class="emphasis"><em>conditional expression</em></span> resembles a control 
        structure but is part of the expression syntax, and evaluates to a value.</p><p>An <span class="emphasis"><em>inline class</em></span> is an anonymous class defined 
        within an expression.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inlineconditionalexpressions"></a>6.7.1.&nbsp;Inline conditional expressions</h3></div></div><div></div></div><i><span class="comment">
            <p>We plan to support inline <tt class="literal">if/then/else</tt> conditional 
            expressions, for example:</p>
            <pre class="brush: ceylon">Integer port = if (exists setting = process.propertyValue("port")) 
                        then parseInteger(setting) else 8080;</pre>
            <p>Note that this is more powerful than the <tt class="literal">then</tt> and
            <tt class="literal">else</tt> operators because it allows all kinds of conditions,
            not only boolean conditions.</p>
            <p>Should we also support:</p>
            <div class="itemizedlist"><ul type="disc"><li><p>inline <tt class="literal">switch/case/else</tt> conditional 
                    expressions, or even</p></li><li><p>inline <tt class="literal">try/catch</tt> exceptional conditions?</p></li></ul></div>
            <p>For example:</p>
            <pre class="brush: ceylon">Float evaluated =&gt; switch (expr)
        case (is Literal) expr.integer
        case (is Plus) expr.left.evaluated + expr.right.evaluated
        case (is Times) expr.left.evaluated * expr.right.evaluated;</pre>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="letexpressions"></a>6.7.2.&nbsp;Let expressions</h3></div></div><div></div></div><i><span class="comment">
            <p>Should we support let expressions, possibly reusing the keyword
            <tt class="literal">given</tt>?</p>
            <pre class="brush: ceylon">given (dist = sqrt(x^2+y^2)) [x/dist,y/dist]</pre>
            </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="inlineanonymousclassexpressions"></a>6.7.3.&nbsp;Inline anonymous class expressions</h3></div></div><div></div></div><i><span class="comment">
            <p>Should we support inline <tt class="literal">object</tt> declarations, for 
            example:</p>
            <pre class="brush: ceylon">iterator =&gt; object satisfies Iterable&lt;Nothing&gt; { next() =&gt; finished; }</pre>
            <p>Or, alternatively, a kind of named argument ""instantiation" syntax for
            interfaces and abstract classes:</p>
            <pre class="brush: ceylon">iterator =&gt; Iterable { next() =&gt; finished; }</pre>
            <p>The first option is more flexible, but also more verbose. The second is
            streamlined for the common case and might even be able to do type argument
            inference as shown here.</p> 
            
            <p>If we go with the first option, should we support inline <tt class="literal">class</tt> 
            declarations? This would be like an inline <tt class="literal">object</tt> and an 
            anonymous function rolled into one. We could even support <tt class="literal">class</tt>
            arguments in named argument lists.</p>
            </span></i></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="operators"></a>6.8.&nbsp;Operators</h2></div></div><div></div></div><p>Operators are syntactic shorthand for more complex expressions involving 
    invocation, evaluation, or instantiation. There is no support for user-defined 
    <span class="emphasis"><em>operator overloading</em></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>new operator symbols may not be defined outside of the operators
            specified below, and</p></li><li><p>the definition of the operators specified below may not be changed 
            or overloaded.</p></li></ul></div><p>However, many of the operators below are defined in terms of 
    <tt class="literal">default</tt> or <tt class="literal">formal</tt> methods or attributes.
    So, within well-defined limits a concrete implementation may customize the  
    behavior of an operator. This approach is called 
    <span class="emphasis"><em>operator polymorphism</em></span>.</p><p>Some examples:</p><pre class="brush: ceylon">Float z = x * y + 1.0;</pre><pre class="brush: ceylon">even = n % 2 == 0;</pre><pre class="brush: ceylon">++count;</pre><pre class="brush: ceylon">Integer j = i++;</pre><pre class="brush: ceylon">if ( x &gt; 100 || x &lt; 0 ) { ... }</pre><pre class="brush: ceylon">User user = users[userId] else guest;</pre><pre class="brush: ceylon">List&lt;Item&gt; firstPage = results[0..20];</pre><pre class="brush: ceylon">for (n in 0:length) { ... }</pre><pre class="brush: ceylon">if (char in 'A'..'Z') { ... }</pre><pre class="brush: ceylon">String[] names = people*.name;</pre><pre class="brush: ceylon">this.total += item.price * item.quantity;</pre><pre class="brush: ceylon">Float vol = length^3;</pre><pre class="brush: ceylon">Vector scaled = scale ** vector;</pre><pre class="brush: ceylon">map.define(person.name-&gt;person);</pre><pre class="brush: ceylon">if (!document.internal || user is Employee) { ... }</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="operatorprecedence"></a>6.8.1.&nbsp;Operator precedence</h3></div></div><div></div></div><p>There are 18 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict.</p><div class="itemizedlist"><ul type="disc"><li><p>Operators in layer 1 produce, transform, and combine
            values.</p></li><li><p>Operators in layer 2 compare or predicate values, producing
            a <tt class="literal">Boolean</tt> result.</p></li><li><p>Operators in layer 3 are logical operators that operate
            upon <tt class="literal">Boolean</tt> arguments to produce a <tt class="literal">Boolean</tt>
            value.</p></li><li><p>Operators in layer 4 perform assignment and conditional
            evaluation.</p></li></ul></div><p>Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators.</p><p>There is a single exception to this principal: the binary 
        exponentiation operator <tt class="literal">^</tt> has a higher precedence than 
        the prefix operators <tt class="literal">+</tt> and <tt class="literal">-</tt>. The 
        reason for this is that the following expressions should be equivalent:</p><pre class="brush: ceylon">-x^2       //means -(x^2)</pre><pre class="brush: ceylon">0 - x^2    //means 0 - (x^2)</pre><p>This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules:</p><div class="table"><a name="d0e12862"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Operations</th><th align="center">Operators</th><th align="center">Type</th><th align="center">Associativity</th></tr></thead><tbody><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 1</em></span></td></tr><tr><td align="center">Member invocation and selection, index, span,
                postfix increment, postfix decrement:</td><td align="center"><tt class="literal">.</tt>,
                <tt class="literal">*.</tt>, 
                <tt class="literal">?.</tt>, 
                <tt class="literal">()</tt>,
                <tt class="literal">{}</tt>,
                <tt class="literal">[]</tt>,
                <tt class="literal">[:]</tt>, 
                <tt class="literal">[..]</tt>, 
                <tt class="literal">[...]</tt>,
                <tt class="literal">++</tt>, 
                <tt class="literal">--</tt></td><td align="center">Binary / ternary / N-ary / unary postfix</td><td align="center">Left</td></tr><tr><td align="center">Prefix increment, prefix decrement:</td><td align="center"><tt class="literal">++</tt>, 
                <tt class="literal">--</tt></td><td align="center">Unary prefix</td><td align="center">Right</td></tr><tr><td align="center">Exponentiation:</td><td align="center"><tt class="literal">^</tt></td><td align="center">Binary</td><td align="center">Right</td></tr><tr><td align="center">Negation:</td><td align="center"><tt class="literal">+</tt>,
                <tt class="literal">-</tt></td><td align="center">Unary prefix</td><td align="center">Right</td></tr><tr><td align="center">Set intersection:</td><td align="center"><tt class="literal">&amp;</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Set union and complement:</td><td align="center"><tt class="literal">|</tt>,
                <tt class="literal">~</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Multiplication, division, remainder:</td><td align="center"><tt class="literal">*</tt>, 
                <tt class="literal">/</tt>, 
                <tt class="literal">%</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Scale:</td><td align="center"><tt class="literal">**</tt></td><td align="center">Binary</td><td align="center">Right</td></tr><tr><td align="center">Addition, subtraction:</td><td align="center"><tt class="literal">+</tt>, 
                <tt class="literal">-</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Range and entry construction:</td><td align="center"><tt class="literal">..</tt>,
                <tt class="literal">:</tt>,  
                <tt class="literal">-&gt;</tt></td><td align="center">Binary</td><td align="center">None</td></tr><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 2</em></span></td></tr><tr><td align="center">Existence, emptiness:</td><td align="center"><tt class="literal">exists</tt>, <tt class="literal">nonempty</tt></td><td align="center">Unary postfix</td><td align="center">None</td></tr><tr><td align="center">Comparison, containment,
                assignability, inheritance:</td><td align="center"><tt class="literal">&lt;=&gt;</tt>,
                <tt class="literal">&lt;</tt>, 
                <tt class="literal">&gt;</tt>, 
                <tt class="literal">&lt;=</tt>, 
                <tt class="literal">&gt;=</tt>,
                <tt class="literal">in</tt>,
                <tt class="literal">is</tt>,
                <tt class="literal">of</tt>,
                <tt class="literal">satisfies</tt></td><td align="center">Binary (and ternary)</td><td align="center">None</td></tr><tr><td align="center">Equality, identity:</td><td align="center"><tt class="literal">==</tt>, 
                <tt class="literal">!=</tt>, 
                <tt class="literal">===</tt></td><td align="center">Binary</td><td align="center">None</td></tr><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 3</em></span></td></tr><tr><td align="center">Logical not:</td><td align="center"><tt class="literal">!</tt></td><td align="center">Unary prefix</td><td align="center">Right</td></tr><tr><td align="center">Logical and:</td><td align="center"><tt class="literal">&amp;&amp;</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Logical or:</td><td align="center"><tt class="literal">||</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td colspan="4" align="center"><span class="emphasis"><em>Layer 4</em></span></td></tr><tr><td align="center">Conditionals:</td><td align="center"><tt class="literal">then</tt>, 
                <tt class="literal">else</tt></td><td align="center">Binary</td><td align="center">Left</td></tr><tr><td align="center">Assignment:</td><td align="center"><tt class="literal">=</tt>, 
                <tt class="literal">+=</tt>, 
                <tt class="literal">-=</tt>, 
                <tt class="literal">*=</tt>, 
                <tt class="literal">/=</tt>, 
                <tt class="literal">%=</tt>, 
                <tt class="literal">&amp;=</tt>, 
                <tt class="literal">|=</tt>, 
                <tt class="literal">^=</tt>, 
                <tt class="literal">~=</tt>, 
                <tt class="literal">&amp;&amp;=</tt>, 
                <tt class="literal">||=</tt></td><td align="center">Binary</td><td align="center">Right</td></tr></tbody></table></div><p>It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator <tt class="literal">!</tt> has a very low
        precedence. The following expressions are equivalent:</p><pre class="brush: ceylon">!x.y == 0.0  //means !(x.y == 0.0)</pre><pre class="brush: ceylon">x.y != 0.0</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="operatordefinition"></a>6.8.2.&nbsp;Operator definition</h3></div></div><div></div></div><p>The following tables define the semantics of the Ceylon operators. 
        There are six basic operators which do not have a definition in terms of 
        other operators or invocations:</p><div class="itemizedlist"><ul type="disc"><li><p>the <span class="emphasis"><em>member selection</em></span> operator
                <tt class="literal">.</tt> separates the receiver expression and member 
                name in a member expression, as defined above in
                <a href="expressions.html#memberexpressions" title="6.5.2.&nbsp;Member expressions">&sect;6.5.2 Member expressions</a>,</p></li><li><p>the <span class="emphasis"><em>argument specification</em></span> operators
                <tt class="literal">()</tt> and <tt class="literal">{}</tt> specify the 
                argument list of an invocation, as defined in
                <a href="expressions.html#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a> and 
                <a href="execution.html#invocation" title="8.4.4.&nbsp;Invocation">&sect;8.4.4 Invocation</a>,</p></li><li><p>the <span class="emphasis"><em>assignment</em></span> operator
                <tt class="literal">=</tt> assigns a new value to a variable and 
                returns the new value after assignment, as defined in
                <a href="execution.html#assignment" title="8.4.3.&nbsp;Assignment">&sect;8.4.3 Assignment</a>,</p></li><li><p>the <span class="emphasis"><em>identity</em></span> operator
                <tt class="literal">===</tt> evaluates to <tt class="literal">true</tt> 
                if its argument expressions evaluate to references to the same 
                object, as defined in <a href="execution.html#objectinstancesidentity" title="8.1.&nbsp;Object instances, identity, and reference passing">&sect;8.1 Object instances, identity, and reference passing</a>,
                or to <tt class="literal">false</tt> otherwise,</p></li><li><p>the <span class="emphasis"><em>assignability</em></span> operator
                <tt class="literal">is</tt> evaluates to <tt class="literal">true</tt> if 
                its argument expression evaluates to an instance of a class, as 
                defined in <a href="execution.html#objectinstancesidentity" title="8.1.&nbsp;Object instances, identity, and reference passing">&sect;8.1 Object instances, identity, and reference passing</a>, that is a 
                subtype of the specified type, or to <tt class="literal">false</tt> 
                otherwise, and</p></li><li><p>the <span class="emphasis"><em>coverage</em></span> operator
                <tt class="literal">of</tt> narrows or widens the type of an expression 
                to any specified type that covers the expression type, as defined
                by <a href="typesystem.html#coverage" title="3.4.1.&nbsp;Coverage">&sect;3.4.1 Coverage</a>, without affecting the value of the
                expression.</p></li></ul></div><p>All other operators are defined below in terms of other operators 
        and/or invocations.</p><p>In the tables, the following pseudo-code is used, which is not legal
        Ceylon syntax:</p><p>First,</p><pre class="brush: ceylon">if (b) then x else y   //pseudocode</pre><p>means the value of <tt class="literal">result</tt> after execution of the
        following:</p><pre class="brush: ceylon">X result; if (b) { result=x; } else { result=y; }</pre><p>Second,</p><pre class="brush: ceylon">let t=x in y   //pseudocode</pre><p>means the value of <tt class="literal">result</tt> after execution of the
        following:</p><pre class="brush: ceylon">X t = x; Y result=y;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="basic"></a>6.8.3.&nbsp;Basic invocation and assignment operators</h3></div></div><div></div></div><p>These operators support method invocation and attribute evaluation and
        assignment.</p><div class="table"><a name="d0e13329"></a><p class="title"><b>Table&nbsp;6.2.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Invocation</em></span></td></tr><tr><td align="center"><tt class="literal">lhs.member</tt></td><td align="center">member</td><td align="center">&nbsp;</td><td align="center"><tt class="literal">X</tt></td><td align="center">a member of <tt class="literal">X</tt>, of type
            <tt class="literal">T</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">lhs(x,y,z)</tt> or 
            <tt class="literal">lhs{a=x;b=y;}</tt></td><td align="center">invoke</td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Callable &lt;T,P&gt;</tt></td><td align="center">argument list of type <tt class="literal">P</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs = rhs</tt></td><td align="center">assign</td><td align="center"><tt class="literal"></tt></td><td align="center">variable of type <tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Coverage</em></span></td></tr><tr><td align="center"><tt class="literal">lhs of Type</tt></td><td align="center">of</td><td align="center"><tt class="literal"></tt></td><td align="center"><tt class="literal">X</tt></td><td align="center">a literal type <tt class="literal">T</tt> that covers 
            <tt class="literal">X</tt></td><td align="center"><tt class="literal">T</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="equalitycomparison"></a>6.8.4.&nbsp;Equality and comparison operators</h3></div></div><div></div></div><p>These operators compare values for equality, order, magnitude, or membership,
        producing boolean values.</p><div class="table"><a name="d0e13448"></a><p class="title"><b>Table&nbsp;6.3.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Equality and identity</em></span></td></tr><tr><td align="center"><tt class="literal">lhs === rhs</tt></td><td align="center">identical</td><td align="center"><tt class="literal">identical(lhs,rhs)</tt></td><td align="center"><tt class="literal">X given X satisfies Identifiable</tt></td><td align="center"><tt class="literal">Y given Y satisfies Identifiable</tt>
            where <tt class="literal">X&amp;Y</tt> is not <tt class="literal">Nothing</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs == rhs</tt></td><td align="center">equal</td><td align="center"><tt class="literal">lhs.equals(rhs)</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs != rhs</tt></td><td align="center">not equal</td><td align="center"><tt class="literal">!lhs.equals(rhs)</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Comparison</em></span></td></tr><tr><td align="center"><tt class="literal">lhs &lt;=&gt; rhs</tt></td><td align="center">compare</td><td align="center"><tt class="literal">lhs.compare(rhs)</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Comparison</tt></td></tr><tr><td align="center"><tt class="literal">lhs &lt; rhs</tt></td><td align="center">smaller</td><td align="center"><tt class="literal">lhs.compare(rhs)==smaller</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &gt; rhs</tt></td><td align="center">larger</td><td align="center"><tt class="literal">lhs.compare(rhs)==larger</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &lt;= rhs</tt></td><td align="center">small as</td><td align="center"><tt class="literal">lhs.compare(rhs)!=larger</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &gt;= rhs</tt></td><td align="center">large as</td><td align="center"><tt class="literal">lhs.compare(rhs)!=smaller</tt></td><td align="center"><tt class="literal">Comparable &lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Containment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs in rhs</tt></td><td align="center">in</td><td align="center"><tt class="literal">let x=lhs in rhs.contains(x)</tt></td><td align="center"><tt class="literal">Object</tt></td><td align="center"><tt class="literal">Category</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Assignability</em></span></td></tr><tr><td align="center"><tt class="literal">rhs is Type</tt></td><td align="center">is</td><td align="center">&nbsp;</td><td align="center">any type which is not a subtype of 
            <tt class="literal">T</tt>, whose intersection with 
            <tt class="literal">T</tt> is not <tt class="literal">Nothing</tt></td><td align="center">any literal type <tt class="literal">T</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr></tbody></table></div><i><span class="comment"><p>TODO: Should we have allow the operators <tt class="literal">&lt;=</tt> 
        and <tt class="literal">&gt;=</tt> to handle partial orders? A particular usecase is
        <tt class="literal">Set</tt> comparison.</p></span></i><p>A <span class="emphasis"><em>bounded comparison</em></span> is an abbreviation 
        for two binary comparisons:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">l&lt;x&lt;u</tt> means 
                <tt class="literal">x&gt;l &amp;&amp; x&lt;u</tt>,</p></li><li><p><tt class="literal">l&lt;=x&lt;u</tt> means 
                <tt class="literal">x&gt;=l &amp;&amp; x&lt;u</tt>,</p></li><li><p><tt class="literal">l&lt;x&lt;=u</tt> means 
                <tt class="literal">x&gt;l &amp;&amp; x&lt;=u</tt>, and</p></li><li><p><tt class="literal">l&lt;=x&lt;=u</tt> means 
                <tt class="literal">x&gt;=l &amp;&amp; x&lt;=u</tt></p></li></ul></div><p>for expressions <tt class="literal">l</tt>, <tt class="literal">u</tt>, 
        and <tt class="literal">x</tt>.</p><p>These abbreviations have the same precedence as the binary 
        <tt class="literal">&lt;</tt> and <tt class="literal">&lt;=</tt> operators, and, 
        like the binary forms, are not associative.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="logical"></a>6.8.5.&nbsp;Logical operators</h3></div></div><div></div></div><p>These are the usual logical operations for boolean values.</p><div class="table"><a name="d0e13753"></a><p class="title"><b>Table&nbsp;6.4.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Logical operators</em></span></td></tr><tr><td align="center"><tt class="literal">!rhs</tt></td><td align="center">not</td><td align="center"><tt class="literal">if (rhs) false else true</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs || rhs</tt></td><td align="center">conditional or</td><td align="center"><tt class="literal">if (lhs) true else rhs</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp;&amp; rhs</tt></td><td align="center">conditional and</td><td align="center"><tt class="literal">if (lhs) rhs else false</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Logical assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs ||= rhs</tt></td><td align="center">conditional or</td><td align="center"><tt class="literal">if (lhs) true else lhs=rhs</tt></td><td align="center">variable of type <tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp;&amp;= rhs</tt></td><td align="center">conditional and</td><td align="center"><tt class="literal">if (lhs) lhs=rhs else false</tt></td><td align="center">variable of type <tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">Boolean</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="nullvalues"></a>6.8.6.&nbsp;Operators for handling null values</h3></div></div><div></div></div><p>These operators make it easy to work with optional expressions.</p><div class="table"><a name="d0e13879"></a><p class="title"><b>Table&nbsp;6.5.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Existence</em></span></td></tr><tr><td align="center"><tt class="literal">lhs exists</tt></td><td align="center">exists</td><td align="center"><tt class="literal">if (exists lhs) true else false</tt></td><td align="center">any type whose intersections with <tt class="literal">Object</tt>
            and <tt class="literal">Null</tt> are not <tt class="literal">Nothing</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td align="center"><tt class="literal">lhs nonempty</tt></td><td align="center">nonempty</td><td align="center"><tt class="literal">if (nonempty lhs) true else false</tt></td><td align="center">any subtype of <tt class="literal">Anything[]?</tt>
            whose intersections with <tt class="literal">[]</tt> and 
            <tt class="literal">[Nothing+]</tt> are not <tt class="literal">Nothing</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Boolean</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Nullsafe invocation</em></span></td></tr><tr><td align="center"><tt class="literal">lhs?.member</tt></td><td align="center">nullsafe attribute</td><td align="center"><tt class="literal">if (exists lhs) lhs.member else null</tt></td><td align="center"><tt class="literal">X?</tt></td><td align="center">an attribute of type <tt class="literal">T</tt>
            of <tt class="literal">X</tt></td><td align="center"><tt class="literal">T?</tt></td></tr><tr><td align="center"><tt class="literal">lhs?.member</tt></td><td align="center">nullsafe method</td><td align="center">&nbsp;</td><td align="center"><tt class="literal">X?</tt></td><td align="center">a method of callable type 
            <tt class="literal">Callable &lt;T,P&gt;</tt> 
            of <tt class="literal">X</tt></td><td align="center"><tt class="literal">Callable &lt;T?,P&gt;</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="listmap"></a>6.8.7.&nbsp;Correspondence and sequence operators</h3></div></div><div></div></div><p>These operators provide a simplified syntax for accessing values 
        of a <tt class="literal">Correspondence</tt>, and for joining and obtaining
        subranges of <tt class="literal">Sequence</tt>s.</p><div class="table"><a name="d0e14012"></a><p class="title"><b>Table&nbsp;6.6.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Keyed item access</em></span></td></tr><tr><td align="center"><tt class="literal">lhs[index]</tt></td><td align="center">lookup</td><td align="center"><tt class="literal">lhs.item(index)</tt></td><td align="center"><tt class="literal">Correspondence&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">Y?</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Spans and segments</em></span></td></tr><tr><td align="center"><tt class="literal">lhs[from:length]</tt></td><td align="center">segment</td><td align="center"><tt class="literal">lhs.segment(from,length)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">X</tt>, <tt class="literal">Integer</tt></td><td align="center"><tt class="literal">Y</tt></td></tr><tr><td align="center"><tt class="literal">lhs[from..to]</tt></td><td align="center">span</td><td align="center"><tt class="literal">lhs.span(from,to)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">X</tt>, <tt class="literal">X</tt></td><td align="center"><tt class="literal">Y</tt></td></tr><tr><td align="center"><tt class="literal">lhs[from...]</tt></td><td align="center">upper span</td><td align="center"><tt class="literal">lhs.spanFrom(from)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">Y</tt></td></tr><tr><td align="center"><tt class="literal">lhs[...to]</tt></td><td align="center">lower span</td><td align="center"><tt class="literal">lhs.spanTo(to)</tt></td><td align="center"><tt class="literal">Ranged&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">Y</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Spread invocation</em></span></td></tr><tr><td align="center"><tt class="literal">lhs*.member</tt></td><td align="center">spread attribute</td><td align="center"><tt class="literal">[ for (X x in lhs) x.member ]</tt></td><td align="center"><tt class="literal">X[]</tt></td><td align="center">attribite of <tt class="literal">X</tt> of
            type <tt class="literal">T</tt></td><td align="center"><tt class="literal">T[]</tt></td></tr><tr><td align="center"><tt class="literal">lhs*.member</tt></td><td align="center">spread method</td><td align="center">&nbsp;</td><td align="center"><tt class="literal">X[]</tt></td><td align="center">method of <tt class="literal">X</tt> of
            callable type <tt class="literal">Callable &lt;T,P&gt;</tt></td><td align="center"><tt class="literal">Callable &lt;T[],P&gt;</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Spread multiplication</em></span></td></tr><tr><td align="center"><tt class="literal">lhs ** rhs</tt></td><td align="center">scale</td><td align="center"><tt class="literal">rhs.scale(lhs)</tt></td><td align="center"><tt class="literal">Y</tt></td><td align="center"><tt class="literal">Scalable&lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">X</tt></td></tr></tbody></table></div><p>There are two special cases related to sequences. A type <tt class="literal">X</tt>
    is a <span class="emphasis"><em>sequence type</em></span> if <tt class="literal">X</tt> is a subtype of 
    <tt class="literal">Sequential&lt;Anything&gt;</tt>.</p><p>For any sequence type <tt class="literal">X</tt> and integer <tt class="literal">n</tt>, 
    we can form the <span class="emphasis"><em><tt class="literal">n</tt>th tail type, <tt class="literal">Xn</tt>, 
    of <tt class="literal">X</tt></em></span> as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>for every <tt class="literal">i&lt;=0</tt>, <tt class="literal">Xi</tt> 
            is <tt class="literal">X</tt>, and</p></li><li><p>for every <tt class="literal">i&gt;0</tt>, if <tt class="literal">Xi</tt> 
            has the principal instantiation <tt class="literal">Tuple&lt;Ui,Fi,Yi&gt;</tt> 
            then <tt class="literal">X(i+1)</tt> is <tt class="literal">Yi</tt>, or, 
            otherwise, <tt class="literal">X(i+1)</tt> is <tt class="literal">Xi</tt>.</p></li></ul></div><p>For any sequence type <tt class="literal">X</tt> and integer <tt class="literal">n</tt>, 
    we can form the <span class="emphasis"><em><tt class="literal">n</tt>th element type, <tt class="literal">En</tt>, 
    of <tt class="literal">X</tt></em></span> as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>if <tt class="literal">Xn</tt> has the principal instantiation
            <tt class="literal">Tuple&lt;Un,Fn,Yn&gt;</tt> then <tt class="literal">En</tt> 
            is <tt class="literal">Fn</tt>, or, otherwise, <tt class="literal">Xn</tt>
            has the principal instantiation <tt class="literal">Sequential&lt;Fn&gt;</tt> 
            and <tt class="literal">En</tt> is <tt class="literal">Fn?</tt>.</p></li></ul></div><p>Then the two special cases are:</p><div class="itemizedlist"><ul type="disc"><li><p>The type of an expression of form <tt class="literal">x[i...]</tt> where
    <tt class="literal">x</tt> is of tuple type <tt class="literal">X</tt> and 
    <tt class="literal">n</tt> is an integer literal is <tt class="literal">Xn</tt>.</p></li><li><p>The type of an expression of form <tt class="literal">x[i]</tt> where
    <tt class="literal">x</tt> is of tuple type <tt class="literal">X</tt> and 
    <tt class="literal">n</tt> is an integer literal is <tt class="literal">En</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constructors"></a>6.8.8.&nbsp;Operators for creating objects</h3></div></div><div></div></div><p>These operators simplify the syntax for instantiating certain 
        commonly used built-in types.</p><div class="table"><a name="d0e14366"></a><p class="title"><b>Table&nbsp;6.7.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Range and entry constructors</em></span></td></tr><tr><td align="center"><tt class="literal">lhs..rhs</tt></td><td align="center">spanned range</td><td align="center"><tt class="literal">Range(lhs, rhs)</tt></td><td align="center"><tt class="literal">T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td><td align="center"><tt class="literal">Range&lt;T&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs:rhs</tt></td><td align="center">segmented range</td><td align="center"><tt class="literal">if (lhs&lt;=0) [] else TODO</tt></td><td align="center"><tt class="literal">T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</tt></td><td align="center"><tt class="literal">Integer</tt></td><td align="center"><tt class="literal">T[]</tt></td></tr><tr><td align="center"><tt class="literal">lhs-&gt;rhs</tt></td><td align="center">entry</td><td align="center"><tt class="literal">Entry(lhs, rhs)</tt></td><td align="center"><tt class="literal">U given U satisfies Object</tt></td><td align="center"><tt class="literal">V given V satisfies Object</tt></td><td align="center"><tt class="literal">Entry&lt;U,V&gt;</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="conditionals"></a>6.8.9.&nbsp;Conditional operators</h3></div></div><div></div></div><p>Two special operators allow emulation of the famous ternary
        operator of C-like languages.</p><div class="table"><a name="d0e14453"></a><p class="title"><b>Table&nbsp;6.8.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Conditionals</em></span></td></tr><tr><td align="center"><tt class="literal">lhs then rhs</tt></td><td align="center">then</td><td align="center"><tt class="literal">if (lhs) then rhs else null</tt></td><td align="center"><tt class="literal">Boolean</tt></td><td align="center"><tt class="literal">T given T satisfies Object</tt></td><td align="center"><tt class="literal">T?</tt></td></tr><tr><td align="center"><tt class="literal">lhs else rhs</tt></td><td align="center">else</td><td align="center"><tt class="literal">if (exists lhs) then lhs else rhs</tt></td><td align="center"><tt class="literal">U</tt> such that <tt class="literal">null is U</tt></td><td align="center"><tt class="literal">V</tt></td><td align="center"><tt class="literal">U&amp;Object|V</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="arithmetic"></a>6.8.10.&nbsp;Arithmetic operators</h3></div></div><div></div></div><p>These are the usual mathematical operations for all kinds of
        numeric values.</p><div class="table"><a name="d0e14524"></a><p class="title"><b>Table&nbsp;6.9.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Increment, decrement</em></span></td></tr><tr><td align="center"><tt class="literal">++rhs</tt></td><td align="center">successor</td><td align="center"><tt class="literal">rhs=rhs.successor</tt></td><td align="center">&nbsp;</td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">--rhs</tt></td><td align="center">predecessor</td><td align="center"><tt class="literal">rhs=rhs.predecessor</tt></td><td align="center">&nbsp;</td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">lhs++</tt></td><td align="center">increment</td><td align="center"><tt class="literal">(++lhs).predecessor</tt></td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">T</tt></td></tr><tr><td align="center"><tt class="literal">lhs--</tt></td><td align="center">decrement</td><td align="center"><tt class="literal">(--lhs).successor</tt></td><td align="center">variable of type <tt class="literal">Ordinal&lt;T&gt;</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">T</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Numeric operators</em></span></td></tr><tr><td align="center"><tt class="literal">+rhs</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">rhs.positiveValue</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Invertable &lt;I&gt;</tt></td><td align="center"><tt class="literal">I</tt></td></tr><tr><td align="center"><tt class="literal">-rhs</tt></td><td align="center">negation</td><td align="center"><tt class="literal">rhs.negativeValue</tt></td><td align="center">&nbsp;</td><td align="center"><tt class="literal">Invertable &lt;I&gt;</tt></td><td align="center"><tt class="literal">I</tt></td></tr><tr><td align="center"><tt class="literal">lhs + rhs</tt></td><td align="center">sum</td><td align="center"><tt class="literal">lhs.plus(rhs)</tt></td><td align="center"><tt class="literal">Summable&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs - rhs</tt></td><td align="center">difference</td><td align="center"><tt class="literal">lhs.minus(rhs)</tt></td><td align="center"><tt class="literal">Subtractable &lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs * rhs</tt></td><td align="center">product</td><td align="center"><tt class="literal">lhs.times(rhs)</tt></td><td align="center"><tt class="literal">Numeric&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs / rhs</tt></td><td align="center">quotient</td><td align="center"><tt class="literal">lhs.divided(rhs)</tt></td><td align="center"><tt class="literal">Numeric&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs % rhs</tt></td><td align="center">remainder</td><td align="center"><tt class="literal">lhs.remainder(rhs)</tt></td><td align="center"><tt class="literal">Integral&lt;X&gt;</tt></td><td align="center"><tt class="literal">X</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td align="center"><tt class="literal">lhs ^ rhs</tt></td><td align="center">power</td><td align="center"><tt class="literal">lhs.power(rhs)</tt></td><td align="center"><tt class="literal">Exponentiable &lt;X,Y&gt;</tt></td><td align="center"><tt class="literal">Y</tt></td><td align="center"><tt class="literal">X</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Numeric assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs += rhs</tt></td><td align="center">add</td><td align="center"><tt class="literal">lhs=lhs.plus(rhs)</tt></td><td align="center">variable of type <tt class="literal">Summable&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs -= rhs</tt></td><td align="center">subtract</td><td align="center"><tt class="literal">lhs=lhs.minus(rhs)</tt></td><td align="center">variable of type <tt class="literal">Subtractable &lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs *= rhs</tt></td><td align="center">multiply</td><td align="center"><tt class="literal">lhs=lhs.times(rhs)</tt></td><td align="center">variable of type <tt class="literal">Numeric&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs /= rhs</tt></td><td align="center">divide</td><td align="center"><tt class="literal">lhs=lhs.divided(rhs)</tt></td><td align="center">variable of type <tt class="literal">Numeric&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr><tr><td align="center"><tt class="literal">lhs %= rhs</tt></td><td align="center">remainder</td><td align="center"><tt class="literal">lhs=lhs.remainder(rhs)</tt></td><td align="center">variable of type <tt class="literal">Integral&lt;N&gt;</tt></td><td align="center"><tt class="literal">N</tt></td><td align="center"><tt class="literal">N</tt></td></tr></tbody></table></div><p>Arithmetic operators automatically widen from <tt class="literal">Integer</tt> 
        to <tt class="literal">Float</tt> when necessary. If one operand expression is 
        of static type <tt class="literal">Integer</tt>, and the other is of type 
        <tt class="literal">Float</tt>, the operand of type <tt class="literal">Integer</tt> 
        is widened to a <tt class="literal">Float</tt> in order to make the operator 
        expression well-typed. Widening is performed by evaluating the attribute 
        <tt class="literal">float</tt> defined by <tt class="literal">Integer</tt>.</p><i><span class="comment"><p>Note: this is the only circumstance in the language where 
        implicit type conversion occurs. In fact, it is more correct to view this 
        behavior as an instance of operator overloading than as an implicit type 
        conversion. Implicit widening does not occur when an expression of type 
        <tt class="literal">Integer</tt> is merely assigned to the type 
        <tt class="literal">Float</tt>, since such behavior would result in ambiguities 
        when generics come into play.</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sets"></a>6.8.11.&nbsp;Set operators</h3></div></div><div></div></div><p>These operators provide traditional mathematical operations for sets.</p><div class="table"><a name="d0e14906"></a><p class="title"><b>Table&nbsp;6.10.&nbsp;</b></p><table border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Example</th><th align="center">Name</th><th align="center">Definition</th><th align="center">LHS type</th><th align="center">RHS type</th><th align="center">Return type</th></tr></thead><tbody><tr><td colspan="6" align="center"><span class="emphasis"><em>Set operators</em></span></td></tr><tr><td align="center"><tt class="literal">lhs | rhs</tt></td><td align="center">union</td><td align="center"><tt class="literal">lhs.union(rhs)</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Y&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X|Y&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp; rhs</tt></td><td align="center">intersection</td><td align="center"><tt class="literal">lhs.intersection(rhs)</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Y&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&amp;Y&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs ~ rhs</tt></td><td align="center">complement</td><td align="center"><tt class="literal">lhs.complement(rhs)</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Object&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr><tr><td colspan="6" align="center"><span class="emphasis"><em>Set assignment</em></span></td></tr><tr><td align="center"><tt class="literal">lhs |= rhs</tt></td><td align="center">union</td><td align="center"><tt class="literal">lhs=lhs|rhs</tt></td><td align="center">variable of type <tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs &amp;= rhs</tt></td><td align="center">intersection</td><td align="center"><tt class="literal">lhs=lhs&amp;rhs</tt></td><td align="center">variable of type <tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Object&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr><tr><td align="center"><tt class="literal">lhs ~= rhs</tt></td><td align="center">complement</td><td align="center"><tt class="literal">lhs=lhs~rhs</tt></td><td align="center">variable of type <tt class="literal">Set&lt;X&gt;</tt></td><td align="center"><tt class="literal">Set&lt;Object&gt;</tt></td><td align="center"><tt class="literal">Set&lt;X&gt;</tt></td></tr></tbody></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="operatorstyleexpressions"></a>6.9.&nbsp;Operator-style member and invocation expressions</h2></div></div><div></div></div><p>An member expression or a method invocation with a single positional 
        argument may be written using an <span class="emphasis"><em>operator-style</em></span> syntax.
        This syntax has an extremely low precedence, just above the precedence of 
        the assignment operator, is not associative, and does not form a legal 
        expression statement.</p><pre class="brush: ceylon">0..max by step</pre><p>In an <span class="emphasis"><em>operator-style invocation expression</em></span>, the 
        invoked method name and optional type arguments occur in an infix location 
        between two expressions. The first expression is interpreted as the receiver 
        expression, and the second expression is interpreted as a positional argument 
        to the first parameter of the method.</p><pre class="synopsis">OperatorInvocation: ValueExpression MemberName TypeArguments? Expression</pre><p>The semantics of this syntax are identical to ordinary invocation 
        expressions, as defined in <a href="expressions.html#invocationexpressions" title="6.6.&nbsp;Invocation expressions">&sect;6.6 Invocation expressions</a>.</p><p>In an <span class="emphasis"><em>operator-style member expression</em></span>, the 
        member name and optional type arguments occur in a postfix location after
        an expression. The expression is interpreted as the receiver expression.</p><pre class="synopsis">OperatorMemberExpression: ValueExpression MemberName TypeArguments?</pre><p>The semantics of this syntax are identical to ordinary member expression,
        as defined in <a href="expressions.html#memberexpressions" title="6.5.2.&nbsp;Member expressions">&sect;6.5.2 Member expressions</a>.</p><i><span class="comment"><p>TODO: Should we rather use this syntax as a sugar for invocation
        of a toplevel function?</p></span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metamodelexpressions"></a>6.10.&nbsp;Metamodel expressions</h2></div></div><div></div></div><p>A <span class="emphasis"><em>metamodel expression</em></span> is a reference to
        a type, a class, a function, or a value. It evaluates to a metamodel 
        object whose static type captures the type itself, the callable type 
        of the class, the callable type of the function, or the type of the 
        value, respectively.</p><pre class="synopsis">Meta: TypeMeta | BaseMeta | MemberMeta</pre><p>A <span class="emphasis"><em>type metamodel expression</em></span> is a type, as
        defined by <a href="typesystem.html#type" title="3.2.&nbsp;Types">&sect;3.2 Types</a>, surrounded by backticks.</p><pre class="synopsis">TypeMeta: "`" Type "`"</pre><p>The type may or may not be a reference to a class or interface.</p><pre class="brush: ceylon">Class&lt;Person,[Name]&gt; personClass = `Person`;</pre><pre class="brush: ceylon">Interface&lt;List&lt;String&gt;&gt; stringListInterface = `List&lt;String&gt;`;</pre><pre class="brush: ceylon">UnionType&lt;Integer|Float&gt; numberType = `Number`;</pre><pre class="brush: ceylon">Type&lt;Element&gt; elementType = `Element`;</pre><p>A <span class="emphasis"><em>base metamodel expression</em></span> is a member name, 
        with an optional list of type arguments, surrounded by backticks.</p><pre class="synopsis">BaseMeta: "`" MemberName TypeArguments? "`"</pre><p>A base metamodel expression is a reference to a value or function. 
        The referenced declaration is determined according to
        <a href="statementblocks.html#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a>.</p><p>A <span class="emphasis"><em>member metamodel expression</em></span> is a type, as
        defined by <a href="typesystem.html#type" title="3.2.&nbsp;Types">&sect;3.2 Types</a>, followed by a member name, with an 
        optional list of type arguments, surrounded by backticks.</p><pre class="synopsis">MemberMeta: "`" (QualifiedType|GroupedType) "." MemberName TypeArguments? "`"</pre><p>A member metamodel expression is a reference to an attribute or 
        method of the type. The member is resolved as a member of the type 
        according to <a href="statementblocks.html#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>.</p><pre class="brush: ceylon">Function&lt;Float,[{Float+}]&gt; sumFunction = `sum&lt;Float&gt;`;</pre><pre class="brush: ceylon">Attribute&lt;Person,String&gt; personNameAttribute = `Person.name`;</pre><pre class="brush: ceylon">Method&lt;Person,Anything,[String]&gt; personSayMethod = `Person.say`;</pre><p>Type argument inference is impossible in a metamodel expression,
        so type arguments must be explicitly provided for every generic 
        declaration.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeofametamodelexpression"></a>6.10.1.&nbsp;Type of a metamodel expression</h3></div></div><div></div></div><p>The type of a metamodel expression depends upon the kind of 
            declaration referenced:</p><div class="itemizedlist"><ul type="disc"><li><p>for a toplevel value of type <tt class="literal">R</tt>, 
                    the type is <tt class="literal">Value&lt;R&gt;</tt>,</p></li><li><p>for a toplevel function of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Function&lt;R,P&gt;</tt>,</p></li><li><p>for a toplevel class of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Class&lt;R,P&gt;</tt>,</p></li><li><p>for a class nested in a block of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Class&lt;R,Nothing&gt;</tt>, and</p></li><li><p>for a toplevel interface or interface nested 
                    in a block of type <tt class="literal">R</tt>, the type is 
                    <tt class="literal">Interface&lt;R&gt;</tt>.</p></li></ul></div><p>Furthermore, given a member of a type <tt class="literal">T</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>for an attribute of type <tt class="literal">R</tt>, the 
                    type is <tt class="literal">Attribute&lt;T,R&gt;</tt>,</p></li><li><p>for a method of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">Method&lt;T,R,P&gt;</tt>,</p></li><li><p>for a member class of callable type 
                    <tt class="literal">Callable&lt;R,P&gt;</tt>, the type is 
                    <tt class="literal">MemberClass&lt;T,R,P&gt;</tt>, and</p></li><li><p>for a nested interface of type 
                    <tt class="literal">R</tt>, the type is 
                    <tt class="literal">MemberInterface&lt;T,R&gt;</tt>.</p></li></ul></div><p>Finally:</p><div class="itemizedlist"><ul type="disc"><li><p>for a union type <tt class="literal">T</tt>, the type is
                    <tt class="literal">UnionType&lt;T&gt;</tt>,</p></li><li><p>for an intersection type <tt class="literal">T</tt>, the 
                    type is <tt class="literal">IntersectionType&lt;T&gt;</tt>,</p></li><li><p>for the type <tt class="literal">Nothing</tt>, the type is 
                    <tt class="literal">Type&lt;Nothing&gt;</tt>, and</p></li><li><p>for a type parameter <tt class="literal">T</tt>, the type is
                    <tt class="literal">Type&lt;T&gt;</tt>.</p></li></ul></div><p>If a type alias occurs inside a typed metamodel expression, it 
            is replaced by its definition, after substituting type arguments, 
            before determining the type of the metamodel expression.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="referenceexpressions"></a>6.11.&nbsp;Reference expressions</h2></div></div><div></div></div><p>A <span class="emphasis"><em>reference expression</em></span> is a reference to
        a program element and evaluates to a detyped metamodel of the program 
        element. Reference expressions are used primarily in annotations, 
        especially the documentation annotations listed in 
        <a href="annotations.html#documentation" title="7.4.2.&nbsp;Documentation">&sect;7.4.2 Documentation</a>. A reference expression may refer to:</p><div class="itemizedlist"><ul type="disc"><li><p>a class, interface, type alias, or type parameter,</p></li><li><p>a function or value, or</p></li><li><p>a package or module.</p></li></ul></div><pre class="synopsis">Dec: TypeDec | MemberDec | PackageDec | ModuleDec</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="declarationreferences"></a>6.11.1.&nbsp;Declaration references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>class reference expression</em></span>, 
            <span class="emphasis"><em>interface reference expression</em></span>,
            <span class="emphasis"><em>alias reference expression</em></span>, or
            <span class="emphasis"><em>type parameter reference expression</em></span> is a
            series of initial uppercase identifiers, with the keyword 
            <tt class="literal">class</tt>, <tt class="literal">interface</tt>, 
            <tt class="literal">alias</tt>, or <tt class="literal">given</tt>, respectively, 
            surrounded by backticks.</p><pre class="synopsis">TypeDec: "`" ("class" | "interface" | "alias" | "given") (TypeName ".")* TypeName "`"</pre><p>A <span class="emphasis"><em>value reference expression</em></span> or
            <span class="emphasis"><em>function reference expression</em></span> is an initial
            lowercase identifier, qualified by a list of initial uppercase 
            identifiers, with the keyword <tt class="literal">value</tt> or
            <tt class="literal">function</tt>, surrounded by backticks.</p><pre class="synopsis">MemberDec: "`" ("value" | "function") (TypeName ".")* MemberName "`"</pre><p>A reference expression is a reference to a declaration. 
            The referenced declaration is determined according to
            <a href="statementblocks.html#unqualifiedreferenceresolution" title="5.1.7.&nbsp;Unqualified reference resolution">&sect;5.1.7 Unqualified reference resolution</a> and
            <a href="statementblocks.html#qualifiedreferenceresolution" title="5.1.8.&nbsp;Qualified reference resolution">&sect;5.1.8 Qualified reference resolution</a>. The kind of the
            referenced declaration must match the kind of reference indicated
            by the keyword.</p><pre class="brush: ceylon">ClassDeclaration personClass = `class Person`;</pre><pre class="brush: ceylon">InterfaceDeclaration stringListInterface = `interface List`;</pre><pre class="brush: ceylon">AliasDeclaration numberAlias = `alias Number`;</pre><pre class="brush: ceylon">TypeParameter elementTypeParameter = `given Element`;</pre><pre class="brush: ceylon">ValueDeclaration personNameAttribute = `value Person.name`;</pre><pre class="brush: ceylon">FunctionDeclaration personSayMethod = `function Person.say`;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="packageandmodulereferences"></a>6.11.2.&nbsp;Package and module references</h3></div></div><div></div></div><p>A <span class="emphasis"><em>package reference expression</em></span> is a package
            name, as defined by <a href="declarations.html#packages" title="4.1.2.&nbsp;Packages">&sect;4.1.2 Packages</a>, with the keyword
            <tt class="literal">package</tt>, surrounded by backticks.</p><pre class="synopsis">PackageDec: "`" "package" FullPackageName "`"</pre><p>The package name must refer to a package from which an 
            <tt class="literal">import</tt> statement in the same compilation unit may 
            import declarations, as defined by <a href="declarations.html#imports" title="4.2.&nbsp;Imports">&sect;4.2 Imports</a>.</p><pre class="brush: ceylon">Package modelPackage = `package ceylon.language.meta.model`;</pre><p>A <span class="emphasis"><em>module reference expression</em></span> is a module
            name, as defined by <a href="modulesystem.html#modulenamesandversionidentifiers" title="9.3.1.&nbsp;Module names and version identifiers">&sect;9.3.1 Module names and version identifiers</a>, 
            with the keyword <tt class="literal">module</tt>, surrounded by backticks.</p><pre class="synopsis">ModuleDec: "`" "module" FullPackageName "`"</pre><p>The module name must refer to the module to which the 
            compilation unit belongs, as specified by <a href="modulesystem.html#sourcelayout" title="9.2.&nbsp;Source layout">&sect;9.2 Source layout</a>, 
            or to a module imported by the module to which the compilation unit 
            belongs, as defined by <a href="modulesystem.html#moduledescriptors" title="9.3.12.&nbsp;Module descriptors">&sect;9.3.12 Module descriptors</a>.</p><pre class="brush: ceylon">Module languageModule = `module ceylon.language`;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typeofareferenceexpression"></a>6.11.3.&nbsp;Type of a reference expression</h3></div></div><div></div></div><p>The type of a reference expression depends upon the kind of 
            program element referenced:</p><div class="itemizedlist"><ul type="disc"><li><p>for a module, the type is 
                    <tt class="literal">Module</tt>,</p></li><li><p>for a package, the type is 
                    <tt class="literal">Package</tt>,</p></li><li><p>for a value, the type is 
                    <tt class="literal">ValueDeclaration</tt>,</p></li><li><p>for a function, the type is 
                    <tt class="literal">FunctionDeclaration</tt>,</p></li><li><p>for a type parameter, the type is 
                    <tt class="literal">TypeParameter</tt>,</p></li><li><p>for a type alias declared using the keyword
                    <tt class="literal">alias</tt>, the type is 
                    <tt class="literal">AliasDeclaration</tt>,</p></li><li><p>for a class or class alias, the type is 
                    <tt class="literal">ClassDeclaration</tt>, and</p></li><li><p>for an interface or interface alias, the type 
                    is <tt class="literal">InterfaceDeclaration</tt>.</p></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="statementblocks.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="annotations.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;5.&nbsp;Statements, blocks, and control structures&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;7.&nbsp;Annotations</td></tr></table></div></body></html>