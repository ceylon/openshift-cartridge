<!DOCTYPE html><html xmlns='http://www.w3.org/1999/xhtml'><head><meta charset='UTF-8'/>
<title>Span.ceylon</title><link href='.resources/favicon.ico' rel='shortcut icon'/>
<link href='.resources/ceylon.css' rel='stylesheet' type='text/css'/>
<link href='.resources/ceylondoc.css' rel='stylesheet' type='text/css'/>
<link href='//fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'/>
<script type='text/javascript'>var resourceBaseUrl = '.resources/'</script><script src='.resources/jquery-1.8.2.min.js' type='text/javascript'></script><script src='.resources/rainbow.min.js' type='text/javascript'></script><script src='.resources/rainbow.linenumbers.js' type='text/javascript'></script><script src='.resources/ceylon.js' type='text/javascript'></script><script src='.resources/ceylondoc.js' type='text/javascript'></script></head><body><pre data-language='ceylon' style='font-family: Inconsolata, Monaco, Courier, monospace'>&quot;A [[Range]] of adjacent [[Enumerable]] values generated by 
 two endpoints: [[first]] and [[last]]. The range includes 
 both endpoints, and all values falling _between_ the 
 endpoints.&quot;
by (&quot;Gavin&quot;)
see (`class Measure`,
    `interface Enumerable`)
final serializable
class Span&lt;Element&gt;(first, last)
        extends Range&lt;Element&gt;()
        given Element satisfies Enumerable&lt;Element&gt; {
    
    &quot;The start of the range.&quot;
    shared actual Element first;
    
    &quot;The end of the range.&quot;
    shared actual Element last;
    
    string =&gt; first.string + &quot;..&quot; + last.string;
    
    increasing = last.offsetSign(first) &gt;= 0;
    
    decreasing =&gt; !increasing;
    
    &quot;Determines if the range is of recursive values, that 
     is, if successors wrap back on themselves. All 
     recursive ranges are [[increasing]].&quot;
    Boolean recursive
            = first.offsetSign(first.successor) &gt; 0 &amp;&amp;
              last.predecessor.offsetSign(last) &gt; 0;
    
    Element next(Element x)
            =&gt; increasing 
            then x.successor
            else x.predecessor;
    
    Element nextStep(Element x, Integer step)
            =&gt; increasing 
            then x.neighbour(step)
            else x.neighbour(-step);
    
    Element fromFirst(Integer offset)
            =&gt; increasing 
            then first.neighbour(offset)
            else first.neighbour(-offset);
    
    Boolean afterLast(Element x)
            =&gt; increasing 
            then x.offsetSign(last) &gt; 0
            else x.offsetSign(last) &lt; 0;
    
    Boolean beforeLast(Element x)
            =&gt; increasing 
            then x.offsetSign(last) &lt; 0
            else x.offsetSign(last) &gt; 0;
    
    Boolean beforeFirst(Element x)
            =&gt; increasing 
            then x.offsetSign(first) &lt; 0
            else x.offsetSign(first) &gt; 0;
    
    Boolean afterFirst(Element x)
            =&gt; increasing 
            then x.offsetSign(first) &gt; 0
            else x.offsetSign(first) &lt; 0;
    
    shared actual Integer size {
        value lastIndex = last.offset(first).magnitude;
        if (lastIndex&lt;runtime.maxIntegerValue) {
            return lastIndex + 1;
        }
        else {
            throw OverflowException(&quot;size of range&quot;);
        }
    }
    
    longerThan(Integer length) 
            =&gt; if (length &lt; 1) then true
            else if (recursive) then size &gt; length
            else beforeLast(fromFirst(length - 1));
    
    shorterThan(Integer length)
            =&gt; if (length &lt; 1) then true
            else if (recursive) then size &lt; length
            else afterLast(fromFirst(length - 1));
    
    lastIndex =&gt; size - 1;
    
    rest =&gt; first == last then [] else next(first)..last;
    
    &quot;This range in reverse, with [[first]] and [[last]]
     interchanged.
     
     For any two range endpoints, `x` and `y`: 
     
         `(x..y).reversed == y..x`
     
     except for [[recursive]] ranges, where the elements are
     evaluated and collected into a new sequence.&quot;
    //TODO: we should have a way to produce a decreasing
    //      recursive range
    shared actual 
    [Element+] reversed
            =&gt; recursive 
            then super.reversed
            else last..first;
    
    &quot;The element of the range that occurs [[index]] values 
     after the start of the range.&quot;
    shared actual 
    Element? getFromFirst(Integer index) {
        if (index &lt; 0) {
            return null;
        } else if (recursive) {
            return index &lt; size then fromFirst(index);
        } else {
            value result = fromFirst(index);
            return !afterLast(result) then result;
        }
    }
    
    &quot;An iterator for the elements of the range. The returned 
     iterator produces elements from [[first]] and continues 
     producing elements until it reaches an element whose 
     `offset` from [[last] is zero.&quot;
    shared actual 
    Iterator&lt;Element&gt; iterator() 
            =&gt; object
            satisfies Iterator&lt;Element&gt; {
        variable Boolean firstTime = true;
        variable Element|Finished element = first;
        shared actual Element|Finished next() {
            if (!is Finished c = element) {
                Element result;
                if (firstTime) {
                    firstTime = false;
                    result = c;
                } else {
                    result = outer.next(c);
                }
                if (result.offset(last) == 0) {
                    this.element = finished;
                } else {
                    this.element  = result;
                }
                return result;
            } else {
                return element ;
            }
        }
        string =&gt; &quot;(``outer``).iterator()&quot;;
    };
    
    shared actual 
    {Element+} by(Integer step) {
        &quot;step size must be greater than zero&quot;
        assert (step &gt; 0);
        return step == 1 then this else By(step);
    }
    
    shifted(Integer shift)
            =&gt; shift == 0
            then this
            else Span(first.neighbour(shift), 
                      last.neighbour(shift));
    
    containsElement(Element x)
            =&gt; recursive 
            then x.offset(first) &lt;= last.offset(first)
            else !afterLast(x) &amp;&amp; !beforeFirst(x);
    
    shared actual 
    Integer count(Boolean selecting(Element element)) {
        variable value element = first;
        variable value count = 0;
        while (containsElement(element)) {
            if (selecting(element)) {
                count++;
            }
            element = next(element);
        }
        return count;
    }
    
    shared actual 
    Boolean includesRange(Range&lt;Element&gt; range) {
        switch (range)
        case (is Span&lt;Element&gt;) {
            if (recursive) {
                return range.first.offset(first) &lt; size &amp;&amp;
                        range.last.offset(first) &lt; size;
            } else {
                return increasing == range.increasing &amp;&amp;
                        !range.afterFirst(first) &amp;&amp;
                        !range.beforeLast(last);
            }
        }
        case (is Measure&lt;Element&gt;) {
            if (decreasing) {
                return false;
            } else {
                value offset = range.first.offset(first);
                return 0 &lt;= offset &lt;= size - range.size;
            }
        }
    }
    
    shared actual 
    Boolean equals(Object that) {
        if (is Span&lt;out Object&gt; that) {
            //optimize for another Span
            return that.first == first &amp;&amp; that.last == last;
        } else if (is Measure&lt;out Object&gt; that) {
            return increasing &amp;&amp;
                    that.first == first &amp;&amp; that.size == size;
        } else {
            //it might be another sort of List
            return super.equals(that);
        }
    }
    
    class By(Integer step)
            satisfies {Element+} {
        
        size =&gt; 1 + (outer.size - 1) / step;
        
        first =&gt; outer.first;
        
        string =&gt; &quot;(``outer``).by(``step``)&quot;;
        
        shared actual 
        Iterator&lt;Element&gt; iterator() {
            if (recursive) {
                return object
                        satisfies Iterator&lt;Element&gt; {
                    variable value count = 0;
                    variable value current = first;
                    shared actual Element|Finished next() {
                        if (++count &gt; size) {
                            return finished;
                        } else {
                            value result = current;
                            current = current.neighbour(step);
                            return result;
                        }
                    }
                    string =&gt; &quot;``outer``.iterator()&quot;;
                };
            } else {
                return object
                        satisfies Iterator&lt;Element&gt; {
                    variable Element|Finished current = first;
                    variable value firstTime = true;
                    shared actual Element|Finished next() {
                        if (firstTime) {
                            firstTime = false;
                            return current;
                        } else {
                            if (is Element c=current) {
                                value r = nextStep(c, step);
                                if (!containsElement(r)) {
                                    current = finished;
                                } else {
                                    current = r;
                                }
                            }
                            return current;
                        }
                    }
                    string =&gt; &quot;``outer``.iterator()&quot;;
                };
            }
        }
    }
    
    shared actual 
    [Element*] measure(Integer from, Integer length)
            =&gt; length &lt;= 0 
            then [] 
            else span(from, from + length - 1);
    
    shared actual 
    [Element*] span(Integer from, Integer to) {
        if (from &lt;= to) {
            if (to &lt; 0 || !longerThan(from)) {
                return [];
            } else {
                return (this[from] else first)..(this[to] else last);
            }
        } else {
            if (from &lt; 0 || !longerThan(to)) {
                return [];
            } else {
                value range = (this[to] else first)..(this[from] else last);
                return range.reversed;
            }
        }
    }
    
    shared actual 
    [Element*] spanFrom(Integer from) {
        if (from &lt;= 0) {
            return this;
        } else if (longerThan(from)) {
            assert (exists first = this[from]);
            return first..last;
        } else {
            return [];
        }
    }
    
    shared actual 
    [Element*] spanTo(Integer to) {
        if (to &lt; 0) {
            return [];
        } else if (longerThan(to + 1)) {
            assert (exists last = this[to]);
            return first..last;
        } else {
            return this;
        }
    }
    
    shared actual void each(void step(Element element)) {
        variable value current = first;
        while (true) {
            step(current);
            if (current.offset(last)==0) {
                break;
            }
            else {
                current = next(current);
            }
        }
    }
}

&quot;Produces a [[Range]] of adjacent [[Enumerable]] values 
 generated by two endpoints: [[first]] and [[last]]. The 
 range includes both endpoints, and all values falling 
 _between_ the endpoints.
 
 - For a recursive enumerable type, a value falls between 
   the endpoints if its [[offset|Enumerable.offset]] from 
   `first` is less than the offset of `last` from `first`.
 - For a linear enumerable type, a value falls between the
   endpoints if the 
   [[sign of its offset|Enumerable.offsetSign]] from `first` 
   is the same as the sign of the offset of `last` from 
   `first` and the sign of its offset from `last` is the 
   opposite of the sign of the offset of `last` from `first`.
 
 More precisely, if `x`, `first`, and `last` are of 
 `Enumerable` type `X`, then `x in first..last` if and 
 only if:
 
 - `X` is recursive and `x.offset(first)&lt;last.offset(first)`,
  or
 - `X` is linear and 
  `x.offsetSign(first)==last.offsetSign(first)` and
  `x.offsetSign(last)==-last.offsetSign(first)`.
 
 For a linear enumerable type, a range is either 
 [[increasing|Range.increasing]] or 
 [[decreasing|Range.decreasing]]:
 
 - in an increasing range, a value occurs before its 
  [[successor|Ordinal.successor]] and after its 
  [[predecessor|Ordinal.predecessor]], but
 - in a decreasing range, a value occurs after its 
  `successor` and before its `predecessor`.
 
 The direction of the range depends upon the sign of the
 offset of `last` from `first`: 
 
 - if `last.offsetSign(first)&gt;=0` the range is increasing,
   but
 - if `last.offsetSign(first)&lt;0`, the range is decreasing.
 
 A range for a recursive enumerable type is always 
 increasing.
 
 The _span operator_ `..` is an abbreviation for `span()`:
 
     for (i in min..max) { ... }
     if (char in &apos;A&apos;..&apos;Z&apos;) { ... }
 
 The span operator accepts the first and last values of 
 the range. It may produce an increasing range:
 
     0..5    // [0, 1, 2, 3, 4, 5]
     0..0    // [0]
 
 Or it may produce a decreasing range:
 
     5..0    // [5, 4, 3, 2, 1, 0]
     0..-5   // [0, -1, -2, -3, -4, -5]&quot;
shared Range&lt;Element&gt; span&lt;Element&gt;
        (Element first, Element last)
        given Element satisfies Enumerable&lt;Element&gt;
        =&gt; Span(first, last);
</pre></body></html>