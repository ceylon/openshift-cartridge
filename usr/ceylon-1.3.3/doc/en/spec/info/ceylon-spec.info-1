This is ceylon-spec.info, produced by makeinfo version 5.2 from
ceylon-spec.texi.

This is the Ceylon Language Specification, version 1.3.

   Copyright (C) 2008-2015 Gavin King and contributors

     Licensed under the Apache License, Version 2.0 (the "License"); you
     may not use this file except in compliance with the License.  You
     may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
     implied.  See the License for the specific language governing
     permissions and limitations under the License.
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Ceylon: (ceylon-spec).       The Ceylon Language Specification.
END-INFO-DIR-ENTRY


File: ceylon-spec.info,  Node: Top,  Next: preface,  Up: (dir)

The Ceylon Language
*******************

This is the Ceylon Language Specification, version 1.3.

* Menu:

* preface:: Welcome to Ceylon.
* introduction:: Introduction
* lexical:: Lexical structure
* typesystem:: Type system
* declarations:: Declarations
* statementblocks:: Statements, blocks, and control structures
* expressions:: Expressions
* annotations:: Annotations
* execution:: Execution
* modulesystem:: Module system
* index:: Complete index.


File: ceylon-spec.info,  Node: preface,  Next: introduction,  Prev: Top,  Up: Top

Preface
*******

This project is the work of a team of people who are fans of Java and of
the Java ecosystem, of its practical orientation, of its culture of
openness, of its developer community, of its roots in the world of
business computing, and of its ongoing commitment to portability.
However, we recognize that the language and class libraries, designed
more than 15 years ago, are no longer the best foundation for a range of
today's business computing problems.  We further recognize that Java
failed in one environment it was originally promoted for: the web
browser.

   The goal of this project is to make a clean break with the legacy
Java SE platform, by improving upon the Java language and class
libraries, and by providing a modular architecture for a new platform
based upon the Java Virtual Machine.  A further goal is to bridge the
gap between the web client and server by supporting execution on
JavaScript virtual machines.

   Of course, we recognize that the ability to interoperate with
existing Java code, thereby leveraging existing investment in the Java
ecosystem, is a critical requirement of any successor to the Java
platform.

   Java is a simple language to learn and Java code is easy to read and
understand.  Java provides a level of typesafety that is appropriate for
business computing and enables sophisticated tooling with features like
refactoring support, code completion, and code navigation.  Ceylon aims
to retain the overall model of Java, while getting rid of some of Java's
warts, and improving upon Java's facilities for creating abstractions
and writing generic libraries and frameworks.

   Ceylon has the following goals:

   * to be appropriate for large scale development, but to also be
     _fun_,

   * to execute on the JVM, and on JavaScript virtual machines, and to
     interoperate with native Java and JavaScript code,

   * to provide language-level modularity,

   * to be easy to learn for Java and C# developers,

   * to eliminate some of Java's verbosity, while retaining its
     readability--Ceylon does _not_ aim to be the most concise/cryptic
     language around,

   * to provide an elegant and more flexible syntax to support
     frameworks, declarative programming, and meta-programming, and, in
     particular

   * to provide a declarative syntax for expressing hierarchical
     information like user interface definition, externalized data, and
     system configuration, thereby eliminating Java's dependence upon
     XML,

   * to support and encourage a more functional style of programming
     with immutable objects and first class functions, alongside the
     familiar imperative mode,

   * to expand compile-time typesafety with compile-time safe handling
     of null values, compile-time safe typecasts, and a more typesafe
     approach to reflection, and

   * to make it easy to _get things done_.

   Unlike other alternative JVM languages, Ceylon aims to completely
replace the legacy Java SE class libraries.

   Therefore, the Ceylon SDK provides:

   * a compiler that compiles Ceylon and Java source to Java bytecode,
     and cross-compiles Ceylon to JavaScript,

   * command-line tooling for compiling modules and documentation, and
     managing modules in module repositories,

   * Eclipse-based tooling for developing, compiling, testing, and
     debugging programs written in Ceylon,

   * a module runtime for modular programs that execute on the Java
     Virtual Machine, and

   * a set of class libraries that provides much of the functionality of
     the Java SE platform, together with the core functionality of the
     Java EE platform.


File: ceylon-spec.info,  Node: introduction,  Next: lexical,  Prev: preface,  Up: Top

1 Introduction
**************

* Menu:


* languageoverview:: Language overview
* thetypesystem:: Type system
* objectorientedprogramming:: Object-oriented programming
* thelanguagemodule:: Language module

This document defines the syntax and semantics of the Ceylon language.
The intended audience includes compiler implementors, interested parties
who wish to contribute to the evolution of the language, and experienced
developers seeking a precise definition of language constructs.
However, in light of the newness of the language, we will begin with an
overview of the main features of the language and SDK. A brief
introduction to programming in the language may be found at the
following address:

     http://ceylon-lang.org/documentation/tour/


File: ceylon-spec.info,  Node: languageoverview,  Next: thetypesystem,  Up: introduction

1.1 Language overview
=====================

* Menu:


* runtimeandplatform:: Runtime and platform

Ceylon is a general-purpose programming language featuring a syntax
similar to Java and C#.  It is imperative, statically-typed,
block-structured, object-oriented, and higher-order.  By
_statically-typed_, we mean that the compiler performs extensive type
checking, with the help of type annotations that appear in the code.  By
_object-oriented_, we mean that the language supports user-defined types
and features a nominative type system where a type is a set of named
attributes and operations, and that it supports inheritance and subtype
polymorphism.  By _higher-order_, we mean that every referenceable
program element (every attribute, every operation, and every type) is
also a value.  By _block-structured_, we mean to say that the language
features lexical scoping and an extremely regular recursive syntax for
declarations and statements.

   Ceylon improves upon the Java language and type system to reduce
verbosity and increase typesafety compared to Java and C#.  Ceylon
encourages a more functional, somewhat less imperative style of
programming, resulting in code which is easier to reason about, and
easier to refactor.


File: ceylon-spec.info,  Node: runtimeandplatform,  Up: languageoverview

1.1.1 Runtime and platform
--------------------------

Ceylon programs execute in any standard Java Virtual Machine or on any
JavaScript virtual machine, and take advantage of the memory management
and concurrency features of the virtual machine in which they execute.
Ceylon programs are packaged into _modules_ with well-defined
inter-module dependencies, and always execute inside a runtime
environment with module isolation.

   The Ceylon compiler is able to compile Ceylon code that calls Java
classes or interfaces, and Java code that calls Ceylon classes or
interfaces.  JavaScript code is able to interact with Ceylon classes and
functions compiled to JavaScript. Via a special _dynamic_ mode, code
written in Ceylon may call functions defined natively in JavaScript.

   Moreover, Ceylon provides its own native SDK as a replacement for the
Java platform class libraries.  Certain SDK modules depend upon services
available only on the Java platform.  Other SDK modules, including the
core _language module_, are cross-platform and may also be used in a
JavaScript virtual machine.

   Finally, the language supports the development of cross-platform
modules that contain platform-specific implementation code, via the
'native' annotation.

     import java.lang { System }

     shared native void hello();

     shared native("jvm") void hello() {
         System.console()?.printf("Hello, world!");
     }

     shared native("js") void hello() {
         dynamic {
             alert("Hello, world!");
         }
     }


File: ceylon-spec.info,  Node: thetypesystem,  Next: objectorientedprogramming,  Prev: languageoverview,  Up: introduction

1.2 Type system
===============

* Menu:


* mixininheritance:: Mixin inheritance
* algrebraictypesselftypes:: Sum types, self types, and type families
* simplifiedgenerics:: Simplified generics
* unionandintersectiontypes:: Union and intersection types
* typealiasesandtypeinference:: Type aliases and type inference
* metaprogramming:: Metaprogramming

Ceylon, like Java and C#, features a hybrid type system with both
subtype polymorphism and parameteric polymorphism.  A type is either a
stateless _interface_, a stateful _class_, a _type parameter_, or a
_union_ or _intersection_ of other types.  A class, interface, or type
parameter may be defined as a subtype of another type.  A class or
interface may declare type parameters, which abstract the definition of
the class or interface over all types which may be substituted for the
type parameters.

   Like C#, and unlike Java, Ceylon's type system is fully reified.  In
particular, generic type arguments are reified, eliminating many
problems that result from type erasure in Java.

   There are no primitive types or arrays in Ceylon--every Ceylon type
can be represented within the language itself.  So all values are
instances of the type hierarchy root 'Anything', which is a class.
However, the Ceylon compiler is permitted to optimize certain code to
take advantage of the optimized performance of primitive types on the
Java or JavaScript VM.

   Furthermore, all types inferred or even computed internally by the
Ceylon compiler are expressible within the language itself.  Within the
type system, _non-denoteable_ types simply do not arise.  The type
system is based upon computation of _principal types_.  There is no
legal expression which does not have a unique principal type expressible
within the language.  The principal type of an expression is a subtype
of all other types to which the expression could be soundly assigned.


File: ceylon-spec.info,  Node: mixininheritance,  Next: algrebraictypesselftypes,  Up: thetypesystem

1.2.1 Mixin inheritance
-----------------------

Ceylon supports a restricted form of multiple inheritance, often called
_mixin inheritance_.  A class must extend exactly one other class.  But
a class or interface may satisfy (extend or implement) an arbitrary
number of interfaces.

   Classes hold state and define logic to initialize that state when the
class is instantiated.  A concrete class is a class that contains only
concrete member definitions.  Concrete classes may be directly
instantiated.  An abstract class may have _formal_ (unimplemented)
member declarations. Abstract classes may not be instantiated.

   Interfaces may define concrete and formal members, but may not hold
state (references to other objects) or initialization logic.  This
restriction helps eliminate the problems traditionally associated with
multiple inheritance. Ceylon never performs any kind of "linearization"
of the supertypes of a type. Interfaces may not be directly
instantiated.


File: ceylon-spec.info,  Node: algrebraictypesselftypes,  Next: simplifiedgenerics,  Prev: mixininheritance,  Up: thetypesystem

1.2.2 Sum types, self types, and type families
----------------------------------------------

Ceylon does not feature Java-style enumerated types as a first-class
construct. Instead, any abstract type may specify its _cases_--an
enumerated list of instances and/or subtypes.  This facility is used to
simulate both enumerated types and functional-style algebraic sum types.

     interface Identity of Person | Organization { ... }

     abstract class Variance() of covariant | contravariant | invariant { ... }

   A closely related feature is support for _self types_ and _type
families_.  A self type is a type parameter of an abstract type (like
'Comparable') which represents the type of a concrete instantiation
(like 'String') of the abstract type, within the definition of the
abstract type itself.

     interface Comparable<in Other> of Other
             given Other satisfies Comparable<Other> { ... }

   In a type family, the self type of a type is declared not by the type
itself, but by a containing type which groups together a set of related
types.


File: ceylon-spec.info,  Node: simplifiedgenerics,  Next: unionandintersectiontypes,  Prev: algrebraictypesselftypes,  Up: thetypesystem

1.2.3 Simplified generics
-------------------------

Ceylon doesn't have raw types, implicit bounds, or wildcard capture.
And the Ceylon compiler never even uses any kind of "non-denotable" type
to reason about the type system.  So generics-related error messages are
understandable to humans.

   Ceylon features _declaration-site variance_.  A type parameter may be
marked as covariant or contravariant by the class or interface that
declares the parameter.

     interface Source<out Item> { ... }
     interface Sink<in Item> { ... }

   In order to support interoperation with Java, Ceylon also features
Java-style _use-site variance_, with a much cleaner syntax than Java's.
A type argument may be marked as covariant or contravariant.

     List<out Element> javaArrayList = ArrayList<Element>();

   Ceylon has a somewhat more expressive system of generic type
constraints with a cleaner, more regular syntax.  The syntax for
declaring constraints on a type parameter looks very similar to a class
or interface declaration.  A type parameter may have upper bound type
constraints or even _enumerated bounds_.

     interface Producer<out Value, in Rate>
             given Value satisfies Object
             given Rate of Float | Decimal { ... }


File: ceylon-spec.info,  Node: unionandintersectiontypes,  Next: typealiasesandtypeinference,  Prev: simplifiedgenerics,  Up: thetypesystem

1.2.4 Union and intersection types
----------------------------------

A _union type_, for example 'String|Number', or _intersection type_, for
example 'Identifiable&List<String>', may be formed from two or more
types defined elsewhere.

   Union types make it possible to write code that operates
polymorphically over types defined in disparate branches of the type
hierarchy without the need for intermediate adaptor classes.

     Float distance(Point|Location x, Point|Location y) => ... ;
   Intersection types make it possible to operate polymorphically over
all subtypes of a list of types.

     void persistRemotely(Persistent&Serializable stuff) { ... }

   Union and intersection types provide some of the benefits of
structural ("duck") typing, within the confines of a nominative type
system, and therefore certain Ceylon idioms are reminiscent of code
written in dynamically-typed languages.

   Union and intersection types underly the whole system of principal
typing in Ceylon, forming the foundation for type inference and
flow-sensitive typing.  In particular, they play a central role in
generic type argument inference.  For example, the following expression
has type 'HashMap<String,Integer|Float>':

     HashMap { "float"->0.0, "integer"->0 }


File: ceylon-spec.info,  Node: typealiasesandtypeinference,  Next: metaprogramming,  Prev: unionandintersectiontypes,  Up: thetypesystem

1.2.5 Type aliases and type inference
-------------------------------------

Type aliases and type inference help reduce the verbosity of code which
uses generic types, eliminating the need to repeatedly specify generic
type arguments.

   A _type alias_ is similar to a C-style 'typedef'.

     interface Strings => Sequence<String>;

     alias Number => Integer|Float|Whole|Decimal;

   Local _type inference_ allows a type annotation to be eliminated
altogether.  The type of a block-local value or function is inferred
from its definition if the keyword 'value' or 'function' occurs in place
of the type declaration.

     value name = person.name;

     function sqrt(Float x) => x^0.5;

   The type of a control-structure variable also may be inferred.

     for (n in 0..max) { ... }

   Ceylon features an especially elegant approach to generic type
argument inference, making it possible to instantiate container types,
even inhomogeneous container types, without the need to explicitly
mention any types at all.

     value numbers = { -1, 0, -1, -1.0, 0.0, 1.0 };

   By limiting type inference to local declarations, Ceylon ensures that
all types may be inferred by the compiler in a single pass of the source
code. Type inference works in the "downward" and "outward" directions.
The compiler is able to determine the type of an expression without
considering the rest of the statement or declaration in which it
appears.


File: ceylon-spec.info,  Node: metaprogramming,  Prev: typealiasesandtypeinference,  Up: thetypesystem

1.2.6 Metaprogramming
---------------------

In other statically typed languages, runtime metaprogramming, or
_reflection_, is a messy business involving untypesafe strings and
typecasting.  Even worse, in Java, generic type arguments are erased at
runtime, and unavailable via reflection. Ceylon, uniquely, features a
_typesafe metamodel_ and typed _metamodel expressions_.  Since generic
type arguments are reified at runtime, the metamodel fully captures
generic types at both compile time and execution time.

     Attribute<String,Integer> stringSize = `String.size`;
   Ceylon's support for program element _annotations_ is based around
this metamodel.  Annotations are more flexible than in Java or C#, and
have a much cleaner syntax.


File: ceylon-spec.info,  Node: objectorientedprogramming,  Next: thelanguagemodule,  Prev: thetypesystem,  Up: introduction

1.3 Object-oriented programming
===============================

* Menu:


* initializationandinstantiation:: Class initialization and instantiation
* methodsandattributes:: Functions, methods, values, and attributes
* defaultparameters:: Defaulted parameters and variadic parameters
* firstclassfunctions:: First-class functions and higher-order programming
* namingconventionsandannotations:: Naming conventions, annotations, and inline documentation
* structureddata:: Named arguments and tree-like structures
* modularity:: Modularity

The primary unit of organization of an object-oriented program is the
class.  But Ceylon, unlike Java, doesn't require that _every_ function
or value belong to a class.  It's perfectly normal to program with a mix
of classes and toplevel functions.  Contrary to popular belief, this
does not make the program less object-oriented.  A function is, after
all, an object.


File: ceylon-spec.info,  Node: initializationandinstantiation,  Next: methodsandattributes,  Up: objectorientedprogramming

1.3.1 Class initialization and instantiation
--------------------------------------------

A Ceylon class may have one or more named constructors, declared using
the 'new' keyword.

     class Point {
         Float x;
         Float y;
         new create(Float x, Float y) {
             this.x = x;
             this.y = y;
         }
         ...
     }

   However, since constructors are often unnecessarily verbose, it is
more common to define a Ceylon class with a parameter list, and exactly
one _initializer_--the body of the class.

     class Point(Float x, Float y) { ... }

   The Ceylon compiler guarantees that the value of any attribute of a
class is initialized before it is used in an expression.

   A class may be a member of an outer class.  Such a member class may
be refined (overridden) by a subclass of the outer class.  Instantiation
is therefore a polymorphic operation in Ceylon, eliminating the need for
a factory method in some circumstances.

   Ceylon provides a streamlined syntax for defining _anonymous
classes_.  An anonymous class is a class which is instantiated only in
exactly the place it is defined.  Among other uses, the 'object'
declaration is useful for creating singleton objects or locally-scoped
interface implementations.

     object origin extends Point(0.0, 0.0) {}

   Strictly speaking, an 'object' declaration is just an abbreviated way
to write a class with a _value constructor_. A value constructor defines
a named instance of a class:

     class Point {
         Float x;
         Float y;
         new create(Float x, Float y) {
             this.x = x;
             this.y = y;
         }
         new origin {
             this.x = 0.0;
             this.y = 0.0;
         }
         ...
     }


File: ceylon-spec.info,  Node: methodsandattributes,  Next: defaultparameters,  Prev: initializationandinstantiation,  Up: objectorientedprogramming

1.3.2 Functions, methods, values, and attributes
------------------------------------------------

_Functions_ and _values_ are the bread and butter of programming.
Ceylon functions are similar to Java methods, except that they don't
need to belong to a class.  Ceylon values are polymorphic, and abstract
their internal representation, similar to C# properties.

     String name => firstName + " " + lastName;

   A function belonging to a type is called a _method_. A value
belonging to a type is called an _attribute_. A function or value may be
declared as a direct _toplevel_ member of a package, or as a member of a
singleton anonymous class.  This approach, along with certain other
features, gives the language a more regular block structure.

   The Ceylon compiler guarantees that any attribute or value is
initialized before it is used in an expression.  By default, an
attribute or value may not be reassigned a new value after its initial
value has been specified. Mutable attributes and variable values must be
explicitly declared using the 'variable' annotation.

     variable value count = 0;

   Ceylon does not support function overloading.  Each method of a type
has a distinct name.


File: ceylon-spec.info,  Node: defaultparameters,  Next: firstclassfunctions,  Prev: methodsandattributes,  Up: objectorientedprogramming

1.3.3 Defaulted parameters and variadic parameters
--------------------------------------------------

Instead of method and constructor overloading, Ceylon supports
parameters with default values and _variadic_ parameters.

     void addItem(Product product, Integer quantity=1) { ... }

     String join(String* strings) { ... }

   Union types also help alleviate the need for overloading.

     String format(String formatString, String|Float|Integer* values) => ... ;
   Therefore, a single method in Ceylon may emulate the signatures of
several overloaded methods in Java.


File: ceylon-spec.info,  Node: firstclassfunctions,  Next: namingconventionsandannotations,  Prev: defaultparameters,  Up: objectorientedprogramming

1.3.4 First-class functions and higher-order programming
--------------------------------------------------------

Ceylon supports first-class function types and higher-order functions.
A function declaration may specify a _callable parameter_ that accepts
references to other functions with a certain signature.

     String find(Boolean where(String string)) { ... }

   The argument of such a callable parameter may be either a reference
to a named function declared elsewhere, or a new function defined inline
as part of the method invocation.

     value result = { "C", "Java", "Ceylon" }.find((String s) => s.size>1);

   The type of a function is expressed within the type system as an
instantiation of the interface 'Callable'.  The parameter types are
expressed as a tuple type.  So the type of the function '(String s) =>
s.size>1' is 'Callable<Boolean,[String]>', which may be abbreviated to
'Boolean(String)'.

   Unlike many other languages with higher-order functions, Ceylon
supports abstraction over function and tuple types of arbitrary arity.

   References to methods and attributes may also be used as functions.

     value names = people.map(Person.name);

     value values = keys.map(keyedValues.get);


File: ceylon-spec.info,  Node: namingconventionsandannotations,  Next: structureddata,  Prev: firstclassfunctions,  Up: objectorientedprogramming

1.3.5 Naming conventions, annotations, and inline documentation
---------------------------------------------------------------

The Ceylon compiler enforces the traditional Smalltalk naming
convention: type names begin with an initial uppercase letter--for
example, 'Liberty' or 'RedWine'--member names and local names with an
initial lowercase letter or underscore--for example, 'blonde',
'immanentize()' or 'boldlyGo()'.

   These restrictions allow a much cleaner syntax for program element
annotations than the syntax found in either Java or C#.  Declaration
"modifiers" like 'shared', 'abstract', and 'variable' aren't keywords in
Ceylon, they're ordinary annotations.

     "Base type for higher-order abstract stuff."
     shared abstract class AbstractMetaThingy() { ... }

   The documentation compiler reads inline documentation specified using
the 'doc' annotation.


File: ceylon-spec.info,  Node: structureddata,  Next: modularity,  Prev: namingconventionsandannotations,  Up: objectorientedprogramming

1.3.6 Named arguments and tree-like structures
----------------------------------------------

Ceylon's named argument lists provide an elegant means of initializing
objects and collections.  The goal of this facility is to replace the
use of XML for expressing hierarchical structures such as documents,
user interfaces, configuration and serialized data.

     Html page = Html {
         doctype = html5;
         Head { title = "Ceylon: home page"; };
         Body {
             H2 ( "Welcome to Ceylon ``language.version``!" ),
             P ( "Now get your code on :)" )
         };
     }


   An especially important application of this facility is Ceylon's
built-in support for program element annotations.


File: ceylon-spec.info,  Node: modularity,  Prev: structureddata,  Up: objectorientedprogramming

1.3.7 Modularity
----------------

Toplevel declarations are organized into _packages_ and _modules_.
Ceylon features language-level access control via the 'shared'
annotation which can be used to express block-local, package-private,
module-private, and public visibility for a program element.  There's no
equivalent to Java's 'protected'.

   A module corresponds to a versioned packaged archive.  Its _module
descriptor_ expresses its dependencies to other modules.  The tooling
and execution model for the language is based around modularity and
module archives.


File: ceylon-spec.info,  Node: thelanguagemodule,  Prev: objectorientedprogramming,  Up: introduction

1.4 Language module
===================

* Menu:


* operatorsandoperatorpolymorphism:: Operators and operator polymorphism
* numerictypes:: Numeric and character types
* compiletimesafety:: Compile-time safety for null values and flow-sensitive typing
* iterableobjectsandcomprehensions:: Streams and comprehensions
* sequencesandtuples:: Sequences and tuples

The Ceylon language module defines a set of built-in types which form
the basis for several powerful features of the language.  The language
itself defines extensive syntactic "sugar" that makes it easier and more
convenient to interact with the language module.


File: ceylon-spec.info,  Node: operatorsandoperatorpolymorphism,  Next: numerictypes,  Up: thelanguagemodule

1.4.1 Operators and operator polymorphism
-----------------------------------------

Ceylon features a rich set of operators, including most of the operators
supported by C and Java.  True operator overloading is not supported.
However, each operator is defined to act upon a certain class or
interface type, allowing application of the operator to any class which
extends or satisfies that type.  For example, the '+' operator may be
applied to any class that satisfies the interface 'Summable'. This
approach is called _operator polymorphism_.


File: ceylon-spec.info,  Node: numerictypes,  Next: compiletimesafety,  Prev: operatorsandoperatorpolymorphism,  Up: thelanguagemodule

1.4.2 Numeric and character types
---------------------------------

Ceylon's numeric type system is much simpler than C, C# or Java, with
exactly three built-in numeric types (compared to six in Java and eleven
in C#).  The built-in types are classes representing integers, floating
point numbers, and bytes.  'Integer' and 'Float' values are signed, with
64 bits of precision by default, and may be optimized for 32 bit
architectures via use of the 'small' annotation. The 'Byte' class
represents 8-bit values with modular arithmetic, sidestepping the
question of whether a byte is signed or unsigned.

   The module 'ceylon.math' provides two additional numeric types
representing arbitrary precision integers and arbitrary precision
decimals.

   Ceylon has 'Character' and 'String' classes, and, unlike Java or C#,
every character is a full 32-bit Unicode codepoint.  Conveniently, a
'String' is a 'List<Character>'.


File: ceylon-spec.info,  Node: compiletimesafety,  Next: iterableobjectsandcomprehensions,  Prev: numerictypes,  Up: thelanguagemodule

1.4.3 Compile-time safety for null values and flow-sensitive typing
-------------------------------------------------------------------

There is no primitive null in Ceylon.  The null value is an instance of
the class 'Null'.  An _optional type_ is a union type like
'Null|String', which may be abbreviated to 'String?'.  An optional type
is never assignable to a non-optional type except via use of the
special-purpose 'if (exists ... )' construct.  Thus, the Ceylon compiler
is able to detect illegal use of a null value at compile time.
Therefore, there is no equivalent to Java's 'NullPointerException' in
Ceylon.

   Similarly, there are no C-style typecasts in Ceylon.  Instead, the
'if (is ... )' and 'case (is ... )' constructs may be used to test and
narrow the type of an object reference in one step, without risk of a
'ClassCastException'. This facility is called _flow-sensitive typing_.

     String name(Organization|Person entity) {
         switch (entity)
         case (is Organization) {
             return entity.tradeName else entity.legalName;
         }
         case (is Person) {
             return entity.nickName else entity.firstName;
         }
     }

   Alternatively, _type assertions_, written 'assert (is ... )' or
'assert (exists ... )' may be used to narrow the type of a reference.

     value arg = process.arguments[0];
     "must specify an amount"
     assert (exists arg);
     "not a legal positive integer amount"
     assert (exists amount = parseInteger(arg), amount>0);

   The combination of 'case (is ... )' with sum types amounts to a kind
of language-level support for the visitor pattern.


File: ceylon-spec.info,  Node: iterableobjectsandcomprehensions,  Next: sequencesandtuples,  Prev: compiletimesafety,  Up: thelanguagemodule

1.4.4 Streams and comprehensions
--------------------------------

The interface 'Iterable' represents a stream of values, which might be
evaluated lazily.  This interface is of central importance in the
language module, and so the language provides a syntactic abbreviation
for the type of an iterable object.  The abbreviation '{String*}' means
'Iterable<String>'.  There is a convenient syntax for instantiating an
iterable object, given a list of values:

     {String*} words = {"hello", "world", "goodbye"};
   A _nonempty iterable_ is an iterable object which always produces at
least one value.  A nonempty iterabe type is written '{String+}'.
Distinguishing nonempty streams of values lets us correctly express the
type of functions like 'max()':

     {Float+} oneOrMore = .... ;
     {Float*} zeroOrMore = .... ;
     Float maxOfOneOrMore = max(oneOrMore); //never null
     Float? maxOfZeroOrMore = max(zeroOrMore); //might be null
   _Comprehensions_ are an expressive syntax for filtering and
transforming streams of values.  For example, they may be used when
instantiating an iterable object or collection:

     value adults = { for (p in people) if (p.age>18) p.name };

     value peopleByName = HashMap { for (p in people) p.name->p };
   Comprehensions are evaluated lazily.


File: ceylon-spec.info,  Node: sequencesandtuples,  Prev: iterableobjectsandcomprehensions,  Up: thelanguagemodule

1.4.5 Sequences and tuples
--------------------------

_Sequences_ are Ceylon's version of arrays. However, the 'Sequential'
interface does not provide operations for mutating the elements of the
sequence--sequences are considered immutable.  Because this interface is
so useful, a type like 'Sequential<String>' may be abbreviated to
'[String*]', or, for the sake of tradition, to 'String[]'.

   A _nonempty sequence_ is a kind of sequence which always has at least
one element.  A nonempty sequence type is written '[String+]'.  The
special-purpose 'if (nonempty ... )' construct narrows a sequence type
to a nonempty sequence type.

   _Tuples_ are a kind of sequence where the type of each element is
encoded into the static type of the tuple.  'Tuple' is just an ordinary
class in Ceylon, but the language lets us write down tuple types using a
streamlined syntax.  For example, '[Float,Float]' is a pair of 'Float's.
There's also a convenient syntax for instantiating tuples and accessing
their elements.

     [Float,Float] origin = [0.0, 0.0];
     Float x = origin[0];
     Float y = origin[1];
     Null z = origin[2]; //only two elements!
   Tuples and nonempty sequences support pattern-based _destructuring_.

     value [x, y] = origin;


File: ceylon-spec.info,  Node: lexical,  Next: typesystem,  Prev: introduction,  Up: Top

2 Lexical structure
*******************

* Menu:


* whitespace:: Whitespace
* comments:: Comments
* identifiersandkeywords:: Identifiers and keywords
* literals:: Literals
* operatorsanddelimiters:: Operators and delimiters

Every Ceylon source file is a sequence of Unicode characters.  Lexical
analysis of the character stream, according to the grammar specified in
this chapter, results in a stream of tokens.  These tokens form the
input of the parser grammar defined in the later chapters of this
specification.  The Ceylon lexer is able to completely tokenize a
character stream in a single pass.


File: ceylon-spec.info,  Node: whitespace,  Next: comments,  Up: lexical

2.1 Whitespace
==============

_Whitespace_ is composed of strings of Unicode 'SPACE', 'CHARACTER
TABULATION', 'FORM FEED (FF)', 'LINE FEED (LF)' and 'CARRIAGE RETURN
(CR)' characters.

Whitespace: " " | Tab | Formfeed | Newline | CarriageReturn

Tab: "\{CHARACTER TABULATION}"

Formfeed: "\{FORM FEED (FF)}"

Newline: "\{LINE FEED (LF)}"

CarriageReturn: "\{CARRIAGE RETURN (CR)}"
   Outside of a comment, string literal, or single quoted literal,
whitespace acts as a token separator and is immediately discarded by the
lexer.  Whitespace is not used as a statement separator.

   Source text is divided into lines by _line-terminating character
sequences_.  The following Unicode character sequences terminate a line:

   * 'LINE FEED (LF)',

   * 'CARRIAGE RETURN (CR)', and

   * 'CARRIAGE RETURN (CR)' followed by 'LINE FEED (LF)'.


File: ceylon-spec.info,  Node: comments,  Next: identifiersandkeywords,  Prev: whitespace,  Up: lexical

2.2 Comments
============

There are two kinds of comments:

   * a _multiline comment_ begins with '/*' and extends until '*/', and

   * an _end-of-line comment_ begins with '//' or '#!' and extends until
     the next line terminating character sequence.

   Both kinds of comments can be nested.

LineComment: ("//"|"#!") ~(Newline | CarriageReturn)* (CarriageReturn Newline | CarriageReturn | Newline)?

MultilineComment: "/*" (MultilineCommentCharacter | MultilineComment)* "*/"

MultilineCommentCharacter: ~("/"|"*") | ("/" ~"*") => "/" | ("*" ~"/") => "*"
   The following examples are legal comments:

     //this comment stops at the end of the line

     /*
        but this is a comment that spans
        multiple lines
     */

     #!/usr/bin/ceylon
   Comments are treated as whitespace by both the compiler and
documentation compiler.  Comments may act as token separators, but their
content is immediately discarded by the lexer and they are not visible
to the parser.


File: ceylon-spec.info,  Node: identifiersandkeywords,  Next: literals,  Prev: comments,  Up: lexical

2.3 Identifiers and keywords
============================

_Identifiers_ may contain letters, digits and underscores.

LowercaseCharacter: LowercaseLetter | "_"

UppercaseCharacter: UppercaseLetter

IdentifierCharacter: LowercaseCharacter | UppercaseCharacter | Number
   The lexer classifies Unicode uppercase letters, lowercase letters,
and numeric characters depending on the general category of the
character as defined by the Unicode standard.

   * A 'LowercaseLetter' is any character whose general category is 'Ll'
     or any character whose general category is 'Lo' or 'Lm' which has
     the property 'Other_Lowercase'.

   * An 'UppercaseLetter' is any character whose general category is
     'Lu' or 'Lt', or any character whose general category is 'Lo' or
     'Lm' which does not have the property 'Other_Lowercase'.

   * A 'Number' is any character whose general category is 'Nd', 'Nl',
     or 'No'.

   All identifiers are case sensitive: 'Person' and 'person' are two
different legal identifiers.

   The lexer distinguishes identifiers which begin with an initial
uppercase character from identifiers which begin with an initial
lowercase character or underscore.  Additionally, an identifier may be
qualified using the prefix '\i' or '\I' to disambiguate it from a
reserved word or to explicitly specify whether it should be considered
an initial uppercase or initial lowercase identifier.

LIdentifier: LowercaseCharacter IdentifierCharacter* | "\i" IdentifierCharacter+

UIdentifier: UppercaseCharacter IdentifierCharacter* | "\I" IdentifierCharacter+
   The following examples are legal identifiers:

     Person

     name

     personName

     _id

     x2

     \I_id

     \Iobject

     \iObject

     \iclass
   The prefix '\I' or '\i' is not considered part of the identifier
name.  Therefore, '\iperson' is just an initial lowercase identifier
named 'person' and '\Iperson' is an initial _uppercase_ identifier named
'person'.

   The following reserved words are not legal identifier names unless
they appear escaped using '\i' or '\I':

   ' assembly module package import alias class interface object given
value assign void function new of extends satisfies abstracts in out
return break continue throw assert dynamic if else switch case for while
try catch finally then let this outer super is exists nonempty '

     Note: 'assembly' and 'abstracts' are reserved for possible use in a
     future release of the language, for declaration of assemblies and
     lower bound type constraints respectively.


File: ceylon-spec.info,  Node: literals,  Next: operatorsanddelimiters,  Prev: identifiersandkeywords,  Up: lexical

2.4 Literals
============

* Menu:


* numericliterals:: Numeric literals
* characterliterals:: Character literals
* stringliterals:: String literals

A _literal_ is a single token that represents a Unicode character, a
character string, or a numeric value.


File: ceylon-spec.info,  Node: numericliterals,  Next: characterliterals,  Up: literals

2.4.1 Numeric literals
----------------------

An _integer literal_ may be expressed in decimal, hexadecimal, or binary
notation:

IntegerLiteral: DecimalLiteral | HexLiteral | BinLiteral
   A _decimal literal_ has a list of digits and an optional magnitude:

DecimalLiteral: Digits Magnitude?
   _Hexadecimal literals_ are prefixed by '#':

HexLiteral: "#" HexDigits
   _Binary literals_ are prefixed by '$':

BinLiteral: "$" BinDigits
   A _floating point literal_ is distinguished by the presence of a
decimal point or fractional magnitude:

FloatLiteral: NormalFloatLiteral | ShortcutFloatLiteral
   Most floating point literals have a list of digits including a
decimal point, and an optional exponent or magnitude.

NormalFloatLiteral: Digits "." FractionalDigits (Exponent | Magnitude | FractionalMagnitude)?
   The decimal point is optional if a fractional magitude is specified.

ShortcutFloatLiteral: Digits FractionalMagnitude
   Decimal digits may be separated into groups of three using an
underscore.

Digits: Digit+ | Digit{1..3} ("_" Digit{3})+

FractionalDigits: Digit+ | (Digit{3} "_")+ Digit{1..3}
   Hexadecimal or binary digits may be separated into groups of four
using an underscore.  Hexadecimal digits may even be separated into
groups of two.

HexDigits: HexDigit+ | HexDigit{1..4} ("_" HexDigit{4})+ | HexDigit{1..2} ("_" HexDigit{2})+

BinDigits: BinDigit+ | BinDigit{1..4} ("_" Digit{4})+
   A digit is a decimal, hexadecimal, or binary digit.

Digit: "0".."9"

HexDigit: "0".."9" | "A".."F" | "a".."f"

BinDigit: "0"|"1"
   A floating point literal may include either an _exponent_ (for
scientific notation) or a _magnitude_ (an SI unit prefix).  A decimal
integer literal may include a magnitude.

Exponent: ("E"|"e") ("+"|"-")? Digit+

Magnitude: "k" | "M" | "G" | "T" | "P"

FractionalMagnitude: "m" | "u" | "n" | "p" | "f"
   The magnitude of a numeric literal is interpreted as follows:

   * 'k' means 'e+3',

   * 'M' means 'e+6',

   * 'G' means 'e+9',

   * 'T' means 'e+12',

   * 'P' means 'e+15',

   * 'm' means 'e-3',

   * 'u' means 'e-6',

   * 'n' means 'e-9',

   * 'p' means 'e-12', and

   * 'f' means 'e-15'.

   The following examples are legal numeric literals:

     69

     6.9

     0.999e-10

     1.0E2

     10000

     1_000_000

     12_345.678_9

     1.5k

     12M

     2.34p

     5u

     $1010_0101

     #D00D

     #FF_FF_FF
   The following are _not_ valid numeric literals:

     .33  //Error: floating point literals may not begin with a decimal point

     1.  //Error: floating point literals may not end with a decimal point

     99E+3  //Error: floating point literals with an exponent must contain a decimal point

     12_34  //Error: decimal digit groups must be of length three

     #FF.00  //Error: floating point numbers may not be expressed in hexadecimal notation


File: ceylon-spec.info,  Node: characterliterals,  Next: stringliterals,  Prev: numericliterals,  Up: literals

2.4.2 Character literals
------------------------

A single _character literal_ consists of a Unicode character, inside
single quotes.

CharacterLiteral: "'" Character "'"

Character: ~("'" | "\") | EscapeSequence
   A character may be identified by an _escape sequence_.  Every escape
sequence begins with a backslash.  An escape sequence is replaced by its
corresponding Unicode character during lexical analysis.

EscapeSequence: "\" (SingleCharacterEscape | "{" CharacterCode "}")

SingleCharacterEscape: "b" | "t" | "n" | "f" | "r" | "e" | "\" | """ | "'" | "`" | "0"
   The single-character escape sequences have their traditional
interpretations as Unicode characters:

   * '\b' means 'BACKSPACE',

   * '\t' means 'CHARACTER TABULATION',

   * '\n' means 'LINE FEED (LF)',

   * '\f' means 'FORM FEED (FF)',

   * '\r' means 'CARRIAGE RETURN (CR)',

   * '\e' means 'ESCAPE',

   * '\\', '\`', '\'', and '\"' mean 'REVERSE SOLIDUS', 'GRAVE ACCENT',
     'APOSTROPHE', and 'QUOTATION MARK', respectively, and, finally

   * '\0' means 'NULL'.

   A Unicode codepoint escape is a two-, four-, or six-digit hexadecimal
literal representing an integer in the range 0 to 10FFFF, or a Unicode
character name, surrounded by braces, and means the Unicode character
with the specified codepoint or character name.

CharacterCode: "#" ( HexDigit{2} | HexDigit{4} | HexDigit{6} ) | UnicodeCharacterName
   Legal Unicode character names are defined by the Unicode
specification.

   The following are legal character literals:

     'A'

     '#'

     ' '

     '\n'

     '\{#212B}'

     '\{ALCHEMICAL SYMBOL FOR GOLD}'


File: ceylon-spec.info,  Node: stringliterals,  Prev: characterliterals,  Up: literals

2.4.3 String literals
---------------------

A character _string literal_ is a sequence of Unicode characters, inside
double quotes.

StringLiteral: """ StringCharacter* """

StringCharacter: ~( "\" | """ | "`" ) | "`" ~"`" | EscapeSequence | EscapedBreak
   A string literal may contain escape sequences.  An escape sequence is
replaced by its corresponding Unicode character during lexical analysis.

   A line-terminating character sequence may be escaped with a
backslash, in which case the escaped line termination is removed from
the string literal during lexical analysis.

EscapedBreak: "\" (CarriageReturn Newline | CarriageReturn | Newline)
   A sequence of two backticks is used to delimit an interpolated
expression embedded in a string template.

StringStart: """ StringCharacter* "``"

StringMid: "``" StringCharacter* "``"

StringEnd: "``" StringCharacter* """
   A _verbatim string_ is a character sequence delimited by a sequence
of three double quotes.  Verbatim strings do not contain escape
sequences or interpolated expressions, so every character occurring
inside the verbatim string is interpreted literally.

VerbatimStringLiteral: """"" VerbatimCharacter* """""

VerbatimCharacter: ~""" | """ ~""" | """ """ ~"""
   The following are legal strings:

     "Hello!"

     "\{#00E5}ngstr\{#00F6}ms"

     " \t\n\f\r,;:"

     "\{POLICE CAR} \{TROLLEYBUS} \{WOMAN WITH BUNNY EARS}"

     """This program prints "hello world" to the console."""
   The column in which the first character of a string literal occurs,
excluding the opening quote characters, is called the _initial column_
of the string literal.  Every following line of a multiline string
literal must contain whitespace up to the initial column.  That is, if
the string contents begin at the 'n'th character in a line of text, the
following lines must start with 'n' whitespace characters.  This
required whitespace is removed from the string literal during lexical
analysis.


File: ceylon-spec.info,  Node: operatorsanddelimiters,  Prev: literals,  Up: lexical

2.5 Operators and delimiters
============================

The following character sequences are operators and/or punctuation:

   ' , ; ... { } ( ) [ ] ` ? . ?. *. = => + - * / % ^ ** ++ -- .. : -> !
&& || ~ & | === == != < > <= >= <=> += -= /= *= %= |= &= ~= ||= &&= '

   Certain symbols serve dual or multiple purposes in the grammar.


File: ceylon-spec.info,  Node: typesystem,  Next: declarations,  Prev: lexical,  Up: Top

3 Type system
*************

* Menu:


* identifiernaming:: Identifier naming
* type:: Types
* inheritance:: Inheritance
* casesandcoverage:: Case enumeration and coverage
* generictypeparameters:: Generic type parameters
* generictypearguments:: Generic type arguments
* principalinstantiations:: Principal instantiations and polymorphism

Every value in a Ceylon program is an instance of a type that can be
expressed within the Ceylon language as a _class_.  The language does
not define any primitive or compound types that cannot, in principle, be
expressed within the language itself.

   A class, fully defined in *note Classes: classes, is a recipe for
producing new values, called _instances_ of the class (or simply
_objects_), and defines the operations and attributes of the resulting
values.  A class instance may hold references to other objects, and has
an identity distinct from these references.

   Each class declaration defines a type.  However, not all types are
classes.  It is often advantageous to write generic code that abstracts
the concrete class of a value.  This technique is called _polymorphism_.
Ceylon features two different kinds of polymorphism:

   * _subtype polymorphism_, where a subtype 'B' inherits a supertype
     'A', and

   * _parametric polymorphism_, where a type definition 'A<T>' is
     parameterized by a _generic type parameter_ 'T'.

   Ceylon, like Java and many other object-oriented languages, features
a single inheritance model for classes.  A class may directly inherit at
most one other class, and all classes eventually inherit, directly or
indirectly, the class 'Anything' defined in the module
'ceylon.language', which acts as the root of the class hierarchy.

   A truly hierarchical type system is much too restrictive for more
abstract programming tasks.  Therefore, in addition to classes, Ceylon
recognizes the following kinds of type:

   * An _interface_, defined in *note Interfaces: interfaces, is an
     abstract type schema that cannot itself be directly instantiated.
     An interface may define concrete members, but these members may not
     hold references to other objects.  A class may inherit one or more
     interfaces.  An instance of a class that inherits an interface is
     also considered an instance of the interface.

   * A _generic type parameter_, defined in *note Generic type
     parameters: generictypeparameters, is considered a type within the
     declaration that it parameterizes.  In fact, it is an abstraction
     over many types: it generalizes the declaration to all types which
     could be assigned to the parameter.

   * An _applied type_, defined in *note Generic type arguments:
     generictypearguments, is formed by specifying arguments for the
     generic type parameters of a parameterized type declaration, and is
     called an _instantiation_ of the parameterized type declaration.

   * A _union type_, defined in *note Union types: uniontypes, is a type
     to which each of an enumerated list of types is assignable.

   * An _intersection type_, defined in *note Intersection types:
     intersectiontypes, is a type which is assignable to each of an
     enumerated list of types.

   Although we often use the term _parameterized type_ or even _generic
type_ to refer to a parameterized type definition, it is important to
keep in mind that a parameterized type definition is not itself a type.
Rather, it is a _type constructor_, a function that maps types to types.
Given a list of type arguments, the function yields an applied type.

   In light of the fact that Ceylon makes it so easy to construct new
types from existing types _without the use of inheritance_, by forming
unions, intersections, and applied types, it's often useful to assign a
name to such a type.

   * A _type alias_, defined in *note Type aliases:
     typealiasedeclarations, *note Class aliases: classaliases, and
     *note Interface aliases: interfacealiases, is a synonym for an
     expression involving other types or generic types.  A type alias
     may itself be generic.

   The Ceylon type system is much more complete than most other object
oriented languages.  In Ceylon, it's possible to answer questions that
might at first sound almost nonsensical if you're used to languages with
more traditional type systems. For example:

   * What is the type of a variable that may or may not hold a value of
     type 'Element'?

   * What is the type of a parameter that accepts either an 'Integer' or
     a 'Float'?

   * What is the type of a parameter that accepts values which are
     instances of both 'Persistent' and 'Printable'?

   * What is the type of a function which accepts any non-null value and
     returns a 'String'?

   * What is the type of a function that accepts one or more 'String's
     and returns an iterable object producing at least one 'String'?

   * What is the type of a sequence consisting of a 'String' followed by
     two 'Float's?

   * What is the type of a list with no elements?

   The answers, as we shall see, are: 'Element?', 'Integer|Float',
'Persistent&Printable', 'String(Object)', '{String+}(String+)',
'[String,Float,Float]', and 'List<Nothing>'.

   It's important that there is always a unique "best" answer to
questions like these in Ceylon.  The "best" answer is called the
_principal type of an expression_.  Every other type to which the
expression is assignable is a supertype of the principal type.

   Thus, every legal Ceylon expression has a unique, well-defined type,
representable within the type system, without reference to how the
expression is used or to what type it is assigned.  This is the case
even when type inference or type argument inference comes into play.

   Neither this specification nor the internal implementation of the
Ceylon compiler itself use any kind of "non-denotable" types.  Every
type mentioned here or inferred internally by the compiler has a
representation within the language itself.  Thus, the programmer is
never exposed to confusing error messages referring to mysterious types
that are not part of the syntax of the language.


File: ceylon-spec.info,  Node: identifiernaming,  Next: type,  Up: typesystem

3.1 Identifier naming
=====================

The Ceylon compiler enforces identifier naming conventions.  Types must
be named with an initial uppercase letter.  Values, functions, and
constructors must be named with an initial lowercase letter or
underscore. The grammar for identifiers is defined by *note Identifiers
and keywords: identifiersandkeywords.

TypeName: UIdentifier

MemberName: LIdentifier
   A package or module name is a sequence of identifiers.

PackageName: LIdentifier | UIdentifier
   Ceylon defines three identifier namespaces:

   * classes, interfaces, type aliases, and type parameters share a
     single namespace,

   * functions and values, including parameters, and constructors share
     a single namespace, and

   * packages and modules have their own dedicated namespace.

   The Ceylon parser is able to unambiguously identify which namespace
an identifier belongs to.

   An identifier that begins with an initial lowercase letter may be
_forced_ into the namespace of types by prefixing the identifier '\I'.
An identifier that begins with an initial uppercase letter may be forced
into the namespace of methods and attributes by prefixing the identifier
'\i'.  A keyword may be used as an identifier by prefixing the keyword
with either '\i' or '\I'.  This allows interoperation with other
languages like Java and JavaScript which do not enforce these naming
conventions.


File: ceylon-spec.info,  Node: type,  Next: inheritance,  Prev: identifiernaming,  Up: typesystem

3.2 Types
=========

* Menu:


* memberdistinctness:: Member distinctness
* subtyping:: Subtyping
* uniontypes:: Union types
* intersectiontypes:: Intersection types
* bottomtype:: The bottom type
* principaltyping:: Principal typing
* typeexpressions:: Type expressions
* typenameabbreviations:: Type abbreviations
* typeinference:: Type inference
* typealiaselimination:: Type alias elimination

A _type_ or _type schema_ is a name (an initial uppercase identifier)
and an optional list of type parameters, with a set of:

   * value schemas,

   * function schemas, and

   * class schemas.

   The value, function, and class schemas are called the _members_ of
the type.

   Speaking formally:

   * A _value schema_ is a name (an initial lowercase identifier) with a
     type and mutability.

   * A _function schema_ is a name (an initial lowercase identifier) and
     an optional list of type parameters, with a type (often called the
     _return type_) and a sequence of one or more parameter lists.

   * A _class schema_ is a type schema with either one parameter list,
     or a list of constructor schemas.

   * A _callable constructor schema_ is a name (an initial lowercase
     identifier) with exactly one parameter list.

   * A _value constructor schema_ is a name (an initial lowercase
     identifier).

   * A _parameter list_ is a list of names (initial lowercase
     identifiers) with types.  The _signature_ of a parameter list is
     formed by discarding the names, leaving the list of types.

   Speaking slightly less formally, we usually refer to an _attribute_,
_method_, or _member class_ of a type, meaning a value schema, function
schema, or class schema that is a member of the type.

   A function or value schema may occur outside of a type schema.  If it
occurs directly in a compilation unit, we often call it a _toplevel
function_ or _toplevel value_.

   A value schema, function schema, or parameter list with a missing
type or types may be defined.  Any such schema, or parameter list with a
missing type is called _partially typed_.

   Two signatures are considered identical if they have exactly the same
types, at exactly the same positions, and missing types at exactly the
same positions.


File: ceylon-spec.info,  Node: memberdistinctness,  Next: subtyping,  Up: type

3.2.1 Member distinctness
-------------------------

Overloading is illegal in Ceylon.  A type may not have:

   * two attributes with the same name,

   * a method and an attribute with the same name,

   * two methods with the same name, or

   * two member classes with the same name.

     Note: the Ceylon compiler itself is able to represent type schemas
     with overloaded members and reason about overloading, and does so
     when compiling code that calls native Java types.  However, this
     behavior is outside the scope of this specification.


File: ceylon-spec.info,  Node: subtyping,  Next: uniontypes,  Prev: memberdistinctness,  Up: type

3.2.2 Subtyping
---------------

A type may be a _subtype_ of another type.  Subtyping obeys the
following rules:

   * Identity: 'X' is a subtype of 'X'.

   * Transitivity: if 'X' is a subtype of 'Y' and 'Y' is a subtype of
     'Z' then 'X' is a subtype of 'Z'.

   * Noncircularity: if 'X' is a subtype of 'Y' and 'Y' is a subtype of
     'X' then 'Y' and 'X' are the same type.

   * Single root: all types are subtypes of the class 'Anything' defined
     in the module 'ceylon.language'.

   Also, every interface type is a subtype of the class 'Object' defined
in 'ceylon.language'.

   If 'X' is a subtype of 'Y', then:

   * For each non-'variable' attribute of 'Y', 'X' has an attribute with
     the same name, whose type is assignable to the type of the
     attribute of 'Y'.

   * For each 'variable' attribute of 'Y', 'X' has a 'variable'
     attribute with the same name and the same type.

   * For each method of 'Y', 'X' has a method with the same name, with
     the same number of parameter lists, with the same signatures, and
     whose return type is assignable to the return type of the method of
     'Y'.

   * For each member class of 'Y', 'X' has a member class of the same
     name, with a parameter list with the same signature, that is a
     subtype of the member class of 'Y'.

   Furthermore, we say that 'X' is _assignable_ to 'Y'.


File: ceylon-spec.info,  Node: uniontypes,  Next: intersectiontypes,  Prev: subtyping,  Up: type

3.2.3 Union types
-----------------

For any types 'X' and 'Y', the _union_, or _disjunction_, 'X|Y', of the
types may be formed.  A union type is a supertype of both of the given
types 'X' and 'Y', and an instance of either type is an instance of the
union type.

     Note: the type expression 'X|Y' is pronounced ``x or y''.

   The union type constructor '|' is associative, so the union of three
types, 'X', 'Y', and 'Z', may be written 'X|Y|Z'.

UnionType: IntersectionType ("|" IntersectionType)*
   If 'X' and 'Y' are both subtypes of a third type 'Z', then 'X|Y'
inherits all members of 'Z'.

     void write(String|Integer|Float printable) { ... }
   Union types satisfy the following rules, for any types 'X', 'Y', and
'Z':

   * Commutativity: 'X|Y' is the same type as 'Y|X'.

   * Associativity: 'X|<Y|Z>' is the same type as '<X|Y>|Z', where the
     angle brackets denote grouping.

   * Simplification: if 'X' is a subtype of 'Y', then 'X|Y' is the same
     type as 'Y'.

   * Subtypes: 'X' is a subtype of 'X|Y'.

   * Supertypes: if both 'X' and 'Y' are subtypes of 'Z', then 'X|Y' is
     also a subtype of 'Z'.

   The following results follow from these rules:

   * 'X|Nothing' is the same type as 'X' for any type 'X', and

   * 'X|Anything' is the same type as 'Anything' for any type 'X'.

   Finally:

   * If 'X<T>' is covariant in the type parameter 'T', then 'X<U>|X<V>'
     is a subtype of 'X<U|V>' for any types 'U' and 'V' that satisfy the
     type constraints on 'T'.

   * If 'X<T>' is contravariant in the type parameter 'T', then
     'X<U>|X<V>' is a subtype of 'X<U&V>' for any types 'U' and 'V' that
     satisfy the type constraints on 'T'.


File: ceylon-spec.info,  Node: intersectiontypes,  Next: bottomtype,  Prev: uniontypes,  Up: type

3.2.4 Intersection types
------------------------

For any types 'X' and 'Y', the _intersection_, or _conjunction_, 'X&Y',
of the types may be formed.  An intersection type is a subtype of both
of the given types 'X' and 'Y', and any object which is an instance of
both types is an instance of the intersection type.

     Note: the type expression 'X&Y' is pronounced ``x and y''.

   The intersection type constructor '&' is associative, so the
intersection of three types, 'X', 'Y', and 'Z', may be written 'X&Y&Z'.

IntersectionType: PrimaryType ("&" PrimaryType)*
   The intersection 'X&Y' inherits all members of both 'X' and 'Y'.

     void store(Persistent&Printable&Identifiable storable) { ... }
   Intersection types satisfy the following rules, for any types 'X',
'Y', and 'Z':

   * Commutativity: 'X&Y' is the same type as 'Y&X'.

   * Associativity: 'X&<Y&Z>' is the same type as '<X&Y>&Z', where the
     angle brackets denote grouping.

   * Simplification: if 'X' is a subtype of 'Y', then 'X&Y' is the same
     type as 'X'.

   * Supertypes: 'X' is a supertype of 'X&Y'.

   * Subtypes: if both 'X' and 'Y' are supertypes of 'Z', then 'X&Y' is
     also a supertype of 'Z'.

   * Distributivity over union: 'X&<Y|Z>' is the same type as
     '<X&Y>|<X&Z>'.

   The following results follow from these rules:

   * 'X&Nothing' is the same type as 'Nothing' for any type 'X', and

   * 'X&Anything' is the same type as 'X' for any type 'X'.

   Finally:

   * If 'X<T>' is covariant in the type parameter 'T', then 'X<U>&X<V>'
     is a supertype of 'X<U&V>' for any types 'U' and 'V' that satisfy
     the type constraints on 'T'.

   * If 'X<T>' is contravariant in the type parameter 'T', then
     'X<U>&X<V>' is a supertype of 'X<U|V>' for any types 'U' and 'V'
     that satisfy the type constraints on 'T'.


File: ceylon-spec.info,  Node: bottomtype,  Next: principaltyping,  Prev: intersectiontypes,  Up: type

3.2.5 The bottom type
---------------------

The special type 'Nothing', sometimes called the _bottom type_,
represents:

   * the intersection of all types, or, equivalently

   * the empty set.

   'Nothing' is assignable to all other types, but has no instances.

   The type schema for 'Nothing' is empty, that is, it is considered to
have no members.

   'Nothing' is considered to belong to the module 'ceylon.language'.
However, it cannot be defined within the language.

     Note: an expression of type 'Nothing' results in a compiler
     warning.

   Because of the restrictions imposed by Ceylon's mixin inheritance
model:

   * If 'X' and 'Y' are classes, and 'X' is not a subclass of 'Y', and
     'Y' is not a subclass of 'X', then the intersection type 'X&Y' is
     equivalent to 'Nothing'.

   * If 'X' is an interface, the intersection type 'X&Null' is
     equivalent to 'Nothing'.

   * If 'X' is an interface, and 'Y' is a 'final' class, and 'Y' is not
     a subtype of 'X', then the intersection type 'X&Y' is equivalent to
     'Nothing'.

   * If 'X<T>' is invariant in its type parameter 'T', and the distinct
     types 'A' and 'B' do not involve type parameters, then 'X<A>&X<B>'
     is equivalent to 'Nothing'.

   * If 'X' is a subtype of a type 'A' and 'Y' is a subtype of a type
     'B', where 'A' and 'B' are distinct cases of an enumerated type,
     then the intersection type 'X&Y' is equivalent to 'Nothing'.

   Furthermore, as a special case,

   * 'Sequence<E>' is equivalent to 'Nothing' if 'E' is equivalent to
     'Nothing', and

   * 'Tuple<E,F,R>' is equivalent to 'Nothing' if any of 'E', 'F', or
     'R' is equivalent to 'Nothing'.

     Note: the soundness of these rules is guaranteed by the
     implementations of the 'sealed' types 'Sequence' and 'Tuple' in the
     module 'ceylon.language'.


File: ceylon-spec.info,  Node: principaltyping,  Next: typeexpressions,  Prev: bottomtype,  Up: type

3.2.6 Principal typing
----------------------

An expression, as defined in *note Expressions: expressions, occurring
at a certain location, may be _assignable_ to a type.  In this case,
every evaluation of the expression at runtime produces an instance of a
class that is a subtype of the type, or results in a thrown exception,
as defined in *note Execution: execution.

   Given an expression occurring at a certain location, a type 'T' is
the _principal type_ of the expression if, given any type 'U' to which
the expression is assignable, 'T' is a subtype of 'U'.  Thus, the
principal type is the "most precise" type for the expression.  The type
system guarantees that every expression has a principal type.  Thus, we
refer uniquely to _the type of an expression_, meaning its principal
type at the location at which it occurs.


File: ceylon-spec.info,  Node: typeexpressions,  Next: typenameabbreviations,  Prev: principaltyping,  Up: type

3.2.7 Type expressions
----------------------

Function and value declarations usually declare a type, by specifying a
_type expression_.

Type: UnionType | EntryType
   Type expressions are formed by combining types using union,
intersection, and type abbreviations.

   Type expressions support grouping using angle brackets:

GroupedType: "<" Type ">"
   Applied types are identified by the name of the type (a class,
interface, type alias, or type parameter), together with a list of type
arguments if the type declaration is generic.

TypeNameWithArguments: TypeName TypeArguments?
   Type names are resolved to type declarations according to *note
Unqualified reference resolution: unqualifiedreferenceresolution. and
*note Qualified reference resolution: qualifiedreferenceresolution.

   If the type is a class, interface, or type alias nested inside a
containing class or interface, the type must be fully qualified by its
containing types, except when used inside the body of a containing type.

BaseType: PackageQualifier? TypeNameWithArguments | GroupedType

QualifiedType: BaseType ("." TypeNameWithArguments)*
   If a type declaration is generic, a type argument list must be
specified. If a type declaration is not generic, no type argument list
may be specified.

   A base type may be qualified by the 'package' keyword, allowing
disambiguation of the type name, as defined in *note Unqualified
reference resolution: unqualifiedreferenceresolution.

PackageQualifier: "package" "."

     Note: the name of a type may not be qualified by its package name.
     Alias imports, as defined in *note Alias imports: aliasimports. may
     be used to disambiguate type names.

     BufferedReader.Buffer

     Entry<Integer,Element>


File: ceylon-spec.info,  Node: typenameabbreviations,  Next: typeinference,  Prev: typeexpressions,  Up: type

3.2.8 Type abbreviations
------------------------

Certain important types may be written using an abbreviated syntax.

PrimaryType: AtomicType | OptionalType | SequenceType | CallableType

AtomicType: QualifiedType | EmptyType | TupleType | IterableType
   First, there are postfix-style abbreviations for _optional types_ and
_sequence types_.

OptionalType: PrimaryType "?"

SequenceType: PrimaryType "[" "]"
   For any type 'X':

   * 'X?' means 'Null|X', and

   * 'X[]' means 'Sequential<X>'.

     Note: the type expression 'X?' is pronounced as ``maybe x'', and
     'X[]' as ``sequence of x''.

   Next, there are type abbreviations for _callable types_ which
represent the types of functions.

CallableType: PrimaryType "(" (TypeList? | SpreadType) ")"

TypeList: (DefaultedType ",")* (DefaultedType | VariadicType)

DefaultedType: Type "="?

VariadicType: UnionType ("*" | "+")

SpreadType: "*" UnionType
   For any type 'X':

   * 'X(Y,Z)' means 'Callable<X,[Y,Z]>' where 'Y,Z' is a list of types
     of any length, and

   * 'X(*Y)' means 'Callable<X,Y>' for any subtype 'Y' of
     'Sequential<Anything>'.

   More precisely, the type meant by a callable type abbreviation is
'Callable<X,T>' where 'X' is the type outside the parentheses in the the
callable type abbreviation, and 'T' is the tuple type formed by the
types listed inside the parentheses.

   Next, abbreviations for _iterable types_ are written using braces.

IterableType: "{" UnionType ("*"|"+") "}"
   For any type 'X':

   * '{X*}' means 'Iterable<X,Null>', and

   * '{X+}' means 'Iterable<X,Nothing>'.

     Note: the type expression '{X*}' is pronounced as ``stream of x'',
     and '{X+}' as ``nonempty stream of x''.

   Next, abbreviations for _sequence types_ and _tuple types_ may be
written using brackets.

EmptyType: "[" "]"

TupleType: "[" TypeList "]" | PrimaryType "[" DecimalLiteral "]"

   * '[]' means 'Empty',

   * '[X]' means 'Tuple<X,X,[]>' for any type 'X',

   * '[X=]' means '[]|[X]' for any type 'X',

   * '[X*]' means 'Sequential<X>' for any type 'X',

   * '[X+]' means 'Sequence<X>' for any type 'X',

   * '[X,Y]' means 'Tuple<X|Y,X,[Y]>' for any types 'X,Y',

   * '[X,Y=]' means 'Tuple<X|Y,X,[Y=]>' for any types 'X,Y',

   * '[X,Y*]' means 'Tuple<X|Y,X,[Y*]>' for any types 'X,Y',

   * '[X,Y+]' means 'Tuple<X|Y,X,[Y+]>' for any types 'X,Y', and,
     finally,

   * 'X[1]' means '[X]', for any type 'X', and 'X[n]' means
     'Tuple<X,X,X[n-1]>' for any type 'X' and positive integer 'n'.

   More precisely:

   * A tuple type abbreviation of form '[X, ... ]' means the type
     'Tuple<X|Y,X,T>' where 'T' is the type meant by the type
     abbreviation formed by removing the first element type 'X' from the
     list of types in the original tuple type abbreviation, and 'T' has
     the principal instantiation 'Y[]', as defined in *note Principal
     instantiations and polymorphism: principalinstantiations.

   * A tuple type abbreviation of form '[X=, ... ]' means the type
     'Empty|T' where 'T' is the type meant by the tuple type
     abbreviation '[X, ... ]', formed by removing the '=' from the first
     element type 'X=' of the list of types in the original tuple type
     abbreviation.

   In a tuple type or callable type expression:

   * an _defaulted element_ is indicated with a postfix '=' or '*', and

   * a _required element_ is indicated with a postfix '+' or no special
     marker.

   In a tuple type or callable type expression, every defaulted element
must occur after every required element.

   Finally, an _entry type_ may be abbreviated using an arrow.

EntryType: UnionType "->" UnionType

   * 'X->Y' means 'Entry<X,Y>', for any types 'X', 'Y'.

     Note: the abbreviations 'T[]' and '[T*]' are synonyms.  The syntax
     'T[]' is supported for reasons of nostalgia.

   Abbreviations may be combined:

     String?[] words = { "hello", "world", null };
     String? firstWord = words[0];

     String->[Integer,Integer] onetwo = "onetwo"->[1, 2];

     [Float+](Float x, Float[] xs) add = (Float x, Float[] xs) => [x, *xs];
   When a type appears in a value expression, these abbreviations cannot
be used (they cannot be disambiguated from operator expressions).


File: ceylon-spec.info,  Node: typeinference,  Next: typealiaselimination,  Prev: typenameabbreviations,  Up: type

3.2.9 Type inference
--------------------

Certain declarations which usually require an explicit type may omit the
type, forcing the compiler to infer it, by specifying the keyword
'value', as defined in *note Value type inference: valuetypeinference,
or 'function', as defined in *note Function return type inference:
returntypeinference, where the type usually appears.

     value names = people*.name;

     function parse(String text) => text.split(" .!?,:;()\n\f\r\t".contains);
   Type inference is only allowed for declarations which are referred to
only by statements and declarations that occur within the lexical scope
of the declaration, as specified by *note Type inference and block
structure: typeinferenceandblockstructure.  A 'value' or 'function'
declaration may not:

   * be annotated 'shared', as defined in *note Visibility: visibility,

   * occur as a toplevel declaration in a compilation unit, as defined
     in *note Toplevel and nested declarations: topleveldeclarations, or

   * be referred to by statements or declarations that occur earlier in
     the body containing of the declaration, as defined in *note Block
     structure and references: blockstructure.

   Nor may a parameter or forward-declared value, as defined in *note
Forward declaration of values: valueforwarddeclaration, or of a
forward-declared function, as defined in *note Forward declaration of
functions: functionforwarddeclaration, have an inferred type.

   These restrictions allow the compiler to infer undeclared types in a
single pass of the code.

     Note: in future releases of the language, the inferred type will be
     context-dependent, that is, in program elements immediately
     following an assignment or specification, the inferred type will be
     the type just assigned.  When conditional execution results in
     definite assignment, the inferred type will be the union of the
     conditionally assigned types.  This will allow us to to relax the
     restriction that forward-declared functions and values can't have
     their type inferred.  For example:

          value one;
          if (float) {
              one = 1.0;
              Float float = one;
          }
          else {
              one = 1;
              Integer int = one;
          }
          Float|Integer num = one;

   An inferred type never involves an anonymous class, as defined in
*note Anonymous classes: anonymousclasses.  When an inferred type would
involve an anonymous class type, the anonymous class is replaced by the
intersection of the class type it extends with all interface types it
satisfies.

     TODO: properly define how expressions with no type occurring in a
     'dynamic' block affect type inference.


File: ceylon-spec.info,  Node: typealiaselimination,  Prev: typeinference,  Up: type

3.2.10 Type alias elimination
-----------------------------

A _type alias_ is a synonym for another type.  A generic type alias is a
type constructor that produces a type alias, given a list of type
arguments.

   Every type alias must be reducible to an equivalent type that does
not involve any type aliases by recursive replacement of type aliases
with the types they alias.  Thus, circular type alias definitions, as in
the following example, are illegal:

     alias X => List<Y>;  //error: circular type alias definition
     alias Y => List<X>;  //error: circular type alias definition
   Replacement of type aliases with the types they alias occurs at
compile time, so type aliases are not reified types, as specified in
*note Type argument reification: reification.


File: ceylon-spec.info,  Node: inheritance,  Next: casesandcoverage,  Prev: type,  Up: typesystem

3.3 Inheritance
===============

* Menu:


* inheritanceandsubtyping:: Inheritance and subtyping
* extendedclass:: Extension
* satisfiedinterfaces:: Satisfaction

Inheritance is a static relationship between classes, interfaces, and
type parameters:

   * a class may _extend_ another class, as defined by *note Class
     inheritance: classinheritance,

   * a class may _satisfy_ one or more interfaces, as defined by *note
     Class inheritance: classinheritance,

   * an interface may _satisfy_ one or more other interfaces, as defined
     by *note Interface inheritance: interfaceinheritance, or

   * a type parameter may _satisfy_ a class and/or one or more
     interfaces or type parameters, as defined by *note Generic type
     constraints: generictypeconstraints.

   We say that a type declaration 'X' _inherits_ a type declaration 'Y'
if 'X' extends or satisfies 'Y', or if a third type declaration 'Z'
inherits 'Y' and 'X' extends or satisfies 'Z'.

   Inheritance relationships may not produce cycles, since that would
violate the noncircularity rule for subtyping.  Thus, a class,
interface, or type parameter may not, directly or indirectly, inherit
itself.

   When a type declaration extends or satisfies a parameterized type
declaration, it must specify type arguments for the type parameters of
the generic declaration. Thus, whenever a type declaration inherits a
parameterized type declaration, it also inherits an instantiation of the
parameterized type declaration.

     Note: when a type declaration specifies a relationship to other
     types, Ceylon visually distinguishes between a list of types which
     conceptually represents a combination of (intersection of) the
     types, and a list of types which represents a choice between (union
     of) the types.  For example, when a class 'C' satisfies multiple
     interfaces, they are written as 'X&Y&Z'.  On the other hand, the
     cases of an enumerated class 'E' are written as 'X|Y|Z'.  This
     syntax emphasizes that 'C' is also a subtype of the intersection
     type 'X&Y&Z', and that 'E' may be narrowed to the union type
     'X|Y|Z' using a 'switch' statement or the 'of' operator.


File: ceylon-spec.info,  Node: inheritanceandsubtyping,  Next: extendedclass,  Up: inheritance

3.3.1 Inheritance and subtyping
-------------------------------

Inheritance relationships between classes, interfaces, and type
parameters result in subtyping relationships between types.

   * If a type declaration 'X' with no type parameters inherits a type
     'Y', then 'X' is a subtype of 'Y'.

   * If a generic type 'X' inherits a type 'Y', which might involve the
     type parameters of 'X', then for any instantiation 'U' of 'X' we
     can construct a type 'V' by, for every type parameter 'T' of 'X',
     substituting the corresponding type argument of 'T' given in 'U'
     everywhere 'T' occurs in 'Y', and then 'U' is a subtype of 'V'.


File: ceylon-spec.info,  Node: extendedclass,  Next: satisfiedinterfaces,  Prev: inheritanceandsubtyping,  Up: inheritance

3.3.2 Extension
---------------

A class may extend another class, in which case the first class is a
subtype of the second class and inherits its members.  A class which
extends another class may have a constructor, as defined in *note
Constructors: constructors, which delegates to a callable constructor of
the second class.  Extension and constructor delegation is specified
using the 'extends' clause.

   The 'extends' clause must specify exactly one class or constructor.

ExtendedType: "extends" (Extension | Construction)
   An 'extends' clause of a class or constructor has either:

   * a reference to a superclass, followed by an optional positional
     argument list, as defined in *note Positional argument lists:
     positionalarguments, or

   * a reference to a superclass constructor, always followed by a
     positional argument list.

   In the case that the 'extends' clause refers to a constructor, the
superclass is taken to be the class to which the constructor belongs.

Extension: (BaseExtension | SuperExtension) PositionalArguments?

Construction: (BaseConstruction | SuperConstruction) PositionalArguments
   The 'extends' clause may not refer to a partial constructor of the
superclass, nor to a value constructor of the superclass.

BaseExtension: PackageQualifier? TypeNameWithArguments

SuperExtension: SuperQualifier TypeNameWithArguments

BaseConstruction: (PackageQualifier? TypeNameWithArguments ".")? MemberNameWithArguments

SuperConstruction: SuperQualifier MemberNameWithArguments

SuperQualifier: "super" "."
   The specification of the superclass or superclass constructor is
treated as a value expression, not as a type expression.

   * If the qualifier 'super' occurs, the specification is treated as a
     member expression, as defined by *note Member expressions:
     memberexpressions, where the qualifier 'super' is treated according
     to *note super: super.

   * If a qualifying type occurs, the specification is treated as a
     constructor expression, as defined by *note Constructor
     expressions: constructorexpressions.

   * Otherwise, if no qualifier occurs, the specification is treated as
     a base expression, as defined by *note Base expressions:
     baseexpressions.

   The type of the value expression is the inherited type.

   The specification of the superclass or superclass constructor may
have type arguments, and, additionally, the extends clause may have a
positional argument list:

   * If the superclass is a parameterized type, the 'extends' clause
     must also explicitly specify type arguments, and the resulting
     applied type is inherited.

   * If the 'extends' clause belongs to a constructor or to a class with
     an initializer parameter list, the 'extends' clause must specify
     arguments for the initializer parameters of the superclass or
     parameters of the superclass constructor.

   * If the 'extends' clause belongs to a class with no initializer
     parameter list, the 'extends' clause may not specify arguments for
     the initializer parameters of the superclass, and the 'extends'
     clause may not refer to a constructor.

   The type arguments may _not_ be inferred from the positional
arguments.

   A type argument occurring in the 'extends' clause may not involve
variance annotations 'in' or 'out', defined below in *note Type
arguments and variance: typeargumentvariance.

     extends Singleton<String>("")

     extends Person(name, org)

     extends withName(name)
   A member class annotated 'actual' may use the qualifier 'super' in
the 'extends' clause to refer to the member class it refines.  When the
qualifier 'super' appears, the following class name refers to a member
class of the superclass of the class that contains the member class
annotated 'actual'.

     extends super.Buffer()
   The root class 'Anything' defined in 'ceylon.language' does not have
a superclass.


File: ceylon-spec.info,  Node: satisfiedinterfaces,  Prev: extendedclass,  Up: inheritance

3.3.3 Satisfaction
------------------

The 'satisfies' clause does double duty.  It's used to specify that a
class or interface is a direct subtype of one or more interfaces, and to
specify upper bound type constraints applying to a type parameter.

     Note: for this reason the keyword is not named "'implements'".  It
     can't reasonably be said that a type parameter "implements" its
     upper bounds.  Nor can it be reasonably said that an interface
     "implements" its super-interfaces.

   * A class or interface may satisfy one or more interfaces, in which
     case the class or interface is a subtype of the satisfied
     interfaces, and inherits their members.

   * A type parameter may satisfy one or more interfaces, optionally, a
     class, and optionally, another type parameter.  In this case, the
     satisfied types are interpreted as upper bound type constraints on
     arguments to the type parameter.

     Note: currently, a type parameter upper bound may not be specified
     in combination with other upper bounds.  This restriction will
     likely be removed in future.

   The 'satisfies' clause may specify multiple types.

SatisfiedTypes: "satisfies" PrimaryType ("&" PrimaryType)*
   If a satisfied class or interface is a parameterized type, the
'satisfies' clause must explicitly specify type arguments, and the
resulting applied type is inherited.

   A type occurring in the 'satisfies' clause may not involve variance
annotations 'in' or 'out', defined below in *note Type arguments and
variance: typeargumentvariance.

     satisfies Correspondence<Integer,Element> & Collection<Element>
   A 'satisfies' clause may not contain two instantiations of the same
type declaration.


File: ceylon-spec.info,  Node: casesandcoverage,  Next: generictypeparameters,  Prev: inheritance,  Up: typesystem

3.4 Case enumeration and coverage
=================================

* Menu:


* coverage:: Coverage
* cases:: Cases
* genericenumeratedtypes:: Generic enumerated types
* disjointtypes:: Disjoint types

_Coverage_ is a static relationship between classes, interfaces, and
type parameters, produced through the use of _case enumeration_:

   * An 'abstract' class or interface may be an _enumerated type_, with
     an enumerated list of disjoint subtypes called _cases_, as defined
     by *note Enumerated classes: classeswithcases. and *note Enumerated
     interfaces: interfaceswithcases.

   * A type parameter may have an _enumerated bound_, with an enumerated
     list possible type arguments, as defined by *note Generic type
     constraints: generictypeconstraints.

   * An 'abstract' class or interface may have a _self type_, a type
     parameter representing the concrete type of an instance.


File: ceylon-spec.info,  Node: coverage,  Next: cases,  Up: casesandcoverage

3.4.1 Coverage
--------------

Coverage is a strictly weaker relationship than assignability:

   * If a type is a subtype of a second type, then the second type
     covers the first type.

   * If a type has a self type, then its self type covers the type.

   * If a type 'X' enumerates its cases 'X1', 'X2', etc, then the union
     'X1|X2|...' of its cases covers the type.

   * If a generic type 'X' enumerates its cases, 'X1', 'X2', etc, which
     might involve the type parameters of 'X', then for any
     instantiation 'U' of 'X', and for each case 'Xi', we can construct
     a type 'Ui' by, for every type parameter 'T' of 'X', substituting
     the corresponding type argument of 'T' given in 'U' everywhere 'T'
     occurs in 'Xi', and then the union type 'U1|U2|...' of all the
     resulting types 'Ui' covers 'Y'.

   * If a type 'X' covers two types 'A' and 'B', then 'X' also covers
     their union 'A|B'.

   * If 'X' and 'Y' are both instantiations of a generic type 'G', and
     if the type 'Z' is formed by replacing every covariant argument in
     'Y' with the intersection of the upper bounds of the corresponding
     type parameter of 'G', after substitution of the given type
     arguments in 'Y' for any occurrences of the type parameters of 'G'
     in the upper bounds, except where the argument is already a subtype
     of the upper bounds, then if 'X' covers 'Z', then 'X' also covers
     'Y'.

   * Coverage is transitive.  If 'X' covers 'Y' and 'Y' covers 'Z', then
     'X' covers 'Z'.

   It follows that coverage obeys the identity property of
assignability: a type covers itself.  However, coverage does not obey
the noncircularity property of assignability.  It is possible to have
distinct types 'A' and 'B' where 'A' covers 'B' and 'B' covers 'A'.

   Case enumeration allows safe use of a type in a 'switch' statement,
or as the subject of the 'of' operator.  The compiler is able to
statically validate that the 'switch' contains an exhaustive list of all
cases of the type, by checking that the union of cases enumerated in the
'switch' covers the type, or that the second operand of 'of' covers the
type.

     Note: however, a type is _not_ considered automatically assignable
     to the union of its cases, or to its self type.  Instead, the type
     must be _explicitly_ narrowed to the union of its cases, nor to its
     self type, using either the 'of' operator or the 'switch'
     construct.  This narrowing type conversion can be statically
     checked--if 'X' covers 'Y' then 'Y of X' is guaranteed to succeed
     at runtime.  Unfortunately, and quite unintuitively, the compiler
     is not able to analyse coverage implicitly at the same time as
     assignability, because that results in undecidability!


File: ceylon-spec.info,  Node: cases,  Next: genericenumeratedtypes,  Prev: coverage,  Up: casesandcoverage

3.4.2 Cases
-----------

The 'of' clause does triple duty.  It's used to define self types and
type families, enumerated types, and enumerated type constraints. The
'of' clause may specify multiple elements, called _cases_.

CaseTypes: "of" CaseType ("|" CaseType)*

CaseType: ValueCase | PrimaryType

ValueCase: ("package" ".")? MemberName
   A type occurring in the 'of' clause may not involve variance
annotations 'in' or 'out', defined below in *note Type arguments and
variance: typeargumentvariance.

   If an interface or 'abstract' class with an 'of' clause has exactly
one case, and it is a type parameter of the interface or 'abstract'
class, or of the immediately containing type, if any, then that type
parameter is a _self type_ of the interface or 'abstract' class, and:

   * the self type parameter covers the declared type within the body of
     the declaration,

   * the type argument to the self type parameter in an instantiation of
     the declared type covers the instantiation, and

   * every type which extends or satisfies an instantiation of the
     declared type must also be covered by the type argument to the self
     type parameter in the instantiation.

     shared abstract class Comparable<Other>() of Other
             given Other satisfies Comparable<Other> {

         shared formal Integer compare(Other that);

         shared Integer reverseCompare(Other that)
                 => that.compare(this) of Other;

     }

     Comparable<Item> comp = ... ;
     Item item = comp of Item;
   Otherwise, an interface or 'abstract' class with an 'of' clause may
have multiple cases, but each case must be either:

   * a subtype of the interface or 'abstract' class, or

   * a value reference to a toplevel anonymous class, as defined in
     *note Anonymous classes: anonymousclasses, that is a subtype of the
     interface or 'abstract' class.

   Then the interface or 'abstract' class is an _enumerated type_, and
every subtype of the interface or 'abstract' class must be a subtype of
exactly one of the enumerated subtypes.  A class or interface may not be
a subtype of more than one case of an enumerated type.

   If a concrete class has an 'of' clause, then each case must be a
value reference to a value constructor of the class, as defined in *note
Constructors: constructors, and the class must be a toplevel class.
Then the concrete class is an enumerated type, and there may be no
additional non-partial constructors of the class that are not listed in
the 'of' clause.

     of larger | smaller | equal

     of Root<Element> | Leaf<Element> | Branch<Element>
   A type parameter with an 'of' clause may specify multiple cases, as
defined in *note Generic type constraints: generictypeconstraints.

   An 'of' clause may not contain:

   * two instantiations of the same type declaration, or

   * two value references to the same toplevel anonymous class or value
     constructor.


File: ceylon-spec.info,  Node: genericenumeratedtypes,  Next: disjointtypes,  Prev: cases,  Up: casesandcoverage

3.4.3 Generic enumerated types
------------------------------

If a generic enumerated type 'X' has a case type 'C', then 'C' must
directly extend or satisfy an instantiation 'Y' of 'X', and for each
type parameter 'T' of 'X' and corresponding argument 'A' of 'T' given in
'Y', either:

   * 'X' is covariant in 'T' and 'A' is exactly 'Nothing',

   * 'X' is contravariant in 'T' and 'A' is exactly the intersection of
     all upper bounds on 'T', or 'Anything' if 'T' has no upper bounds,
     or

   * 'C' is an instantiation of a generic type 'G' and 'A' is exactly
     'S' for some type parameter 'S' of 'G', and 'S' must have the same
     variance as 'T'.

   Furthermore, if 'C' is an instantiation of a generic type, then 'T'
may not occur twice in 'C'.

   For example, the following covariant enumerated type is legal:

     interface List<out Element>
             of Cons<Element> | nil { ... }

     class Cons<out Element>(Element element)
             satisfies List<Element> { ... }

     object nil
             satisfies List<Nothing> { ... }
   As is the following contravariant enumerated type:

     interface Consumer<in Event>
             of Logger | Handler<Event>
             given Event satisfies AbstractEvent { ... }

     interface Logger
             satisfies Consumer<AbstractEvent> { ... }

     interface Handler<in Event>
             satisfies Consumer<AbstractEvent>
             given Event satisfies AbstractEvent { ... }
   But the following enumerated type is not legal, since it is possible
to choose a legal argument 'T' of the type parameter 'Type' of
'Expression', such that the case types 'StringLiteral' and
'NumberLiteral' aren't subtypes of the instantiation 'Expression<T>':

     interface Expression<out Type>
             of Function<Type> | StringLiteral | NumberLiteral { ... }

     interface Function<out Type>
             satisfies Expression<Type> { ... }

     interface StringLiteral
             satisfies Expression<String> { ... } //error String is not exactly Nothing

     interface NumberLiteral
             satisfies Expression<Integer|Float> { ... } //error Integer|Float is not exactly Nothing

     Note: these rules could be relaxed to allow the definition of
     generic enumerated types where the list of cases of an
     instantiation of a generic type depends upon the given type
     arguments (a "generalized" algebraic type).


File: ceylon-spec.info,  Node: disjointtypes,  Prev: genericenumeratedtypes,  Up: casesandcoverage

3.4.4 Disjoint types
--------------------

Two types are said to be _disjoint_ if it is impossible to have a value
that is an instance of both types.  If 'X' and 'Y' are disjoint, then
their intersection 'X&Y' is the bottom type 'Nothing'.

   Two types 'X' and 'Y' are disjoint if either:

   * 'X' is a subtype of a type 'A' and 'Y' is a subtype of a type 'B',
     where 'A' and 'B' are distinct cases of an enumerated type,

   * 'X' and 'Y' are both classes and 'X' is not a subclass of 'Y' and
     'Y' is not a subclass of 'X',

   * 'X' is the class 'Null' and 'Y' is an interface,

   * 'X' is an anonymous class or an instantiation of a 'final' class
     and 'Y' is an instantiation of a class of interface, and 'X' does
     not inherit 'Y',

   * 'X' is an anonymous class or a 'final' class with no type
     parameters and 'Y' is a type in which no type parameter reference
     occurs, and 'X' is not a suptype of 'Y',

   * 'X' is a type parameter and 'Y' and the intersection of the upper
     bounds of 'X' are disjoint,

   * 'X' is a union type 'A|B' and both 'Y' and 'A' are disjoint and 'Y'
     and 'B' are disjoint,

   * 'X' is an enumerated type with cases 'A1|A2|...' and for every case
     'Ai' of 'X', 'Y' and 'Ai' are disjoint,

   * 'X' is an intersection type 'A&B' and either 'Y' and 'A' are
     disjoint or 'Y' and 'B' are disjoint, or

   * 'X' and 'Y' inherit disjoint instantiations of a generic type 'Z',
     that is, two instantiations of 'Z' that have the intersection
     'Nothing', as defined below, in *note Principal instantiation
     inheritance: principalinstantiationinheritance.

   Furthermore, as a special case, the types 'X' and 'Y' are disjoint
if:

   * 'X' is a subtype of some instantiation of 'Sequential', 'Y' is an
     instantiation of a class or interface that is not a subtype of any
     instantiation of 'Sequential', and 'Y' is not an instantiation of a
     class or interface that is inherited by 'Sequential',

   * 'X' has the principal supertype instantiation 'Sequence<A>', 'Y'
     has the principal supertype instantiation 'Sequential<B>', and 'A'
     and 'B' are disjoint,

   * 'X' has the principal supertype instantiation 'Sequential<A>', 'Y'
     has the principal supertype instantiation 'Tuple<J,B,V>', and 'A'
     and 'B' are disjoint or 'Sequential<A>' and 'V' are disjoint, or

   * 'X' has the principal supertype instantiation 'Tuple<I,A,U>', 'Y'
     has the principal supertype instantiation 'Tuple<J,B,V>', and 'A'
     and 'B' are disjoint or 'U' and 'V' are disjoint.

     Note: the soundness of these rules is guaranteed by the
     implementations of the 'sealed' types 'Sequence', 'Sequential',
     'Range', and 'Tuple' in the module 'ceylon.language'.


File: ceylon-spec.info,  Node: generictypeparameters,  Next: generictypearguments,  Prev: casesandcoverage,  Up: typesystem

3.5 Generic type parameters
===========================

* Menu:


* typeparametersandvariance:: Type parameters and variance
* variancevalidation:: Variance validation
* generictypeconstraints:: Generic type constraints

A function, class, or interface schema may be parameterized by one or
more generic type parameters.  A parameterized type schema defines a
type constructor, a function that produces a type given a tuple of
compatible type arguments.  A parameterized class or function schema
defines a function that produces the signature of an invokable operation
given a tuple of compatible type arguments.

TypeParameters: "<" (TypeParameter ",")* TypeParameter ">"
   A declaration with type parameters is called _generic_ or
_parameterized_.

   * A type schema with no type parameters defines exactly one type.  A
     parameterized type schema defines a template for producing types:
     one type for each possible combination of type arguments that
     satisfy the type constraints specified by the type.  The types of
     members of the this type are determined by replacing every
     appearance of each type parameter in the schema of the
     parameterized type definition with its type argument.

   * A function schema with no type parameters defines exactly one
     operation per type.  A parameterized function declaration defines a
     template for producing overloaded operations: one operation for
     each possible combination of type arguments that satisfy the type
     constraints specified by the method declaration.

   * A class schema with no type parameters defines exactly one
     instantiation operation.  A parameterized class schema defines a
     template for producing overloaded instantiation operations: one
     instantiation operation for each possible combination of type
     arguments that satisfy the type constraints specified by the class
     declaration.  The type of the object produced by an instantiation
     operation is determined by substituting the same combination of
     type arguments for the type parameters of the parameterized class
     schema.

     Note: by convention, type parameter names should be constructed
     from meaningful words.  The use of single-letter type parameter
     names is discouraged.  The name of a type parameter should be
     chosen so that declarations within the body of the parameterized
     declaration read naturally.  For example, 'class Entry<Key,Item>'
     is reasonable, since 'Key key' and 'Item item' read naturally
     within the body of the 'Entry' class.  The following identifier
     names usually refer to a type parameter: 'Element', 'Other',
     'This', 'Value', 'Key', 'Item', 'Absent', 'Argument', 'Args' and
     'Result'.  Avoid, where reasonable, using these names for
     interfaces and classes.


File: ceylon-spec.info,  Node: typeparametersandvariance,  Next: variancevalidation,  Up: generictypeparameters

3.5.1 Type parameters and variance
----------------------------------

A _type parameter_ allows a declaration to be abstracted over a
constrained set of types.

TypeParameter: Variance TypeName ("=" Type)?
   Every type parameter has a name and a _variance_.

Variance: ("out" | "in")?

   * A _covariant_ type parameter is indicated using the keyword 'out'.

   * A _contravariant_ type parameter is indicated using the keyword
     'in'.

   * By default, a type parameter is _invariant_.

   A type parameter may, optionally, have a _default type argument_. A
type parameter with a default type argument must occur after every type
parameter with no default type argument in the type parameter list.

   The default type argument for a type parameter must satisfy the
constraints on the type parameter.

     TODO: this restriction could be relaxed, and the assignability of
     the default type argument to the type constraints checked at
     use-sites where the default type argument is used in type
     expressions.

   A default type argument expression for a type parameter of a generic
declaration may not involve:

   * the type parameter itself,

   * any type parameter of the declaration that occurs later in the list
     of type parameters, nor

   * the generic declaration.

   Within the body of the schema it parameterizes, a type parameter is
itself a type.  The type parameter is a subtype of every upper bound of
the type parameter. However, a class or interface may not extend or
satisfy a type parameter.

     <Key, out Item>

     <in Message>

     <out Element=Object>

     <in Left, in Right, out Result>


File: ceylon-spec.info,  Node: variancevalidation,  Next: generictypeconstraints,  Prev: typeparametersandvariance,  Up: generictypeparameters

3.5.2 Variance validation
-------------------------

A covariant type parameter may only appear in _covariant positions_ of
the parameterized schema.  A contravariant type parameter may only
appear in _contravariant positions_ of the parameterized schema.  An
invariant type parameter may appear in any position.

   Furthermore, a type with a contravariant type parameter may only
appear in a covariant position in an extended type, satisfied type, case
type, or upper bound type constraint.

     Note: this restriction exists to eliminate certain undecidable
     cases described in the paper Taming Wildcards in Java's Type
     System, by Tate et al.

   To determine if a type expression occurs in a covariant or
contravariant position, we first consider how the type occurs
syntactically.

   For a generic function we examine the return type of the function,
which is a covariant position.

   For a generic type schema we examine each 'shared' member, along with
extended/satisfied types and case types.

     Note: since the visibility rules are purely lexical in nature, it
     is legal for a member expression occurring in the body of a class
     or interface to have a receiver expression other that is not a
     self-reference, as defined in *note Self references:
     selfreferences, and refer to an un-'shared' member of the class or
     interface.  In this special case, the member is treated as if it
     were 'shared' for the purposes of the following variance validation
     rules.

   * An extended type, satisfied type, or case type of the type schema
     itself is a covariant position.

   In a 'shared' method declaration of the parameterized type schema:

   * The return type of the method is a covariant position.

   * Any parameter type of the method is a contravariant position.

   * Any upper bound or enumerated bound of a type parameter of the
     method is a contravariant position.

   In a 'shared' attribute declaration that is neither variable nor
'late':

   * The type of the attribute is a covariant position.

   In a 'shared' reference declaration that is either variable or
'late':

   * The type of the attribute is an invariant position.

   In a 'shared' nested class declaration of the parameterized type
schema:

   * Any initializer parameter type of the class is a contravariant
     position.

   * Any callable constructor parameter type of the class is an
     invariant position of the class itself, but a contravariant
     position of any outer containing type.

   * Any upper bound or enumerated bound of a type parameter of the
     class is a contravariant position.

   * An extended type, satisfied type, or case type of the nested class
     is a covariant position.

   * Every covariant position of the nested class schema is a covariant
     position of the containing type schema.  Every contravariant
     position of the nested class schema is a contravariant position of
     the containing type schema.

   In a 'shared' nested interface declaration of the parameterized type
schema:

   * An extended type, satisfied type, or case type of the nested
     interface is a covariant position.

   * Every covariant position of the nested interface schema is a
     covariant position of the containing type schema.  Every
     contravariant position of the nested interface schema is a
     contravariant position of the containing type schema.

   For parameters of callable parameters, we first determine if the
callable parameter itself is covariant or contravariant:

   * A callable parameter of a method or nested class is contravariant.

   * A callable parameter of a covariant parameter is contravariant.

   * A callable parameter of a contravariant parameter is covariant.

   Then:

   * The return type of a covariant callable parameter is a covariant
     position.

   * The return type of a contravariant callable parameter is a
     contravariant position.

   * The type of a parameter of a covariant callable parameter is a
     contravariant position.

   * The type of a parameter of a contravariant callable parameter is a
     covariant position.

   Finally, to determine if a type parameter that occurs as a type
argument occurs in a covariant or contravariant position, we must
consider the declared variance of the corresponding type parameter:

   * A type argument of a covariant type parameter of a type in a
     covariant position is a covariant position.

   * A type argument of a contravariant type parameter of a type in a
     covariant position is a contravariant position.

   * A type argument of a covariant type parameter of a type in a
     contravariant position is a contravariant position.

   * A type argument of a contravariant type parameter of a type in a
     contravariant position is a covariant position.

   * A type argument of an invariant type parameter of a type in any
     position is an invariant position.

   * A type argument of any type parameter of a type in an invariant
     position is an invariant position.


File: ceylon-spec.info,  Node: generictypeconstraints,  Prev: variancevalidation,  Up: generictypeparameters

3.5.3 Generic type constraints
------------------------------

A parameterized method, class, or interface declaration may declare
constraints upon ordinary type parameters using the 'given' clause.

TypeConstraints: TypeConstraint+
   There may be at most one 'given' clause per type parameter.

TypeConstraint: "given" TypeName TypeConstraintInheritance

TypeConstraintInheritance: CaseTypes? SatisfiedTypes?

     Note that the syntax for a type constraint is essentially the same
     syntax used for other type declarations such as class and interface
     declarations.

   There are two different kinds of type constraint:

   * An _upper bound_, 'given X satisfies T', specifies that the type
     parameter 'X' is a subtype of a given type 'T'.

   * An _enumerated bound_, 'given X of T|U|V' specifies that the type
     parameter 'X' represents one of the enumerated types.

   The types listed in an enumerated bound must be mutually disjoint,
and each type must be a class or interface type.

     TODO: Should we allow unions in upper bounds?  Should we allow
     intersections in enumerated bounds?

   A single 'given' clause may specify multiple constraints on a certain
type parameter.  In particular, it may specify multiple upper bounds
together with an enumerated bound.  If multiple upper bounds are
specified, at most one upper bound may be a class, and at most one upper
bound may be a type parameter.

     Note: in Ceylon 1.0, a type parameter with multiple upper bounds
     may not have an upper bound which is another type parameter.

     given Value satisfies Ordinal<Value> & Comparable<Value>

     given Argument of String | Integer | Float
   A type parameter is a subtype of its upper bounds.

     class Holder<Value>(shared Value element)
             extends Object()
             given Value satisfies Object {
         shared actual Boolean equals(Object that) {
             return if (is Holder<Value> that
                 then element==that.element
                 else false;
         }
         shared actual Integer hash => element.hash;
     }
   Every type parameter has an implicit upper bound of type 'Anything'.

     TODO: eventually, we would like to have Ceylon's system of
     flow-sensitive typing support a special sort of'switch' over the
     cases of a type parameter with an enumerated bound:

          Characters uppercase<Characters>(Characters chars)
                 given Characters of String | Range<Character> {
              switch (Characters)
              case (satisfies String) {
                  return chars.uppercased;
              }
              case (satisfies Range<Character>) {
                  return chars.first.uppercased..chars.last.uppercased;
              }
          }

     Note: we have often searched for a need for lower bound type
     constraints.  The syntax would be:

          given T abstracts One|Two

     With union types they don't appear to be very useful, since it
     seems that almost every operation with a lower bound can be
     rewritten in a more general form using a union type.  However,
     perhaps lower bounds will someday turn out to be useful when
     combined with contravariant types.  (A lower bound on a parameter
     which occurs as the argument of a contravariant type is more like
     an upper bound).

     Note: since we have reified types, it would be possible to support
     a type constraint that allows instantiation of the type parameter.

          given T(Object arg)

     The problem with this is that then inferring 'T' is fragile.  And
     if we don't let it be inferred, we may as well pass 'T' as an
     ordinary parameter.  So Ceylon, unlike C#, doesn't support this.


File: ceylon-spec.info,  Node: generictypearguments,  Next: principalinstantiations,  Prev: generictypeparameters,  Up: typesystem

3.6 Generic type arguments
==========================

* Menu:


* typeargumentvariance:: Type arguments and variance
* typeargumentsubstitution:: Type argument substitution
* typeargumentsandconstraints:: Type arguments and type constraints
* producedtypes:: Applied types and and variance
* typeargumentinference:: Type argument inference

A list of _type arguments_ produces a new type schema from a
parameterized type schema, or a new function schema from a from a
parameterized function schema.  In the case of a type schema, this new
schema is the schema of an applied type, and is called an instantiation
of the parameterized type schema.

   A type argument list is a list of type arguments.

TypeArguments: "<" ((TypeArgument ",")* TypeArgument)? ">"
   A type argument is a type with a variance.

TypeArgument: Variance Type
   A type argument may itself be an applied type, or type parameter, or
may involve unions and intersections.

     <Key, List<Item>>

     <String, Person?>

     <String[](Integer), [{Object*}]>

     <out Object, in Nothing>
   Type arguments are assigned to type parameters according to the
positions they occur in the list.


File: ceylon-spec.info,  Node: typeargumentvariance,  Next: typeargumentsubstitution,  Up: generictypearguments

3.6.1 Type arguments and variance
---------------------------------

Every type argument has a variance:

   * if the type argument is annotated 'out' then it must be assigned to
     an invariant type parameter, and it is _covariant_,

   * if the type argument is annotated 'in' then it must be assigned to
     an invariant type parameter, and it is _contravariant_, or,

   * otherwise, the type argument has the same variance as the type
     parameter to which it is assigned.

   It is illegal for both the type parameter and its type argument to
have an explicit variance.


File: ceylon-spec.info,  Node: typeargumentsubstitution,  Next: typeargumentsandconstraints,  Prev: typeargumentvariance,  Up: generictypearguments

3.6.2 Type argument substitution
--------------------------------

Given the schema of a generic declaration, we form the new schema by
_type argument substitution_.  Each type argument is substituted for
every appearance of the corresponding type parameter in the schema of
the generic declaration, including:

   * attribute types,

   * function or method return types,

   * function or method parameter types,

   * class initializer and callable constructor parameter types, and

   * type arguments of extended classes and satisfied interfaces.

   When a type argument 'A' with no explicit variance annotation is
substituted for a type parameter 'T', all occurrences of 'T' in the
schema of the generic declaration are replaced with 'A'.

   For type arguments with explicit variance of a type parameter 'T',
substitution of the type argument depends upon whether an occurrence of
'T' is a covariant or contravariant position in the schema of the
generic declaration, as defined above in *note Variance validation:
variancevalidation.

   When a type argument 'out A' explicitly marked covariant is
substituted for a type parameter 'T':

   * Every occurrence of 'T' in a covariant position as a type argument
     of an invariant type parameter is replaced by 'out A'.

   * Every other occurrence of 'T' in a covariant position is replaced
     by 'A'.

   * Every occurrence of 'T' in a contravariant position is replaced by
     'Nothing'.

   * Every applied type expression 'E' involving 'A', and occurring as a
     type argument of an invariant type parameter, and which was
     replaced by 'F' according to the previous rules is replaced by 'out
     F'.

   When a type argument 'in A' explicitly marked contravariant is
substituted for a type parameter 'T':

   * Every occurrence of 'T' in a contravariant position as a type
     argument of an invariant type parameter is replaced by 'in A'.

   * Every other occurrence of 'T' in a contravariant position is
     replaced by 'A'.

   * Every occurrence of 'T' in a covariant position is replaced by the
     intersection of the upper bound type constraints on 'T' in which
     'T' itself does not occur covariantly, or by 'Anything' if there
     are no such constraints.

   * Every applied type expression 'E' involving 'A', and occurring as a
     type argument of an invariant type parameter, and which was
     replaced by 'F' according to the previous rules is replaced by 'out
     F'.


File: ceylon-spec.info,  Node: typeargumentsandconstraints,  Next: producedtypes,  Prev: typeargumentsubstitution,  Up: generictypearguments

3.6.3 Type arguments and type constraints
-----------------------------------------

A generic type constraint affects the type arguments that can be
assigned to a type parameter in any type argument list belonging
directly to:

   * a base expression or member expression

   * an applied type expression that occurs directly in a 'satisfies',
     'of', or 'extends' clause, or

   * a metamodel expression, as defined by *note Metamodel expressions:
     metamodelexpressions.

   A type constraint does _not_ apply to any type argument list
belonging to an applied type expression that occurs:

   * outside of the 'satisfies', 'of', and 'extends' clauses, or

   * as a type argument within these clauses.

   In locations where type constraints apply:

   * A type argument to a type parameter 'T' with an upper bound must be
     a type which is a subtype of all upper bounds of 'T' in the
     realization of the generic declaration, as defined in *note
     Realizations: realizations.

   * A type argument to a type parameter 'T' with an enumerated bound
     must be a subtype of one of the enumerated types of the bound on
     'T' in the realization of the generic declaration, or it must be a
     type parameter 'A' with an enumerated bound where every enumerated
     type of the bound on 'A' is a subtype of one of the enumerated
     types of the bound on 'T' in the realization of the generic
     declaration.

   A type argument list _conforms_ to a type parameter list if, for
every type parameter in the list, either:

   * there is a type argument to the type parameter, and either the type
     argument satisfies the constraints of the type parameter, or the
     type argument list occurs in a location where type constraints do
     not apply, or, alternatively,

   * there is no explicit type argument but the type parameter has a
     default type argument, in which case the type argument is defaulted
     by substituting the arguments of all type parameters that occur
     earlier in the list of type parameters of the declaration into this
     default type argument.

   There must be at least as many type parameters as type arguments.
There must be at least as many type arguments as type parameters without
default values.


File: ceylon-spec.info,  Node: producedtypes,  Next: typeargumentinference,  Prev: typeargumentsandconstraints,  Up: generictypearguments

3.6.4 Applied types and and variance
------------------------------------

If a type argument list conforms to a type parameter list, the
combination of the parameterized type together with the type argument
list is itself a type, called an _applied type_.  We also call the
applied type an _instantiation_ of the generic type.

   For a generic type 'X', the instantiations 'Y' and 'Z' of 'X'
represent the same type if and only if for every type parameter 'P' of
'X' and corresponding type arguments 'A' in 'Y' and 'B' in 'Z':

   * 'A' is exactly the same type as 'B',	and the variance of 'A' is the
     same as 'B',

   * 'A' and 'B' are both covariant type arguments, and both types are
     supertypes of 'P',

   * either 'A' or 'B' is a contravariant type argument with type
     precisely 'Nothing', and the other type argument is covariant and
     its type is a supertype of 'P',

   * both 'A' and 'B' have type precisely 'Nothing', and one is an
     invariant type argument, and the other is a covariant type
     argument, or

   * both 'A' and 'B' have types which are supertypes of 'P', and one is
     an invariant type argument, and the other is an contravariant type
     argument.

   For a generic type 'G', and instantiations 'Y' and 'Z' of 'G', 'Y' is
a subtype of 'Z' if and only if, for every type parameter 'T' of 'G',
and corresponding arguments 'A' specified in 'Y' and 'B' specified in
'Z':

   * 'B' is a covariant type argument, and 'T' is a subtype of 'B',

   * 'B' is a contravariant type argument, and the type 'B' is precisely
     'Nothing',

   * 'B' is a covariant type argument, and 'A' is not contravariant, and
     the type 'A' is a subtype of the type 'B',

   * 'B' is a contravariant type argument, and 'A' is not covariant, and
     the type 'B' is a subtype of the type 'A',

   * 'B' is an invariant type argument, 'A' is a covariant type
     argument, and 'T' is a subtype of both types, or

   * 'B' is an invariant type argument, 'A' is a contravariant type
     argument, and both types are precisely 'Nothing',

   * 'B' and 'A' are both invariant type arguments (neither covariant
     nor contravariant), and 'A' and 'B' are exactly the same type.

     Note that if 'A' is an invariant type argument in the instantiation
     'X<A>' of a generic type 'X<T>', then a type 'Z' is a subtype of
     'X<A>' if and only if 'Z' has the principal instantiation 'X<A>'.


File: ceylon-spec.info,  Node: typeargumentinference,  Prev: producedtypes,  Up: generictypearguments

3.6.5 Type argument inference
-----------------------------

When a direct invocation expression, as defined by *note Invocation
expressions: invocationexpressions, does not explicitly specify type
arguments, the type arguments are inferred from the argument expression
types.

   * In the case of a direct invocation of a function or class, type
     arguments are inferred for the type parameters of the function or
     class.

   * In the case of a direct invocation of a callable constructor, type
     arguments are inferred for the type parameters of the class to
     which the constructor belongs.

   The types of the argument expressions and the declared types of the
corresponding parameters determine an _inferred lower bound_ or
_inferred upper bound_ for each type parameter.

   If a list of argument expressions has types 'A1,A2,...' and the
corresponding list of parameters has declared types 'P1,P2,...' then:

   * The inferred lower bound for a type parameter 'T' of the generic
     declaration is the conjunction of all inferred lower bounds 'Ai' on
     'Pi' for 'T'.

   * The inferred upper bound for a type parameter 'T' of the generic
     declaration is the conjunction of all inferred upper bounds 'Ai' on
     'Pi' for 'T'.

   Given types 'A' and 'P', we determine the _inferred lower bound_ 'A'
on 'P' for 'T' according to the nature of 'A' and 'P':

   * If 'P' is exactly 'T', and the location at which 'P' occurs in the
     parameter list is not a contravariant location, the inferred lower
     bound 'A' on 'P' for 'T' is 'T abstracts A'.

   * If 'P' is a union type 'Q|R', the lower bound 'A' on 'P' for 'T' is
     the disjunction of the lower bound 'A' on 'Q' for 'T' with the
     lower bound 'A' on 'R' for 'T'.  _Note: this case is special._

   * If 'P' is an intersection type 'Q&R', the lower bound 'A' on 'P'
     for 'T' is the conjunction of the lower bound 'A' on 'Q' for 'T'
     with the lower bound 'A' on 'R' for 'T'.

   * If 'A' is a union type 'B|C', the lower bound 'A' on 'P' for 'T' is
     the conjunction of the lower bound 'B' on 'P' for 'T' with the
     lower bound 'C' on 'P' for 'T'.

   * If 'A' is an intersection type 'B&C', the lower bound 'A' on 'P'
     for 'T' is the disjunction of the lower bound 'B' on 'P' for 'T'
     with the lower bound 'C' on 'P' for 'T'.

   * If 'P' is an applied type 'Q<P1,P2,...>' of a parameterized type
     'Q', and 'A' is a subtype of an applied type 'Q<A1,A2,..>', the
     lower bound 'A' on 'P' for 'T' is the conjunction of all lower
     bounds 'Ai' on 'Pi' for 'T'.

   * Otherwise, if 'A' is not a union or intersection, and if 'P' is
     neither an applied type, a union, or an intersection, nor exactly
     'T', the lower bound 'A' on 'P' for 'T' is _null_.

   Where:

   * the conjunction of a lower bound 'T abstracts A' with a lower bound
     'T abstracts B' is the lower bound 'T abstracts A|B',

   * the disjunction of a lower bound 'T abstracts A' with a lower bound
     'T abstracts B' is the lower bound 'T abstracts A&B',

   * the conjunction or disjunction of a lower bound 'T abstracts A'
     with a null lower bound is 'T abstracts A', and

   * the conjunction or disjunction of two null lower bounds is null.

   Given types 'A' and 'P', we determine the _inferred upper bound_ 'A'
on 'P' for 'T' according to the nature of 'A' and 'P':

   * If 'P' is exactly 'T', and the location at which 'P' occurs in the
     parameter list is not a covariant location, the inferred upper
     bound 'A' on 'P' for 'T' is 'T satisfies A'.

   * If 'P' is a union type 'Q|R', the upper bound 'A' on 'P' for 'T' is
     the disjunction of the upper bound 'A' on 'Q' for 'T' with the
     upper bound 'A' on 'R' for 'T'.  _Note: this case is special._

   * If 'P' is an intersection type 'Q&R', the upper bound 'A' on 'P'
     for 'T' is the conjunction of the upper bound 'A' on 'Q' for 'T'
     with the upper bound 'A' on 'R' for 'T'.

   * If 'A' is a union type 'B|C', the upper bound 'A' on 'P' for 'T' is
     the disjunction of the upper bound 'B' on 'P' for 'T' with the
     upper bound 'C' on 'P' for 'T'.

   * If 'A' is an intersection type 'B&C', the upper bound 'A' on 'P'
     for 'T' is the conjunction of the upper bound 'B' on 'P' for 'T'
     with the upper bound 'C' on 'P' for 'T'.

   * If 'P' is an applied type 'Q<P1,P2,...>' of a parameterized type
     'Q', and 'A' is a subtype of an applied type 'Q<A1,A2,..>', the
     upper bound 'A' on 'P' for 'T' is the conjunction of all upper
     bounds 'Ai' on 'Pi' for 'T'.

   * Otherwise, if 'A' is not a union or intersection, and if 'P' is
     neither an applied type, a union, or an intersection, nor exactly
     'T', the upper bound 'A' on 'P' for 'T' is _null_.

   Where:

   * the conjunction of an upper bound 'T satisfies A' with an upper
     bound 'T satisfies B' is the upper bound 'T satisfies A&B',

   * the disjunction of an upper bound 'T satisfies A' with an upper
     bound 'T satisfies B' is the upper bound 'T satisfies A|B',

   * the conjunction or disjunction of an upper bound 'T satisfies A'
     with a null upper bound is 'T satisfies A', and

   * the conjunction or disjunction of two null upper bounds is null.

   The inferred type argument to a covariant type parameter 'T' of the
generic declaration is:

   * 'Nothing', if the inferred lower bound for 'T' is null, or,
     otherwise,

   * the type 'A', where the inferred lower bound for 'T' is 'T
     abstracts A'.

   The inferred type argument to a contravariant type parameter 'T' of
the generic declaration is:

   * 'Anything', if the inferred upper bound for 'T' is null, or,
     otherwise,

   * the type 'A', where the inferred upper bound for 'T' is 'T
     satisfies A'.

   An invariant type parameter 'T' of the generic declaration is
treated, for the purposes of type argument inference, as if it were
covariant or contravariant, depending upon how it occurs in the types of
parameters explicitly assigned arguments by the direct invocation, and,
in the case of direct invocation of a generic function or class alias,
upon how it occurs in the return type of the function or aliased type of
the class alias.

   * If the generic declaration is a function or class alias, and 'T'
     occurs covariantly in its return type or aliased type, and does not
     occur contravariantly or invariantly in its return type or aliased
     type, then 'T' is treated as covariant.

   * If the generic declaration is a function or class alias, and 'T'
     occurs contravariantly in its return type or aliased type, and does
     not occur covariantly or invariantly in its return type or aliased
     type, then 'T' is treated as contravariant.

   * Otherwise, if 'T' occurs contravariantly in the type of any
     parameter to which an argument is explicity assigned by the
     argument list of the direct invocation, and does not occur
     covariantly or invariantly in the type of any parameter to which an
     argument is explicitly assigned, then 'T' is treated as
     contravariant.

   * Finally, if none of the above cases apply, 'T' is treated as
     covariant.

   An argument expression with no type occurring in a 'dynamic' block,
as defined in *note Dynamic blocks: dynamicblocks, may cause type
argument inference to fail.  When combining bounds using union, any
constituent bound with no type results in a bound with no type.  When
combining bounds using intersection, any constituent bound with no type
is eliminated.  If the resulting inferred upper or lower bound has no
type, type argument inference is impossible for the type argument, and
type arguments must be specified explicitly.

   Finally, when every type parameter 'Pi' has been assigned an inferred
type argument 'Ai', each inferred type argument is adjusted according to
the upper bound type constraints on 'Pi'.  The final inferred type
argument is the intersection of 'Ai' with every type 'Vj' formed by
substituting all 'Ai's for their corresponding 'Pi's in an upper bound
'Uj' of 'Pi'.

   If the inferred type argument does not satisfy the generic type
constraints on 'T', a compilation error results.

   Consider the following invocation:

     [Element+] prepend<Element>(Element head, Element[] sequence) { ... }
     value result = prepend(null, {"hello", "world"});
   The inferred type of 'Element' is the union type 'String?'.

   Now consider:

     class Bag<out Element>(Element* elements) {
         shared Bag<ExtraElement> with<ExtraElement>(ExtraElement* elements)
                 given ExtraElement abstracts Element { ... }
     }
     Bag<String> bag = Bag("hello", "world");
     value biggerBag = bag.with(1, 2, 5.0);
   The inferred type of 'ExtraElement' is the union type
'Integer|Float|String'.

   Finally consider:

     interface Delegate<in Value> { ... }
     class Consumer<in Value>(Delegate<Value>* delegates) { ... }
     Delegate<String> delegate1 = ... ;
     Delegate<Object> delegate2 = ... ;
     value consumer = Consumer(delegate1, delegate2);
   The inferred type of 'Value' is 'Consumer<String>'.

     TODO: What about upper bounds in which the type parameter itself
     appears (the infamous self-type problem with 'Comparable' and
     'Numeric') or in which another type parameter appears?

   An inferred type argument never involves an anonymous class, as
defined in *note Anonymous classes: anonymousclasses.  When an inferred
type would involve an anonymous class type, the anonymous class is
replaced by the intersection of the class type it extends with all
interface types it satisfies.


File: ceylon-spec.info,  Node: principalinstantiations,  Prev: generictypearguments,  Up: typesystem

3.7 Principal instantiations and polymorphism
=============================================

* Menu:


* inheritedinstantiations:: Inherited instantiations
* typeargumentdistinctness:: Type argument distinctness
* principalinstantiationinheritance:: Principal instantiation inheritance
* principalinstantiationofasupertype:: Principal instantiation of a supertype
* refinement:: Refinement
* qualifiedtypes:: Qualified types
* realizations:: Realizations

Inheritance interacts with type parameterization to produce subtyping
relationships between instantiations of generic types.  The notion of an
_inherited instantiation_ and the notion of a _principal instantation_
help us reason about these relationships.

     Warning: this section is not for the faint of heart.  Feel free to
     skip to *note Declarations: declarations, unless you're really,
     really interested in precisely how the compiler reasons about
     inheritance of generic types.


File: ceylon-spec.info,  Node: inheritedinstantiations,  Next: typeargumentdistinctness,  Up: principalinstantiations

3.7.1 Inherited instantiations
------------------------------

For a generic type 'G', inheritance produces subtypes with _inherited
instantiations_ of the generic type.

   * If a type 'X' directly extends or satisfies an instantiation 'V' of
     'G', then 'X' has the inherited instantiation 'V' of 'G'.

   * If a generic type 'H' extends or satisfies an instantiation 'V' of
     'G', that may involve the type parameters of 'H', then for any
     instantiation 'U' of 'H', we can construct an instantiation 'W' of
     'G' by, for every type parameter 'T' of 'H', substituting the type
     argument of 'T' given in 'U' everywhere 'T' occurs in 'V', and then
     'U' has the inherited instantiation 'W' of 'G'.

   * If a type 'X' is a subtype of a type 'Y', and 'Y' has an inherited
     instantiation 'W' of a generic type 'G', then 'X' also has this
     inherited instantiation.


File: ceylon-spec.info,  Node: typeargumentdistinctness,  Next: principalinstantiationinheritance,  Prev: inheritedinstantiations,  Up: principalinstantiations

3.7.2 Type argument distinctness
--------------------------------

A pair of type arguments 'A' and 'B' are considered:

   * _provably distinct_, if neither 'A' nor 'B' involves a type
     parameter and either:

        * both arguments are invariant, and are not exactly the same
          type,

        * one argument is covariant and the other argument is invariant
          and is not a subtype of the covariant argument, or

        * one argument is contravariant and the other argument is
          invariant and is not a supertype of the contravariant
          argument,

   * _provably not distinct_, if either:

        * both arguments are invariant, and are exactly the same type,

        * both arguments are covariant,

        * both arguments are contravariant,

        * one argument is covariant and the other argument is invariant
          and is a subtype of the covariant argument, or

        * one argument is contravariant and the other argument is
          invariant and is a supertype of the contravariant argument,

   * otherwise, _possibly distinct_, if either 'A' or 'B' involves a
     type parameter and 'A' and 'B' are not provably not distinct, or if
     'A' and 'B' have opposite variances.

     Note: the unfortunate case of possible distinctness is an
     incompleteness in the type system arising from the fact that Ceylon
     does not currently allow a type argument with both an upper and a
     lower bound, that is, a type argument of form 'in X out Y'.


File: ceylon-spec.info,  Node: principalinstantiationinheritance,  Next: principalinstantiationofasupertype,  Prev: typeargumentdistinctness,  Up: principalinstantiations

3.7.3 Principal instantiation inheritance
-----------------------------------------

If a class or interface type 'X' has the inherited instantiations 'V'
and 'W' of some generic type 'Y', then:

   * for every invariant type parameter 'T' of 'Y', the type argument
     'A' of 'T' given in 'V' and the type argument 'B' of 'T' given in
     'W' must be exactly the same type, and, furthermore,

   * 'X' is a subtype of an instantiation 'U' of 'Y' such that 'U' is a
     subtype of 'V&W'.

   Therefore, if a type 'X' is a subtype of the instantiations 'V' and
'W' of some generic type 'Y', then either:

   * for some invariant type parameter 'T' of 'Y', the argument 'A' of
     'T' given in 'V' and the argument 'B' of 'T' given in 'W' are
     provably distinct type arguments, and then the type 'V&W' is the
     bottom type 'Nothing', and we say that 'V' and 'W' are _disjoint
     instantiations_ of 'Y', or

   * for some invariant type parameter 'T' of 'Y', the argument of 'A'
     of 'T' given in 'V' and the argument 'B' of 'T' given in 'W' are
     possibly distinct, and then we say that 'V' and 'W' are
     _irreconcilable instantiations_ of 'Y', or

   * otherwise, 'X' must be a subtype of an instantiation 'P' of 'Y'
     formed by taking each type parameter 'T' of 'Y', and constructing a
     type argument 'C' for 'T' from the type arguments 'A' of 'T' given
     in 'V' and 'B' of 'T' given in 'W':

        * if 'A' and 'B' are both invariant, then they must be exactly
          the same type, and 'C' is the same type as 'A' and 'B',

        * if both 'A' and 'B' are covariant, then 'C' is 'out A&B'

        * if both 'A' and 'B' are contravariant, then 'C' is 'in A|B',

        * if either 'A' or 'B' is covariant and the other is invariant,
          with exact type 'D', then 'C' is just 'D', or

        * if either 'A' or 'B' is contravariant, and the other is
          invariant, with exact type 'D', then 'C' is just 'D'.

   Finally, the following identities result from principal instantiation
inheritance.  For any generic type 'X<T>', and for any given types 'A'
and 'B':

   * 'X<A>&X<B>' is exactly equivalent to 'X<A&B>' if 'X<T>' is
     covariant in 'T', unless either 'A' or 'B' involves type
     parameters, and

   * 'X<A>&X<B>' is exactly equivalent to 'X<A|B>' if 'X<T>' is
     contravariant in 'T', unless either 'A' or 'B' involves type
     parameters.


File: ceylon-spec.info,  Node: principalinstantiationofasupertype,  Next: refinement,  Prev: principalinstantiationinheritance,  Up: principalinstantiations

3.7.4 Principal instantiation of a supertype
--------------------------------------------

If a type 'X' is a subtype of some instantiation 'V' of a generic type
'Y', then, as a result of the principal instantiation inheritance
restriction, we can form a unique instantiation of 'Y' that is a subtype
of every instantiation of 'Y' to which 'X' is assignable.  We call this
type the _principal instantiation of Y for X_.

   We compute principal instantiations by making use of the identities
observed above in *note Union types: uniontypes, *note Intersection
types: intersectiontypes, and *note Principal instantiation inheritance:
principalinstantiationinheritance. For any generic type 'X':

   * The principal instantiation of the union 'U|V' of two
     instantiations of 'X', 'U' and 'V', is an instantiation 'P' of 'X'
     formed by taking each type parameter 'T' of 'X' and constructing a
     type argument 'C' for 'T' from the type arguments 'A' of 'T' given
     in 'U' and 'B' of 'T' given in 'V':

        * if either 'A' or 'B' is covariant, and neither is
          contravariant, then 'C' is the covariant type argument 'out
          A|B',

        * if either 'A' or 'B' is contravariant, and neither is
          covariant, then 'C' is the contravariant type argument 'in
          A&B', or

        * if both 'A' and 'B' are invariant, and if 'A' and 'B' are
          exactly the same type, then 'C' is this type.

   * The principal instantiation of the intersection 'U&V' of two
     instantiations of 'X', 'U' and 'V', is an instantiation 'P' of 'X'
     formed by taking each type parameter 'T' of 'X' and constructing a
     type argument 'C' for 'T' from the type arguments 'A' of 'T' given
     in 'U' and 'B' of 'T' given in 'V':

        * if either 'A' or 'B' is covariant, and neither is
          contravariant, then 'C' is the covariant type argument 'out
          A&B',

        * if either 'A' or 'B' is contravariant, and neither is
          covariant, then 'C' is the contravariant type argument 'in
          A|B', or

        * if both 'A' and 'B' are invariant, and if 'A' and 'B' are
          exactly the same type, then 'C' is this type.

   * Finally, the principal instantiation of a generic type 'X' for a
     type 'Y' which has one or more inherited instantiations of 'X' is
     the principal instantiation of the intersection of all the
     inherited instantiations of 'X'.

     Note: since we do not support type arguments with both upper and
     lower bounds, there are two cases where we cannot form a principal
     instantiation for an intersection type.

        * Intersections such as 'X<in A> & X<out B>', where the
          principal instantiation would be 'X<in A out B>'.

        * An intersection 'X<A> & X<P>' of two instantiations of an
          invariant type, 'X<T>' where one type argument 'P' is a type
          parameter.  The principal instantiation should be 'X<in A|P
          out A&P>'.

     In these cases we simply disallow references to members of the
     intersection type.


File: ceylon-spec.info,  Node: refinement,  Next: qualifiedtypes,  Prev: principalinstantiationofasupertype,  Up: principalinstantiations

3.7.5 Refinement
----------------

A class or interface may declare an 'actual' member with the same name
as a member that it inherits from a supertype if the supertype member is
declared 'formal' or 'default'.  Then we say that the first member
_refines_ the second member, and it must obey restrictions defined in
*note Member class refinement: classrefinement, *note Method refinement:
methodrefinement, or *note Attribute refinement: attributerefinement.

   A declaration may not be annotated both 'formal' and 'default'.

   If a declaration is annotated 'formal', 'default', or 'actual' then
it must also be annotated 'shared'.

   For any class or interface 'X', and for every declared or inherited
member of 'X' that is not refined by some other declared or inherited
member of 'X', and for every other member declared or inherited by 'X'
that directly or indirectly refines a declaration that the first member
itself directly or indirectly refines, the principal instantiation for
'X' of the type that declares the first member must be a subtype of the
principal instantiation for 'X' of the type that declares the second
member.

     Note: a related restriction is defined in *note Declaration name
     uniqueness: declarationnameuniqueness.


File: ceylon-spec.info,  Node: qualifiedtypes,  Next: realizations,  Prev: refinement,  Up: principalinstantiations

3.7.6 Qualified types
---------------------

A type declaration that directly occurs in the body of another type is
called a _nested type_.  If a nested type is annotated 'shared', it may
be used in a type expression outside the body in which it is declared,
if and only if it occurs as a _qualified type_, as specified in *note
Type expressions: typeexpressions.

   The qualified types 'X.U' and 'Y.V' are exactly the same types if and
only if 'U' is exactly the same type as 'V', and in the case that this
type is a member of a generic type 'Z', then the principal instantiation
of 'Z' for 'X' is exactly the same type as the principal instantiation
of 'Z' for 'Y'.

   A qualified type 'X.U' is a subtype of a qualified type 'Y.V' if 'U'
is a subtype of 'V', and in the case that 'V' is a member of a generic
type 'Z', then 'X' is a subtype of the principal instantiation of 'Z'
for 'Y'.


File: ceylon-spec.info,  Node: realizations,  Prev: qualifiedtypes,  Up: principalinstantiations

3.7.7 Realizations
------------------

Given a member declared by 'Y', and a declaration that refines it, we
can construct a _refined realization_ of the member or nested type:

   * first determine the principal instantiation of 'Y' for the class or
     interface which refines the member, and then

   * substitute the type arguments in this principal instantiation into
     the member schema.

   Given an unqualified reference, as defined in *note Unqualified
reference resolution: unqualifiedreferenceresolution, to a declaration,
and, in the case of a generic declaration, a list of type arguments for
the type parameters of the declaration, we can construct an _unqualified
realization_ of the declaration:

   * if the declaration is a member declared by a type 'Y', first
     determine the principal instantiation of 'Y' for the inheriting or
     declaring class or interface, and then

   * again, only if the declaration is a member declared by a type,
     substitute the type arguments in this principal instantiation into
     the declaration schema, and, finally,

   * substitute the type arguments into the declaration schema.

   Given a qualified reference, as defined in *note Qualified reference
resolution: qualifiedreferenceresolution, with a qualifying type 'X', to
a member or nested type declared by 'Y', and, in the case of a generic
member or generic nested type, a list of type arguments for the type
parameters of the member, we can construct a _qualified realization_ of
the member or nested type:

   * first determining the principal instantiation of 'Y' for 'X', and
     then

   * substituting the type arguments in this principal instantiation
     into the declaration schema, and, finally,

   * in the case of a generic member or generic nested type,
     substituting the type arguments into the declaration schema.

   If, for any given qualified or unqualified reference, it is
impossible to form the principal instantiation of the type that declares
the referenced declaration, due to the hole described above in *note
Principal instantiation of a supertype:
principalinstantiationofasupertype, it is impossible to form a
realization, and the reference to the declaration is illegal.


File: ceylon-spec.info,  Node: declarations,  Next: statementblocks,  Prev: typesystem,  Up: Top

4 Declarations
**************

* Menu:


* compilationunitstructure:: Compilation unit structure
* imports:: Imports
* parameters:: Parameters
* interfaces:: Interfaces
* classes:: Classes
* typealiasedeclarations:: Type aliases
* functions:: Functions
* values:: Values
* constructors:: Constructors

Ceylon is a statically typed language.  Classes, interfaces, functions,
values and aliases must be declared before use.  The declaration of a
function or value must include an explicit type, or allow the type to be
inferred.  Static typing allows the compiler to detect many errors,
including:

   * typing errors in identifier names,

   * references to types which do not exist or are not visible,

   * references to type members which do not exist or are not visible,

   * argument lists which do not match parameter lists,

   * type argument lists which do not match type parameter lists,

   * operands to which an operator cannot apply,

   * incompatible assignment of an expression of one type to a program
     element of a different type,

   * evaluation of a value before it has been explicitly specified or
     assigned,

   * assignment to a non-'variable' value,

   * failure to refine a 'formal' member of a supertype,

   * refinement of a non-'formal', non-'default' member of a supertype,

   * 'switch' statements which do not exhaust all cases of an enumerated
     type.

   All declarations follow a general pattern:

     Annotations
     (keyword | Type) (TypeName | MemberName) TypeParameters? Parameters*
     CaseTypes? ExtendedType? SatisfiedTypes?
     TypeConstraints?
     (Definition | ";")
   A type parameter does not need an explicit declaration of this form
unless it has constraints.  In the case that it does have constraints,
the constraint declaration does follow the general pattern.

   This consistent pattern for declarations, together with the strict
block structure of the language, makes Ceylon a highly regular language.


File: ceylon-spec.info,  Node: compilationunitstructure,  Next: imports,  Up: declarations

4.1 Compilation unit structure
==============================

* Menu:


* topleveldeclarations:: Toplevel and nested declarations
* packages:: Packages

A _compilation unit_ is a text file, with the filename extension
'.ceylon'.

     Note: it is recommended that source file names contain only
     characters from the ASCII character set.  This minimizes problems
     when transferring Ceylon source between operating systems.

   There are three kinds of compilation unit:

   * A regular compilation unit contains a list of toplevel type, value,
     or function definitions.

   * A _module descriptor_, defined in *note Module descriptors:
     moduledescriptors, contains a 'module' declaration.  The file must
     be named 'module.ceylon'.

   * A _package descriptor_, defined in *note Package descriptors:
     packagedescriptors, contains a 'package' declaration.  The file
     must be named 'package.ceylon'.

   Any compilation unit may begin with a list of imported types, values,
and functions.

Import* (ModuleDescriptor | PackageDescriptor | Declaration*)


File: ceylon-spec.info,  Node: topleveldeclarations,  Next: packages,  Up: compilationunitstructure

4.1.1 Toplevel and nested declarations
--------------------------------------

A _toplevel declaration_ defines a type--a class or interface--or a type
alias, or a function or value.

Declaration: FunctionValueDeclaration | TypeDeclaration | ParameterDeclaration

FunctionValueDeclaration: FunctionDeclaration | ValueDeclaration | SetterDeclaration

TypeDeclaration: ClassDeclaration | ObjectDeclaration | InterfaceDeclaration | TypeAliasDeclaration
   A toplevel declaration is not polymorphic and so may not be annotated
'formal', 'default', or 'actual'.

     Note: in a future release of the language, we might relax this
     restriction and support package extension with toplevel member
     refinement.  This can be viewed as a regularization of the
     language.  The practical application is that it would make toplevel
     invocations and instantiations polymorphic, obviating the need for
     things like dependency injection.

   Most toplevel declarations contain nested declarations.

   Nested declarations are often mixed together with executable
statements.


File: ceylon-spec.info,  Node: packages,  Prev: topleveldeclarations,  Up: compilationunitstructure

4.1.2 Packages
--------------

Each compilation unit belongs to exactly one _package_.  Every toplevel
declaration of the compilation unit also belongs directly to this
package.  The package is identified by the location of the text file on
the file system, relative to a root _source directory_, as defined in
*note Source layout: sourcelayout.

   A package is a namespace.  A full package name is a period-separated
list of identifiers.

FullPackageName: PackageName ("." PackageName)*

     Note: it is recommended that package names contain only lowercase
     characters and decimal digits from the ASCII character set.

   There is also a _default package_ whose name is empty.  It is
impossible to import declarations from this package.

   Every package belongs to exactly one module, as specified in *note
Module architecture: modules.  The default package belongs to the
default module.


File: ceylon-spec.info,  Node: imports,  Next: parameters,  Prev: compilationunitstructure,  Up: declarations

4.2 Imports
===========

* Menu:


* typeimports:: Type imports
* anonymousclassimports:: Anonymous class imports
* methodattributeimports:: Function and value imports
* aliasimports:: Alias imports
* wildcardimports:: Wildcard imports
* importedname:: Imported name

Code in one compilation unit may refer to a toplevel declaration in
another compilation unit in the same package without explicitly
importing the declaration. It may refer to a declaration defined in a
compilation unit in another package only if it explicitly _imports_ the
declaration using the 'import' statement.

   An 'import' statement specifies the name of a package to import from,
and a list of declarations to import from that package.

Import: "import" FullPackageName ImportElements
   A _toplevel_ 'import' statement is an 'import' statement that occurs
at the beginning of a compilation unit.  A _local_ 'import' statement is
an 'import' statement that occurs at the beginning of a block, as
defined in *note Blocks and statements: blocksandstatements, class body,
as defined in *note Classes: classes, or interface body, as defined in
*note Interfaces: interfaces.

   An 'import' statement may introduce names into a _namespace_:

   * A toplevel 'import' statement may introduce names into the
     _toplevel namespace_ of the compilation unit in which it occurs.

   * A local 'import' statement may introduce names into the _local
     namespace_ of block, class body, or interface body in which it
     occurs.

   For a given package:

   * in each compilation unit, there may be at most one toplevel
     'import' statement that imports the package, and

   * in each block, class body, or interface body, there may be at most
     one local 'import' statement that imports the package.

   An 'import' statement may import from a package if and only if:

   * the package belongs to the same module as the compilation unit
     containing the 'import' statement, as specified by *note Source
     layout: sourcelayout, or

   * the package is declared 'shared' in its package descriptor, as
     defined by *note Package descriptors: packagedescriptors, and the
     module descriptor of the module to which the compilation unit
     containing the 'import' statement belongs, as specified by *note
     Source layout: sourcelayout, explicitly or implicitly imports the
     module containing the package, as defined by *note Module
     descriptors: moduledescriptors.

   Each 'import' statement imports one or more toplevel declarations
from the given package, specifying a list of _import elements_.

ImportElements: "{" (ImportElement ",")* (ImportElement | ImportWildcard) "}"

ImportElement: ImportTypeElement | ImportObjectElement | ImportFunctionValueElement
   An import element is a reference to either:

   * a single toplevel type (a class, interface, or alias) of the
     package,

   * a single toplevel function or value of the package, or

   * all toplevel declarations of the package.

   An import element belonging to a toplevel 'import' may either:

   * introduce a name into the toplevel namespace of the compilation
     unit in which it occurs, or

   * result in an alias for a member of a type within the compilation
     unit in which it occurs.

   Every import element belonging _directly_ to a toplevel 'import'
statement introduces a name into the toplevel namespace of the
compilation unit.

   An import element belonging to a local 'import' may either:

   * introduce a name into the namespace of the block, class body, or
     interface body in which it occurs, or

   * result in an alias for a member of a type within the block, class
     body, or interface body in which it occurs.

   Every import element belonging _directly_ to a local 'import'
statement introduces a name into the namespace of the block, class body,
or interface body in which it occurs.

   An import element may not refer to a declaration that is not visible
to the compilation unit, as defined by *note Visibility: visibility.

   An 'import' statement may not contain two import elements which refer
to the same declaration.

   Note that toplevel declarations in the package 'ceylon.language'
never need to be explicitly imported.  They are implicitly imported by
every compilation unit.

     Note: the compiler produces a warning if an imported function or
     value hides, as defined in *note Hidden declarations:
     hiddendeclarations, any of the modifiers declared in
     'ceylon.language' listed in *note Declaration modifiers:
     declarationmodifiers, unless the modifier itself has an alias
     import in the compilation unit.

     Note: an unused import results in a compiler warning.


File: ceylon-spec.info,  Node: typeimports,  Next: anonymousclassimports,  Up: imports

4.2.1 Type imports
------------------

An import element that specifies a type name imports the toplevel type
with that name from the imported package or type.

ImportTypeElement: TypeAlias? TypeName ImportElements?
   The specified name must be the name of a type declaration belonging
to the imported package or type.

     import ceylon.collection { MutableSet, MutableList, MutableMap }
   The import element may be followed by a list of nested import
elements:

   * if the import element introduces a name into a namespace, and if a
     nested import element is a reference to a constructor, then the
     nested import element also introduces a name into the same
     namespace, and need not specify an alias, or, otherwise

   * the nested import element only defines an alias for the referenced
     member of the imported type, and this alias must be specified
     explicitly.

     Note: an import element referring to a 'static' member of a Java
     class imports the static member into the toplevel namespace of the
     compilation unit.  However, this behavior is outside the scope of
     this specification.


File: ceylon-spec.info,  Node: anonymousclassimports,  Next: methodattributeimports,  Prev: typeimports,  Up: imports

4.2.2 Anonymous class imports
-----------------------------

An import element that specifies the name of an anonymous class, as
defined in *note Anonymous classes: anonymousclasses, imports the
anonymous class with that name from the imported package or type.

ImportObjectElement: FunctionValueAlias? MemberName ImportElements?
   The specified name must be the name of an anonymous class declaration
belonging to the imported package or type.

     import ceylon.file { home, current }
   The import element may be followed by a list of nested import
elements:

   * if the import element introduces a name into a namespace, then a
     nested import element also introduces a name into the same
     namespace, and need not specify an alias, or, otherwise

   * the nested import element only defines an alias for the referenced
     member of the imported anonymous class, and this alias must be
     specified explicitly.


File: ceylon-spec.info,  Node: methodattributeimports,  Next: aliasimports,  Prev: anonymousclassimports,  Up: imports

4.2.3 Function and value imports
--------------------------------

An import element that specifies a function or value name imports the
toplevel function or value with that name from the imported package or
type.

ImportFunctionValueElement: FunctionValueAlias? MemberName
   The specified name must be the name of a function or value
declaration belonging to the imported package or type.

     import ceylon.math.float { sqrt, e, pi }


File: ceylon-spec.info,  Node: aliasimports,  Next: wildcardimports,  Prev: methodattributeimports,  Up: imports

4.2.4 Alias imports
-------------------

The optional alias clause in a fully-explicit import allows resolution
of cross-namespace declaration name collisions.

TypeAlias: TypeName "="

FunctionValueAlias: MemberName "="
   An alias assigns a different name to the imported declaration, or to
a member of the imported declaration.  This name is visible within the
compilation unit, block, class body, or interface body in which the
'import' statement occurs.

     import java.util { JavaMap = Map }

     import my.math { fib = fibonnacciNumber }

     import java.lang {
         Math { sin, cos, ln=log },
         System { sysprops=properties },
         Char=Character { upper=toUpperCase, lower=toLowerCase, char=charValue }
     }


File: ceylon-spec.info,  Node: wildcardimports,  Next: importedname,  Prev: aliasimports,  Up: imports

4.2.5 Wildcard imports
----------------------

The elipsis '...' acts as a wildcard in 'import' statements.  An
'import' statement that specifies a wildcard imports every toplevel
declaration of the imported package, except for any declaration whose
name collides with the name of a declaration contained directly in the
compilation unit, block, class body, or interface body in which the
'import' statement occurs.

ImportWildcard: "..."
   An 'import' statement may specify a list of alias imports followed by
a wildcard.  In this case, the alias imports are imported with the
specified names, and all other toplevel declarations are imported with
their declared names.

     import ceylon.collection { ... }

     import my.math { fib = fibonnacciNumber, ... }

     Note: overuse of wildcard imports is discouraged.


File: ceylon-spec.info,  Node: importedname,  Prev: wildcardimports,  Up: imports

4.2.6 Imported name
-------------------

Inside a compilation unit which imports a declaration, the declaration
may be referred to, as specified in *note Unqualified reference
resolution: unqualifiedreferenceresolution. and *note Qualified
reference resolution: qualifiedreferenceresolution, by its _imported
name_:

   * For an import element with an alias, the imported name is the
     alias.

   * For an import element with no alias, or for a wildcard import, the
     imported name is the original name of the declaration.

   An import element may not result in an imported name that is the same
as the name of a declaration directly contained in the compilation unit,
block, class body, or interface body in which the import element occurs.

   Two import elements occurring in the same compilation unit, block,
class body, or interface body, which import into the toplevel namespace
of the compilation unit, or into a local scope, may not result in the
same imported name.

   Two nested import elements belonging to the same import element may
not result in the same imported name.

   _Note: if an imported declaration is already referenceable within a
compilation unit without the import statement, for example, if it is
defined in the same package, or in ceylon.language, then, even with the
import statement, it is still referenceable via its declared name, as
well as via the imported name._


File: ceylon-spec.info,  Node: parameters,  Next: interfaces,  Prev: imports,  Up: declarations

4.3 Parameters
==============

* Menu:


* parameterlists:: Parameter lists
* requiredparameters:: Required parameters
* defaultedparameters:: Defaulted parameters
* valueparameters:: Value parameters
* callableparameters:: Callable parameters
* sequencedparameters:: Variadic parameters

A function, class, or callable constructor declaration may declare
_parameters_.  A parameter is a value or function belonging to the
declaration it parameterizes.  Parameters are distinguished from other
values or functions because they occur in a _parameter list_.  A value
or function is a parameter of a function, class, or constructor if it
is:

   * declared inline in a parameter list of the function, class, or
     callable constructor, or

   * declared normally, within the body of the class, function, or
     callable constructor, but named in a parameter list of the class,
     function, or callable constructor.

   A parameter list of a function, class, or constructor may have one or
more elements without explicit type declarations.  Each such element is
interpreted as the name of a parameter declaration occurring in the body
of the class, function, or constructor, and there must be a value or
function declaration with that name.  For a function, such an element is
only allowed in the last parameter list of the function.

   As a special exception, if a parameter of an anonymous function has
no explicit type declaration, and there is no declaration with the given
name occurring in the body of the anonymous function, then the type of
the parameter must be inferable, according to *note Anonymous function
parameter type inference: parametertypeinference.

   Conversely, every parameter declaration that occurs outside a
parameter list must have the same name as a parameter with no explicit
type that occurs in the parameter list of the function, class, or
constructor in whose body the parameter declaration directly occurs, and
its default argument, if any, must be specified in the parameter list.

   A parameter declaration may only occur in a parameter list, or
directly, as defined by *note Block structure and references:
blockstructure, in the body of a class, function, or callable
constructor.  A parameter declaration may not occur directly in the body
of a getter, setter, or value constructor, nor in the body of a control
structure.  Nor may a parameter declaration appear as a toplevel
declaration in a compilation unit.

ParameterDeclaration: (ValueParameter | CallableParameter | VariadicParameter) ";"
   The following class definitions are semantically identical:

     class Person(shared String name, shared variable Integer age=0, Address* addresses) {}

     class Person(name, age=0, addresses) {
         shared String name;
         shared variable Integer age;
         Address* addresses;
     }


File: ceylon-spec.info,  Node: parameterlists,  Next: requiredparameters,  Up: parameters

4.3.1 Parameter lists
---------------------

A parameter list is a list of parameter declarations and of names of
parameters declared in the body of the class or function to which the
parameter list belongs.  A parameter list may include, optionally:

   * one or more _required parameters_,

   * one or more _defaulted parameters_ (parameters with default
     values), and/or

   * a _variadic parameter_.

   In a parameter list, defaulted parameters, if any, must occur after
required parameters, if any.  The variadic parameter, if any, must occur
last.

Parameters: "(" ( (Required ",")* ( Required | (Defaulted ",")* (Defaulted | Variadic) ) )? ")"
   Every parameter list has a type, which captures the types of the
individual parameters in the list, whether they are defaulted, and
whether the last parameter is variadic.  This type is always an subtype
of 'Anything[]'.  The type of an empty parameter list with no parameters
is '[]'.

   A parameter may not be annotated 'formal', but it may be annotated
'default'.


File: ceylon-spec.info,  Node: requiredparameters,  Next: defaultedparameters,  Prev: parameterlists,  Up: parameters

4.3.2 Required parameters
-------------------------

A required parameter is a value or callable parameter without a default
argument.

   A required parameter in a parameter list may be a parameter
declaration, or the name of a non-variadic parameter declared in the
body of the function or class.

Required: ValueParameter | CallableParameter | MemberName
   Required parameters must occur before any other parameters in the
parameter list.


File: ceylon-spec.info,  Node: defaultedparameters,  Next: valueparameters,  Prev: requiredparameters,  Up: parameters

4.3.3 Defaulted parameters
--------------------------

A defaulted parameter is a value or callable parameter that specifies an
expression that produces a _default argument_.  A defaulted parameter
may be either:

   * a non-variadic parameter declaration, together with a default
     argument expression, or

   * the name of a non-variadic parameter declared in the body of the
     function or class, together with its default argument expression.

Defaulted: ValueParameter Specifier | CallableParameter LazySpecifier | MemberName Specifier
   The '=' and '=>' specifiers are used throughout the language.  In a
parameter list they are used to specify a default argument.

Specifier: "=" Expression

LazySpecifier: "=>" Expression
   The default argument expression may involve other non-'variable'
parameters declared earlier in the parameter list or lists.  It may not
involve parameters declared later in the parameter list or lists.  It
may not involve 'variable' parameters of the parameter list.

   The default argument expression may not involve an assignment,
compound assignment, increment, or decrement operator.

   Defaulted parameters must occur after required parameters in the
parameter list.

     (Product product, Integer quantity=1, Price pricing(Product p) => p.price)
   A parameter of a method or class annotated 'actual' may not specify a
default argument.  Instead, it inherits the default argument, if any, of
the corresponding parameter of the method it refines.

   If two parameter lists are almost identical, differing only in that
the first parameter of one list is defaulted, and the first parameter of
the second list is required, and 'P' is the the type of the second
parameter list, then the type of the first parameter list is '[]|P'.

     Note: in Ceylon 1.0, for a function with multiple parameter lists,
     defaulted parameters may only occur in the first parameter list.
     This restriction will be removed.

     TODO: Should we, purely for consistency, let you write 'f(Float x)
     => x' in a parameter list, when the callable parameter is declared
     in the body of the function or class?


File: ceylon-spec.info,  Node: valueparameters,  Next: callableparameters,  Prev: defaultedparameters,  Up: parameters

4.3.4 Value parameters
----------------------

A _value parameter_ is a reference, as specified in *note References:
references, that is named or defined in a parameter list. Like any other
value declaration, it has a name, type, and, optionally, annotations.

ValueParameter: Annotations ValueParameterPrefix MemberName

ValueParameterPrefix: Type | "value" | "dynamic"
   A value parameter may be declared using the keyword 'dynamic' in
place of the parameter type, indicating that it is a partially typed
declaration.  Such a parameter has no type.

   In general, a value parameter must have an explicit type declaration,
and may not be declared with the keyword 'value'.

   As a special exception, if a parameter of an anonymous function is
declared with the keyword 'value', then the type of the parameter must
be inferable, according to *note Anonymous function parameter type
inference: parametertypeinference.

   If a value parameter 'x' has type 'X', and a parameter list has type
'P' with the principal instantiation 'Sequential<Y>', then the type of a
new parameter list formed by prepending 'x' to the first parameter list
is:

   * 'Tuple<X|Y,X,P>', or

   * '[]|Tuple<X|Y,X,P>' if 'x' is defaulted.

   The default argument expression, if any, for a callable parameter is
specified using an ordinary '=' specifier.  The type of the default
argument expression must be assignable to the declared type of the value
parameter.

     (String label, Anything() onClick)

     ({Value*} values, Comparison(Value,Value) by)


File: ceylon-spec.info,  Node: callableparameters,  Next: sequencedparameters,  Prev: valueparameters,  Up: parameters

4.3.5 Callable parameters
-------------------------

A _callable parameter_ is a function, as specified in *note Functions:
functions, named or defined in a parameter list.  Like any other
function declaration, it has a name, type, one or more parameter lists,
and, optionally, annotations.

CallableParameter: Annotations CallableParameterPrefix MemberName Parameters+

CallableParameterPrefix: Type | "void" | "dynamic"
   A callable parameter may be declared using the keyword 'dynamic' in
place of the return type, indicating that it is a partially typed
declaration.  Such a parameter has no return type.

   If a callable parameter 'f' has callable type 'X(*A)', as specified
below in *note Callable type of a function: callabletypeoffunction, and
a parameter list has type 'P' with the principal instantiation
'Sequential<Y>', then the type of a new parameter list formed by
prepending 'f' to the first parameter list is:

   * 'Tuple<Y|X(*A),X(*A),P>', or

   * '[]|Tuple<Y|X(*A),X(*A),P>' if 'f' is defaulted.

   The default argument expression, if any, for a callable parameter is
specified using a lazy '=>' specifier.  The type of the default argument
expression must be assignable to the return type of the callable
parameter.

     (String label, void onClick())

     ({Value*} values, Comparison by(Value x, Value y))


File: ceylon-spec.info,  Node: sequencedparameters,  Prev: callableparameters,  Up: parameters

4.3.6 Variadic parameters
-------------------------

A _variadic parameter_ is a value parameter that accepts multiple
arguments:

   * A variadic parameter declared 'T*' accepts zero or more arguments
     of type 'T', and has type '[T*]'.

   * A variadic parameter declared 'T+' accepts one or more arguments of
     type 'T', and has type '[T+]'.

VariadicParameter: Annotations VariadicParameterPrefix MemberName

VariadicParameterPrefix: UnionType ("*" | "+")
   A variadic parameter in a parameter list may be a variadic parameter
declaration, or the name of a variadic parameter declared in the body of
the function or class.

Variadic: VariadicParameter | MemberName
   The variadic parameter must be the last parameter in a parameter
list.  A variadic parameter may not have a default argument.  A variadic
parameter declared 'T+' may not occur in a parameter list with defaulted
parameters.

     (Name name, Organization? org=null, Address* addresses)

     (Float+ floats)
   The type of a parameter list containing just a variadic parameter of
type 'T*' is '[T*]' The type of a parameter list containing just a
variadic parameter of type 'T+' is '[T+]'.

     Note: in Ceylon 1.0, for a function with multiple parameter lists,
     a variadic parameters may only occur in the first parameter list.
     This restriction will be removed.


File: ceylon-spec.info,  Node: interfaces,  Next: classes,  Prev: parameters,  Up: declarations

4.4 Interfaces
==============

* Menu:


* interfacebodies:: Interface bodies
* interfaceinheritance:: Interface inheritance
* sealedinterfaces:: Sealed interfaces
* interfaceswithcases:: Enumerated interfaces
* interfacealiases:: Interface aliases
* dynamicinterfaces:: Dynamic interfaces

An _interface_ is a type schema, together with implementation details
for some members of the type.  Interfaces may not be directly
instantiated.

InterfaceDeclaration: Annotations InterfaceHeader (InterfaceBody | TypeSpecifier ";")
   An interface declaration may optionally specify a list of type
parameters.  An interface declaration may also have a list of interfaces
is satisfies, a self type or an enumerated list of cases, and/or a list
of type constraints.

InterfaceHeader: ("interface"|"dynamic") TypeName TypeParameters? InterfaceInheritance TypeConstraints?

InterfaceInheritance: CaseTypes? SatisfiedTypes?
   To obtain a concrete instance of an interface, it is necessary to
define and instantiate a class that satisfies the interface, or define
an anonymous class that satisfies the interface.

   The body of an interface contains:

   * an optional list of local 'import' statements,

   * member (method, attribute, and member class) declarations,

   * specification statements interpretable as attribute or method
     refinement, as defined in *note Attribute refinement:
     attributerefinement. and *note Method refinement: methodrefinement,
     and

   * nested interface, type alias, and 'abstract' class declarations.

InterfaceBody: "{" Import* (Declaration | Specification)* "}"
   Unlike the body of a class, method, or attribute, the body of an
interface is not executable, and does not directly contain procedural
code.

     shared interface Comparable<Other> {
         shared formal Comparison compare(Other other);
         shared Boolean largerThan(Other other) => compare(other)==larger;
         shared Boolean smallerThan(Other other) => compare(other)==smaller;
     }
   An interface may declare 'formal' methods, attributes, and member
classes, and concrete methods, getters, setters, and member classes.  A
reference declaration, as defined in *note References: references, or
anonymous class declaration, as defined in *note Anonymous classes:
anonymousclasses, may not directly occur in the body of an interface.

   A non-'abstract ' nested class declaration is called a _member class_
of the interface.  A nested interface or 'abstract' class declaration is
not part of the schema of the interface type, and is therefore not
considered a member of the interface.


File: ceylon-spec.info,  Node: interfacebodies,  Next: interfaceinheritance,  Up: interfaces

4.4.1 Interface bodies
----------------------

The body of an interface consists purely of declarations.  The following
constructs may not occur sequentially in the body of an interface:

   * a statement or control structure (except for specification
     statements interpretable as attribute or method refinement),

   * a reference declaration,

   * a forward-declared method or attribute declaration, or

   * an 'object' declaration.

   Within an interface body, a _super reference_ is any occurrence of
the expression 'super', unless it also occurs in the body of a nested
class or interface declaration.  A statement or declaration contained in
the interface body may not:

   * pass a super reference as an argument of an instantiation, function
     invocation, or 'extends' clause expression or as the value of a
     value assignment or specification,

   * use a super reference as an operand of any operator except the
     member selection operator, or the 'of' operator as specified in
     *note super: super,

   * return a super reference, or

   * narrow the type of a super reference using an assignability
     condition, as defined in *note Assignability conditions:
     assignabilityconditions.


File: ceylon-spec.info,  Node: interfaceinheritance,  Next: sealedinterfaces,  Prev: interfacebodies,  Up: interfaces

4.4.2 Interface inheritance
---------------------------

An interface may satisfy any number of other interfaces, as defined in
*note Satisfaction: satisfiedinterfaces.

     shared interface List<Element>
             satisfies Collection<Element> & Correspondence<Integer,Element>
             given Element satisfies Object {
         ...
     }
   Every type listed in the 'satisfies' clause must be an interface.  An
interface may not satisfy the same interface twice (not even with
distinct type arguments).

     Note: this second restriction is not strictly necessary.  In fact,
     'satisfies List<One>&List<Two>' means the same thing as 'satisfies
     List<One&Two>', and the compiler already needs to be able to figure
     that out when it comes to multiple instantiations of the same
     interface inherited indirectly.  Still, the restriction seems
     harmless enough.

   The interface is a subtype of every type listed in the 'satisfies'
clause.  The interface is also a subtype of the type 'Object' defined in
'ceylon.language'.

   An interface inherits all members (methods, attributes and member
types) of every supertype.  That is, every member of every supertype of
the interface is also a member of the interface.  Furthermore, the
interface inherits all nested types (interfaces and 'abstract' classes)
of every supertype.

   The schema of the inherited members is formed by substituting type
arguments specified in the 'satisfies' clause.

   An interface that satisfies a nested interface must be a member of
the type that declares the nested interface or of a subtype of the type
that declares the nested interface.

   A user-defined interface may not satisfy the interface 'Callable'
defined in 'ceylon.language' nor directly satisfy the interface
'ConstrainedAnnotation' defined in 'ceylon.language'.


File: ceylon-spec.info,  Node: sealedinterfaces,  Next: interfaceswithcases,  Prev: interfaceinheritance,  Up: interfaces

4.4.3 Sealed interfaces
-----------------------

A toplevel or nested interface may be annotated 'sealed' and is called a
'sealed' interface.

   An interface annotated 'sealed' may not be satisfied by a class or
interface outside the module in which it is defined.


File: ceylon-spec.info,  Node: interfaceswithcases,  Next: interfacealiases,  Prev: sealedinterfaces,  Up: interfaces

4.4.4 Enumerated interfaces
---------------------------

An interface declaration may enumerate a list of cases of the interface,
as defined in *note Cases: cases.

     shared interface Node<Element>
                 of Root<Element> | Branch<Element> | Leaf<Element> { ... }
   The cases may be interfaces, classes, or toplevel anonymous classes.
A case may be an 'abstract' class.  Each case must be a direct subtype
of the interface type.  An interface may not be a case of itself.  An
interface declaration may not list the same case twice.

   If an interface has an 'of' clause, then every interface or class
which directly inherits the interface must occur as exactly one of the
enumerated cases of the interface.  Furthermore, any interface or class
which indirectly inherits the interface must inherit exactly one of the
enumerated cases of the interface.


File: ceylon-spec.info,  Node: interfacealiases,  Next: dynamicinterfaces,  Prev: interfaceswithcases,  Up: interfaces

4.4.5 Interface aliases
-----------------------

An _interface alias_ is an interface declaration which specifies another
type.

TypeSpecifier: "=>" Type
   The specified type must be an _interface type_, that is, a reference
to an interface with no type parameters or an instantiation of a generic
interface, and is called the _aliased type_.

   An interface alias simply assigns an alternative name to the aliased
type. A reference to the alias may occur anywhere a reference to an
interface may occur.

     shared interface PeopleByName => Map<String,Person>;

     interface Compare<Value> => Comparison(Value,Value);
   If the aliased interface is a parameterized type, the aliased type
must explicitly specify type arguments.

   A class or interface may satisfy an interface alias, in which case,
the class or interface inherits the aliased interface type.

   Interface aliases are not reified types.  The metamodel reference for
an interface alias type--for example, 'PeopleByName'--returns the
metamodel object for the aliased interface--in this case,
'Map<String,Person>', as specified in *note Type argument reification:
reification.


File: ceylon-spec.info,  Node: dynamicinterfaces,  Prev: interfacealiases,  Up: interfaces

4.4.6 Dynamic interfaces
------------------------

A _dynamic interface_ is an interface declared with the keyword
'dynamic'.  Dynamic interfaces may be used to model the type of objects
defined in dynamically typed native code.

   Every declaration nested inside a dynamic interface must be declared
'formal'.  A dynamic interface may not satisfy any interface that is not
also a dynamic interface.

   Within a dynamic block, defined in *note Dynamic blocks:
dynamicblocks, assignment of a value with no Ceylon type to a dynamic
interface type does not result in an 'AssertionError', as defined in
*note Dynamic type checking: dynamictypechecking.  Instead, the value is
coerced to the dynamic interface type.


File: ceylon-spec.info,  Node: classes,  Next: typealiasedeclarations,  Prev: interfaces,  Up: declarations

4.5 Classes
===========

* Menu:


* callabletypeofclass:: Callable type of a class
* initializersection:: Initializer section
* declarationsection:: Declaration section
* classinheritance:: Class inheritance
* abstractandformalclasses:: Abstract, final, sealed, formal, and default classes
* classrefinement:: Member class refinement
* anonymousclasses:: Anonymous classes
* classeswithcases:: Enumerated classes
* classaliases:: Class aliases

A _class_ is a stateful, instantiable type.  It is a type schema,
together with implementation details of the members of the type.

ClassDeclaration: Annotations ClassHeader (ClassBody | ClassSpecifier ";")
   An ordinary class declaration may specify, optionally, a list of
parameters required to instantiate the type, and, also optionally, a
list of type parameters.  A class declaration may have a superclass, a
list of interfaces it satisfies, a self type or an enumerated list of
cases, and/or a list of type constraints.

ClassHeader: "class" TypeName TypeParameters? Parameters? ClassInheritance TypeConstraints?

ClassInheritance: CaseTypes? ExtendedType? SatisfiedTypes?
   To obtain an instance of a class, it is necessary to instantiate the
class, or a subclass of the class.

   The body of a class contains:

   * an optional list of local 'import' statements,

   * member (method, attribute, and member class) declarations,

   * nested interface, type alias, and 'abstract' class declarations,
     and

   * instance initialization code and, if the class does not have a
     parameter list, constructors.

ClassBody: "{" Import* (Declaration | Statement | ConstructorDeclaration)* "}"
   The body of a class may contain executable code.

     shared class Counter(Integer initialCount=0) {

         variable Integer n = initialCount;

         print("Initial count: ``n``");

         shared Integer count => n;

         shared void increment() {
             n++;
             print("Count: ``n``");
         }

     }
   A non-'abstract ' nested class declaration is called a _member class_
of the class.  A nested interface or 'abstract' class declaration is not
part of the schema of the class type, and is therefore not considered a
member of the class.

   A class is not required to have a separate nested constructor
declaration.  Instead, the body of the class may itself declare its
_initializer parameters_.  An initializer parameter may be used anywhere
in the class body, including in method and attribute definitions.

     shared class Key(Lock lock) {
         shared void lock() {
             lock.engage(this);
             print("Locked.");
         }
         shared void unlock() {
             lock.disengage(this);
             print("Unlocked.");
         }
         shared Boolean locked => lock.engaged;
     }
   An initializer parameter may be 'shared'.

     shared class Point(shared Float x, shared Float y) { ... }

     shared class Counter(count=0) {
         shared variable Integer count;
         shared void increment() => count++;
     }
   If a class does not specify an initializer parameter list, it must
have at least one shared constructor, as defined below in *note
Constructors: constructors.


File: ceylon-spec.info,  Node: callabletypeofclass,  Next: initializersection,  Up: classes

4.5.1 Callable type of a class
------------------------------

The _callable type_ of a class with an initializer parameter list
captures the type and initializer parameter types of the class. The
callable type is 'T(*P)', where 'T' is the applied type formed by the
class with its own type parameters as type arguments, and 'P' is the
type of the initializer parameter list of the class.

   The callable type of a class with a default constructor is the
callable type of the default constructor.

   A class with no initializer parameter list and no default constructor
does not have a callable type.

   An 'abstract' class is not callable, except from the 'extends' clause
of a subclass, or the class specifier of a class alias.


File: ceylon-spec.info,  Node: initializersection,  Next: declarationsection,  Prev: callabletypeofclass,  Up: classes

4.5.2 Initializer section
-------------------------

The initial part of the body of a class is called the _initializer_ of
the class and contains a mix of declarations, statements, and control
structures.  The initializer is executed every time the class is
instantiated.  If the class does not have an initializer parameter list,
the initializer section may include one or more constructor
declarations, as defined in *note Constructors: constructors.

   A class initializer is responsible for initializing the state of the
new instance of the class, before a reference to the new instance is
available to clients.

     shared abstract class Point() {
         shared formal Float x;
         shared formal Float y;
     }

     shared class DiagonalPoint(Float distance)
             extends Point() {

         value d = distance / 2^0.5;
         x => d;
         y => d;

         "must have correct distance from origin"
         assert (x^2 + y^2 == distance^2);

     }

     shared object origin
             extends Point() {
         x => 0.0;
         y => 0.0;
     }
   Within a class initializer, a _self reference to the instance being
initialized_ is:

   * any occurrence of the expression 'this', as defined in *note this:
     this, or 'super', as defined in *note super: super, unless it also
     occurs in the body of a nested class or interface declaration,

   * any occurrence of the expression 'outer', as defined in *note
     outer: outer, in the body of a class or interface declaration
     immediately contained by the class,

   * any reference to an anononymous class that inherits the class, or,
     if the class is an anonymous class, to the anonymous class itself,
     or

   * any reference to a value constructor of the class or of a class
     which inherits the class.

   A statement or declaration contained in the initializer of a class
may not evaluate an attribute, invoke a method, or instantiate a member
class upon the instance being initialized, including upon a self
reference to the instance being initialized, if the attribute, method,
or member class:

   * occurs later in the body of the class,

   * is annotated 'formal' or 'default', or

   * is inherited from an interface or superclass, and is not refined by
     a declaration occurring earlier in the body of the class.

   A member class contained in the initializer of a class may not
'extend' a member or nested class of an interface or superclass of the
class.

   Furthermore, a statement or declaration contained in the initializer
of a class may not:

   * pass a self reference to the instance being initialized as an
     argument of an instantiation, function invocation, or 'extends'
     clause expression or as the value of a value assignment or
     specification,

   * use a self reference to the instance being initialized as an
     operand of any operator except the member selection operator, or
     the 'of' operator,

   * return a self reference to the instance being initialized, or

   * narrow the type of a self reference to the instance being
     initialized using an assignability condition, as defined in *note
     Assignability conditions: assignabilityconditions.

   Nor may the class pass a self reference to the instance being
initialized as an argument of its own 'extends' clause expression, if
any.

   As a special exception to these rules, a statement contained in an
initializer may assign a self-reference to the instance being
initialized to a reference annotated 'late'.

   For example, the following code fragments are not legal:

     class Graph() {
         OpenList<Node> nodes = ArrayList<Node>();
         class Node() {
             nodes.add(this);    //error: self reference in initializer
         }
     }

     class Graph() {
         class Node() {}
         Node createNode() {
             Node node = Node();
             nodes.add(node);    //error: forward reference in initializer
             return node;
         }
         OpenList<Node> nodes = ArrayList<Node>();
     }
   But this code fragment is legal:

     class Graph() {
         OpenList<Node> nodes = ArrayList<Node>();
         Node createNode() {
             Node node = Node();
             nodes.add(node);
             return node;
         }
         class Node() {}
     }


File: ceylon-spec.info,  Node: declarationsection,  Next: classinheritance,  Prev: initializersection,  Up: classes

4.5.3 Declaration section
-------------------------

The remainder of the body of the class consists purely of declarations,
similar to the body of an interface.  The following constructs may not
occur sequentially in the declaration section:

   * a statement or control structure, defined in *note Control
     structures and assertions: controlstructures,

   * a reference declaration, as defined below in *note References:
     references,

   * a constructor declaration, as defined below in *note Constructors:
     constructors,

   * a forward-declared function or value declaration not annotated
     'late', as defined below in *note Forward declaration of functions:
     functionforwarddeclaration. and *note Forward declaration of
     values: valueforwarddeclaration,

   * an 'object' declaration with a non-empty initializer section, or

   * an 'object' declaration that directly extends a class other than
     'Object' or 'Basic' in 'ceylon.language'.

   However, the declarations in this second section may freely use
'this' and 'super', and may invoke any method, evaluate any attribute,
or instantiate any member class of the class or its superclasses.

   Within the declaration section of a class body, a _super reference_
is any occurrence of the expression 'super', unless it also occurs in
the body of a nested class or interface declaration.  A statement or
declaration contained in the declaration section of a class body may
not:

   * pass a super reference as an argument of an instantiation, function
     invocation, or 'extends' clause expression or as the value of a
     value assignment or specification,

   * use a super reference as an operand of any operator except the
     member selection operator, or the 'of' operator as specified in
     *note super: super,

   * return a super reference, or

   * narrow the type of a super reference using an assignability
     condition, as defined in *note Assignability conditions:
     assignabilityconditions.


File: ceylon-spec.info,  Node: classinheritance,  Next: abstractandformalclasses,  Prev: declarationsection,  Up: classes

4.5.4 Class inheritance
-----------------------

A class may extend another class, as defined in *note Extension:
extendedclass.

     shared class Customer(Name name, Organization? org = null)
             extends Person(name, org) {
         ...
     }
   The class is a subtype of the type specified by the 'extends' clause.
If a class does not explicitly specify a superclass using 'extends', its
superclass is the class 'Basic' defined in 'ceylon.language'.

   A class may satisfy any number of interfaces, as defined in *note
Satisfaction: satisfiedinterfaces.

     class Token()
             extends Datetime()
             satisfies Comparable<Token> & Identifier {
         ...
     }
   The class is a subtype of every type listed in the 'satisfies'
clause.  A class may not satisfy the same interface twice (not even with
distinct type arguments).

   A class inherits all members (methods, attributes, and member types)
of every supertype.  That is, every member of every supertype of the
class is also a member of the class.  Furthermore, the class inherits
all nested types (interfaces and 'abstract' classes) of every supertype.

   Unless the class is declared 'abstract' or 'formal', the class:

   * must declare or inherit a member that refines each 'formal' member
     of every interface it satisfies directly or indirectly, and

   * must declare or inherit a member that refines each 'formal' member
     of its superclass.

   The schema of the inherited members is formed by substituting type
arguments specified in the 'extends' or 'satisfies' clause.

   A subclass with an initializer parameter list must pass arguments to
each superclass initialization parameter or callable constructor
parameter in the 'extends' clause.  A subclass with no initializer
parameter list may not pass arguments in the 'extends' clause.

     shared class SpecialKey1()
             extends Key( SpecialLock() ) {
         ...
     }

     shared class SpecialKey2(Lock lock)
             extends Key(lock) {
         ...
     }
   A subclass of a nested class must be a member of the type that
declares the nested class or of a subtype of the type that declares the
nested class. A class that satisfies a nested interface must be a member
of the type that declares the nested interface or of a subtype of the
type that declares the nested interface.

   A user-defined class may not satisfy the interface 'Callable' defined
in 'ceylon.language' nor directly satisfy the interface
'ConstrainedAnnotation' defined in 'ceylon.language'.


File: ceylon-spec.info,  Node: abstractandformalclasses,  Next: classrefinement,  Prev: classinheritance,  Up: classes

4.5.5 Abstract, final, sealed, formal, and default classes
----------------------------------------------------------

A toplevel or nested class may be annotated 'abstract' and is called an
'abstract' class.

   A toplevel or nested class may be annotated 'final' and is called a
'final' class.

   A toplevel or nested class may be annotated 'sealed' and is called a
'sealed' class.

   If a class annotated 'shared' is a member of a containing class or
interface, then the class may be annotated 'formal' and is called a
'formal' member class, or, sometimes, an _abstract member class_.

   An 'abstract' class or 'formal' member class may have 'formal'
members.

   An 'abstract' class may not be instantiated.

   A 'formal' member class may be instantiated.

   A class which is not annotated 'formal' or 'abstract' is called a
_concrete_ class.

   A concrete class may not have 'formal' members.

   A class annotated 'final' must be a concrete class.

   A class annotated 'final' may not have 'default' members.

   If a concrete class annotated 'shared' is a member of a containing
class or interface, then the class may be annotated 'default' and is
called a 'default' member class.

   A toplevel class may not be annotated 'formal' or 'default'.

   An un-'shared' class may not be annotated 'formal' or 'default'.

   A class annotated 'sealed' may not be instantiated or extended
outside the module in which it is defined.

   A class with no parameter list may not be annotated 'sealed'.

   A member class annotated 'sealed formal' must belong to a 'sealed'
class or interface.

     Note: a 'formal' member class would be a reasonable syntax for
     declaring virtual types.  We think we don't need virtual types
     because they don't offer much that type parameters don't already
     provide.  For example:

          shared formal class Buffer(Character...)
                  satisfies Sequence<Character>;


File: ceylon-spec.info,  Node: classrefinement,  Next: anonymousclasses,  Prev: abstractandformalclasses,  Up: classes

4.5.6 Member class refinement
-----------------------------

Member class refinement is a unique feature of Ceylon, akin to the
"factory method" pattern of many other languages.

   * A member class annotated 'formal' or 'default' may be refined by
     any class or interface which is a subtype of the class or interface
     which declares the member class.

   * A member class annotated 'formal' _must_ be refined by every
     concrete class which is a subtype of the class or interface that
     declares the member class, unless the class inherits a concrete
     member class from a superclass that refines the 'formal' member
     class.

   A member class of a subtype _refines_ a member class of a supertype
if the member class of the supertype is 'shared' and the two classes
have the same name.  The first class is called the _refining_ class, and
the second class is called the _refined_ class.

   Then, given the refined realization of the class it refines, as
defined in *note Realizations: realizations, and, after substituting the
type parameters of the refined class for the type parameters of the
refining class in the schema of the refining class, the refining class
must:

   * have the same number of type parameters as the refined schema, and
     for each type parameter the intersection of its upper bounds must
     be a supertype of the intersection of the upper bounds of the
     corresponding type parameter of the realization,

   * have a parameter list with the same signature as the realization,
     and

   * directly or indirectly extend the class it refines.

   Furthermore:

   * the refining class must be annotated 'actual', and

   * the refined class must be annotated 'formal' or 'default'.

   If a member class is annotated 'actual', it must refine some member
class of a supertype.

   A member class may not, directly or indirectly, refine two different
member classes not themselves annotated 'actual'.

   Then instantiation of the member class is polymorphic, and the actual
subtype instantiated depends upon the concrete type of the containing
class instance.

     shared abstract class Reader() {
         shared formal class Buffer(Character* chars)
                 satisfies Character[] {}
         ...
     }

     shared class FileReader(File file)
             extends Reader() {
         shared actual class Buffer(Character* chars)
                 extends super.Buffer(chars) {
             ...
         }
         ...
     }
   All of the above rules apply equally to member classes which are
aliases.

     shared abstract class Reader() {
         shared formal class Buffer(Character* chars) => AbstractBuffer(*chars);
         ...
     }

     shared class FileReader(File file)
             extends Reader() {
         shared actual class Buffer(Character* chars) => FileBuffer(*chars);
         ...
     }


File: ceylon-spec.info,  Node: anonymousclasses,  Next: classeswithcases,  Prev: classrefinement,  Up: classes

4.5.7 Anonymous classes
-----------------------

An 'object' or _anonymous class_ declaration is a compact way to define
a class with a single value constructor, together with a getter aliasing
this value constructor.

ObjectDeclaration: Annotations ObjectHeader ClassBody
   An 'object' has an initial lowercase identifier.  An 'object'
declaration does not specify parameters or type parameters.

ObjectHeader: "object" MemberName ObjectInheritance

ObjectInheritance: ExtendedType? SatisfiedTypes?
   An 'object' declaration specifies the name of the value and the
schema, supertypes, and implementation of the class.  It does not
explicitly specify a type name.  Instead, the type name is formed by
prefixing the value name with '\I', turning it into an initial uppercase
identifier, as specified by *note Identifiers and keywords:
identifiersandkeywords.

   An 'object' class:

   * satisfies and/or extends the types specified by the 'object'
     declaration,

   * has no initializer parameter list,

   * has a single 'shared' value constructor with the same name as the
     'object', with an empty body and the same 'extends' clause as the
     'object' declaration, which is the single enumerated case of the
     class,

   * is 'shared', if and only if the 'object' is annotated 'shared',

   * is neither 'abstract' nor 'formal',

   * is implicitly 'final'.

   Therefore, members of an 'object' may not be declared 'formal' nor
'default'.

   The body of the 'object' declaration is the body of the class.

   This class never appears in types inferred by local declaration type
inference or generic type argument inference.  Instead, occurrences of
the class are replaced with the intersection of the extended type with
all satisfied types.

   An 'object' value is a getter, as defined in *note Getters: getters,
that simply returns a reference to the value constructor of the class.
The value:

   * is 'shared', if and only if the 'object' is annotated 'shared',

   * may refine a member of a supertype, if and only if the 'object' is
     annotated 'actual', and

   * is neither 'default' nor 'formal'.

   Therefore, the 'object' may not be annotated 'default' nor 'formal'.

   Annotations applying to an 'object' declaration are considered
annotations of the 'object' value, and are accessible via its
'ValueDeclaration', as defined in *note Reference expressions:
referenceexpressions.

   The following declaration:

     shared my object red extends Color('FF0000') {
          string => "Red";
     }
   Is exactly equivalent to:

     shared final class \Ired of red extends Color {
          shared new red extends Color('FF0000') {}
          string => "Red";
     }

     shared my \Ired red => \Ired.red;
   Where '\Ired' is the type name assigned by the compiler.

     shared object sql {
         shared String escape(String string) { ... }
     }

     ...

     String escapedSearchString = sql.escape(searchString);


File: ceylon-spec.info,  Node: classeswithcases,  Next: classaliases,  Prev: anonymousclasses,  Up: classes

4.5.8 Enumerated classes
------------------------

A class declaration may enumerate a list of cases of the class, as
defined in *note Cases: cases.

   * For an 'abstract' class, the cases may be	classes or toplevel
     anonymous classes.  Each case must be a direct	subclass of the
     enumerated class.  A case may itself be an	'abstract' class.

   * For a non-'abstract' toplevel class, the cases must be value
     constructors of the class.

   The cases listed in the 'of' clause must exhaust every means by which
an instance of the class may be instantiated:

   * if an 'abstract' class has an	'of' clause, then every class that
     directly	extends the class must occur as exactly one of the
     enumerated	cases of the class listed in the 'of' clause	and,
     furthermore, every class that indirectly inherits the	'abstract'
     class must inherit one of the	enumerated cases of the class, or

   * if a non-'abstract' class has an	'of' clause, then every
     non-partial constructor	of the class must occur as exactly one of
     the enumerated cases of	the class listed in the 'of' clause.

     shared abstract class Boolean()
             of true | false {}

     shared object true extends Boolean() { string => "true"; }
     shared object false extends Boolean() { string => "false"; }

     shared abstract class Node<Element>(String name)
             of Branch<Element> | Leaf<Element> { ... }

     shared class Leaf<Element>(String name, Element element)
             extends Node<Element>(name) { ... }

     shared class Branch<Element>(String name, Node<Element> left, Node<Element> right)
             extends Node<Element>(name) { ... }

     shared class Status of enabled | disabled {
         shared actual String string;
         shared new enabled { string => "enabled"; }
         shared new disabled { string => "disabled"; }
     }
   A non-'abstract' class with an initializer parameter list or a
callable constructor may not specify an 'of' clause.

   A non-'abstract', non-toplevel class may not specify an 'of' clause.

   A class declaration may not list the same case twice.

     Note: in a future release of the language, we may introduce an
     abbreviated syntax like:

          shared abstract class Boolean(shared actual String string)
                  of object true ("true") |
                     object false ("false") {}


File: ceylon-spec.info,  Node: classaliases,  Prev: classeswithcases,  Up: classes

4.5.9 Class aliases
-------------------

A _class alias_ is a class declaration which specifies a reference to a
class or callable constructor of a class, followed by a positional
argument list, as defined in *note Positional argument lists:
positionalarguments.

ClassSpecifier: "=>" (Extension | Construction)
   The specification of the class or callable constructor is treated as
a value expression, as in *note Extension: extendedclass.  The type of
this value expression must be a _class type_, that is, a reference to a
class with no type parameters or an instantiation of a generic class,
and is called the _aliased type_.

   A class alias simply assigns an alternative name to the aliased type.
A reference to the alias may occur anywhere a reference to a class may
occur.

     shared class People(Person* people) => ArrayList<Person>(*people);

     class Named<Value>(String name, Value val)
             given Value satisfies Object
             => Entry<String,Value>(name, val);
   Arguments to the initializer parameters of the aliased class must be
specified.

   If the aliased class is a parameterized type, the aliased type must
explicitly specify type arguments.

   The type arguments may not be inferred from the initializer
arguments.

     Note: currently the compiler imposes a restriction that the
     callable type of the aliased class must be assignable to the
     callable type of the class alias.  This restriction will be removed
     in future.

   If a toplevel class alias or un-'shared' class alias aliases an
'abstract' class, the alias must be annotated 'abstract', and it may not
be directly instantiated.

   If a 'shared' class alias nested inside the body of a class or
interface aliases an 'abstract' class, the alias must be annotated
'abstract' or 'formal'.  If it is annotated 'formal', it is considered a
member class of the containing class or interface.  If it is annotated
'abstract', it is considered an abstract nested class of the containing
class or interface.

   A class alias may not alias a partial constructor.  A 'shared' class
alias may not alias an un-'shared' constructor.

   A class may extend a class alias, in which case, the class inherits
the aliased class type.

   Class aliases are not reified types.  The metamodel reference for a
class alias type--for example, 'People'--returns the metamodel object
for the aliased class--in this case, 'ArrayList<Person>', as specified
in *note Type argument reification: reification.


File: ceylon-spec.info,  Node: typealiasedeclarations,  Next: functions,  Prev: classes,  Up: declarations

4.6 Type aliases
================

A type alias declaration assigns a name to an arbitrary type expression,
usually involving a union and/or intersection of types.

TypeAliasDeclaration: Annotations AliasHeader TypeSpecifier ";"

AliasHeader: "alias" TypeName TypeParameters? TypeConstraints?
   The specified type may be any kind of type.  A reference to the alias
may be used anywhere a union or intersection type may be used.  The
alias may not appear in an 'extends' or 'satisfies' clause.  The alias
may not be instantiated.

     shared alias Number => Integer|Float|Decimal|Whole;

     alias ListLike<Value> => List<Value>|Map<Integer,Value>;

     alias Numbered<Num,Value> given Num satisfies Ordinal<Num>
             => Correspondence<Num,Value>;

     Note: class, interface, and type aliases use a "fat arrow" lazy
     specifier '=>' instead of '=' because the type parameters declared
     on the left of the specifier are in scope on the right of the
     specifier.  An alias is in general a type constructor.

   A class or interface may not extend or satisfy a type alias.

   Type aliases are not reified types.  The metamodel reference for a
type alias type--for example, 'Number'--returns the metamodel object for
the aliased type--in this case, 'Integer|Float|Decimal|Whole', as
specified in *note Type argument reification: reification.


File: ceylon-spec.info,  Node: functions,  Next: values,  Prev: typealiasedeclarations,  Up: declarations

4.7 Functions
=============

* Menu:


* callabletypeoffunction:: Callable type of a function
* functionswithblocks:: Functions with blocks
* functionswithspecifiers:: Functions with specifiers
* returntypeinference:: Function return type inference
* functionforwarddeclaration:: Forward declaration of functions
* multipleparameterlists:: Functions with multiple parameter lists
* formalmethods:: Formal and default methods
* methodrefinement:: Method refinement

A _function_ is a callable block of code.  A function may have
parameters and may return a value.  If a function belongs to a type, it
is called a _method_.

FunctionDeclaration: Annotations FunctionHeader (Block | LazySpecifier? ";")
   All function declarations specify the function name, one or more
parameter lists, and, optionally, a list of type parameters.  A generic
function declaration may have a list of type constraints.

FunctionHeader: FunctionPrefix MemberName TypeParameters? Parameters+ TypeConstraints?
   A function declaration may specify a type, called the _return type_,
to which the values the method returns are assignable, or it may specify
that the function is a 'void' function--a function which does not return
a useful value, and only useful for its effect.

FunctionPrefix: Type | "function" | "dynamic" | "void"
   Instead of an explicit return type, a function may be declared using:

   * the keyword 'dynamic', indicating that it is a partially typed
     declaration with no return type, or

   * the keyword 'function', indicating that its return	type is
     inferred.

   A function implementation may be specified using either:

   * a block of code, or

   * a lazy specifier.

   If a function is a parameter, it must not specify any implementation.

   The return type of a 'void' function is considered to be 'Anything'
defined in 'ceylon.language'.

     Note: a 'void' function with a concrete implementation returns the
     value 'null'.  However, since a 'void' function may be a reference
     to a non-'void' function, or a method refined by a non-'void'
     function, this behavior can not be depended upon and is not implied
     by the semantics of 'void'.


File: ceylon-spec.info,  Node: callabletypeoffunction,  Next: functionswithblocks,  Up: functions

4.7.1 Callable type of a function
---------------------------------

The _callable type_ of a function captures the return type and parameter
types of the function.

   * The callable type of a function with a single parameter list is
     'R(*P)' where 'R' is the return type of the method, or 'Anything'
     if the function is 'void', and 'P' is the type of the parameter
     list.

   * The callable type of a function with multiple parameter lists is
     'O(*P)', where 'O' is the callable type of a method produced by
     eliminating the first parameter list, and 'P' is the type of the
     first parameter list of the function.

     Note: this means that the callable type of a function lists the
     parameter lists in reverse order of the function declaration.  A
     function 'C f(A a)(B b)' has the callable type 'C(B)(A)', not
     'C(A)(B)'.

     Note: the identification of 'void' with 'Anything' instead of
     'Null' or some other unit type will probably be contraversial.
     This approach allows a non-'void' method to refine a 'void' method
     or a non-'void' function to be assigned to a 'void' functional
     parameter.  Thus, we avoid rejecting perfectly well-typed code.


File: ceylon-spec.info,  Node: functionswithblocks,  Next: functionswithspecifiers,  Prev: callabletypeoffunction,  Up: functions

4.7.2 Functions with blocks
---------------------------

A function implementation may be a block.

   * If the function is declared 'void', the block may not contain a
     'return' directive that specifies an expression.

   * Otherwise, every conditional execution path of the block must end
     in a 'return' directive that specifies an expression assignable to
     the return type of the function, or in a 'throw' directive, as
     specified in *note Definite return: definitereturn.

     shared Integer add(Integer x, Integer y) {
         return x + y;
     }

     shared void printAll(Object* objects) {
         for (obj in objects) {
             print(obj);
         }
     }

     shared void addEntry(Key->Item entry) {
         map.put(entry.key,entry.item);
     }

     shared Set<Element> singleton<Element>(Element element)
             given Element satisfies Comparable<Element> {
         return TreeSet { element };
     }


File: ceylon-spec.info,  Node: functionswithspecifiers,  Next: returntypeinference,  Prev: functionswithblocks,  Up: functions

4.7.3 Functions with specifiers
-------------------------------

Alternatively, a function implementation may be a lazy specifier, that
is, an expression specified using '=>'.  The type of the specified
expression must be assignable to the return type of the function.  In
the case of a function declared 'void', the expression must be a legal
statement, as defined by *note Expression statements:
expressionstatements.

     shared Integer add(Integer x, Integer y) => x + y;

     shared void addEntry(Key->Item entry) => map.put(entry.key,entry.item);

     shared Set<Element> singleton<Element>(Element element)
                 given Element satisfies Comparable<Element>
             => TreeSet { element };


File: ceylon-spec.info,  Node: returntypeinference,  Next: functionforwarddeclaration,  Prev: functionswithspecifiers,  Up: functions

4.7.4 Function return type inference
------------------------------------

A non-'void', un-'shared' function with a block or lazy specifier may be
declared using the keyword 'function' in place of the explicit return
type declaration.  Then the function return type is inferred:

   * if the function implementation is a lazy specifier, then the return
     type of the function is the type of the specified expression,

   * if the function implementation is a block, and the function
     contains no 'return' directive, then the return type of the method
     is 'Nothing' (this is the case where the method always terminates
     in a 'throw' directive), or,

   * otherwise, the return type of the function is the union of all
     returned expression types of 'return' directives of the method
     body.

   This function has inferred return type 'Integer'.

     function add(Integer x, Integer y) => x + y;
   This function has inferred return type 'Float|Integer'.

     function unit(Boolean floating) {
         if (floating) {
             return 1.0;
         }
         else {
             return 1;
         }
     }
   This function has inferred return type 'Nothing'.

     function die() {
         throw;
     }


File: ceylon-spec.info,  Node: functionforwarddeclaration,  Next: multipleparameterlists,  Prev: returntypeinference,  Up: functions

4.7.5 Forward declaration of functions
--------------------------------------

The declaration of a function may be separated from the specification of
its implementation.  If a function declaration does not have a lazy
specifier, or a block, and is not annotated 'formal', and is not a
parameter, it is a _forward-declared_ function.

   A forward-declared function may later be specified using a
specification statement, as defined in *note Specification statements:
specificationstatements.  The specification statement for a
forward-declared function may be:

   * a lazy specification statement with parameter lists of exactly the
     same types as the function, and a specified expression assignable
     to the declared type of the function, or

   * an ordinary specification statement with a specified expression
     assignable to the callable type of the function.

     Comparison order(String x, String y);
     if (reverseOrder) {
         order(String x, String y) => y<=>x;
     }
     else {
         order(String x, String y) => x<=>y;
     }

     Comparison format(Integer x);
     switch (base)
     case (decimal) {
         format = (Integer i) => i.string;
     }
     case (binary) {
         format = formatBin;
     }
     case (hexadecimal) {
         format = formatHex;
     }
   Every forward-declared function must explicitly specify a type.  It
may not be declared using the keyword 'function'.

   A toplevel function may not be forward-declared.  A method of an
interface may not be forward-declared.  A method annotated 'default' may
not be forward-declared.

   If a 'shared' method is forward-declared, its implementation must be
definitely specified by all conditional paths in the class initializer.


File: ceylon-spec.info,  Node: multipleparameterlists,  Next: formalmethods,  Prev: functionforwarddeclaration,  Up: functions

4.7.6 Functions with multiple parameter lists
---------------------------------------------

A function may declare multiple lists of parameters.  A function with
more than one parameter list returns instances of 'Callable' in
'ceylon.language' when invoked.  Every function with multiple parameter
lists is exactly equivalent to a function with a single parameter list
that returns an anonymous function.

   This function declaration:

     Boolean greaterThan<Element>(Element val)(Element element)
             given Element satisfies Comparable<Element> =>
                     element>val;
   is equivalent to the following:

     Boolean(Element) greaterThan<Element>(Element val)
             given Element satisfies Comparable<Element> =>
                     (Element element) => element>val;
   For a function with 'n' parameter lists, there are 'n-1' inferred
anonymous functions.  The 'i'th inferred function:

   * has a callable type formed by eliminating the first 'i' parameter
     lists of the original declared function,

   * has the 'i+1'th parameter list of the original declared function,
     and

   * if 'i<n', returns the 'i+1'th inferred function, or

   * otherwise, if 'i==n', has the implementation of the original
     declared function.

   Then the original function returns the first inferred anonymous
function.

   This method declaration:

     function fullName(String firstName)(String middleName)(String lastName)
             => firstName + " " + middleName + " " + lastName;
   Is equivalent to:

     function fullName(String firstName) =>
             (String middleName) =>
                     (String lastName) =>
                             firstName + " " + middleName + " " + lastName;


File: ceylon-spec.info,  Node: formalmethods,  Next: methodrefinement,  Prev: multipleparameterlists,  Up: functions

4.7.7 Formal and default methods
--------------------------------

If a function declaration does not have a lazy specifier, or a block,
and is annotated 'shared', and is a method of either:

   * an interface, or

   * a class annotated 'abstract' or 'formal',

   then the function declaration may be annotated 'formal', and is
called a 'formal' method, or, sometimes, an _abstract method_.

     shared formal Item? get(Key key);
   A method which is not annotated 'formal' is called a _concrete_
method.

   If a concrete method is annotated 'shared', and is a member of a
class or interface, then it may be annotated 'default' and is called a
'default' method.

     shared default void writeLine(String line) {
         write(line);
         write("\n");
     }
   A method annotated 'formal' may not specify an implementation (a lazy
specifier, or a block).

   A method annotated 'default' must specify an implementation (a lazy
specifier, or a block), and may not be forward-declared.

   Every 'formal' method must explicitly specify a type. It may not be
declared using the keyword 'function'.

   A toplevel method may not be annotated 'formal' or 'default'.

   An un-'shared' method may not be annotated 'formal' or 'default'.


File: ceylon-spec.info,  Node: methodrefinement,  Prev: formalmethods,  Up: functions

4.7.8 Method refinement
-----------------------

Methods may be refined, just like in other object-oriented languages.

   * A class or interface may refine any 'formal' or 'default' method it
     inherits, unless it inherits a non-'formal' non-'default' method
     that refines the method.

   * A concrete class must refine every 'formal' method it inherits,
     unless it inherits a non-'formal' method that refines the method.

   A method of a subtype _refines_ a method of a supertype if the method
of the supertype is 'shared' and the two methods have the same name.
The first method is called the _refining_ method, and the second method
is called the _refined_ method.

   Then, given the refined realization of the method it refines, as
defined in *note Realizations: realizations, and, after substituting the
type parameters of the refined method for the type parameters of the
refining method in the schema of the refining method, the refining
method must:

   * have the same number of type parameters as the refined schema, and
     for each type parameter the intersection of its upper bounds must
     be a supertype of the intersection of the upper bounds of the
     corresponding type parameter of the realization,

   * have the same number of parameter lists, with the same signatures,
     as the realization, and

   * have a return type that is assignable to the return type of the
     realization, or

   * if it has no return type, the refined method must also have no
     return type.

     Note: in a future release of the language, we would like to support
     contravariant refinement of method parameter types.

   Furthermore:

   * the refining method must be annotated 'actual', and

   * the refined method must be annotated 'formal' or 'default'.

   If a method is annotated 'actual', it must refine some method defined
by a supertype.

   A method may not, directly or indirectly, refine two different
methods not themselves annotated 'actual'.

   Then invocation of the method is polymorphic, and the actual method
invoked depends upon the concrete type of the class instance.

     shared abstract class AbstractSquareRooter() {
         shared formal Float squareRoot(Float x);
     }

     class ConcreteSquareRooter()
             extends AbstractSquareRooter() {
         shared actual Float squareRoot(Float x) => x^0.5;
     }
   Alternatively, a subtype may refine a method using a specification
statement, as defined in *note Specification statements:
specificationstatements.  The specification statement must satisfy the
requirements of *note Forward declaration of functions:
functionforwarddeclaration. above for specification of a
forward-declared function.

     class ConcreteSquareRooter()
             extends AbstractSquareRooter() {
         squareRoot(Float x) => x^0.5;
     }


File: ceylon-spec.info,  Node: values,  Next: constructors,  Prev: functions,  Up: declarations

4.8 Values
==========

* Menu:


* references:: References
* getters:: Getters
* setters:: Setters
* valuetypeinference:: Value type inference
* valueforwarddeclaration:: Forward declaration of values
* formalattributes:: Formal and default attributes
* attributerefinement:: Attribute refinement

There are two basic kinds of _value_:

   * A _reference_ defines state.  It has a persistent value, determined
     at the moment it is specified or assigned.

   * A _getter_ defines how a value is evaluated.  It is defined using a
     block or lazy specifier, which is executed every time the value is
     evaluated.  A getter may have a matching _setter_.

   If a value belongs to a type, it is called an _attribute_.

ValueDeclaration: Annotations ValueHeader (Block | (Specifier | LazySpecifier)? ";")
   All value declarations specify the value name.

ValueHeader: ValuePrefix MemberName
   A value declaration may specify a type.

ValuePrefix: Type | "value" | "dynamic"
   Instead of an explicit return type, a value may be declared using:

   * the keyword 'dynamic', indicating that it is a partially typed
     declaration with no type, or

   * the keyword 'value', indicating that its type is inferred.

     Note: syntactically a value declaration looks like a function
     declaration with zero parameter lists.  It is often helpful, in
     thinking about the syntax and semantics of Ceylon, to take the
     perspective that a value is a function with zero parameter lists,
     or, alternatively, that a function is a value of type 'Callable'.

   A value may be _variable_, in which case it may be freely assigned
using the assignment and compound assignment operators defined in *note
Operators: operators.  This is the case for a reference annotated
'variable', or for a getter with a matching setter.


File: ceylon-spec.info,  Node: references,  Next: getters,  Up: values

4.8.1 References
----------------

The lifecycle and scope of the persistent value of a reference depends
upon where the reference declaration occurs:

   * A toplevel reference represents global state associated with the
     lifecyle of a module, as defined by *note Initialization of
     toplevel references: toplevelinitialization.

   * A reference declared directly inside the body of a class represents
     a persistent value associated with every instance of the class, as
     defined by *note Current instance of a class or interface:
     currentinstanceofaclassorinterface.  Repeated evaluation of the
     attribute of a particular instance of the class produces the same
     result until the attribute of the instance is assigned a new value.

   * A reference declared inside a block represents state associated
     with a frame, that is, with a particular execution of the
     containing block of code, as defined in *note Current frame of a
     block: currentframeofablock.

   The persistent value of a reference may be specified or initialized
as part of the declaration of the reference, or via a later
specification statement, as defined in *note Specification statements:
specificationstatements, or assignment expression, as defined in *note
Operators: operators, or, if it is a parameter, by an argument to an
invocation expression, as defined in *note Invocation expressions:
invocationexpressions.

   A reference annotated 'variable' has a persistent value that can be
assigned multiple times.  A reference not annotated 'variable' has a
persistent value that can be specified exactly once and not subsequently
modified.

     variable Integer count = 0;

     shared Decimal pi = calculatePi();

     shared Integer[] evenDigits = [0,2,4,6,8];
   A reference declaration may have a specifier which specifies its
persistent value or, in the case of a variable reference, its initial
persistent value.  The type of the specified expression must be
assignable to the type of the reference.

   If the specified expression has no type, and the declaration occurs
within a 'dynamic' block, then the specification is not type-checked at
compile time.

   If a reference is a parameter, it must not specify a persistent
value.

   A reference belonging to a class may be annotated 'late', in which
case the initializer of the class is not required to initialize its
persistent value.  Furthermore, a self-reference to an instance being
initialized may be assigned to the reference.

   A reference annotated 'late' may not be initialized or assigned a
value by the class initializer.  A parameter may not be annotated
'late'.  A reference not belonging to a class may not be annotated
'late'.

   If a class declares or inherits a 'variable' reference, it must
(directly or indirectly) extend the class 'Basic' defined in
'ceylon.language'.


File: ceylon-spec.info,  Node: getters,  Next: setters,  Prev: references,  Up: values

4.8.2 Getters
-------------

A getter implementation may be a block.

     shared Float total {
         variable Float sum = 0.0;
         for (li in lineItems) {
             sum += li.amount;
         }
         return sum;
     }
   Every conditional execution path of the block must end in a 'return'
directive that specifies an expression assignable to the type of the
value, or in a 'throw' directive, as specified in *note Definite return:
definitereturn.

   Alternatively, a getter implementation may be a lazy specifier, that
is, an expression specified using '=>'.  The type of the specified
expression must be assignable to the type of the value.

     Name name => Name(firstName, initial, lastName);


File: ceylon-spec.info,  Node: setters,  Next: valuetypeinference,  Prev: getters,  Up: values

4.8.3 Setters
-------------

A setter defines how the value of a getter is assigned.

SetterDeclaration: Annotations "assign" MemberName (Block | LazySpecifier)
   The name specified in a setter declaration must be the name of a
matching getter that directly occurs earlier in the body containing the
setter declaration.  If a getter has a setter, we say that the value is
_variable_.

   Within the body of the setter, a value reference to the getter
evaluates to the value being assigned.

   A setter implementation may be a block.  The block may not contain a
return directive that specifies an expression.

     shared String name { return join(firstName, lastName); }
     assign name { firstName=first(name); lastName=last(name); }
   Alternatively, a setter implementation may be a lazy specifier. The
specified expression must be a legal statement.

     shared String name => join(n[0], n[1]);
     assign name => n = [first(name), last(name)];
   A setter may not be annotated 'shared', 'default' or 'actual'.  The
visibility and refinement modifiers of an attribute with a setter are
specified by annotating the matching getter.


File: ceylon-spec.info,  Node: valuetypeinference,  Next: valueforwarddeclaration,  Prev: setters,  Up: values

4.8.4 Value type inference
--------------------------

An un-'shared' value with a block, specifier, or lazy specifier may be
declared using the keyword 'value' in place of the explicit type
declaration.  Then the value's type is inferred:

   * if the value is a reference with a specifier, then the type of the
     value is the type of the specified expression,

   * if the value is a getter, and the getter implementation is a lazy
     specifier, then the type of the value is the type of the specified
     expression,

   * if the value is a getter, and the getter implementation is a block,
     and the getter contains no 'return' directive, then the type of the
     value is 'Nothing' (this is the case where the getter always
     terminates in a 'throw' directive), or

   * otherwise, the type of the value is the union of all returned
     expression types of 'return' directives of the getter body.

     value names = List<String>();

     variable value count = 0;

     value name => Name(firstName, initial, lastName);


File: ceylon-spec.info,  Node: valueforwarddeclaration,  Next: formalattributes,  Prev: valuetypeinference,  Up: values

4.8.5 Forward declaration of values
-----------------------------------

The declaration of a reference may be separated from the specification
or initialization of its persistent value.  The declaration of a getter
may be separated from the specification of its implementation.  If a
value declaration does not have a specifier, lazy specifier, or a block,
and is not annotated 'formal', it is a _forward-declared_ value.

   A forward-declared value may later be specified using a specification
statement, as defined in *note Specification statements:
specificationstatements.

   * The specification statement for a forward-declared getter is a lazy
     specification statement with no parameter list, and a specified
     expression assignable to the type of the value.

   * The specification statement for a forward-declared reference is an
     ordinary specification statement with a specified expression
     assignable to the type of the value.

     String greeting;
     switch (language)
     case (en) {
         greeting = "Hello";
     }
     case (es) {
         greeting = "Hola";
     }
     else {
         throw LanguageNotSupported();
     }
     print(greeting);
   Every forward-declared value must explicitly specify a type.  It may
not be declared using the keyword 'value'.

   A toplevel value may not be forward-declared.  An attribute of an
interface may not be forward-declared.  An attribute annotated 'default'
may not be forward-declared.

   A forward-declared getter may not have a setter.

   If a 'shared' value is forward-declared, its implementation must be
definitely specified by all conditional paths in the class initializer.


File: ceylon-spec.info,  Node: formalattributes,  Next: attributerefinement,  Prev: valueforwarddeclaration,  Up: values

4.8.6 Formal and default attributes
-----------------------------------

If a value declaration does not have a specifier, lazy specifier, or a
block, and is annotated 'shared', and is a member of either:

   * an interface, or

   * a class annotated 'abstract' or 'formal',

   then the value declaration may be annotated 'formal', and is called a
'formal' attribute, or, sometimes, an _abstract attribute_.

     shared formal variable String firstName;
   An attribute which is not annotated 'formal' is called a _concrete_
attribute.

   If a concrete attribute is annotated 'shared', and is a member of a
class or interface, then it may be annotated 'default' and is called a
'default' attribute.

     shared default String greeting = "Hello";
   An attribute annotated 'formal' may not specify an implementation (a
specifier, lazy specifier, or a block).  Nor may there be a setter for a
formal attribute.

   An attribute annotated 'default' must specify an implementation (a
specifier, lazy specifier, or a block), and may not be forward-declared.

   Every 'formal' attribute must explicitly specify a type. It may not
be declared using the keyword 'function'.

   A toplevel attribute may not be annotated 'formal' or 'default'.

   An un-'shared' attribute may not be annotated 'formal' or 'default'.


File: ceylon-spec.info,  Node: attributerefinement,  Prev: formalattributes,  Up: values

4.8.7 Attribute refinement
--------------------------

Ceylon allows attributes to be refined, just like methods.  This helps
eliminate the need for Java-style getter and setter methods.

   * A class or interface may refine any 'formal' or 'default' attribute
     it inherits, unless it inherits a non-'formal' non-'default'
     attribute that refines the attribute.

   * A concrete class must refine every 'formal' attribute it inherits,
     unless it inherits a non-'formal' attribute that refines the
     attribute.

   Any non-variable attribute may be refined by a reference or getter.
A variable attribute may be refined by a 'variable' refernce or by a
getter and setter pair.

     TODO: are you allowed to refine a getter or setter without also
     refining its matching setter or getter?

   An attribute of a subtype _refines_ an attribute of a supertype if
the attribute of the supertype is 'shared' and the two attributes have
the same name.  The first attribute is called the _refining_ attribute,
and the second attribute is called the _refined_ attribute.

   Then, given the refined realization of the attribute it refines, as
defined in *note Realizations: realizations, the refining attribute
must:

   * be variable, if the attribute it refines is variable, and

   * have _exactly the same type_ as the realization, if the attribute
     it refines is variable,

   * have a type that is assignable to the type of the refined schema,
     if the attribute it refines is not variable, or

   * if it has no type, the refined attribute must also have no type.

   Furthermore:

   * the refining attribute must be annotated 'actual', and

   * the refined attribute must be annotated 'formal' or 'default'.

   If an attribute is annotated 'actual', it must refine some attribute
defined by a supertype.

   An attribute may not, directly or indirectly, refine two different
attributes not themselves annotated 'actual'.

   A non-variable attribute may be refined by a variable attribute.

     TODO: Is that really allowed?  It could break the superclass.
     Should we say that you are allowed to do it when you refine an
     interface attribute, but not when you refine a superclass
     attribute?

   Then evaluation and assignment of the attribute is polymorphic, and
the actual attribute evaluated or assigned depends upon the concrete
type of the class instance.

     shared abstract class AbstractPi() {
         shared formal Float pi;
     }

     class ConcretePi()
             extends AbstractPi() {
         shared actual Float pi = calculatePi();
     }
   Alternatively, a subtype may refine an attribute using a
specification statement, as defined in *note Specification statements:
specificationstatements.  The specification statement must satisfy the
requirements of *note Forward declaration of values:
valueforwarddeclaration. above for specification of a forward-declared
attribute.

     class ConcretePi()
             extends AbstractPi() {
         pi = calculatePi();
     }


File: ceylon-spec.info,  Node: constructors,  Prev: values,  Up: declarations

4.9 Constructors
================

* Menu:


* callabletypeofaconstructor:: Callable type of a constructor
* partialconstructors:: Partial constructors
* constructordelegation:: Constructor delegation

A _constructor_ is a callable block of code that produces a new instance
of the class to which the constructor belongs.  Every constructor must
occur directly in the initializer section of a class. A constructor may
have parameters.  Every constructor implementation is a block of code.

ConstructorDeclaration: Annotations ConstructorHeader Block
   The are two basic kinds of constructor:

   * A _callable constructor_ declaration specifies the constructor
     name, if any, and exactly one parameter list.

   * A _value constructor_ declaration specifies just the constructor
     name.

   Any constructor declaration may, optionally, have an 'extends'
clause.

   A constructor name must be an initial lowercase identifier.

ConstructorHeader: ValueConstructorHeader | CallableConstructorHeader

CallableConstructorHeader: "new" MemberName? Parameters ExtendedType?

ValueConstructorHeader: "new" MemberName ExtendedType?
   If two constructors belong to the same class, then the constructors
must have distinct names.  A class may have at most one constructor with
no name.

   If a constructor has no name, then the constructor is called the
_default constructor_ of the class to which it belongs.  The default
constructor is always a callable constructor.

   Every default constructor must be annotated 'shared'.

     Note: from the point of view of a client, a class with a default
     constructor and no named constructors is indistinguishable from a
     class with an initializer parameter list.

     shared class Point {
         shared Float x;
         shared Float y;

         shared new origin {
             x = 0.0;
             y = 0.0;
         }
         shared new cartesian(Float x, Float y) {
             this.x = x;
             this.y = y;
         }
         shared new polar(Float r, Float theta) {
             this.x = r * cos(theta);
             this.y = r * sin(theta);
         }
         shared new (Float x, Float y)
                 extends cartesian(x, y) {}

         string => "(``x``, ``y``)";
     }
   A class with an initializer parameter list may not declare
constructors.

   A generic class may not declare value constructors.

   A class nested directly inside an interface may not declare value
constructors.

   A member class annotated 'formal', 'default', or 'actual' may not
declare constructors.

     Note: in a future release of the language, we might relax this
     restriction, and simply require that every 'actual' class provide a
     constructor with the same signature as the constructor of its
     superclass.

   A constructor annotated 'sealed' may not be invoked outside the
module in which it is defined.


File: ceylon-spec.info,  Node: callabletypeofaconstructor,  Next: partialconstructors,  Up: constructors

4.9.1 Callable type of a constructor
------------------------------------

For a callable constructor, the _callable type_ of the constructor
captures the type of the class, and parameter types of the constructor.
The callable type is 'T(*P)', where 'T' is the applied type formed by
the class with its own type parameters as type arguments, and 'P' is the
type of the parameter list of the constructor.

   A constructor of an 'abstract' class is not callable, except from the
'extends' clause of a subclass, or the class specifier of a class alias.

   A partial constructor is not callable, except from the 'extends'
clause of another constructor of the same class.

   The type of a value constructor is simply 'T', where 'T' is the class
to which it belongs.


File: ceylon-spec.info,  Node: partialconstructors,  Next: constructordelegation,  Prev: callabletypeofaconstructor,  Up: constructors

4.9.2 Partial constructors
--------------------------

A callable constructor annotated 'abstract' is called a _partial
constructor_.

   A partial constructor may not be annotated 'shared'.

   A default constructor may not be annotated 'abstract'.

   A value constructor may not be annotated 'abstract'.


File: ceylon-spec.info,  Node: constructordelegation,  Prev: partialconstructors,  Up: constructors

4.9.3 Constructor delegation
----------------------------

Every constructor of any class which does not directly extend 'Basic'
defined in 'ceylon.language' must explicitly delegate, as defined in
*note Extension: extendedclass, to either:

   * a different callable constructor of the same class, specifying
     arguments for the parameters of the constructor, or,

   * a callable constructor of its immediate superclass, specifying
     arguments for the parameters of the superclass constructor, if the
     superclass declares constructors, or, otherwise

   * the initializer of its immediate superclass, specifying arguments
     for the initializer parameters, if the superclass has an
     initializer parameter list.

   If the constructor of a class which directly extends 'Basic' does not
have an 'extends' clause, the constructor implicitly delegates to the
initializer of 'Basic'.


File: ceylon-spec.info,  Node: statementblocks,  Next: expressions,  Prev: declarations,  Up: Top

5 Statements, blocks, and control structures
********************************************

* Menu:


* blockstructure:: Block structure and references
* patternsandvariables:: Patterns and variables
* blocksandstatements:: Blocks and statements
* controlstructureconditions:: Conditions
* controlstructures:: Control structures and assertions

Function, value, and class bodies contain procedural code that is
executed when the function is invoked, the value evaluated, or the class
instantiated.  The code contains expressions and control directives and
is organized using blocks and control structures.

     Note: the Ceylon language has a recursive block
     structure--statements and declarations that are syntactically valid
     in the body of a toplevel declaration are, in general, also
     syntactically valid in the body of a nested declaration or of a
     control structure, and vice-versa.


File: ceylon-spec.info,  Node: blockstructure,  Next: patternsandvariables,  Up: statementblocks

5.1 Block structure and references
==================================

* Menu:


* declarationnameuniqueness:: Declaration name uniqueness
* scopeofdeclaration:: Scope of a declaration
* visibility:: Visibility
* hiddendeclarations:: Hidden declarations
* referenceabilityofdeclaration:: References and block structure
* typeinferenceandblockstructure:: Type inference and block structure
* unqualifiedreferenceresolution:: Unqualified reference resolution
* qualifiedreferenceresolution:: Qualified reference resolution

A _body_ is a block, defined in *note Blocks and statements:
blocksandstatements, class body, defined in *note Classes: classes,
interface body, defined in *note Interfaces: interfaces, or
comprehension clause, defined in *note Comprehensions: comprehensions.
Every body (except for a comprehension clause) is list of
semicolon-delimited statements, control structures, and declarations,
surrounded by braces.  Some bodies end in a control directive.  Every
program element in the list is said to _directly occur_ in the body. A
program element _directly occurs earlier_ than a second program element
if both program elements directly occur in a body and the first program
element occurs (lexically) earlier in the list than the second program
element.

   A program element _(indirectly) occurs_ in a body if:

   * the program element directly occurs in the body, or

   * the program element indirectly occurs inside the body of a
     declaration or control structure that occurs directly in the body.

   We sometimes say that the body _contains_ the program element if the
program element (indirectly) occurs in the body.

   A program element _(indirectly) occurs earlier_ than a second program
element if:

   * the two program elements both directly occur in the same body, and
     the second program element occurs after the first program element,
     or

   * the second program element indirectly occurs inside the body of a
     declaration or control structure, and the first program element
     directly occurs earlier than the declaration or control structure.

   Then we also say that the second program element _(indirectly) occurs
later_ than the first.  The set of program elements that occur later
than a program element is sometimes called the _lexical scope_ of the
program element.

   A program element _sequentially occurs_ in a body if:

   * the program element directly occurs in the body, or

   * the program element sequentially occurs inside the body of a
     control structure or constructor that occurs directly in the body.

   A program element _sequentially occurs earlier_ than a second program
element if:

   * the two program elements both directly occur in the same body, and
     the second program element occurs after the first program element,
     or

   * the second program element sequentially occurs inside the body of a
     control structure or constructor, and the first program element
     directly occurs earlier than the control structure or constructor.

   If a program element sequentially occurs earlier than a second
program element, the _sequence of statements_ from the first program
element to the second program element comprises:

   * the sequence of statements that occur directly in the body in which
     the first program element directly occurs, beginning from the first
     program element and ending with the second program element, if the
     second program element occurs directly in the same body as the
     first program element, or

   * the sequence of statements that occur directly in the body in which
     the first program element directly occurs, beginning from the first
     program element and ending with the control structure or
     constructor in whose body the second program element sequentially
     occurs, followed by the sequence of statements from the first
     statement of the declaration whose body contains the second program
     element to the second program element itself, otherwise.


File: ceylon-spec.info,  Node: declarationnameuniqueness,  Next: scopeofdeclaration,  Up: blockstructure

5.1.1 Declaration name uniqueness
---------------------------------

A program element is contained within the _namespace_ of a declaration
if either:

   * the declaration is a toplevel declaration, and the program element
     is a toplevel declaration of the same package,

   * the declaration directly occurs in a body, the program element
     occurs in the same body, and the declaration sequentially occurs
     earlier than the program element,

   * the declaration is a parameter or type parameter, and the program
     element sequentially occurs in the body of the parameterized
     declaration, or

   * the program element is a control structure variable or iteration
     variable of a control structure that sequentially occurs in the
     namespace of the declaration.

   The namespace of a declaration may not contain a second declaration
with the same name.  For example, the following is illegal:

     function fun(Float number) {
         if (number<0.0) {
             Float number = 1.0; //error
             ...
         }
         ...
     }
   As an exception to this rule, the namespace of a declaration
annotated 'native' may contain a second declaration with the same name
if:

   * the second declaration has exactly the same schema, as defined in
     *note Types: type,

   * the second declaration is also annotated 'native', and

   * the two 'native' annotations have distinct arguments for the
     'backend' parameter.

   A class or interface may not inherit a declaration with the same name
as a declaration it contains unless either:

   * the contained declaration directly or indirectly refines the
     inherited declaration,

   * the contained declaration is not 'shared', or

   * the inherited declaration is not 'shared'.

   A class or interface may not inherit two declarations with the same
name unless either:

   * the class or interface contains a declaration that directly or
     indirectly refines both the inherited declarations (in which case
     both the inherited declarations directly or indirectly refine some
     member of a common supertype, as required by *note Member class
     refinement: classrefinement, *note Attribute refinement:
     attributerefinement, and *note Method refinement:
     methodrefinement.),

   * one of the inherited declarations directly or indirectly refines
     the other inherited declaration, or

   * at least one of the inherited declarations is not 'shared'.


File: ceylon-spec.info,  Node: scopeofdeclaration,  Next: visibility,  Prev: declarationnameuniqueness,  Up: blockstructure

5.1.2 Scope of a declaration
----------------------------

The scope of a declaration is governed by the body or package in which
it occurs.  A declaration is _in scope_ at a program element if and only
if either:

   * the declaration is a parameter or type parameter of a declaration
     whose body contains the program element,

   * the declaration is a control structure variable or iteration
     variable belonging to a block of a control structure that contains
     the program element,

   * the program element belongs to or is contained in the body of the
     declaration itself,

   * the program element belongs to or is contained in the body of a
     class or interface which inherits the declaration,

   * the declaration directly occurs in a body containing the program
     element,

   * the declaration is imported into the toplevel namespace of the
     compilation unit containing the program element, or into the local
     namespace of a body containing the program element, as defined by
     *note Imports: imports, and is visible to the program element, as
     defined below in *note Visibility: visibility, or

   * the declaration is a toplevel declaration in the package containing
     the program element.

   Where:

   * A control structure variable or iteration variable _belongs_ to a
     block of a control structure if the block immediately follows the
     declaration of the variable.

   * A program element _belongs_ to a declaration if it occurs in the
     'extends', 'satisfies', 'of', or 'given' clause of the declaration.

   Furthermore:

   * A condition variable of a condition belonging to a condition list
     is in scope in any condition of the same condition list that occurs
     lexically later.

   * A resource expression variable of a 'try' statement is in scope in
     any resource expression of the same resource expression list that
     occurs lexically later.

   * An iteration variable or condition variable of a comprehension is
     in scope in any clause of the comprehension that occurs lexically
     later, since comprehension clauses are viewed as nested bodies.

   And finally, there are special rules for annotation lists, defined in
*note Annotation lists: annotationlists.:

   * An annotation argument list belongs to the annotated declaration.

   * An annotation name is considered to occur directly in the
     compilation unit containing the program element.

     Note: if no reference to an un-'shared' declaration occurs within
     the scope of the declaration, a compiler warning is produced.


File: ceylon-spec.info,  Node: visibility,  Next: hiddendeclarations,  Prev: scopeofdeclaration,  Up: blockstructure

5.1.3 Visibility
----------------

Classes, interfaces, functions, values, aliases, and type parameters
have names.  Occurrence of a name in code implies a hard dependency from
the code in which the name occurs to the schema of the named
declaration.  We say that a class, interface, value, function, alias, or
type parameter is _visible_ to a certain program element if its name may
occur in the code that belongs to that program element.

   The visibility of a declaration depends upon where it occurs, and
upon whether it is annotated 'shared'.  A toplevel or member declaration
may be annotated 'shared':

   * If a toplevel declaration is annotated 'shared', it is visible
     wherever the package that contains it is visible.  Otherwise, a
     toplevel declaration is visible only to code in the package
     containing its compilation unit.

   * If a member declaration is annotated 'shared', it is visible
     wherever the class or interface that contains it is visible.
     Otherwise, a declaration that occurs directly inside a class or
     interface body is visible only inside the class or interface
     declaration.

     Note: the Ceylon compiler enforces additional visibility
     restrictions for members of Java classes, since Java's visibility
     modifiers can express restrictions that cannot be reproduced within
     Ceylon's visibility model.  These restrictions are outside the
     scope of this specification.

   A type parameter or a declaration that occurs directly inside a block
(the body of a function, getter, setter, or control structure) may not
be annotated 'shared'.

   * A type parameter is visible only inside the declaration to which it
     belongs.

   * A declaration that occurs directly inside a block is visible only
     inside the block.

     TODO: Should we allow you to limit the effect of the 'shared'
     annotation by specifying a containing program element or package?

   We say that a type is _visible_ to a certain program element if it is
formed from references to classes, interfaces, type parameters, and type
aliases whose declarations are visible to the program element.  For
'shared' declarations:

   * The type of a value must be visible everywhere the value itself is
     visible.

   * The return type of a function must be visible everywhere the
     function itself is visible.

   * The satisfied interfaces of a class or interface must be visible
     everywhere the class or interface itself is visible.

   * The superclass of a class must be visible everywhere the class
     itself is visible.

   * The aliased type of a class alias, interface alias, or type alias
     must be visible everywhere the alias itself is visible.


File: ceylon-spec.info,  Node: hiddendeclarations,  Next: referenceabilityofdeclaration,  Prev: visibility,  Up: blockstructure

5.1.4 Hidden declarations
-------------------------

If two declarations with the same name or imported name, as defined in
*note Imported name: importedname, are both in scope at a certain
program element, then one declaration may _hide_ the other declaration.

   * If an inner body is contained (directly or indirectly) in an outer
     body, then a declaration that is in scope in the inner body, but is
     not in scope in the outer body, hides a declaration that is in
     scope in the outer body.  In particular, a declaration inherited by
     a nested class or interface hides a declaration of the containing
     body.

   * An un-'shared' declaration occurring directly in the body of a
     class containing the program element, or imported into the local
     namespace of the class body, hides a declaration inherited by the
     class.

   * An 'actual' declaration hides the declaration it refines.

   * A declaration occurring in a body containing the program element,
     or imported into the local namespace of a body containing the
     program element, hides a declaration imported into the toplevel
     namespace of the compilation unit containing the program element or
     implicitly imported from the module 'ceylon.language'.

   * A toplevel declaration of the package containing the program
     element hides a declaration implicitly imported from the module
     'ceylon.language'.

   * A declaration imported into the toplevel namespace of the
     compilation unit containing the program element, or into the local
     namespace of a body containing the program element, hides a
     toplevel declaration of the package containing the compilation unit
     in which the program element occurs.

   * A declaration explicitly imported by name into a namespace
     containing the program element hides a declaration imported by
     wildcard into the same namespace.

   For example, the following code is legal:

     class Person(name) {
         String name;
         shared String lowerCaseName {
             String name = this.name.lowercased;
             return name;
         }
     }
   As is this code:

     class Point(x, y) {
         shared Float x;
         shared Float y;
     }

     class Complex(Float x, Float y=0.0)
             extends Point(x, y) {}
   When a member of a class is hidden by a nested declaration, the
member may be accessed via the self reference 'this', defined in *note
this: this, or via the outer instance reference 'outer', defined in
*note outer: outer.

     shared class Item(name) {
         variable String name;
         shared void changeName(String name) {
             this.name = name;
         }
     }

     class Catalog(name) {
         shared String name;
         class Schema(name) {
             shared String name;
             Catalog catalog => outer;
             String catalogName => outer.name;
             class Table(name) {
                 shared String name;
                 Schema schema => outer;
                 String schemaName => outer.name;
                 String catalogName => catalog.name;
             }
         }
     }
   When a toplevel declaration of a package is hidden by another
declaration, the toplevel declaration may be accessed via the containing
package reference 'package', as defined in *note Unqualified reference
resolution: unqualifiedreferenceresolution.

     Integer n => 0;
     Integer f(Integer n) => n+package.n;


File: ceylon-spec.info,  Node: referenceabilityofdeclaration,  Next: typeinferenceandblockstructure,  Prev: hiddendeclarations,  Up: blockstructure

5.1.5 References and block structure
------------------------------------

A declaration may be in scope at a program element, but not
_referenceable_ at the program element.  A declaration is referenceable
at a program element if the declaration is in scope at the program
element and either:

   * the declaration is imported from a different compilation unit,

   * the program element occurs within the lexical scope of the
     declaration,

   * the declaration is a parameter and the program element occurs
     within the 'extends' clause of the declaration it parameterizes, or

   * the declaration does not directly occur in a block, nor in the
     initializer section of a class body.

   Note that these rules have very different consequences for:

   * a declaration that occurs in a block, as specified in *note Blocks
     and statements: blocksandstatements, or in an class initializer
     section, as specified in *note Initializer section:
     initializersection, and

   * a toplevel declaration, as specified in *note Toplevel and nested
     declarations: topleveldeclarations, or a declaration that occurs in
     a class declaration section, as specified in *note Declaration
     section: declarationsection, or interface body, as specified in
     *note Interface bodies: interfacebodies.

   Declarations that occurs in a block or class initializer section are
interspersed with procedural code that initializes references.
Therefore, a program element in a block or initializer may not refer to
a declaration that occurs later in the block or class body.  This
restriction does not apply to declarations that occur in an interface
body or class declaration section.  Nor does it apply to toplevel
declarations, which are not considered to have a well-defined order.

   The following toplevel function declarations, belonging to the same
package, are legal:

     Float x => y;

     Float y => x;
   This code is not legal, since the body of a function is an ordinary
block:

     Float->Float xy() {
         Float x => y;  //error: y is not referenceable
         Float y => x;
         return x->y;
     }
   This code is not legal, since all three statements occur in the
initializer section of the class body:

     class Point() {
         Float x => y;  //error: y is not referenceable
         Float y => x;
         Float->Float xy = x->y;
     }
   However, this code _is_ legal, since the statements occur in the
declaration section of the class body:

     class Point() {
         Float x => y;
         Float y => x;
     }
   Likewise, this code is legal, since the statements occur in an
interface body:

     interface Point {
         Float x => y;
         Float y => x;
     }
   If a declaration is annotation 'restricted', and a program element
does not occur in either:

   * the same package as the declaration, or

   * one of the modules specified as arguments to the 'restricted'
     annotation of the declaration,

   then the declaration is not referenceable at the program element.


File: ceylon-spec.info,  Node: typeinferenceandblockstructure,  Next: unqualifiedreferenceresolution,  Prev: referenceabilityofdeclaration,  Up: blockstructure

5.1.6 Type inference and block structure
----------------------------------------

A value declared using the keyword 'value' or a function declared using
the keyword 'function' may be in scope at a program element, but its
type may not be _inferable_, as defined by *note Type inference:
typeinference, from the point of view of that program element.

   The type of a value or function declared using the keyword 'value' or
'function' is inferable to a program element if the declaration is in
scope at the program element and the program element occurs within the
lexical scope of the declaration.

     Note: the type of a value or function declared using the keyword
     'value' or 'function' is not inferable within the body of the value
     or function itself.

   For any other declaration, including any declaration which explicitly
specifies its type, the type is considered inferable to a program
element if the declaration is in scope at the program element.

   The following code is not legal:

     interface Point {
         value x => y;  //error: type of y is not inferable
         value y => x;
     }
   However, this code is legal:

     interface Point {
         value x => y;
         Float y => x;
     }


File: ceylon-spec.info,  Node: unqualifiedreferenceresolution,  Next: qualifiedreferenceresolution,  Prev: typeinferenceandblockstructure,  Up: blockstructure

5.1.7 Unqualified reference resolution
--------------------------------------

An _unqualified reference_ is:

   * the type name in an unqualified type declaration or type argument,
     as defined by *note Type expressions: typeexpressions, for example
     'String' and 'Sequence' in 'Sequence<String>',

   * the value, function, constructor, or type name in a base
     expression, as defined by *note Base expressions: baseexpressions,
     for example 'counter' in 'counter.count', 'entries' and 'people' in
     'entries(people*.name)', or 'Entry', 'name', and 'item' in
     'Entry(name,item)', or

   * the type name in an unqualified type in a static expression, as
     defined by *note Static expressions: staticexpressions, or
     constructor expression, as defined by *note Constructor
     expressions: constructorexpressions, for example 'Sequence' in
     'Sequence.iterator'.

   If a program element contains an unqualified reference:

   * there must be at least one declaration in scope at the program
     element with the given name, or aliased to the given name by an
     'import' statement, as defined in *note Imported name:
     importedname, and

   * if multiple declarations with the given name or aliased to the
     given name are in scope at the program element where the given name
     occurs, then it is guaranteed by the type system and *note
     Declaration name uniqueness: declarationnameuniqueness. that there
     is exactly one such declaration which is not hidden by any other
     declaration.

   There are two exceptions to the above rules.

   * If the expression or type expression begins with the qualifier
     keyword 'package', then there must be a toplevel declaration with
     the given name defined in the package to which the compilation unit
     belongs.

   * If the expression or type expression occurs in an annotation list,
     as defined by *note Annotation lists: annotationlists, then there
     must be a toplevel declaration with the given name defined in the
     package to which the compilation unit belongs, or imported by a
     toplevel 'import' statement of the compilation unit.

   Then the reference is to this unique unhidden declaration, and:

   * the declaration must be referenceable at the program element,

   * the type of the declaration must be inferable to the program
     element, and

   * if the declaration is forward-declared, it must be definitely
     initialized at the program element.

   As a special exception to the above, if there is no declaration with
the given name or imported name in scope at the program element and the
program element occurs inside a 'dynamic' block, then the unqualified
reference does not refer to any statically typed declaration.

   If an unqualified reference refers to a member declaration of a type,
then there is a unique _inheriting or declaring class or interface_ for
the unqualified reference, that is, the unique class or interface in
whose body the unqualified reference occurs, and which declares or
inherits the member declaration, and for which the member is not hidden
at the program element where the unqualified reference occurs.


File: ceylon-spec.info,  Node: qualifiedreferenceresolution,  Prev: unqualifiedreferenceresolution,  Up: blockstructure

5.1.8 Qualified reference resolution
------------------------------------

A _qualified reference_ is:

   * the type name in a qualified type declaration or type argument, as
     defined by *note Type expressions: typeexpressions, for example
     'Buffer' in 'BufferedReader.Buffer',

   * the value, function, or type name in a member expression, as
     defined by *note Member expressions: memberexpressions, for example
     'count' in 'counter.count', 'split' in 'text.split()', or 'Buffer'
     in 'br.Buffer()',

   * the constructor name in a constructor expression, as defined by
     *note Constructor expressions: constructorexpressions, or

   * the type name in a qualified type in a static expression, as
     defined by *note Static expressions: staticexpressions, for example
     'Buffer' in 'BufferedReader.Buffer.size', or the member name in a
     static expression, for example 'iterator' in 'Sequence.iterator',
     or 'size' in 'BufferedReader.Buffer.size'.

   Every qualified reference has a qualifying type:

   * For a type declaration, the qualifying type is the full qualified
     type the qualifies the type name.

   * For a value reference or callable reference, the qualifying type is
     the type of the receiver expression.

   * For a constructor reference, the qualifying type is the type of the
     qualifying base or member expression.

   * For a static reference, the qualifying type is the full qualified
     type the qualifies the type or member name.

   A qualified reference may not have 'Nothing' as the qualifying type.

   If a program element contains a qualified reference:

   * the qualifying type must have or inherit at least one member or
     nested type with the given name or aliased to the given imported
     name, as defined in *note Imported name: importedname, which is
     visible at the program element, and

   * if there are multiple visible members with the given name or
     imported name, then it is guaranteed by the type system and *note
     Declaration name uniqueness: declarationnameuniqueness. that there
     is exactly one such member which is not refined by another member,
     except

   * if the qualifying type inherits a class or interface that contains
     the program element, and an un-'shared' declaration contained
     directly in the body of this class or interface has the same name
     as a 'shared' member of the qualifying type, in which case the
     un-'shared' declaration hides the 'shared' member, or

   * if the qualifying type is an intersection type, in which case there
     may be multiple members which are not refined by another member,
     but where there is exactly one such member that is refined by each
     of these members, but is not refined by another member that is
     refined by all of these members, except

   * in the case of certain pathological intersection types, where two
     of the intersected types declare distinct members with the same
     name, that do not refine any member of a common supertype (in which
     case what we actually have are disjoint types that are nevertheless
     not considered provably disjoint within the rules of the
     typesystem), and in this case the qualified reference is considered
     illegal.

   Then the reference is to the unique member or nested class.  If the
program element is contained in the body of a class or interface, and
the member declaration directly occurs in the body of the class or
interface, and the qualified reference is a value reference or callable
reference, and the receiver expression is a self reference to the
instance being initialized, then:

   * the member declaration must be referenceable at the program
     element,

   * the type of the member must be inferable to the program element,
     and

   * if the member declaration is forward-declared, it must be
     definitely initialized at the program element.

   As a special exception to the above, if the program element occurs
inside a 'dynamic' block, and the the receiver expression has no type,
then the qualified reference does not refer to any statically typed
declaration.


File: ceylon-spec.info,  Node: patternsandvariables,  Next: blocksandstatements,  Prev: blockstructure,  Up: statementblocks

5.2 Patterns and variables
==========================

* Menu:


* controlstructurevariables:: Variables
* patterns:: Patterns
* patternvariables:: Pattern variables
* tuplepatterns:: Tuple patterns
* entrypatterns:: Entry patterns

Destructuring statements, assertions, and some control structures allow
inline declaration of a _variables_, which often occur as part of a more
complex _pattern_.

     Note: the use of the term variable here does not imply any
     connection to the 'variable' annotation for values.  A variable in
     a destructuring statement, assertion, or control structure may not
     be assigned using a specification or assignment statement.


File: ceylon-spec.info,  Node: controlstructurevariables,  Next: patterns,  Up: patternsandvariables

5.2.1 Variables
---------------

A variable is a streamlined form of reference declaration, as defined by
*note References: references.

TypedVariable: Type MemberName
   In most cases, the explicit type be omitted.

Variable: (Type | "value")? MemberName
   If the explicit type is missing from the declaration, the type of the
variable is inferred, according to rules that depend upon the control
structure to which the variable belongs.

   A variable declared by a destructuring statement is a reference
scoped to the body in which the destructuring statement occurs.

   A variable declared by an assertion is a reference scoped to the body
in which the 'assert' statement occurs.

   A variable declared by a control structure is a reference scoped to
the block that immediately follows the variable declaration:

   * For a variable in an 'if' condition, the scope of the variable is
     the 'if' block.

   * For a variable in a 'while' condition, the scope of the variable is
     the 'while' block.

   * For a variable in a 'for' iterator, the scope of the variable is
     the 'for' block.

   * For a variable in a 'try' clause, the scope of the variable is the
     'try' block.

   * For a variable in a 'catch' clause, the scope of the variable is
     the 'catch' block.

   * For a variable in an 'assert' statement, the scope of the variable
     is the body containing the 'assert' statement.


File: ceylon-spec.info,  Node: patterns,  Next: patternvariables,  Prev: controlstructurevariables,  Up: patternsandvariables

5.2.2 Patterns
--------------

An expression whose type is an instantiation of 'Sequential',
'Sequence', 'Tuple', or 'Entry' may be assigned to a _pattern_.  The
type of an expression assigned to a pattern is called the _patterned
type_.

     TODO: actually, the following section does not do justice to the
     compiler, which can actually handle subtypes of these types,
     including type parameters upper bounded by these types.

   Patterns are formed from:

   * pattern variables,

   * tuple patterns, and

   * entry patterns.

Pattern: Variable | TuplePattern | EntryPattern

     Note: in a future release of the language, we might introduce a
     more general pattern matching system, allowing pattern matching
     against arbitrary classes.


File: ceylon-spec.info,  Node: patternvariables,  Next: tuplepatterns,  Prev: patterns,  Up: patternsandvariables

5.2.3 Pattern variables
-----------------------

A _pattern variable_ is just a variable, as defined above, that occurs
in a pattern.

   If the variable has an explicit type, then the patterned type must be
assignable to this type.  Otherwise, the type of the variable is
inferred to be the patterned type.

   A _variadic pattern variable_ is indicated with an asterisk.

VariadicVariable: UnionType? "*" MemberName
   Variadic pattern variables only occur in tuple patterns.


File: ceylon-spec.info,  Node: tuplepatterns,  Next: entrypatterns,  Prev: patternvariables,  Up: patternsandvariables

5.2.4 Tuple patterns
--------------------

A tuple pattern comprises a list of _element patterns_, ending in,
optionally, a variadic pattern variable called a _variadic_ element
pattern. Tuple patterns are enclosed in brackets.

TuplePattern: "[" (Pattern ",")* (Pattern | VariadicVariable) "]"
   The patterned type must be an instantiation of the type 'Tuple',
'Sequential', or 'Sequence' in 'ceylon.language'.  Then:

   * If the tuple pattern has only one element pattern, and it is
     variadic, then the patterned type of this variadic element pattern
     is just the patterned type of the surrounding tuple pattern.

   * Or, if the tuple pattern has only one element pattern, and it is
     not variadic, then the patterned type must be a single-element
     instantiation '[T]' of 'Tuple', and the patterned type of the
     element pattern is 'T'.

   * Otherwise, if the patterned type is an instantiation 'Tuple<T,F,R>'
     of 'Tuple', then the patterned type of the first element pattern is
     'F', and the patterned types of the remaining element patterns, if
     any, are determined by forming a new tuple pattern with patterned
     type 'R' by removing the first element pattern from the list of
     element patterns.

   * Or, if the patterned type is an instantiation '[T+]' of 'Sequence',
     then there must be exactly two element patterns, and the second
     element pattern must be variadic.  Then the patterned type of the
     first element pattern is 'T', and the patterned type of the second
     element pattern is '[T*]'.

     value [x, y, z] = [1.0, 2.0, 0.0];

     value [first, *rest] = sequence;

     Note: Ceylon does not support parallel assignment statements of
     form 'value x, y, z = 1.0, 2.0, 0.0;' since the infix '=' symbol
     has a higher precedence than the comma ',' throughout the language.


File: ceylon-spec.info,  Node: entrypatterns,  Prev: tuplepatterns,  Up: patternsandvariables

5.2.5 Entry patterns
--------------------

An entry pattern comprises a _key pattern_, followed by an _item
pattern_.

EntryPattern: KeyOrItemPattern "->" KeyOrItemPattern

KeyOrItemPattern: Variable | TuplePattern
   The patterned type must be an instantiation 'K->V' of the type
'Entry' in 'ceylon.language'.  Then:

   * the patterned type of the key pattern is 'K', and

   * the patterned type of the item pattern is 'V'.

     value name->[lat,long] = observatory;


File: ceylon-spec.info,  Node: blocksandstatements,  Next: controlstructureconditions,  Prev: patternsandvariables,  Up: statementblocks

5.3 Blocks and statements
=========================

* Menu:


* expressionstatements:: Expression statements
* controldirectives:: Control directives
* specificationstatements:: Specification statements
* destructuringstatements:: Destructuring statements
* dynamicblocks:: Dynamic blocks
* definitereturn:: Definite return
* definiteinitialization:: Definite initialization
* definiteuninitialization:: Definite uninitialization

A _block_ is list of semicolon-delimited statements, control structures,
and declarations, surrounded by braces.  A block may begin with a list
of local 'import' statements, as defined in *note Imports: imports.

Block: "{" Import* (Declaration | Statement)* "}"
   A _statement_ is an assignment or specification, an invocation of a
method, an instantiation of a class, a destructuring statement, a
control structure, a control directive, or an assertion.

Statement: ExpressionStatement | Specification | Destructure | Directive | ControlStructure | Dynamic
   A statement or declaration contained in a block may not evaluate a
value, invoke a function, instantiate a class, or extend a class whose
declaration occurs later in the block.


File: ceylon-spec.info,  Node: expressionstatements,  Next: controldirectives,  Up: blocksandstatements

5.3.1 Expression statements
---------------------------

Only certain expressions are valid statements:

   * assignment,

   * prefix or postfix increment or decrement,

   * invocation of a method,

   * instantiation of a class.

ExpressionStatement: ( Assignment | IncrementOrDecrement | Invocation ) ";"
   For example:

     x += 1;

     x++;

     print("Hello");

     Main(process.arguments);


File: ceylon-spec.info,  Node: controldirectives,  Next: specificationstatements,  Prev: expressionstatements,  Up: blocksandstatements

5.3.2 Control directives
------------------------

A _control directive_ statement ends execution of the current block and
forces the flow of execution to resume in some outer scope. They may
only occur as the lexically last statement of a block.

   There are four control directives:

   * the 'return' directive--to return a value from a getter or
     non-'void' function or terminate execution of a setter, class
     initializer, or 'void' method,
   * the 'break' directive--to terminate a loop,
   * the 'continue' directive--to jump to the next iteration of a loop,
     and
   * the 'throw' directive--to raise an exception.

Directive: (Return | Throw | Break | Continue) ";"
   For example:

     throw Exception();

     return x+y;

     break;

     continue;
   The 'return' directive must sequentially occur in the body of a
function, getter, setter, or class initializer.  In the case of a
setter, class initializer, or 'void' function, no expression may be
specified.  In the case of a getter or non-'void' function, an
expression must be specified.  The expression type must be assignable to
the return type of the function or the type of the value.  When the
directive is executed, the expression is evaluated to determine the
return value of the function or getter.

Return: "return" Expression?
   If the specified expression has no type, or if the function or getter
has no type, and the directive occurs within a 'dynamic' block, then the
directive is not type-checked at compile time.

     Note: a 'return' statement returns only from the innermost
     function, getter, setter, or class initializer, even in the case of
     a nested or anonymous function.  There are no "non-local returns"
     in the language.

   The 'break' directive must sequentially occur in the body of a loop.

Break: "break"
   The 'continue' directive must sequentially occur in the body of a
loop.

Continue: "continue"
   A 'throw' directive may appear anywhere and may specify an
expression, whose type must be a subtype of type 'Throwable' defined in
'ceylon.language'.  When the directive is executed, the expression is
evaluated and the resulting exception is thrown.  If no expression is
specified, the directive is equivalent to 'throw Exception()'.

Throw: "throw" Expression?
   If the specified expression has no type, and the directive occurs
within a 'dynamic' block, then the directive is not type-checked at
compile time.


File: ceylon-spec.info,  Node: specificationstatements,  Next: destructuringstatements,  Prev: controldirectives,  Up: blocksandstatements

5.3.3 Specification statements
------------------------------

A _specification_ statement may specify or initialize the persistent
value of a forward-declared reference, or specify the implementation of
a forward-declared getter or function.

Specification: ValueSpecification | LazySpecification
   The persistent value of a forward-declared reference or the
implementation of a forward-declared function may be specified by a
_value specification statement_.  The value specification statement
consists of an unqualified value reference, or a qualified value
reference where the receiver expression is 'this', and an ordinary '='
specifier.  The value reference must refer to a declaration which
sequentially occurs earlier in the body in which the specification
statement occurs.

ValueSpecification: ("this" ".")? MemberName Specifier ";"
   The type of the specified expression must be assignable to the type
of the reference, or to the callable type of the function.

   If the specified expression has no type, or if the reference or
function has no type, and the specification occurs within a 'dynamic'
block, then the specification is not type-checked at compile time.

     String greeting;
     if (exists name) {
         greeting = "hello ``name``";
     }
     else {
         greeting = "hello world";
     }

     String process(String input);
     if (normalize) {
         process = String.normalized;
     }
     else {
         process = (String s) => s;
     }

     Note: there is an apparent ambiguity here.  Is the statement 'x=1;'
     a value specification statement, or an assignment expression
     statement?  The language resolves this ambiguity by favoring the
     interpretation as a specification statement whenever that
     interpretation is viable.  This is a transparent solution, since it
     accepts strictly more code than the alternative interpretation, and
     for ambiguous cases the actual semantics are identical between the
     two interpretations.

   The implementation of forward-declared getter or function may be
specified using a _lazy specification statement_.  The specification
statement consists of either:

   * an unqualified value reference, or a qualified value reference
     where the receiver expression is 'this', and a lazy '=>' specifier,
     or

   * a unqualified callable reference, or a qualified value reference
     where the receiver expression is 'this', one or more parameter
     lists, and a lazy specifier.

   The value reference or callable reference must refer to a declaration
which sequentially occurs earlier in the body in which the specification
statement occurs.

   A callable reference followed by a parameter list is itself
considered a callable reference, called a _parameterized reference_. If
the parameter list has type 'P' then the callable reference must have
the exact type 'R(*P)' for some type 'R'.  Then the type of the
parameterized reference is 'R'.

ParameterizedReference: ("this" ".")? MemberName Parameters+
   Thus, the specification statement consists of a parameterized
reference followed by a lazy specifier.

LazySpecification: (MemberName | ParameterizedReference) LazySpecifier ";"
   The type of the specified expression must be assignable to the type
of the parameterized reference, or to the type of the value reference.

     String greeting;
     if (exists name) {
         greeting => "hello ``name``";
     }
     else {
         greeting => "hello world";
     }

     String process(String input);
     if (normalize) {
         process(String input) => input.normalized;
     }
     else {
         process(String s) => s;
     }


File: ceylon-spec.info,  Node: destructuringstatements,  Next: dynamicblocks,  Prev: specificationstatements,  Up: blocksandstatements

5.3.4 Destructuring statements
------------------------------

A _destructuring statement_ assigns an expression to a pattern, as
defined above in *note Patterns: patterns.

Destructure: "value" (TuplePattern | EntryPattern) Specifier ";"
   The type of the specified expression is the patterned type of the
tuple or entry pattern.


File: ceylon-spec.info,  Node: dynamicblocks,  Next: definitereturn,  Prev: destructuringstatements,  Up: blocksandstatements

5.3.5 Dynamic blocks
--------------------

A 'dynamic' block allows interoperation with dynamically typed native
code.

Dynamic: "dynamic" Block
   Inside a 'dynamic' block an expression may have no type, as specified
in *note Expressions: expressions.

   An expression with no type:

   * may be specified or assigned to a typed value, as defined in *note
     Specification statements: specificationstatements,

   * may be passed as the argument of a typed parameter in an invocation
     expression, as defined in *note Direct invocations:
     directinvocations,

   * may be the invoked expression of an invocation, as defined in *note
     Invocation expressions: invocationexpressions,

   * may be returned by a typed function or getter, or thrown as an
     exception, as defined in *note Control directives:
     controldirectives,

   * may be the operand of an operator expression, as defined in *note
     Compound expressions: compoundexpressions, or

   * may be the subject of a control structure condition, as defined in
     *note Conditions: controlstructureconditions, a 'switch', as
     defined in *note switch/case/else: switchcaseelse, or a 'for'
     iterator, as defined in *note for/else: forelse.

   Furthermore:

   * a qualified or unqualified reference may not refer to a statically
     typed declaration, as defined by *note Unqualified reference
     resolution: unqualifiedreferenceresolution. and *note Qualified
     reference resolution: qualifiedreferenceresolution.

   These situations result in _dynamic type checking_, as defined in
*note Dynamic type checking: dynamictypechecking, since the usual static
type checks are impossible.

     Note: within a 'dynamic' block, Ceylon behaves like a language with
     optional static typing, performing static type checks where
     possible, and dynamic type checking where necessary.


File: ceylon-spec.info,  Node: definitereturn,  Next: definiteinitialization,  Prev: dynamicblocks,  Up: blocksandstatements

5.3.6 Definite return
---------------------

A sequence of statements may _definitely return._

   * A sequence of statements definitely returns if it ends in a
     'return' or 'throw' directive, or in a control structure that
     definitely returns, or contains an assertion with a condition list
     that is never satisfied.

   * A body definitely returns if it contains a list of statements that
     definitely returns.

   * An 'if' conditional definitely returns if it has an 'else' block
     and both the 'if' and 'else' blocks definitely return, or if its
     condition list is always satisfied and the 'if' block definitely
     returns, or if its condition list is never satisfied and it has an
     'else' block that definitely returns.

   * A 'switch' conditional definitely returns if all 'case' blocks
     definitely return and the 'else' block, if any, definitely returns.

   * A 'for' loop definitely returns if it has an 'else' block that
     definitely returns, and there is no 'break' directive in the 'for'
     block, or if the iterated expression type is a nonempty type, and
     the 'for' block definitely returns.

   * A 'while' loop definitely returns if its condition list is always
     satisfied and the 'while' block definitely returns.

   * A 'try/catch' exception manager definitely returns if the 'try'
     block definitely returns and all 'catch' blocks definitely return
     or if the 'finally' block definitely returns.

   The body of a non-'void' method or getter must definitely return.

   A body may not contain an additional statement, control structure, or
declaration following a sequence of statements that definitely returns.
Such a statement, control structure, or declaration is considered
_unreachable_.


File: ceylon-spec.info,  Node: definiteinitialization,  Next: definiteuninitialization,  Prev: definitereturn,  Up: blocksandstatements

5.3.7 Definite initialization
-----------------------------

A sequence of statements may _definitely initialize_ a forward-declared
declaration.

   * A sequence of statements definitely initializes a declaration if
     one of the statements is a specification statement or assigment
     expression for the declaration or a control structure that
     definitely initializes the declaration, or if the sequence of
     statements ends in a 'return' or 'throw' directive, or contains an
     assertion with a condition list that is never satisfied.

   * An 'if' conditional definitely initializes a declaration if it has
     an 'else' block and both the 'if' and 'else' blocks definitely
     initialize the declaration, of if its condition list is always
     satisfied and the 'if' block definitely initializes the
     declaration, of if its condition list is never satisfied and it has
     an 'else' block that definitely initializes the declaration.

   * A 'switch' conditional definitely initializes a declaration if all
     'case' blocks definitely initialize the declaration and the 'else'
     block, if any, definitely initializes the declaration.

   * A 'for' loop definitely initializes a declaration if it has an
     'else' block that definitely initializes the declaration, and there
     is no 'break' directive in the 'for' block, or if the iterated
     expression type is a nonempty type, and the 'for' block definitely
     initializes the declaration.

   * A 'while' loop definitely initializes a declaration if its
     condition list is always satisfied and the 'while' block definitely
     initializes the declaration.

   * A 'try/catch' exception manager definitely initializes a
     declaration if the 'try' block definitely initializes the
     declaration and all 'catch' blocks definitely initialize the
     declaration or if the 'finally' block definitely initializes the
     declaration.

   * A constructor of a class definitely initializes a declaration if
     the body of the constructor definitely initializes the declaration,
     or if the constructor delegates to a constructor which definitely
     initializes the declaration.

   * The constructors of a class definitely initialize a declaration if
     every non-partial constructor of the class definitely initializes
     the declaration.

     TODO: an assignment expression occurring within a containing
     expression may or may not definitely initialize a value.  Specify
     this!

   If a function or value declaration is referenceable at a certain
statement or declaration, it may additionally be considered _definitely
initialized_ at that statement or declaration.

   If a function declaration is definitely initialized at a certain
statement or declaration if it is referenceable at that statement or
declaration and:

   * it is a parameter,

   * it is not forward-declared, or

   * it is forward-declared and is definitely initialized by the
     sequence of statements from its declaration to the given statement
     or declaration.

   As an exception, a member of a class is not considered definitely
initialized within the 'extends' clause of the class or of any of its
constructors.

   If a value declaration is definitely initialized at a certain
statement or declaration if it is referenceable at that statement or
declaration and:

   * it is a parameter,

   * it is not forward-declared and the given statement or declaration
     is not the value declaration itself, and does not occur within the
     body of the value declaration, or

   * it is forward-declared and is definitely initialized by the
     sequence of statements from its declaration to the given statement
     or declaration.

   A function or value declaration must be definitely initialized
wherever any value reference or callable reference to it occurs as an
expression within the body in which it is declared.

   A 'shared' forward-declared declaration belonging to a class and not
annotated 'late' must be definitely initialized:

   * at every 'return' statement of the initializer of the containing
     class, and

   * at the end of the very last expression statement, directive
     statement, constructor, or specification statement of the
     initializer of the containing class.

   A specification statement for a method or non-'variable' reference,
getter, or function may not (indirectly) occur in a 'for' or 'while'
block unless the declaration itself occurs within the same 'for' or
'while' block.

     TODO: Furthermore, the typechecker does some tricky analysis to
     determine that code like the following can be accepted:

          Boolean minors;
          for (p in people) {
              if (p.age<18) {
                  minors = true;
                  break;
              }
          }
          else {
              minors = false;
          }


File: ceylon-spec.info,  Node: definiteuninitialization,  Prev: definiteinitialization,  Up: blocksandstatements

5.3.8 Definite uninitialization
-------------------------------

A sequence of statements may _possibly initialize_ a forward-declared
declaration.

   * A sequence of statements possibly initializes a declaration if one
     of the statements is a specification statement for the declaration
     or a control structure that possibly initializes the declaration.

   * An 'if' conditional possibly initializes a declaration if either
     the 'if' block possibly initializes the declaration and the
     condition list is not never satisfied, or if the 'else' block, if
     any, possibly initializes the declaration and the condition list is
     not always satisfied.

   * A 'switch' conditional possibly initializes a declaration if one of
     the 'case' blocks possibly initializes the declaration or the
     'else' block, if any, possibly initializes the declaration.

   * A 'for' loop possibly initializes a declaration if the 'for' block
     possibly initializes the declaration or if it has an 'else' block
     that possibly initializes the declaration.

   * A 'while' loop possibly initializes a declaration if the 'while'
     block possibly initializes the declaration and the condition list
     is not never satisfied.

   * A 'try/catch' exception manager possibly initializes a declaration
     if the 'try' block possibly initializes the declaration, if one of
     the 'catch' blocks possibly initializes the declaration, or if the
     'finally' block possibly initializes the declaration.

   * A constructor of a class possibly initializes a declaration if the
     body of the constructor possibly initializes the declaration, or if
     the constructor delegates to a constructor which possibly
     initializes the declaration.

   * The constructors of a class possibly initialize a declaration if at
     least one constructor of the class possibly initializes the
     declaration.

   A forward-declared declaration is considered _definitely
uninitialized_ at a certain statement or declaration if:

   * it is not possibly initialized by the sequence of statements from
     its declaration to the given statement or declaration,

   * the statement does not (indirectly) occur in the 'for' block or
     'else' block of a 'for' loop with a 'for' block that possibly
     initializes it,

   * the statement does not (indirectly) occur in the 'while' block of a
     'while' loop with a 'while' block that possibly initializes it,

   * the statement does not (indirectly) occur in a 'catch' block of a
     'try/catch' exception manager with a 'try' block that possibly
     initializes it, and

   * the statement does not (indirectly) occur in the 'finally' block of
     a 'try/catch' exception manager with a 'try' block or 'catch' block
     that possibly initializes it.

   A function or non-'variable' value declaration must be definitely
uninitialized wherever any value reference or callable reference to it
occurs as a specification statement within the body in which it is
declared.

