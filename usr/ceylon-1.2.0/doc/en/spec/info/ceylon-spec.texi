
\input texinfo
@setfilename ceylon-spec.info
@settitle The Ceylon Language
@dircategory Software development
@direntry
* Ceylon: (ceylon-spec).       The Ceylon Language Specification.
@end direntry
@codequotebacktick on

@copying
This is the Ceylon Language Specification, version 1.2.

Copyright @copyright{} 2008--2015 Gavin King and contributors

@quotation
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
@end quotation
@end copying

@titlepage
@title The Ceylon Language
@subtitle Say more, more clearly

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top The Ceylon Language

This is the Ceylon Language Specification, version 1.2.
@end ifnottex

@menu
* preface:: Welcome to Ceylon.
* introduction:: Introduction
* lexical:: Lexical structure
* typesystem:: Type system
* declarations:: Declarations
* statementblocks:: Statements, blocks, and control structures
* expressions:: Expressions
* annotations:: Annotations
* execution:: Execution
* modulesystem:: Module system
* index:: Complete index.
@end menu


@node preface
@unnumbered Preface
@cindex Preface
 
  
This project is the work of a team of people who are fans of Java
    and of the Java ecosystem, of its practical orientation, of its culture of 
    openness, of its developer community, of its roots in the world of business 
    computing, and of its ongoing commitment to portability. 
    However, we recognize that the language and class libraries, designed more 
    than 15 years ago, are no longer the best foundation for a range of today's 
    business computing problems. We further recognize that Java failed in one
    environment it was originally promoted for: the web browser. 

  The goal of this project is to make a clean break with the legacy 
    Java SE platform, by improving upon the Java language and class libraries, 
    and by providing a modular architecture for a new platform based upon the 
    Java Virtual Machine. A further goal is to bridge the gap between the web
    client and server by supporting execution on JavaScript virtual machines. 

  Of course, we recognize that the ability to interoperate with existing 
    Java code, thereby leveraging existing investment in the Java ecosystem, is a 
    critical requirement of any successor to the Java platform. 

  Java is a simple language to learn and Java code is easy to read and
    understand. Java provides a level of typesafety that is appropriate for
    business computing and enables sophisticated tooling with features like
    refactoring support, code completion, and code navigation. Ceylon aims to 
    retain the overall model of Java, while getting rid of some of Java's warts,
    and improving upon Java's facilities for creating abstractions and writing 
    generic libraries and frameworks.
     

  Ceylon has the following goals: 

  
  @itemize @bullet
  
  @item to be appropriate for large scale development, but to also
            be @emph{fun}, 

  
  @item to execute on the JVM, and on JavaScript virtual machines, 
            and to interoperate with native Java and JavaScript code, 

  
  @item to provide language-level modularity, 

  
  @item to be easy to learn for Java and C# developers, 

  
  @item to eliminate some of Java's verbosity, while retaining its 
            readability---Ceylon does @emph{not} aim to be 
            the most concise/cryptic language around, 

  
  @item to provide an elegant and more flexible syntax to support 
            frameworks, declarative programming, and meta-programming, and, 
            in particular 

  
  @item to provide a declarative syntax for expressing hierarchical 
            information like user interface definition, externalized data, and 
            system configuration, thereby eliminating Java's dependence upon 
            XML, 

  
  @item to support and encourage a more functional style of programming 
            with immutable objects and first class functions, alongside the
            familiar imperative mode, 

  
  @item to expand compile-time typesafety with compile-time safe handling 
            of null values, compile-time safe typecasts, and a more typesafe approach 
            to reflection, and 

  
  @item to make it easy to @emph{get things done}. 

  
  @end itemize
Unlike other alternative JVM languages, Ceylon aims to completely replace 
    the legacy Java SE class libraries. 

  Therefore, the Ceylon SDK provides: 

  
  @itemize @bullet
  
  @item a compiler that compiles Ceylon and Java source to Java 
            bytecode, and cross-compiles Ceylon to JavaScript, 

  
  @item command-line tooling for compiling modules and 
            documentation, and managing modules in module repositories, 

  
  @item Eclipse-based tooling for developing, compiling, testing, and 
            debugging programs written in Ceylon, 

  
  @item a module runtime for modular programs that execute on the Java
            Virtual Machine, and 

  
  @item a set of class libraries that provides much of the functionality
            of the Java SE platform, together with the core functionality of the
            Java EE platform. 

  
  @end itemize

@node introduction
@chapter Introduction
@cindex Introduction

@menu
  
* languageoverview:: Language overview
* thetypesystem:: Type system
* objectorientedprogramming:: Object-oriented programming
* thelanguagemodule:: Language module
@end menu

  This document defines the syntax and semantics of the Ceylon language.
    The intended audience includes compiler implementors, interested parties
    who wish to contribute to the evolution of the language, and experienced 
    developers seeking a precise definition of language constructs. However, in
    light of the newness of the language, we will begin with an overview of the
    main features of the language and SDK. A brief introduction to programming 
    in the language may be found at the following address: 

  
@example
http://ceylon-lang.org/documentation/tour/
@end example

@node languageoverview
@section Language overview
@cindex Language overview

  
      
@menu
      
* runtimeandplatform:: Runtime and platform
@end menu

      
        Ceylon is a general-purpose programming  language featuring a syntax similar 
        to Java and C#. It is imperative, statically-typed, block-structured, 
        object-oriented, and higher-order. By @emph{statically-typed}, 
        we mean that the compiler performs extensive type checking, with the help of 
        type annotations that appear in the code. By @emph{object-oriented}, 
        we mean that the language supports user-defined types and features a nominative 
        type system where a type is a set of named attributes and operations, and that 
        it supports inheritance and subtype polymorphism. By @emph{higher-order}, 
        we mean that every referenceable program element (every attribute, every 
        operation, and every type) is also a value. By @emph{block-structured}, 
        we mean to say that the language features lexical scoping and an extremely 
        regular recursive syntax for declarations and statements.
         

  
        Ceylon improves upon the Java language and type system to reduce verbosity 
        and increase typesafety compared to Java and C#. Ceylon encourages a more 
        functional, somewhat less imperative style of programming, resulting in code 
        which is easier to reason about, and easier to refactor. 
         

  
@node runtimeandplatform
@subsection Runtime and platform
@cindex Runtime and platform

  
            Ceylon programs execute in any standard Java Virtual Machine or on any
            JavaScript virtual machine, and take advantage of the memory management and 
            concurrency features of the virtual machine in which they execute. Ceylon
            programs are packaged into @emph{modules} with well-defined
            inter-module dependencies, and always execute inside a runtime environment 
            with module isolation.
             

  
            The Ceylon compiler is able to compile Ceylon code that calls Java classes or 
            interfaces, and Java code that calls Ceylon classes or interfaces. JavaScript
            code is able to interact with Ceylon classes and functions compiled to JavaScript. 
            Via a special @emph{dynamic} mode, code written in Ceylon may call
            functions defined natively in JavaScript.
             

  
            Moreover, Ceylon provides its own native SDK as a replacement for the Java 
            platform class libraries. Certain SDK modules depend upon services available
            only on the Java platform. Other SDK modules, including the core 
            @emph{language module}, are cross-platform and may also be used 
            in a JavaScript virtual machine.
             

  
            Finally, the language supports the development of cross-platform modules that
            contain platform-specific implementation code, via the @code{native}
            annotation.
             

  
@example
import java.lang @{ System @}

shared native void hello();

shared native("jvm") void hello() @{
    System.console()?.printf("Hello, world!");
@}

shared native("js") void hello() @{
    dynamic @{
        alert("Hello, world!");
    @}
@}
@end example

@node thetypesystem
@section Type system
@cindex Type system

  
      
@menu
      
* mixininheritance:: Mixin inheritance
* algrebraictypesselftypes:: Sum types, self types, and type families
* simplifiedgenerics:: Simplified generics
* unionandintersectiontypes:: Union and intersection types
* typealiasesandtypeinference:: Type aliases and type inference
* metaprogramming:: Metaprogramming
@end menu

      
        Ceylon, like Java and C#, features a hybrid type system with both subtype 
        polymorphism and parameteric polymorphism. A type is either a stateless 
        @emph{interface}, a stateful @emph{class}, a 
        @emph{type parameter}, or a @emph{union} or 
        @emph{intersection} of other types. A class, interface, or 
        type parameter may be defined as a subtype of another type. A class or 
        interface may declare type parameters, which abstract the definition of the 
        class or interface over all types which may be substituted for the type 
        parameters.
         

  
        Like C#, and unlike Java, Ceylon's type system is fully reified. In 
        particular, generic type arguments are reified, eliminating many problems 
        that result from type erasure in Java.
         

  
        There are no primitive types or arrays in Ceylon---every Ceylon type can 
        be represented within the language itself. So all values are instances of the 
        type hierarchy root @code{Anything}, which is a class. However, 
        the Ceylon compiler is permitted to optimize certain code to take advantage 
        of the optimized performance of primitive types on the Java or JavaScript VM.
         

  
        Furthermore, all types inferred or even computed internally by the Ceylon 
        compiler are expressible within the language itself. Within the type system,
        @emph{non-denoteable} types simply do not arise. The type system 
        is based upon computation of @emph{principal types}. There is no 
        legal expression which does not have a unique principal type expressible within 
        the language. The principal type of an expression is a subtype of all other 
        types to which the expression could be soundly assigned.
         

  
@node mixininheritance
@subsection Mixin inheritance
@cindex Mixin inheritance

  
            Ceylon supports a restricted form of multiple inheritance, often called 
            @emph{mixin inheritance}. A class must extend exactly one other 
            class. But a class or interface may satisfy (extend or implement) an arbitrary 
            number of interfaces.
             

  
            Classes hold state and define logic to initialize that state when the class is 
            instantiated. A concrete class is a class that contains only concrete member 
            definitions. Concrete classes may be directly instantiated. An abstract class 
            may have @emph{formal} (unimplemented) member declarations. 
            Abstract classes may not be instantiated.
             

  
            Interfaces may define concrete and formal members, but may not hold state 
            (references to other objects) or initialization logic. This restriction helps 
            eliminate the problems traditionally associated with multiple inheritance. 
            Ceylon never performs any kind of "linearization" of the supertypes of a type. 
            Interfaces may not be directly instantiated.
             

  
@node algrebraictypesselftypes
@subsection Sum types, self types, and type families
@cindex Sum types, self types, and type families

  
            Ceylon does not feature Java-style enumerated types as a first-class construct. 
            Instead, any abstract type may specify its @emph{cases}---an
            enumerated list of instances and/or subtypes. This facility is used to simulate 
            both enumerated types and functional-style algebraic sum types. 
             

  
@example
interface Identity of Person | Organization @{ ... @}
@end example

@example
abstract class Variance() of covariant | contravariant | invariant @{ ... @}
@end example

            A closely related feature is support for @emph{self types} and 
            @emph{type families}. A self type is a type parameter of an 
            abstract type (like @code{Comparable}) which represents the type of 
            a concrete instantiation (like @code{String}) of the abstract type,
            within the definition of the abstract type itself.
             

  
@example
interface Comparable<in Other> of Other
        given Other satisfies Comparable<Other> @{ ... @}
@end example

            In a type family, the self type of a type is declared not by the type itself, 
            but by a containing type which groups together a set of related types.
             

  
@node simplifiedgenerics
@subsection Simplified generics
@cindex Simplified generics

  
            Ceylon doesn't have raw types, implicit bounds, or wildcard capture. And the 
            Ceylon compiler never even uses any kind of "non-denotable" type to reason 
            about the type system. So generics-related error messages are understandable 
            to humans.
             

  
            Ceylon features @emph{declaration-site variance}. A type parameter 
            may be marked as covariant or contravariant by the class or interface that 
            declares the parameter.
             

  
@example
interface Source<out Item> @{ ... @}
interface Sink<in Item> @{ ... @}
@end example

            In order to support interoperation with Java, Ceylon also features 
            Java-style @emph{use-site variance}, with a much cleaner syntax
            than Java's. A type argument may be marked as covariant or contravariant.
             

  
@example
List<out Element> javaArrayList = ArrayList<Element>();
@end example

            Ceylon has a somewhat more expressive system of generic type constraints with 
            a cleaner, more regular syntax. The syntax for declaring constraints on a type 
            parameter looks very similar to a class or interface declaration. A type 
            parameter may have upper bound type constraints or even 
            @emph{enumerated bounds}.
             

  
@example
interface Producer<out Value, in Rate> 
        given Value satisfies Object 
        given Rate of Float | Decimal @{ ... @}
@end example

@node unionandintersectiontypes
@subsection Union and intersection types
@cindex Union and intersection types

  
            A @emph{union type}, for example @code{String|Number}, 
            or @emph{intersection type}, for example 
            @code{Identifiable&List<String>}, may be formed from 
            two or more types defined elsewhere. 
             

  
            Union types make it possible to write code that operates polymorphically 
            over types defined in disparate branches of the type hierarchy without the 
            need for intermediate adaptor classes. 
             

  
@example
Float distance(Point|Location x, Point|Location y) => ... ;
@end example
Intersection types make it possible to operate polymorphically over 
            all subtypes of a list of types. 

  
@example
void persistRemotely(Persistent&Serializable stuff) @{ ... @}
@end example

            Union and intersection types provide some of the benefits of structural 
            ("duck") typing, within the confines of a nominative type system, and 
            therefore certain Ceylon idioms are reminiscent of code written in 
            dynamically-typed languages.  
             

  
            Union and intersection types underly the whole system of principal typing 
            in Ceylon, forming the foundation for type inference and flow-sensitive 
            typing. In particular, they play a central role in generic type argument 
            inference. For example, the following expression has type 
            @code{HashMap<String,Integer|Float>}:
             

  
@example
HashMap @{ "float"->0.0, "integer"->0 @}
@end example

@node typealiasesandtypeinference
@subsection Type aliases and type inference
@cindex Type aliases and type inference

      
            Type aliases and type inference help reduce the verbosity of code which 
            uses generic types, eliminating the need to repeatedly specify generic
            type arguments.
             

  
            A @emph{type alias} is similar to a C-style @code{typedef}.
             

  
@example
interface Strings => Sequence<String>;
@end example

@example
alias Number => Integer|Float|Whole|Decimal;
@end example

            Local @emph{type inference} allows a type annotation to be
            eliminated altogether. The type of a block-local value or function is 
            inferred from its definition if the keyword @code{value} or 
            @code{function} occurs in place of the type declaration.
             

  
@example
value name = person.name;
@end example

@example
function sqrt(Float x) => x^0.5;
@end example

            The type of a control-structure variable also may be inferred.
             

  
@example
for (n in 0..max) @{ ... @}
@end example

            Ceylon features an especially elegant approach to generic type argument 
            inference, making it possible to instantiate container types, even 
            inhomogeneous container types, without the need to explicitly mention any 
            types at all.  
             

  
@example
value numbers = @{ -1, 0, -1, -1.0, 0.0, 1.0 @};
@end example

            By limiting type inference to local declarations, Ceylon ensures that all 
            types may be inferred by the compiler in a single pass of the source code. 
            Type inference works in the "downward" and "outward" directions. The compiler 
            is able to determine the type of an expression without considering the rest 
            of the statement or declaration in which it appears.
             

  
@node metaprogramming
@subsection Metaprogramming
@cindex Metaprogramming

  In other statically typed languages, runtime metaprogramming, 
            or @emph{reflection}, is a messy business involving
            untypesafe strings and typecasting. Even worse, in Java, generic
            type arguments are erased at runtime, and unavailable via reflection. 
            Ceylon, uniquely, features a @emph{typesafe metamodel} 
            and typed @emph{metamodel expressions}. Since generic 
            type arguments are reified at runtime, the metamodel fully captures 
            generic types at both compile time and execution time. 

  
@example
Attribute<String,Integer> stringSize = `String.size`;
@end example
Ceylon's support for program element @emph{annotations}
            is based around this metamodel. Annotations are more flexible than
            in Java or C#, and have a much cleaner syntax. 

  
@node objectorientedprogramming
@section Object-oriented programming
@cindex Object-oriented programming

  
      
@menu
      
* initializationandinstantiation:: Class initialization and instantiation
* methodsandattributes:: Functions, methods, values, and attributes
* defaultparameters:: Defaulted parameters and variadic parameters
* firstclassfunctions:: First-class functions and higher-order programming
* namingconventionsandannotations:: Naming conventions, annotations, and inline documentation
* structureddata:: Named arguments and tree-like structures
* modularity:: Modularity
@end menu

      The primary unit of organization of an object-oriented program is
        the class. But Ceylon, unlike Java, doesn't require that @emph{every} 
        function or value belong to a class. It's perfectly normal to program 
        with a mix of classes and toplevel functions. Contrary to popular belief, 
        this does not make the program less object-oriented. A function is, after 
        all, an object. 

  
@node initializationandinstantiation
@subsection Class initialization and instantiation
@cindex Class initialization and instantiation

  
            A Ceylon class may have one or more named constructors, declared
            using the @code{new} keyword.
             

  
@example
class Point @{
    Float x; 
    Float y;
    new create(Float x, Float y) @{
        this.x = x;
        this.y = y;
    @}
    ...
@}
@end example

            However, since constructors are often unnecessarily verbose, it is more
            common to define a Ceylon class with a parameter list, and exactly one 
            @emph{initializer}---the body of the class.
             

  
@example
class Point(Float x, Float y) @{ ... @}
@end example

            The Ceylon compiler guarantees that the value of any attribute of a class 
            is initialized before it is used in an expression.
             

  
            A class may be a member of an outer class. Such a member class may be 
            refined (overridden) by a subclass of the outer class. Instantiation is 
            therefore a polymorphic operation in Ceylon, eliminating the need for a 
            factory method in some circumstances.
             

  
            Ceylon provides a streamlined syntax for defining @emph{anonymous 
            classes}. An anonymous class is a class which is instantiated 
            only in exactly the place it is defined. Among other uses, the 
            @code{object} declaration is useful for creating singleton 
            objects or locally-scoped interface implementations. 
             

  
@example
object origin extends Point(0.0, 0.0) @{@}
@end example

            Strictly speaking, an @code{object} declaration is just an
            abbreviated way to write a class with a @emph{value constructor}. 
            A value constructor defines a named instance of a class:
             

  
@example
class Point @{
    Float x; 
    Float y;
    new create(Float x, Float y) @{
        this.x = x;
        this.y = y;
    @}
    new origin @{
        this.x = 0.0;
        this.y = 0.0;
    @}
    ...
@}
@end example

@node methodsandattributes
@subsection Functions, methods, values, and attributes
@cindex Functions, methods, values, and attributes

  @emph{Functions} and @emph{values} are 
            the bread and butter of programming. Ceylon functions are similar to Java 
            methods, except that they don't need to belong to a class. Ceylon values 
            are polymorphic, and abstract their internal representation, similar to 
            C# properties. 

  
@example
String name => firstName + " " + lastName;
@end example

            A function belonging to a type is called a @emph{method}. 
            A value belonging to a type is called an @emph{attribute}.  
            There are no @code{static} members. Instead, a function or 
            value may be declared as a direct @emph{toplevel} member 
            of a package, or as a member of a singleton anonymous class. This 
            approach, along with certain other features, gives the language a more 
            regular block structure.
             

  
            The Ceylon compiler guarantees that any attribute or value is initialized 
            before it is used in an expression. By default, an attribute or value may 
            not be reassigned a new value after its initial value has been specified. 
            Mutable attributes and variable values must be explicitly declared using 
            the @code{variable} annotation.
             

  
@example
variable value count = 0;
@end example

            Ceylon does not support function overloading. Each method of a type has a 
            distinct name.
             

  
@node defaultparameters
@subsection Defaulted parameters and variadic parameters
@cindex Defaulted parameters and variadic parameters

  
            Instead of method and constructor overloading, Ceylon supports parameters 
            with default values and @emph{variadic} parameters.
             

  
@example
void addItem(Product product, Integer quantity=1) @{ ... @}
@end example

@example
String join(String* strings) @{ ... @}
@end example

            Union types also help alleviate the need for overloading.
             

  
@example
String format(String formatString, String|Float|Integer* values) => ... ;
@end example
Therefore, a single method in Ceylon may emulate the signatures of 
            several overloaded methods in Java. 

  
@node firstclassfunctions
@subsection First-class functions and higher-order programming
@cindex First-class functions and higher-order programming

  
            Ceylon supports first-class function types and higher-order functions. A 
            function declaration may specify a @emph{callable parameter} 
            that accepts references to other functions with a certain signature. 
             

  
@example
String find(Boolean where(String string)) @{ ... @}
@end example

            The argument of such a callable parameter may be either a reference to a 
            named function declared elsewhere, or a new function defined inline as part 
            of the method invocation. 
             

  
@example
value result = @{ "C", "Java", "Ceylon" @}.find((String s) => s.size>1);
@end example

            The type of a function is expressed within the type system as an 
            instantiation of the interface @code{Callable}. The 
            parameter types are expressed as a tuple type. So the type of the 
            function @code{(String s) => s.size>1} is 
            @code{Callable<Boolean,[String]>}, which may be 
            abbreviated to @code{Boolean(String)}.
             

  
            Unlike many other languages with higher-order functions, Ceylon supports
            abstraction over function and tuple types of arbitrary arity.
             

  
            References to methods and attributes may also be used as functions.
             

  
@example
value names = people.map(Person.name);
@end example

@example
value values = keys.map(keyedValues.get);
@end example

@node namingconventionsandannotations
@subsection Naming conventions, annotations, and inline documentation
@cindex Naming conventions, annotations, and inline documentation

  
            The Ceylon compiler enforces the traditional Smalltalk naming convention:
            type names begin with an initial uppercase letter---for example, 
            @code{Liberty} or @code{RedWine}---member names 
            and local names with an initial lowercase letter or underscore---for
            example, @code{blonde}, @code{immanentize()} or 
            @code{boldlyGo()}.
             

  
            These restrictions allow a much cleaner syntax for program element 
            annotations than the syntax found in either Java or C#. Declaration 
            "modifiers" like @code{shared}, @code{abstract}, 
            and @code{variable} aren't keywords in Ceylon, they're ordinary 
            annotations.
             

  
@example
"Base type for higher-order abstract stuff."
shared abstract class AbstractMetaThingy() @{ ... @}
@end example

            The documentation compiler reads inline documentation specified 
            using the @code{doc} annotation.
             

  
@node structureddata
@subsection Named arguments and tree-like structures
@cindex Named arguments and tree-like structures

  
            Ceylon's named argument lists provide an elegant means of initializing objects 
            and collections. The goal of this facility is to replace the use of XML for 
            expressing hierarchical structures such as documents, user interfaces, 
            configuration and serialized data.
             

  
@example
Html page = Html @{
    doctype = html5;
    Head @{ title = "Ceylon: home page"; @};
    Body @{
        H2 ( "Welcome to Ceylon ``language.version``!" ),
        P ( "Now get your code on :)" )
    @};
@}

@end example

            An especially important application of this facility is Ceylon's built-in 
            support for program element annotations.
             

  
@node modularity
@subsection Modularity
@cindex Modularity

  
            Toplevel declarations are organized into @emph{packages} and 
            @emph{modules}. Ceylon features language-level access control 
            via the @code{shared} annotation which can be used to express 
            block-local, package-private, module-private, and public visibility for 
            a program element. There's no equivalent to Java's @code{protected}.
             

  A module corresponds to a versioned packaged archive. Its 
            @emph{module descriptor} expresses its dependencies to other
            modules. The tooling and execution model for the language is based around 
            modularity and module archives. 

  
@node thelanguagemodule
@section Language module
@cindex Language module

  
      
@menu
      
* operatorsandoperatorpolymorphism:: Operators and operator polymorphism
* numerictypes:: Numeric and character types
* compiletimesafety:: Compile-time safety for null values and flow-sensitive typing
* iterableobjectsandcomprehensions:: Streams and comprehensions
* sequencesandtuples:: Sequences and tuples
@end menu

      The Ceylon language module defines a set of built-in types which form 
        the basis for several powerful features of the language. The language itself 
        defines extensive syntactic "sugar" that makes it easier and more convenient 
        to interact with the language module. 

  
@node operatorsandoperatorpolymorphism
@subsection Operators and operator polymorphism
@cindex Operators and operator polymorphism

  
            Ceylon features a rich set of operators, including most of the operators 
            supported by C and Java. True operator overloading is not supported. 
            However, each operator is defined to act upon a certain class or interface 
            type, allowing application of the operator to any class which extends or 
            satisfies that type. For example, the @code{+} operator may be
            applied to any class that satisfies the interface @code{Summable}. 
            This approach is called @emph{operator polymorphism}.
             

  
@node numerictypes
@subsection Numeric and character types
@cindex Numeric and character types

  Ceylon's numeric type system is much simpler than C, C# or Java, with
            exactly three built-in numeric types (compared to six in Java and eleven in 
            C#). The built-in types are classes representing integers, floating point 
            numbers, and bytes. @code{Integer} and @code{Float} 
            values are signed, with 64 bits of precision by default, and may be optimized 
            for 32 bit architectures via use of the @code{small} annotation. 
            The @code{Byte} class represents 8-bit values with modular 
            arithmetic, sidestepping the question of whether a byte is signed or 
            unsigned. 

  The module @code{ceylon.math} provides two additional
            numeric types representing arbitrary precision integers and arbitrary 
            precision decimals. 

  Ceylon has @code{Character} and @code{String}
            classes, and, unlike Java or C#, every character is a full 32-bit Unicode
            codepoint. Conveniently, a @code{String} is a 
            @code{List<Character>}. 

  
@node compiletimesafety
@subsection Compile-time safety for null values and flow-sensitive typing
@cindex Compile-time safety for null values and flow-sensitive typing

  
            There is no primitive null in Ceylon. The null value is an instance of 
            the class @code{Null}. An @emph{optional type} 
            is a union type like @code{Null|String}, which may be 
            abbreviated to @code{String?}. An optional type is never 
            assignable to a non-optional type except via use of the special-purpose 
            @code{if (exists ... )} construct. Thus, the Ceylon compiler 
            is able to detect illegal use of a null value at compile time. Therefore, 
            there is no equivalent to Java's @code{NullPointerException} 
            in Ceylon.
             

  
            Similarly, there are no C-style typecasts in Ceylon. Instead, the 
            @code{if (is ... )} and @code{case (is ... )} 
            constructs may be used to test and narrow the type of an object reference 
            in one step, without risk of a @code{ClassCastException}. 
            This facility is called @emph{flow-sensitive typing}.
             

  
@example
String name(Organization|Person entity) @{
    switch (entity)
    case (is Organization) @{
        return entity.tradeName else entity.legalName;
    @}
    case (is Person) @{
        return entity.nickName else entity.firstName;
    @}
@}
@end example

            Alternatively, @emph{type assertions}, written 
            @code{assert (is ... )} or @code{assert (exists ... )}
            may be used to narrow the type of a reference.
             

  
@example
value arg = process.arguments[0];
"must specify an amount"
assert (exists arg);
"not a legal positive integer amount"
assert (exists amount = parseInteger(arg), amount>0);
@end example

            The combination of @code{case (is ... )} with sum types 
            amounts to a kind of language-level support for the visitor pattern.
             

  
@node iterableobjectsandcomprehensions
@subsection Streams and comprehensions
@cindex Streams and comprehensions

  The interface @code{Iterable} represents a stream of
            values, which might be evaluated lazily. This interface is of central
            importance in the language module, and so the language provides a
            syntactic abbreviation for the type of an iterable object. The 
            abbreviation @code{@{String*@}} means 
            @code{Iterable<String>}. There is a convenient syntax
            for instantiating an iterable object, given a list of values: 

  
@example
@{String*@} words = @{"hello", "world", "goodbye"@};
@end example
A @emph{nonempty iterable} is an iterable object
            which always produces at least one value. A nonempty iterabe type is
            written @code{@{String+@}}. Distinguishing nonempty streams
            of values lets us correctly express the type of functions like
            @code{max()}: 

  
@example
@{Float+@} oneOrMore = .... ;
@{Float*@} zeroOrMore = .... ;
Float maxOfOneOrMore = max(oneOrMore); //never null
Float? maxOfZeroOrMore = max(zeroOrMore); //might be null
@end example
@emph{Comprehensions} are an expressive syntax for
            filtering and transforming streams of values. For example, they may be 
            used when instantiating an iterable object or collection: 

  
@example
value adults = @{ for (p in people) if (p.age>18) p.name @};
@end example

@example
value peopleByName = HashMap @{ for (p in people) p.name->p @};
@end example
Comprehensions are evaluated lazily. 

  
@node sequencesandtuples
@subsection Sequences and tuples
@cindex Sequences and tuples

  @emph{Sequences} are Ceylon's version of arrays. 
            However, the @code{Sequential} interface does not provide 
            operations for mutating the elements of the sequence---sequences
            are considered immutable. Because this interface is so useful, a type 
            like @code{Sequential<String>} may be abbreviated to 
            @code{[String*]}, or, for the sake of tradition, to 
            @code{String[]}. 

  A @emph{nonempty sequence} is a kind of sequence
            which always has at least one element. A nonempty sequence type is 
            written @code{[String+]}. The special-purpose 
            @code{if (nonempty ... )} construct narrows a sequence 
            type to a nonempty sequence type. 

  @emph{Tuples} are a kind of sequence where the 
            type of each element is encoded into the static type of the tuple.
            @code{Tuple} is just an ordinary class in Ceylon, but 
            the language lets us write down tuple types using a streamlined 
            syntax. For example, @code{[Float,Float]} is a pair of 
            @code{Float}s. There's also a convenient syntax for 
            instantiating tuples and accessing their elements. 

  
@example
[Float,Float] origin = [0.0, 0.0];
Float x = origin[0];
Float y = origin[1];
Null z = origin[2]; //only two elements!
@end example
Tuples and nonempty sequences support pattern-based 
            @emph{destructuring}. 

  
@example
value [x, y] = origin;
@end example

@node lexical
@chapter Lexical structure
@cindex Lexical structure

@menu
  
* whitespace:: Whitespace
* comments:: Comments
* identifiersandkeywords:: Identifiers and keywords
* literals:: Literals
* operatorsanddelimiters:: Operators and delimiters
@end menu

  Every Ceylon source file is a sequence of Unicode characters. Lexical
    analysis of the character stream, according to the grammar specified in this
    chapter, results in a stream of tokens. These tokens form the input of the 
    parser grammar defined in the later chapters of this specification. The
    Ceylon lexer is able to completely tokenize a character stream in a single 
    pass. 

  
@node whitespace
@section Whitespace
@cindex Whitespace

  @emph{Whitespace} is composed of strings of Unicode 
        @code{SPACE}, @code{CHARACTER TABULATION}, 
        @code{FORM FEED (FF)}, @code{LINE FEED (LF)} and 
        @code{CARRIAGE RETURN (CR)} characters. 

  
@verbatim
Whitespace: " " | Tab | Formfeed | Newline | CarriageReturn
@end verbatim

@verbatim
Tab: "\{CHARACTER TABULATION}"
@end verbatim

@verbatim
Formfeed: "\{FORM FEED (FF)}"
@end verbatim

@verbatim
Newline: "\{LINE FEED (LF)}"
@end verbatim

@verbatim
CarriageReturn: "\{CARRIAGE RETURN (CR)}"
@end verbatim
Outside of a comment, string literal, or single quoted literal,
        whitespace acts as a token separator and is immediately discarded by
        the lexer. Whitespace is not used as a statement separator. 

  Source text is divided into lines by @emph{line-terminating 
        character sequences}. The following Unicode character sequences 
        terminate a line: 

  
  @itemize @bullet
  
  @item @code{LINE FEED (LF)}, 

  
  @item @code{CARRIAGE RETURN (CR)}, and 

  
  @item @code{CARRIAGE RETURN (CR)} followed by
                @code{LINE FEED (LF)}. 

  
  @end itemize

@node comments
@section Comments
@cindex Comments

  There are two kinds of comments: 

  
  @itemize @bullet
  
  @item a @emph{multiline comment} begins with 
                @code{/*} and extends until @code{*/}, 
                and 

  
  @item an @emph{end-of-line comment} begins with 
                @code{//} or @code{#!} and extends until 
                the next line terminating character sequence. 

  
  @end itemize
Both kinds of comments can be nested. 

  
@verbatim
LineComment: ("//"|"#!") ~(Newline | CarriageReturn)* (CarriageReturn Newline | CarriageReturn | Newline)?
@end verbatim

@verbatim
MultilineComment: "/*" (MultilineCommentCharacter | MultilineComment)* "*/"
@end verbatim

@verbatim
MultilineCommentCharacter: ~("/"|"*") | ("/" ~"*") => "/" | ("*" ~"/") => "*"
@end verbatim
The following examples are legal comments: 

  
@example
//this comment stops at the end of the line
@end example

@example
/*
   but this is a comment that spans
   multiple lines
*/
@end example

@example
#!/usr/bin/ceylon
@end example
Comments are treated as whitespace by both the compiler and documentation
        compiler. Comments may act as token separators, but their content is immediately 
        discarded by the lexer and they are not visible to the parser. 

  
@node identifiersandkeywords
@section Identifiers and keywords
@cindex Identifiers and keywords

  @emph{Identifiers} may contain letters, digits and 
        underscores. 

  
@verbatim
LowercaseCharacter: LowercaseLetter | "_"
@end verbatim

@verbatim
UppercaseCharacter: UppercaseLetter
@end verbatim

@verbatim
IdentifierCharacter: LowercaseCharacter | UppercaseCharacter | Number
@end verbatim
The lexer classifies Unicode uppercase letters, lowercase letters, 
        and numeric characters depending on the general category of the character
        as defined by the Unicode standard. 

  
  @itemize @bullet
  
  @item 
                    A @code{LowercaseLetter} is any character whose 
                    general category is @code{Ll} or any character whose 
                    general category is @code{Lo} or @code{Lm} 
                    which has the property @code{Other_Lowercase}.
                 

  
  @item 
                    An @code{UppercaseLetter} is any character whose 
                    general category is @code{Lu} or @code{Lt}, 
                    or any character whose general category is @code{Lo} or 
                    @code{Lm} which does not have the property
                    @code{Other_Lowercase}.
                 

  
  @item 
                    A @code{Number} is any character whose general 
                    category is @code{Nd}, @code{Nl}, or 
                    @code{No}.
                 

  
  @end itemize
All identifiers are case sensitive: @code{Person} and
        @code{person} are two different legal identifiers. 

  The lexer distinguishes identifiers which begin with an initial 
        uppercase character from identifiers which begin with an initial lowercase
        character or underscore. Additionally, an identifier may be qualified using 
        the prefix @code{\i} or @code{\I} to disambiguate it 
        from a reserved word or to explicitly specify whether it should be considered
        an initial uppercase or initial lowercase identifier. 

  
@verbatim
LIdentifier: LowercaseCharacter IdentifierCharacter* | "\i" IdentifierCharacter+
@end verbatim

@verbatim
UIdentifier: UppercaseCharacter IdentifierCharacter* | "\I" IdentifierCharacter+
@end verbatim
The following examples are legal identifiers: 

  
@example
Person
@end example

@example
name
@end example

@example
personName
@end example

@example
_id
@end example

@example
x2
@end example

@example
\I_id
@end example

@example
\Iobject
@end example

@example
\iObject
@end example

@example
\iclass
@end example
The prefix @code{\I} or @code{\i} is not 
        considered part of the identifier name. Therefore, @code{\iperson}
        is just an initial lowercase identifier named @code{person} and
        @code{\Iperson} is an initial @emph{uppercase} 
        identifier named @code{person}. 

  The following reserved words are not legal identifier names unless they 
        appear escaped using @code{\i} or @code{\I}: 

  @code{
        assembly module package import
        alias class interface object given value assign void function new
        of extends satisfies abstracts
        in out
        return break continue throw
        assert dynamic
        if else switch case for while try catch finally then let
        this outer super
        is exists nonempty
        } 

  
@smallindentedblock
  Note: @code{assembly} and @code{abstracts}
        are reserved for possible use in a future release of the language, for declaration
        of assemblies and lower bound type constraints respectively. 

  
@end smallindentedblock

@node literals
@section Literals
@cindex Literals

  
      
@menu
      
* numericliterals:: Numeric literals
* characterliterals:: Character literals
* stringliterals:: String literals
@end menu

      A @emph{literal} is a single token that represents a
        Unicode character, a character string, or a numeric value. 

  
@node numericliterals
@subsection Numeric literals
@cindex Numeric literals

  An @emph{integer literal} may be expressed in decimal, 
            hexadecimal, or binary notation: 

  
@verbatim
IntegerLiteral: DecimalLiteral | HexLiteral | BinLiteral
@end verbatim
A @emph{decimal literal} has a list of digits and an
            optional magnitude: 

  
@verbatim
DecimalLiteral: Digits Magnitude?
@end verbatim
@emph{Hexadecimal literals} are prefixed by @code{#}: 

  
@verbatim
HexLiteral: "#" HexDigits
@end verbatim
@emph{Binary literals} are prefixed by @code{$}: 

  
@verbatim
BinLiteral: "$" BinDigits
@end verbatim
A @emph{floating point literal} is distinguished by the
            presence of a decimal point or fractional magnitude: 

  
@verbatim
FloatLiteral: NormalFloatLiteral | ShortcutFloatLiteral
@end verbatim
Most floating point literals have a list of digits including a decimal 
            point, and an optional exponent or magnitude. 

  
@verbatim
NormalFloatLiteral: Digits "." FractionalDigits (Exponent | Magnitude | FractionalMagnitude)?
@end verbatim
The decimal point is optional if a fractional magitude is specified. 

  
@verbatim
ShortcutFloatLiteral: Digits FractionalMagnitude
@end verbatim
Decimal digits may be separated into groups of three using an underscore. 

  
@verbatim
Digits: Digit+ | Digit{1..3} ("_" Digit{3})+
@end verbatim

@verbatim
FractionalDigits: Digit+ | (Digit{3} "_")+ Digit{1..3} 
@end verbatim
Hexadecimal or binary digits may be separated into groups of four using 
            an underscore. Hexadecimal digits may even be separated into groups of two. 

  
@verbatim
HexDigits: HexDigit+ | HexDigit{1..4} ("_" HexDigit{4})+ | HexDigit{1..2} ("_" HexDigit{2})+
@end verbatim

@verbatim
BinDigits: BinDigit+ | BinDigit{1..4} ("_" Digit{4})+
@end verbatim
A digit is a decimal, hexadecimal, or binary digit. 

  
@verbatim
Digit: "0".."9"
@end verbatim

@verbatim
HexDigit: "0".."9" | "A".."F" | "a".."f"
@end verbatim

@verbatim
BinDigit: "0"|"1"
@end verbatim
A floating point literal may include either an @emph{exponent} 
            (for scientific notation) or a @emph{magnitude} (an SI unit
            prefix). A decimal integer literal may include a magnitude. 

  
@verbatim
Exponent: ("E"|"e") ("+"|"-")? Digit+
@end verbatim

@verbatim
Magnitude: "k" | "M" | "G" | "T" | "P"
@end verbatim

@verbatim
FractionalMagnitude: "m" | "u" | "n" | "p" | "f"
@end verbatim
The magnitude of a numeric literal is interpreted as follows: 

  
  @itemize @bullet
  
  @item @code{k} means @code{e+3}, 

  
  @item @code{M} means @code{e+6}, 

  
  @item @code{G} means @code{e+9}, 

  
  @item @code{T} means @code{e+12}, 

  
  @item @code{P} means @code{e+15}, 

  
  @item @code{m} means @code{e-3}, 

  
  @item @code{u} means @code{e-6}, 

  
  @item @code{n} means @code{e-9}, 

  
  @item @code{p} means @code{e-12}, and 

  
  @item @code{f} means @code{e-15}. 

  
  @end itemize
The following examples are legal numeric literals: 

  
@example
69
@end example

@example
6.9
@end example

@example
0.999e-10
@end example

@example
1.0E2
@end example

@example
10000
@end example

@example
1_000_000
@end example

@example
12_345.678_9
@end example

@example
1.5k
@end example

@example
12M
@end example

@example
2.34p
@end example

@example
5u
@end example

@example
$1010_0101
@end example

@example
#D00D
@end example

@example
#FF_FF_FF
@end example
The following are @emph{not} valid numeric literals: 

  
@example
.33  //Error: floating point literals may not begin with a decimal point
@end example

@example
1.  //Error: floating point literals may not end with a decimal point
@end example

@example
99E+3  //Error: floating point literals with an exponent must contain a decimal point
@end example

@example
12_34  //Error: decimal digit groups must be of length three
@end example

@example
#FF.00  //Error: floating point numbers may not be expressed in hexadecimal notation
@end example

@node characterliterals
@subsection Character literals
@cindex Character literals

  A single @emph{character literal} consists of a Unicode 
            character, inside single quotes. 

  
@verbatim
CharacterLiteral: "'" Character "'"
@end verbatim

@verbatim
Character: ~("'" | "\") | EscapeSequence
@end verbatim
A character may be identified by an @emph{escape sequence}.
            Every escape sequence begins with a backslash. An escape sequence is replaced
            by its corresponding Unicode character during lexical analysis. 

  
@verbatim
EscapeSequence: "\" (SingleCharacterEscape | "{" CharacterCode "}")
@end verbatim

@verbatim
SingleCharacterEscape: "b" | "t" | "n" | "f" | "r" | "e" | "\" | """ | "'" | "`" | "0"
@end verbatim
The single-character escape sequences have their traditional interpretations as
            Unicode characters: 

  
  @itemize @bullet
  
  @item @code{\b} means @code{BACKSPACE}, 

  
  @item @code{\t} means @code{CHARACTER TABULATION}, 

  
  @item @code{\n} means @code{LINE FEED (LF)}, 

  
  @item @code{\f} means @code{FORM FEED (FF)}, 

  
  @item @code{\r} means @code{CARRIAGE RETURN (CR)}, 

  
  @item @code{\e} means @code{ESCAPE}, 

  
  @item @code{\\}, @code{\`}, @code{\'}, 
                    and @code{\"} mean @code{REVERSE SOLIDUS}, 
                    @code{GRAVE ACCENT}, @code{APOSTROPHE}, and 
                    @code{QUOTATION MARK}, respectively, and, finally 

  
  @item @code{\0} means @code{NULL}. 

  
  @end itemize
A Unicode codepoint escape is a two-, four-, or six-digit hexadecimal literal 
            representing an integer in the range 0 to 10FFFF, or a Unicode character name, 
            surrounded by braces, and means the Unicode character with the specified codepoint or 
            character name. 

  
@verbatim
CharacterCode: "#" ( HexDigit{2} | HexDigit{4} | HexDigit{6} ) | UnicodeCharacterName
@end verbatim
Legal Unicode character names are defined by the Unicode specification. 

  The following are legal character literals: 

  
@example
'A'
@end example

@example
'#'
@end example

@example
' '
@end example

@example
'\n'
@end example

@example
'\@{#212B@}'
@end example

@example
'\@{ALCHEMICAL SYMBOL FOR GOLD@}'
@end example

@node stringliterals
@subsection String literals
@cindex String literals

  A character @emph{string literal} is a sequence of Unicode 
            characters, inside double quotes. 

  
@verbatim
StringLiteral: """ StringCharacter* """
@end verbatim

@verbatim
StringCharacter: ~( "\" | """ | "`" ) | "`" ~"`" | EscapeSequence | EscapedBreak
@end verbatim
A string literal may contain escape sequences. An escape sequence is 
            replaced by its corresponding Unicode character during lexical analysis. 

  A line-terminating character sequence may be escaped with a backslash,
            in which case the escaped line termination is removed from the string literal
            during lexical analysis. 

  
@verbatim
EscapedBreak: "\" (CarriageReturn Newline | CarriageReturn | Newline)
@end verbatim
A sequence of two backticks is used to delimit an interpolated expression
            embedded in a string template. 

  
@verbatim
StringStart: """ StringCharacter* "``"
@end verbatim

@verbatim
StringMid: "``" StringCharacter* "``"
@end verbatim

@verbatim
StringEnd: "``" StringCharacter* """
@end verbatim
A @emph{verbatim string} is a character sequence delimited
            by a sequence of three double quotes. Verbatim strings do not contain escape
            sequences or interpolated expressions, so every character occurring inside the
            verbatim string is interpreted literally. 

  
@verbatim
VerbatimStringLiteral: """"" VerbatimCharacter* """""
@end verbatim

@verbatim
VerbatimCharacter: ~""" | """ ~""" | """ """ ~"""
@end verbatim
The following are legal strings: 

  
@example
"Hello!"
@end example

@example
"\@{#00E5@}ngstr\@{#00F6@}ms"
@end example

@example
" \t\n\f\r,;:"
@end example

@example
"\@{POLICE CAR@} \@{TROLLEYBUS@} \@{WOMAN WITH BUNNY EARS@}"
@end example

@example
"""This program prints "hello world" to the console."""
@end example
The column in which the first character of a string literal occurs, excluding the 
            opening quote characters, is called the @emph{initial column} of the string 
            literal. Every following line of a multiline string literal must contain whitespace up to 
            the initial column. That is, if the string contents begin at the @code{n}th 
            character in a line of text, the following lines must start with @code{n} 
            whitespace characters. This required whitespace is removed from the string literal during 
            lexical analysis. 

  
@node operatorsanddelimiters
@section Operators and delimiters
@cindex Operators and delimiters

  The following character sequences are operators and/or punctuation: 

  @code{
        , ; ...
        @{ @} ( ) [ ] `
        ?
        . ?. *. 
        = =>
        + - * / % ^ **
        ++ --
        .. : ->
        ! && ||
        ~ & |
        === == != < > <= >= <=>
        += -= /= *= %= |= &= ~= ||= &&=
        } 

  Certain symbols serve dual or multiple purposes in the grammar. 

  
@node typesystem
@chapter Type system
@cindex Type system

@menu
  
* identifiernaming:: Identifier naming
* type:: Types
* inheritance:: Inheritance
* casesandcoverage:: Case enumeration and coverage
* generictypeparameters:: Generic type parameters
* generictypearguments:: Generic type arguments
* principalinstantiations:: Principal instantiations and polymorphism
@end menu

  Every value in a Ceylon program is an instance of a type that can be expressed 
    within the Ceylon language as a @emph{class}. The language does not 
    define any primitive or compound types that cannot, in principle, be expressed within 
    the language itself. 

  A class, fully defined in @ref{classes, ,Classes}, is a recipe for producing 
    new values, called @emph{instances}
    of the class (or simply @emph{objects}), and defines the operations and 
    attributes of the resulting values. A class instance may hold references to other 
    objects, and has an identity distinct from these references. 

  Each class declaration defines a type. However, not all types are classes. It 
    is often advantageous to write generic code that abstracts the concrete class of a 
    value. This technique is called @emph{polymorphism}. Ceylon features 
    two different kinds of polymorphism: 

  
  @itemize @bullet
  
  @item @emph{subtype polymorphism}, where a subtype @code{B}
            inherits a supertype @code{A}, and 

  
  @item @emph{parametric polymorphism}, where a type definition 
            @code{A<T>} is parameterized by a @emph{generic type 
            parameter} @code{T}. 

  
  @end itemize
Ceylon, like Java and many other object-oriented languages, features a single
    inheritance model for classes. A class may directly inherit at most one other class, 
    and all classes eventually inherit, directly or indirectly, the class 
    @code{Anything} defined in the module @code{ceylon.language}, 
    which acts as the root of the class hierarchy. 

  A truly hierarchical type system is much too restrictive for more abstract 
    programming tasks. Therefore, in addition to classes, Ceylon recognizes the following 
    kinds of type: 

  
  @itemize @bullet
  
  @item An @emph{interface}, defined in @ref{interfaces, ,Interfaces}, 
            is an abstract type schema that cannot itself be directly instantiated. An 
            interface may define concrete members, but these members may not hold references 
            to other objects. A class may inherit one or more interfaces. An instance of a 
            class that inherits an interface is also considered an instance of the interface. 

  
  @item A @emph{generic type parameter}, defined in 
            @ref{generictypeparameters, ,Generic type parameters}, is considered a type within the 
            declaration that it parameterizes. In fact, it is an abstraction over many types: 
            it generalizes the declaration to all types which could be assigned to the 
            parameter. 

  
  @item An @emph{applied type}, defined in 
            @ref{generictypearguments, ,Generic type arguments}, is formed by specifying arguments for the 
            generic type parameters of a parameterized type declaration, and is called an
            @emph{instantiation} of the parameterized type declaration. 

  
  @item A @emph{union type}, defined in @ref{uniontypes, ,Union types}, 
            is a type to which each of an enumerated list of types is assignable. 

  
  @item An @emph{intersection type}, defined in 
            @ref{intersectiontypes, ,Intersection types}, is a type which is assignable to each of an 
            enumerated list of types. 

  
  @end itemize
Although we often use the term @emph{parameterized type} or even
    @emph{generic type} to refer to a parameterized type definition, it is
    important to keep in mind that a parameterized type definition is not itself a type.
    Rather, it is a @emph{type constructor}, a function that maps types 
    to types. Given a list of type arguments, the function yields an applied type. 

  In light of the fact that Ceylon makes it so easy to construct new types from
    existing types @emph{without the use of inheritance}, by forming unions, 
    intersections, and applied types, it's often useful to assign a name to such a type. 

  
  @itemize @bullet
  
  @item A @emph{type alias}, defined in 
            @ref{typealiasedeclarations, ,Type aliases}, @ref{classaliases, ,Class aliases}, 
            and @ref{interfacealiases, ,Interface aliases}, is a synonym for an expression 
            involving other types or generic types. A type alias may itself be 
            generic. 

  
  @end itemize
The Ceylon type system is much more complete than most other object oriented
    languages. In Ceylon, it's possible to answer questions that might at first sound
    almost nonsensical if you're used to languages with more traditional type systems. 
    For example: 

  
  @itemize @bullet
  
  @item What is the type of a variable that may or may not hold a value of 
            type @code{Element}? 

  
  @item What is the type of a parameter that accepts either an 
            @code{Integer} or a @code{Float}? 

  
  @item What is the type of a parameter that accepts values which are instances 
            of both @code{Persistent} and @code{Printable}? 

  
  @item What is the type of a function which accepts any non-null value and 
            returns a @code{String}? 

  
  @item What is the type of a function that accepts one or more
            @code{String}s and returns an iterable object producing at least 
            one @code{String}? 

  
  @item What is the type of a sequence consisting of a @code{String}
            followed by two @code{Float}s? 

  
  @item What is the type of a list with no elements? 

  
  @end itemize
The answers, as we shall see, are: @code{Element?}, 
    @code{Integer|Float}, @code{Persistent&Printable}, 
    @code{String(Object)}, @code{@{String+@}(String+)},   
    @code{[String,Float,Float]}, and @code{List<Nothing>}. 

  It's important that there is always a unique "best" answer to questions
    like these in Ceylon. The "best" answer is called the @emph{principal type
    of an expression}. Every other type to which the expression is 
    assignable is a supertype of the principal type. 

  Thus, every legal Ceylon expression has a unique, well-defined type, 
    representable within the type system, without reference to how the expression 
    is used or to what type it is assigned. This is the case even when type inference 
    or type argument inference comes into play. 

  Neither this specification nor the internal implementation of the Ceylon 
    compiler itself use any kind of "non-denotable" types. Every type mentioned 
    here or inferred internally by the compiler has a representation within the 
    language itself. Thus, the programmer is never exposed to confusing error 
    messages referring to mysterious types that are not part of the syntax of the 
    language. 

  
@node identifiernaming
@section Identifier naming
@cindex Identifier naming

  The Ceylon compiler enforces identifier naming conventions. Types 
        must be named with an initial uppercase letter. Values, functions, and
        constructors must be named with an initial lowercase letter or underscore. 
        The grammar for identifiers is defined by 
        @ref{identifiersandkeywords, ,Identifiers and keywords}. 

  
@verbatim
TypeName: UIdentifier
@end verbatim

@verbatim
MemberName: LIdentifier
@end verbatim
A package or module name is a sequence of identifiers, each with an 
        initial lowercase letter or underscore. 

  
@verbatim
PackageName: LIdentifier
@end verbatim
Ceylon defines three identifier namespaces: 

  
  @itemize @bullet
  
  @item classes, interfaces, type aliases, and type parameters
                share a single namespace, 

  
  @item functions and values, including parameters, and constructors 
                share a single namespace, and 

  
  @item packages and modules have their own dedicated namespace. 

  
  @end itemize
The Ceylon parser is able to unambiguously identify which namespace an 
        identifier belongs to. 

  An identifier that begins with an initial lowercase letter may be 
        @emph{forced} into the namespace of types by prefixing the
        identifier @code{\I}. An identifier that begins with an initial
        uppercase letter may be forced into the namespace of methods and attributes
        by prefixing the identifier @code{\i}. A keyword may be used as 
        an identifier by prefixing the keyword with either @code{\i} or 
        @code{\I}. This allows interoperation with other languages like 
        Java and JavaScript which do not enforce these naming conventions. 

  
@node type
@section Types
@cindex Types

  
      
@menu
      
* memberdistinctness:: Member distinctness
* subtyping:: Subtyping
* uniontypes:: Union types
* intersectiontypes:: Intersection types
* bottomtype:: The bottom type
* principaltyping:: Principal typing
* typeexpressions:: Type expressions
* typenameabbreviations:: Type abbreviations
* typeinference:: Type inference
* typealiaselimination:: Type alias elimination
@end menu

      A @emph{type} or @emph{type schema} is a name 
        (an initial uppercase identifier) and an optional list of type parameters, with 
        a set of: 

  
  @itemize @bullet
  
  @item value schemas, 

  
  @item function schemas, and 

  
  @item class schemas. 

  
  @end itemize
The value, function, and class schemas are called the @emph{members} 
        of the type. 

  Speaking formally: 

  
  @itemize @bullet
  
  @item A @emph{value schema} is a name (an initial 
                lowercase identifier) with a type and mutability. 

  
  @item A @emph{function schema} is a name (an initial 
                lowercase identifier) and an optional list of type parameters, with a 
                type (often called the @emph{return type}) and a sequence 
                of one or more parameter lists. 

  
  @item A @emph{class schema} is a type schema with either
                one parameter list, or a list of constructor schemas. 

  
  @item A @emph{callable constructor schema} is a name (an 
                initial lowercase identifier) with exactly one parameter list. 

  
  @item A @emph{value constructor schema} is a name (an 
                initial lowercase identifier). 

  
  @item A @emph{parameter list} is a list of names (initial 
                lowercase identifiers) with types. The @emph{signature} of 
                a parameter list is formed by discarding the names, leaving the list of 
                types. 

  
  @end itemize
Speaking slightly less formally, we usually refer to an @emph{attribute}, 
        @emph{method}, or @emph{member class} of a type, meaning 
        a value schema, function schema, or class schema that is a member of the type. 

  A function or value schema may occur outside of a type schema. If it occurs 
        directly in a compilation unit, we often call it a @emph{toplevel function} 
        or @emph{toplevel value}. 

  A value schema, function schema, or parameter list with a missing type or types 
        may be defined. Any such schema, or parameter list with a missing type is called 
        @emph{partially typed}. 

  Two signatures are considered identical if they have exactly the same types, at
        exactly the same positions, and missing types at exactly the same positions. 

  
@node memberdistinctness
@subsection Member distinctness
@cindex Member distinctness

  Overloading is illegal in Ceylon. A type may not have: 

  
  @itemize @bullet
  
  @item two attributes with the same name, 

  
  @item a method and an attribute with the same name, 

  
  @item two methods with the same name, or 

  
  @item two member classes with the same name. 

  
  @end itemize

@smallindentedblock
  Note: the Ceylon compiler itself is able to represent type schemas 
            with overloaded members and reason about overloading, and does so when compiling 
            code that calls native Java types. However, this behavior is outside the scope of 
            this specification. 

  
@end smallindentedblock

@node subtyping
@subsection Subtyping
@cindex Subtyping

  A type may be a @emph{subtype} of another type. Subtyping obeys 
            the following rules: 

  
  @itemize @bullet
  
  @item Identity: @code{X} is a subtype of @code{X}. 

  
  @item Transitivity: if @code{X} is a subtype of @code{Y}
                    and @code{Y} is a subtype of @code{Z} then
                    @code{X} is a subtype of @code{Z}. 

  
  @item Noncircularity: if @code{X} is a subtype of @code{Y}
                    and @code{Y} is a subtype of @code{X} then
                    @code{Y} and @code{X} are the same type. 

  
  @item Single root: all types are subtypes of the class @code{Anything}
                    defined in the module @code{ceylon.language}. 

  
  @end itemize
Also, every interface type is a subtype of the class @code{Object} 
            defined in @code{ceylon.language}. 

  If @code{X} is a subtype of @code{Y}, then: 

  
  @itemize @bullet
  
  @item For each non-@code{variable} attribute of @code{Y}, 
                    @code{X} has an attribute with the same name, whose type is 
                    assignable to the type of the attribute of @code{Y}. 

  
  @item For each @code{variable} attribute of @code{Y}, 
                    @code{X} has a @code{variable} attribute with the 
                    same name and the same type. 

  
  @item For each method of @code{Y}, @code{X} has a 
                    method with the same name, with the same number of parameter lists, with 
                    the same signatures, and whose return type is assignable to the return type 
                    of the method of @code{Y}. 

  
  @item For each member class of @code{Y}, @code{X}
                    has a member class of the same name, with a parameter list with the same 
                    signature, that is a subtype of the member class of @code{Y}. 

  
  @end itemize
Furthermore, we say that @code{X} is @emph{assignable}
            to @code{Y}. 

  
@node uniontypes
@subsection Union types
@cindex Union types

  For any types @code{X} and @code{Y}, the 
            @emph{union}, or @emph{disjunction}, @code{X|Y}, 
            of the types may be formed. A union type is a supertype of both of the given types 
            @code{X} and @code{Y}, and an instance of either type is an 
            instance of the union type. 

  
@smallindentedblock
  Note: the type expression @code{X|Y} is pronounced
            @quotedblleft{}x or y@quotedblright{}. 

  
@end smallindentedblock
The union type constructor @code{|} is associative, so the union 
            of three types, @code{X}, @code{Y}, and @code{Z}, 
            may be written @code{X|Y|Z}. 

  
@verbatim
UnionType: IntersectionType ("|" IntersectionType)*
@end verbatim
If @code{X} and @code{Y} are both subtypes of a third type 
            @code{Z}, then @code{X|Y} inherits all members of @code{Z}. 

  
@example
void write(String|Integer|Float printable) @{ ... @}
@end example
Union types satisfy the following rules, for any types @code{X},
            @code{Y}, and @code{Z}: 

  
  @itemize @bullet
  
  @item 
                        Commutativity: @code{X|Y} is the same 
                        type as @code{Y|X}.
                     

  
  @item 
                        Associativity: @code{X|(Y|Z)} is the same 
                        type as @code{(X|Y)|Z}.
                     

  
  @item 
                        Simplification: if @code{X} is a subtype 
                        of @code{Y}, then @code{X|Y} 
                        is the same type as @code{Y}.
                     

  
  @item 
                        Subtypes: @code{X} is a subtype of 
                        @code{X|Y}.
                     

  
  @item 
                        Supertypes: if both @code{X} and 
                        @code{Y} are subtypes of @code{Z}, 
                        then @code{X|Y} is also a subtype of
                        @code{Z}.
                     

  
  @end itemize
The following results follow from these rules: 

  
  @itemize @bullet
  
  @item 
                        @code{X|Nothing} is the same  type as @code{X} 
                        for any type @code{X}, and
                     

  
  @item 
                        @code{X|Anything} is the same type as @code{Anything}
                        for any type @code{X}.
                     

  
  @end itemize
Finally: 

  
  @itemize @bullet
  
  @item If @code{X<T>} is covariant in the type parameter 
                    @code{T}, then @code{X<U>|X<V>} is a
                    subtype of @code{X<U|V>} for any types @code{U}
                    and @code{V} that satisfy the type constraints on @code{T}. 

  
  @item If @code{X<T>} is contravariant in the type parameter 
                    @code{T}, then @code{X<U>|X<V>} is a
                    subtype of @code{X<U&V>} for any types @code{U}
                    and @code{V} that satisfy the type constraints on @code{T}. 

  
  @end itemize

@node intersectiontypes
@subsection Intersection types
@cindex Intersection types

  For any types @code{X} and @code{Y}, the 
            @emph{intersection}, or @emph{conjunction},
            @code{X&Y}, of the types may be formed. An intersection type is a 
            subtype of both of the given types @code{X} and @code{Y}, 
            and any object which is an instance of both types is an instance of the intersection 
            type. 

  
@smallindentedblock
  Note: the type expression @code{X&Y} is pronounced
            @quotedblleft{}x and y@quotedblright{}. 

  
@end smallindentedblock
The intersection type constructor @code{&} is associative, 
            so the intersection of three types, @code{X}, @code{Y}, 
            and @code{Z}, may be written @code{X&Y&Z}. 

  
@verbatim
IntersectionType: PrimaryType ("&" PrimaryType)*
@end verbatim
The intersection @code{X&Y} inherits all members of both
            @code{X} and @code{Y}. 

  
@example
void store(Persistent&Printable&Identifiable storable) @{ ... @}
@end example
Intersection types satisfy the following rules, for any types @code{X},
            @code{Y}, and @code{Z}: 

  
  @itemize @bullet
  
  @item 
                        Commutativity: @code{X&Y} is the same 
                        type as @code{Y&X}.
                     

  
  @item 
                        Associativity: @code{X&(Y&Z)} is the same 
                        type as @code{(X&Y)&Z}.
                     

  
  @item 
                        Simplification: if @code{X} is a subtype 
                        of @code{Y}, then @code{X&Y} 
                        is the same type as @code{X}.
                     

  
  @item 
                        Supertypes: @code{X} is a supertype of 
                        @code{X&Y}.
                     

  
  @item 
                        Subtypes: if both @code{X} and 
                        @code{Y} are supertypes of @code{Z}, 
                        then @code{X&Y} is also a supertype of
                        @code{Z}.
                     

  
  @item 
                        Distributivity over union: @code{X&(Y|Z)} is the same 
                        type as @code{(X&Y)|(X&Z)}.
                     

  
  @end itemize
The following results follow from these rules: 

  
  @itemize @bullet
  
  @item 
                        @code{X&Nothing} is the same type as @code{Nothing} 
                        for any type @code{X}, and
                     

  
  @item 
                        @code{X&Anything} is the same type as @code{X}
                        for any type @code{X}.
                     

  
  @end itemize
Finally: 

  
  @itemize @bullet
  
  @item If @code{X<T>} is covariant in the type parameter 
                    @code{T}, then @code{X<U>&X<V>} is a
                    supertype of @code{X<U&V>} for any types @code{U}
                    and @code{V} that satisfy the type constraints on @code{T}. 

  
  @item If @code{X<T>} is contravariant in the type parameter 
                    @code{T}, then @code{X<U>&X<V>} is a
                    supertype of @code{X<U|V>} for any types @code{U}
                    and @code{V} that satisfy the type constraints on @code{T}. 

  
  @end itemize

@node bottomtype
@subsection The bottom type
@cindex The bottom type

  The special type @code{Nothing}, sometimes called the
            @emph{bottom type}, represents: 

  
  @itemize @bullet
  
  @item the intersection of all types, or, equivalently 

  
  @item the empty set. 

  
  @end itemize
@code{Nothing} is assignable to all other types, but has
            no instances. 

  The type schema for @code{Nothing} is empty, that is, it
            is considered to have no members. 

  @code{Nothing} is considered to belong to the module
            @code{ceylon.language}. However, it cannot be defined within
            the language. 

  
@smallindentedblock
  Note: an expression of type @code{Nothing} results 
            in a compiler warning. 

  
@end smallindentedblock
Because of the restrictions imposed by Ceylon's mixin inheritance 
            model: 

  
  @itemize @bullet
  
  @item If @code{X} and @code{Y} are classes, and
                    @code{X} is not a subclass of @code{Y}, and 
                    @code{Y} is not a subclass of @code{X}, then
                    the intersection type @code{X&Y} is equivalent to 
                    @code{Nothing}. 

  
  @item If @code{X} is an interface, the intersection type 
                    @code{X&Null} is equivalent to @code{Nothing}. 

  
  @item If @code{X} is an interface, and @code{Y}
                    is a @code{final} class, and @code{Y} is not a
                    subtype of @code{X}, then the intersection type 
                    @code{X&Y} is equivalent to @code{Nothing}. 

  
  @item If @code{X<T>} is invariant in its type parameter
                    @code{T}, and the distinct types @code{A} and 
                    @code{B} do not involve type parameters, then 
                    @code{X<A>&X<B>} is equivalent to 
                    @code{Nothing}. 

  
  @item If @code{X} is a subtype of a type @code{A}
                    and @code{Y} is a subtype of a type @code{B},
                    where @code{A} and @code{B} are distinct cases 
                    of an enumerated type, then the intersection type @code{X&Y} 
                    is equivalent to @code{Nothing}. 

  
  @end itemize
Furthermore, as a special case, 

  
  @itemize @bullet
  
  @item @code{Sequence<E>} is equivalent to 
                    @code{Nothing} if @code{E} is equivalent 
                    to @code{Nothing}, and 

  
  @item @code{Tuple<E,F,R>} is equivalent to 
                    @code{Nothing} if any of @code{E}, 
                    @code{F}, or @code{R} is equivalent to 
                    @code{Nothing}. 

  
  @end itemize

@smallindentedblock
  Note: the soundness of these rules is guaranteed by the 
            implementations of the @code{sealed} types @code{Sequence}
            and @code{Tuple} in the module @code{ceylon.language}.
             

  
@end smallindentedblock

@node principaltyping
@subsection Principal typing
@cindex Principal typing

  An expression, as defined in @ref{expressions, ,Expressions}, occurring at a 
            certain location, may be @emph{assignable} to a type. In this case, 
            every evaluation of the expression at runtime produces an instance of a class that 
            is a subtype of the type, or results in a thrown exception, as defined in 
            @ref{execution, ,Execution}. 

  Given an expression occurring at a certain location, a type @code{T}
            is the @emph{principal type} of the expression if, given any type
            @code{U} to which the expression is assignable, @code{T} 
            is a subtype of @code{U}. Thus, the principal type is the "most precise"
            type for the expression. The type system guarantees that every expression has a 
            principal type. Thus, we refer uniquely to @emph{the type of an expression}, 
            meaning its principal type at the location at which it occurs. 

  
@node typeexpressions
@subsection Type expressions
@cindex Type expressions

  Function and value declarations usually declare a type, by specifying
            a @emph{type expression}. 

  
@verbatim
Type: UnionType | EntryType
@end verbatim
Type expressions are formed by combining types using union, intersection, 
            and type abbreviations. 

  Type expressions support grouping using angle brackets: 

  
@verbatim
GroupedType: "<" Type ">"
@end verbatim
Applied types are identified by the name of the type (a class, interface, 
            type alias, or type parameter), together with a list of type arguments if the 
            type declaration is generic. 

  
@verbatim
TypeNameWithArguments: TypeName TypeArguments?
@end verbatim
Type names are resolved to type declarations according to 
            @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution} and 
            @ref{qualifiedreferenceresolution, ,Qualified reference resolution}. 

  If the type is a class, interface, or type alias nested inside a containing 
            class or interface, the type must be fully qualified by its containing types, 
            except when used inside the body of a containing type. 

  
@verbatim
BaseType: PackageQualifier? TypeNameWithArguments | GroupedType
@end verbatim

@verbatim
QualifiedType: BaseType ("." TypeNameWithArguments)*
@end verbatim
If a type declaration is generic, a type argument list must be specified. 
            If a type declaration is not generic, no type argument list may be specified. 

  A base type may be qualified by the @code{package} keyword, allowing 
            disambiguation of the type name, as defined in 
            @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution}. 

  
@verbatim
PackageQualifier: "package" "."
@end verbatim

@smallindentedblock
  Note: the name of a type may not be qualified by its package name.
            Alias imports, as defined in @ref{aliasimports, ,Alias imports} may be used to 
            disambiguate type names. 

  
@end smallindentedblock

@example
BufferedReader.Buffer
@end example

@example
Entry<Integer,Element>
@end example

@node typenameabbreviations
@subsection Type abbreviations
@cindex Type abbreviations

  Certain important types may be written using an abbreviated syntax. 

  
@verbatim
PrimaryType: AtomicType | OptionalType | SequenceType | CallableType
@end verbatim

@verbatim
AtomicType: QualifiedType | EmptyType | TupleType | IterableType
@end verbatim
First, there are postfix-style abbreviations for @emph{optional types} 
            and @emph{sequence types}. 

  
@verbatim
OptionalType: PrimaryType "?"
@end verbatim

@verbatim
SequenceType: PrimaryType "[" "]"
@end verbatim
For any type @code{X}: 

  
  @itemize @bullet
  
  @item @code{X?} means 
                    @code{Null|X}, and 

  
  @item @code{X[]} means 
                    @code{Sequential<X>}. 

  
  @end itemize

@smallindentedblock
  Note: the type expression @code{X?} is pronounced
           as @quotedblleft{}maybe x@quotedblright{}, and @code{X[]} as 
           @quotedblleft{}sequence of x@quotedblright{}. 

  
@end smallindentedblock
Next, there are type abbreviations for @emph{callable types}
           which represent the types of functions. 

  
@verbatim
CallableType: PrimaryType "(" (TypeList? | SpreadType) ")"
@end verbatim

@verbatim
TypeList: (DefaultedType ",")* (DefaultedType | VariadicType)
@end verbatim

@verbatim
DefaultedType: Type "="?
@end verbatim

@verbatim
VariadicType: UnionType ("*" | "+")
@end verbatim

@verbatim
SpreadType: "*" UnionType
@end verbatim
For any type @code{X}: 

  
  @itemize @bullet
  
  @item @code{X(Y,Z)} means 
                    @code{Callable<X,[Y,Z]>} where 
                    @code{Y,Z} is a list of types of any length, 
                    and 

  
  @item @code{X(*Y)} means 
                    @code{Callable<X,Y>} for any subtype 
                    @code{Y} of 
                    @code{Sequential<Anything>}. 

  
  @end itemize
More precisely, the type meant by a callable type abbreviation is
            @code{Callable<X,T>} where @code{X} is the 
            type outside the parentheses in the the callable type abbreviation, and 
            @code{T} is the tuple type formed by the types listed inside the 
            parentheses. 

  Next, abbreviations for @emph{iterable types} are written
            using braces. 

  
@verbatim
IterableType: "{" UnionType ("*"|"+") "}"
@end verbatim
For any type @code{X}: 

  
  @itemize @bullet
  
  @item @code{@{X*@}} means 
                    @code{Iterable<X,Null>}, and 

  
  @item @code{@{X+@}} means 
                    @code{Iterable<X,Nothing>}. 

  
  @end itemize

@smallindentedblock
  Note: the type expression @code{@{X*@}} is pronounced
            as @quotedblleft{}stream of x@quotedblright{}, and @code{@{X+@}} as 
            @quotedblleft{}nonempty stream of x@quotedblright{}. 

  
@end smallindentedblock
Next, abbreviations for @emph{sequence types} and 
            @emph{tuple types} may be written using brackets. 

  
@verbatim
EmptyType: "[" "]"
@end verbatim

@verbatim
TupleType: "[" TypeList "]" | PrimaryType "[" DecimalLiteral "]"
@end verbatim

  @itemize @bullet
  
  @item @code{[]} means @code{Empty}, 

  
  @item @code{[X]} means @code{Tuple<X,X,[]>}
                    for any type @code{X}, 

  
  @item @code{[X=]} means @code{[]|[X]}
                    for any type @code{X}, 

  
  @item @code{[X*]} means @code{Sequential<X>} 
                    for any type @code{X}, 

  
  @item @code{[X+]} means @code{Sequence<X>} 
                    for any type @code{X}, 

  
  @item @code{[X,Y]} means 
                    @code{Tuple<X|Y,X,[Y]>} for 
                    any types @code{X,Y}, 

  
  @item @code{[X,Y=]} means 
                    @code{Tuple<X|Y,X,[Y=]>} 
                    for any types @code{X,Y}, 

  
  @item @code{[X,Y*]} means 
                    @code{Tuple<X|Y,X,[Y*]>} for 
                    any types @code{X,Y}, 

  
  @item @code{[X,Y+]} means 
                    @code{Tuple<X|Y,X,[Y+]>} for 
                    any types @code{X,Y}, and, finally, 

  
  @item @code{X[1]} means @code{[X]},
                    for any type @code{X},
                    and @code{X[n]} means
                    @code{Tuple<X,X,X[n-1]>}
                    for any type @code{X} and positive integer 
                    @code{n}. 

  
  @end itemize
More precisely: 

  
  @itemize @bullet
  
  @item A tuple type abbreviation of form @code{[X, ... ]}
                    means the type @code{Tuple<X|Y,X,T>} where 
                    @code{T} is the type meant by the type abbreviation formed 
                    by removing the first element type @code{X} from the list of 
                    types in the original tuple type abbreviation, and @code{T} 
                    has the principal instantiation @code{Y[]}, as defined in
                    @ref{principalinstantiations, ,Principal instantiations and polymorphism}. 

  
  @item A tuple type abbreviation of form @code{[X=, ... ]}
                    means the type @code{Empty|T} where @code{T} is the 
                    type meant by the tuple type abbreviation @code{[X, ... ]},
                    formed by removing the @code{=} from the first element type 
                    @code{X=} of the list of types in the original tuple type 
                    abbreviation. 

  
  @end itemize
In a tuple type or callable type expression: 

  
  @itemize @bullet
  
  @item an @emph{defaulted element} is indicated with a
                    postfix @code{=} or @code{*}, and 

  
  @item a @emph{required element} is indicated with a 
                    postfix @code{+} or no special marker. 

  
  @end itemize
In a tuple type or callable type expression, every defaulted element must 
            occur after every required element. 

  Finally, an @emph{entry type} may be abbreviated using an 
            arrow. 

  
@verbatim
EntryType: UnionType "->" UnionType
@end verbatim

  @itemize @bullet
  
  @item @code{X->Y} means @code{Entry<X,Y>}, 
                    for any types @code{X}, @code{Y}. 

  
  @end itemize

@smallindentedblock
  Note: the abbreviations @code{T[]} and 
            @code{[T*]} are synonyms. The syntax @code{T[]} is
            supported for reasons of nostalgia. 

  
@end smallindentedblock
Abbreviations may be combined: 

  
@example
String?[] words = @{ "hello", "world", null @};
String? firstWord = words[0];

String->[Integer,Integer] onetwo = "onetwo"->[1, 2];

[Float+](Float x, Float[] xs) add = (Float x, Float[] xs) => [x, *xs];
@end example
When a type appears in a value expression, these abbreviations cannot be used 
            (they cannot be disambiguated from operator expressions). 

  
@node typeinference
@subsection Type inference
@cindex Type inference

  Certain declarations which usually require an explicit type may omit the type, 
            forcing the compiler to infer it, by specifying the keyword @code{value},
            as defined in @ref{valuetypeinference, ,Value type inference}, or @code{function},
            as defined in @ref{returntypeinference, ,Function return type inference}, where the type usually appears. 

  
@example
value names = people*.name;
@end example

@example
function parse(String text) => text.split(" .!?,:;()\n\f\r\t".contains);
@end example
Type inference is only allowed for declarations which are referred to only by 
            statements and declarations that occur within the lexical scope of the declaration, 
            as specified by @ref{typeinferenceandblockstructure, ,Type inference and block structure}. A 
            @code{value} or @code{function} declaration may not: 

  
  @itemize @bullet
  
  @item be annotated @code{shared}, as defined in
                    @ref{visibility, ,Visibility}, 

  
  @item occur as a toplevel declaration in a compilation unit, as 
                    defined in @ref{topleveldeclarations, ,Toplevel and nested declarations}, or 

  
  @item be referred to by statements or declarations that occur earlier in 
                    the body containing of the declaration, as defined in 
                    @ref{blockstructure, ,Block structure and references}. 

  
  @end itemize
Nor may a parameter or forward-declared value, as defined in 
            @ref{valueforwarddeclaration, ,Forward declaration of values}, or of a forward-declared function, as 
            defined in @ref{functionforwarddeclaration, ,Forward declaration of functions}, have an inferred type. 

  These restrictions allow the compiler to infer undeclared types in a single 
            pass of the code. 

  
@smallindentedblock
  Note: in future releases of the language, the inferred type will
            be context-dependent, that is, in program elements immediately following an
            assignment or specification, the inferred type will be the type just assigned.
            When conditional execution results in definite assignment, the inferred type
            will be the union of the conditionally assigned types. This will allow us to to
            relax the restriction that forward-declared functions and values can't have their
            type inferred. For example: 

  
            
@example
value one;
if (float) @{
    one = 1.0;
    Float float = one;
@}
else @{
    one = 1;
    Integer int = one;
@}
Float|Integer num = one;
@end example

@end smallindentedblock
An inferred type never involves an anonymous class, as defined in
            @ref{anonymousclasses, ,Anonymous classes}. When an inferred type would involve an 
            anonymous class type, the anonymous class is replaced by the intersection 
            of the class type it extends with all interface types it satisfies. 

  
@smallindentedblock
  TODO: properly define how expressions with no type occurring 
            in a @code{dynamic} block affect type inference. 

  
@end smallindentedblock

@node typealiaselimination
@subsection Type alias elimination
@cindex Type alias elimination

  A @emph{type alias} is a synonym for another type. A
            generic type alias is a type constructor that produces a type alias, given 
            a list of type arguments. 

  Every type alias must be reducible to an equivalent type that does
            not involve any type aliases by recursive replacement of type aliases with
            the types they alias. Thus, circular type alias definitions, as in the 
            following example, are illegal: 

  
@example
alias X => List<Y>;  //error: circular type alias definition
alias Y => List<X>;  //error: circular type alias definition
@end example
Replacement of type aliases with the types they alias occurs at 
            compile time, so type aliases are not reified types, as specified in 
            @ref{reification, ,Type argument reification}. 

  
@node inheritance
@section Inheritance
@cindex Inheritance

  
      
@menu
      
* inheritanceandsubtyping:: Inheritance and subtyping
* extendedclass:: Extension
* satisfiedinterfaces:: Satisfaction
@end menu

      Inheritance is a static relationship between classes, interfaces, and type 
        parameters: 

  
  @itemize @bullet
  
  @item a class may @emph{extend} another class, as defined
                by @ref{classinheritance, ,Class inheritance}, 

  
  @item a class may @emph{satisfy} one or more interfaces, 
                as defined by @ref{classinheritance, ,Class inheritance}, 

  
  @item an interface may @emph{satisfy} one or more other 
                interfaces, as defined by @ref{interfaceinheritance, ,Interface inheritance}, or 

  
  @item a type parameter may @emph{satisfy} a class and/or 
                one or more interfaces or type parameters, as defined by 
                @ref{generictypeconstraints, ,Generic type constraints}. 

  
  @end itemize
We say that a type declaration @code{X} @emph{inherits} 
        a type declaration @code{Y} if @code{X} extends or satisfies 
        @code{Y}, or if a third type declaration @code{Z} inherits 
        @code{Y} and @code{X} extends or satisfies @code{Z}. 

  Inheritance relationships may not produce cycles, since that would violate
        the noncircularity rule for subtyping. Thus, a class, interface, or type parameter
        may not, directly or indirectly, inherit itself. 

  When a type declaration extends or satisfies a parameterized type declaration, 
        it must specify type arguments for the type parameters of the generic declaration. 
        Thus, whenever a type declaration inherits a parameterized type declaration, it also 
        inherits an instantiation of the parameterized type declaration. 

  
@smallindentedblock
  
        Note: when a type declaration specifies a relationship to other types, Ceylon 
        visually distinguishes between a list of types which conceptually represents a 
        combination of (intersection of) the types, and a list of types which represents a 
        choice between (union of) the types. For example, when a class @code{C} 
        satisfies multiple interfaces, they are written as @code{X&Y&Z}.
        On the other hand, the cases of an enumerated class @code{E} are written 
        as @code{X|Y|Z}. This syntax emphasizes that @code{C} is also 
        a subtype of the intersection type @code{X&Y&Z}, and that 
        @code{E} may be narrowed to the union type @code{X|Y|Z} using 
        a @code{switch} statement or the @code{of} operator. 

  
        
@end smallindentedblock

@node inheritanceandsubtyping
@subsection Inheritance and subtyping
@cindex Inheritance and subtyping

  Inheritance relationships between classes, interfaces, and type parameters
            result in subtyping relationships between types. 

  
  @itemize @bullet
  
  @item If a type declaration @code{X} with no type parameters 
                inherits a type @code{Y}, then @code{X} is a subtype 
                of @code{Y}. 

  
  @item If a generic type @code{X} inherits a type @code{Y}, 
                which might involve the type parameters of @code{X}, then for any 
                instantiation @code{U} of @code{X} we can construct 
                a type @code{V} by, for every type parameter @code{T} 
                of @code{X}, substituting the corresponding type argument of 
                @code{T} given in @code{U} everywhere @code{T} 
                occurs in @code{Y}, and then @code{U} is a subtype of
                @code{V}. 

  
  @end itemize

@node extendedclass
@subsection Extension
@cindex Extension

  A class may extend another class, in which case the first class is a 
            subtype of the second class and inherits its members. A class which extends 
            another class may have a constructor, as defined in @ref{constructors, ,Constructors}, 
            which delegates to a callable constructor of the second class. Extension and 
            constructor delegation is specified using the @code{extends} 
            clause. 

  The @code{extends} clause must specify exactly one class
            or constructor. 

  
@verbatim
ExtendedType: "extends" (Extension | Construction)
@end verbatim
An @code{extends} clause of a class or constructor has 
            either: 

  
  @itemize @bullet
  
  @item a reference to a superclass, followed by an optional positional 
                    argument list, as defined in @ref{positionalarguments, ,Positional argument lists}, 
                    or 

  
  @item a reference to a superclass constructor, always followed by a 
                    positional argument list. 

  
  @end itemize
In the case that the @code{extends} clause refers to a 
            constructor, the superclass is taken to be the class to which the constructor 
            belongs. 

  
@verbatim
Extension: (BaseExtension | SuperExtension) PositionalArguments?
@end verbatim

@verbatim
Construction: (BaseConstruction | SuperConstruction) PositionalArguments
@end verbatim
The @code{extends} clause may not refer to a partial 
            constructor of the superclass, nor to a value constructor of the superclass.
             

  
@verbatim
BaseExtension: PackageQualifier? TypeNameWithArguments
@end verbatim

@verbatim
SuperExtension: "super" "." TypeNameWithArguments
@end verbatim

@verbatim
BaseConstruction: (PackageQualifier? TypeNameWithArguments ".")? MemberNameWithArguments
@end verbatim

@verbatim
SuperConstruction: "super" "." MemberNameWithArguments
@end verbatim
The specification of the superclass or superclass constructor is treated 
            as a value expression, not as a type expression. 

  
  @itemize @bullet
  
  @item If the qualifier @code{super} occurs, the 
                    specification is treated as a member expression, as defined by 
                    @ref{memberexpressions, ,Member expressions}, where the qualifier 
                    @code{super} is treated according to 
                    @ref{super, ,super}. 

  
  @item If a qualifying type occurs, the specification is treated 
                    as a constructor expression, as defined by 
                    @ref{constructorexpressions, ,Constructor expressions}. 

  
  @item Otherwise, if no qualifier occurs, the specification is 
                    treated as a base expression, as defined by 
                    @ref{baseexpressions, ,Base expressions}. 

  
  @end itemize
The type of the value expression is the inherited type. 

  The specification of the superclass or superclass constructor may have 
            type arguments, and, additionally, the extends clause may have a positional 
            argument list: 

  
  @itemize @bullet
  
  @item If the superclass is a parameterized type, the @code{extends} 
                    clause must also explicitly specify type arguments, and the resulting 
                    applied type is inherited. 

  
  @item If the @code{extends} clause belongs to a constructor or 
                    to a class with an initializer parameter list, the @code{extends} 
                    clause must specify arguments for the initializer parameters of the superclass
                    or parameters of the superclass constructor. 

  
  @item If the @code{extends} clause belongs to a class with no 
                    initializer parameter list, the @code{extends} clause may not 
                    specify arguments for the initializer parameters of the superclass, and the 
                    @code{extends} clause may not refer to a constructor. 

  
  @end itemize
The type arguments may @emph{not} be inferred from the 
            positional arguments. 

  A type argument occurring in the @code{extends} clause may not 
            involve variance annotations @code{in} or @code{out},
            defined below in @ref{typeargumentvariance, ,Type arguments and variance}. 

  
@example
extends Singleton<String>("")
@end example

@example
extends Person(name, org)
@end example

@example
extends withName(name)
@end example
A member class annotated @code{actual} may use the qualifier 
            @code{super} in the @code{extends} clause to refer to the 
            member class it refines. When the qualifier @code{super} appears, the
            following class name refers to a member class of the superclass of the class that
            contains the member class annotated @code{actual}. 

  
@example
extends super.Buffer()
@end example
The root class @code{Anything} defined in 
            @code{ceylon.language} does not have a superclass. 

  
@node satisfiedinterfaces
@subsection Satisfaction
@cindex Satisfaction

  The @code{satisfies} clause does double duty. It's used to 
            specify that a class or interface is a direct subtype of one or more interfaces, 
            and to specify upper bound type constraints applying to a type parameter. 

  
@smallindentedblock
  Note: for this reason the keyword is not named 
            "@code{implements}". It can't reasonably be said that a type 
            parameter "implements" its upper bounds. Nor can it be reasonably said that
            an interface "implements" its super-interfaces. 

  
@end smallindentedblock

  @itemize @bullet
  
  @item A class or interface may satisfy one or more interfaces, in which case
                the class or interface is a subtype of the satisfied interfaces, and inherits 
                their members. 

  
  @item A type parameter may satisfy one or more interfaces, optionally, a class,
                and optionally, another type parameter. In this case, the satisfied types are 
                interpreted as upper bound type constraints on arguments to the type 
                parameter. 

  
  @end itemize

@smallindentedblock
  Note: currently, a type parameter upper bound may not be specified
            in combination with other upper bounds. This restriction will likely be removed in
            future. 

  
@end smallindentedblock
The @code{satisfies} clause may specify multiple types. 

  
@verbatim
SatisfiedTypes: "satisfies" PrimaryType ("&" PrimaryType)*
@end verbatim
If a satisfied class or interface is a parameterized type, the 
            @code{satisfies} clause must explicitly specify type arguments, and 
            the resulting applied type is inherited. 

  A type occurring in the @code{satisfies} clause may not involve
            variance annotations @code{in} or @code{out}, defined below 
            in @ref{typeargumentvariance, ,Type arguments and variance}. 

  
@example
satisfies Correspondence<Integer,Element> & Collection<Element>
@end example
A @code{satisfies} clause may not contain two instantiations of 
            the same type declaration. 

  
@node casesandcoverage
@section Case enumeration and coverage
@cindex Case enumeration and coverage

  
      
@menu
      
* coverage:: Coverage
* cases:: Cases
* genericenumeratedtypes:: Generic enumerated types
* disjointtypes:: Disjoint types
@end menu

      @emph{Coverage} is a static relationship between classes, 
        interfaces, and type parameters, produced through the use of @emph{case 
        enumeration}: 

  
  @itemize @bullet
  
  @item An @code{abstract} class or interface may be an 
            @emph{enumerated type}, with an enumerated list of 
            disjoint subtypes called @emph{cases}, as defined by
            @ref{classeswithcases, ,Enumerated classes} and 
            @ref{interfaceswithcases, ,Enumerated interfaces}. 

  
  @item A type parameter may have an @emph{enumerated bound},
            with an enumerated list possible type arguments, as defined by
            @ref{generictypeconstraints, ,Generic type constraints}. 

  
  @item An @code{abstract} class or interface may have a 
            @emph{self type}, a type parameter representing the
            concrete type of an instance. 

  
  @end itemize

@node coverage
@subsection Coverage
@cindex Coverage

  Coverage is a strictly weaker relationship than assignability: 

  
  @itemize @bullet
  
  @item If a type is a subtype of a second type, then the second type
                covers the first type. 

  
  @item If a type has a self type, then its self type covers the type. 

  
  @item If a type @code{X} enumerates its cases 
                @code{X1}, @code{X2}, etc, then the union 
                @code{X1|X2|...} of its cases covers the type. 

  
  @item If a generic type @code{X} enumerates its cases, 
                @code{X1}, @code{X2}, etc, which might involve
                the type parameters of @code{X}, then for any instantiation 
                @code{U} of @code{X}, and for each case 
                @code{Xi}, we can construct a type @code{Ui} by,
                for every type parameter @code{T} of @code{X},
                substituting the corresponding type argument of @code{T} 
                given in @code{U} everywhere @code{T} occurs in 
                @code{Xi}, and then the union type @code{U1|U2|...}
                of all the resulting types @code{Ui} covers 
                @code{Y}. 

  
  @item If a type @code{X} covers two types @code{A} 
                and @code{B}, then @code{X} also covers their
                union @code{A|B}. 

  
  @item If @code{X} and @code{Y} are both 
                instantiations of a generic type @code{G}, and if the type 
                @code{Z} is formed by replacing every covariant argument in 
                @code{Y} with the intersection of the upper bounds of the 
                corresponding type parameter of @code{G}, after substitution 
                of the given type arguments in @code{Y} for any occurrences
                of the type parameters of @code{G} in the upper bounds, except 
                where the argument is already a subtype of the upper bounds, then if 
                @code{X} covers @code{Z}, then @code{X} 
                also covers @code{Y}. 

  
  @item Coverage is transitive. If @code{X} covers
                @code{Y} and @code{Y} covers @code{Z},
                then @code{X} covers @code{Z}. 

  
  @end itemize
It follows that coverage obeys the identity property of assignability:
            a type covers itself. However, coverage does not obey the noncircularity property 
            of assignability. It is possible to have distinct types @code{A} and 
            @code{B} where @code{A} covers @code{B} and 
            @code{B} covers @code{A}. 

  Case enumeration allows safe use of a type in a @code{switch} 
            statement, or as the subject of the @code{of} operator. The compiler 
            is able to statically validate that the @code{switch} contains an 
            exhaustive list of all cases of the type, by checking that the union of cases 
            enumerated in the @code{switch} covers the type, or that the second 
            operand of @code{of} covers the type. 

  
@smallindentedblock
  
            Note: however, a type is @emph{not} considered automatically 
            assignable to the union of its cases, or to its self type. Instead, the type
            must be @emph{explicitly} narrowed to the union of its cases, nor 
            to its self type, using either the @code{of} operator or the
            @code{switch} construct. This narrowing type conversion can be
            statically checked---if @code{X} covers @code{Y}
            then @code{Y of X} is guaranteed to succeed at runtime. Unfortunately, 
            and quite unintuitively, the compiler is not able to analyse coverage implicitly 
            at the same time as assignability, because that results in undecidability! 

  
            
@end smallindentedblock

@node cases
@subsection Cases
@cindex Cases

  The @code{of} clause does triple duty. It's used to define 
            self types and type families, enumerated types, and enumerated type constraints. 
            The @code{of} clause may specify multiple elements, called 
            @emph{cases}. 

  
@verbatim
CaseTypes: "of" CaseType ("|" CaseType)*
@end verbatim

@verbatim
CaseType: MemberName | PrimaryType
@end verbatim
A type occurring in the @code{of} clause may not involve
            variance annotations @code{in} or @code{out}, defined 
            below in @ref{typeargumentvariance, ,Type arguments and variance}. 

  If an interface or @code{abstract} class with an 
            @code{of} clause has exactly one case, and it is a type parameter 
            of the interface or @code{abstract} class, or of the immediately 
            containing type, if any, then that type parameter is a 
            @emph{self type} of the interface or @code{abstract} 
            class, and: 

  
  @itemize @bullet
  
  @item the self type parameter covers the declared type within the 
                    body of the declaration, 

  
  @item the type argument to the self type parameter in an 
                    instantiation of the declared type covers the instantiation, 
                    and 

  
  @item every type which extends or satisfies an instantiation of the 
                    declared type must also be covered by the type argument to the self
                    type parameter in the instantiation. 

  
  @end itemize

@example
shared abstract class Comparable<Other>() of Other 
        given Other satisfies Comparable<Other> @{
    
    shared formal Integer compare(Other that);
    
    shared Integer reverseCompare(Other that) 
            => that.compare(this) of Other;
    
@}
@end example

@example
Comparable<Item> comp = ... ;
Item item = comp of Item;
@end example
Otherwise, an interface or @code{abstract} class with an 
            @code{of} clause may have multiple cases, but each case must be 
            either: 

  
  @itemize @bullet
  
  @item a subtype of the interface or @code{abstract} 
                    class, or 

  
  @item a value reference to a toplevel anonymous class, as defined
                    in @ref{anonymousclasses, ,Anonymous classes}, that is a subtype of the 
                    interface or @code{abstract} class. 

  
  @end itemize
Then the interface or @code{abstract} class is an
            @emph{enumerated type}, and every subtype of the interface 
            or @code{abstract} class must be a subtype of exactly one of 
            the enumerated subtypes. A class or interface may not be a subtype of more 
            than one case of an enumerated type. 

  If a concrete class has an @code{of} clause, then each
            case must be a value reference to a value constructor of the class, as 
            defined in @ref{constructors, ,Constructors}, and the class must be a toplevel 
            class. Then the concrete class is an enumerated type, and there may be no 
            additional non-partial constructors of the class that are not listed in the 
            @code{of} clause. 

  
@example
of larger | smaller | equal
@end example

@example
of Root<Element> | Leaf<Element> | Branch<Element>
@end example
A type parameter with an @code{of} clause may specify 
            multiple cases, as defined in @ref{generictypeconstraints, ,Generic type constraints}. 

  An @code{of} clause may not contain: 

  
  @itemize @bullet
  
  @item two instantiations of the same type declaration, or 

  
  @item two value references to the same toplevel anonymous class
                    or value constructor. 

  
  @end itemize

@node genericenumeratedtypes
@subsection Generic enumerated types
@cindex Generic enumerated types

  If a generic enumerated type @code{X} has a case type 
            @code{C}, then @code{C} must directly extend or 
            satisfy an instantiation @code{Y} of @code{X}, and 
            for each type parameter @code{T} of @code{X} and 
            corresponding argument @code{A} of @code{T} given 
            in @code{Y}, either: 

  
  @itemize @bullet
  
  @item @code{X} is covariant in @code{T} and 
                    @code{A} is exactly @code{Nothing}, 

  
  @item @code{X} is contravariant in @code{T} 
                    and @code{A} is exactly the intersection of all upper 
                    bounds on @code{T}, or @code{Anything} if 
                    @code{T} has no upper bounds, or 

  
  @item @code{C} is an instantiation of a generic type 
                    @code{G} and @code{A} is exactly 
                    @code{S} for some type parameter @code{S} 
                    of @code{G}, and @code{S} must have the same 
                    variance as @code{T}. 

  
  @end itemize
Furthermore, if @code{C} is an instantiation of a generic
            type, then @code{T} may not occur twice in @code{C}.
             

  For example, the following covariant enumerated type is legal: 

  
@example
interface List<out Element> 
        of Cons<Element> | nil @{ ... @}

class Cons<out Element>(Element element) 
        satisfies List<Element> @{ ... @}

object nil 
        satisfies List<Nothing> @{ ... @}
@end example
As is the following contravariant enumerated type: 

  
@example
interface Consumer<in Event> 
        of Logger | Handler<Event> 
        given Event satisfies AbstractEvent @{ ... @}

interface Logger 
        satisfies Consumer<AbstractEvent> @{ ... @}

interface Handler<in Event> 
        satisfies Consumer<AbstractEvent> 
        given Event satisfies AbstractEvent @{ ... @}
@end example
But the following enumerated type is not legal, since it is possible 
            to choose a legal argument @code{T} of the type parameter 
            @code{Type} of @code{Expression}, such that the case 
            types @code{StringLiteral} and @code{NumberLiteral} 
            aren't subtypes of the instantiation @code{Expression<T>}: 

  
@example
interface Expression<out Type>
        of Function<Type> | StringLiteral | NumberLiteral @{ ... @}

interface Function<out Type> 
        satisfies Expression<Type> @{ ... @}

interface StringLiteral
        satisfies Expression<String> @{ ... @} //error String is not exactly Nothing

interface NumberLiteral
        satisfies Expression<Integer|Float> @{ ... @} //error Integer|Float is not exactly Nothing
@end example

@smallindentedblock
  Note: these rules could be relaxed to allow the definition of
            generic enumerated types where the list of cases of an instantiation of a 
            generic type depends upon the given type arguments (a "generalized" algebraic
            type). 

  
@end smallindentedblock

@node disjointtypes
@subsection Disjoint types
@cindex Disjoint types

  Two types are said to be @emph{disjoint} if it is impossible
            to have a value that is an instance of both types. If @code{X} and 
            @code{Y} are disjoint, then their intersection @code{X&Y}
            is the bottom type @code{Nothing}. 

  Two types @code{X} and @code{Y} are disjoint if
            either: 

  
  @itemize @bullet
  
  @item @code{X} is a subtype of a type @code{A}
                    and @code{Y} is a subtype of a type @code{B},
                    where @code{A} and @code{B} are distinct cases 
                    of an enumerated type, 

  
  @item @code{X} and @code{Y} are both classes and
                    @code{X} is not a subclass of @code{Y} and 
                    @code{Y} is not a subclass of @code{X}, 

  
  @item @code{X} is the class @code{Null} and 
                    @code{Y} is an interface, 

  
  @item @code{X} is an anonymous class or an instantiation 
                    of a @code{final} class and @code{Y} is an 
                    instantiation of a class of interface, and @code{X} 
                    does not inherit @code{Y}, 

  
  @item @code{X} is an anonymous class or a @code{final} 
                    class with no type parameters and @code{Y} is a type in 
                    which no type parameter reference occurs, and @code{X} 
                    is not a suptype of @code{Y}, 

  
  @item @code{X} is a type parameter and @code{Y} 
                    and the intersection of the upper bounds of @code{X} are 
                    disjoint, 

  
  @item @code{X} is a union type @code{A|B} and 
                    both @code{Y} and @code{A} are disjoint and 
                    @code{Y} and @code{B} are disjoint, 

  
  @item @code{X} is an enumerated type with cases 
                    @code{A1|A2|...} and for every case @code{Ai}
                    of @code{X}, @code{Y} and @code{Ai} 
                    are disjoint, 

  
  @item @code{X} is an intersection type @code{A&B} 
                    and either @code{Y} and @code{A} are disjoint or
                    @code{Y} and @code{B} are disjoint, or 

  
  @item @code{X} and @code{Y} inherit disjoint
                    instantiations of a generic type @code{Z}, that is, two 
                    instantiations of @code{Z} that have the intersection
                    @code{Nothing}, as defined below, in 
                    @ref{principalinstantiationinheritance, ,Principal instantiation inheritance}. 

  
  @end itemize
Furthermore, as a special case, the types @code{X} and 
            @code{Y} are disjoint if: 

  
  @itemize @bullet
  
  @item @code{X} is a subtype of some instantiation of
                    @code{Sequential}, @code{Y} is an instantiation
                    of a class or interface that is not a subtype of any instantiation of 
                    @code{Sequential}, and @code{Y} is not an 
                    instantiation of a class or interface that is inherited by 
                    @code{Sequential}, 

  
  @item @code{X} has the principal supertype instantiation 
                    @code{Sequence<A>}, 
                    @code{Y} has the principal supertype instantiation 
                    @code{Sequential<B>},
                    and @code{A} and @code{B} are disjoint, 

  
  @item @code{X} has the principal supertype instantiation 
                    @code{Sequential<A>}, 
                    @code{Y} has the principal supertype instantiation 
                    @code{Tuple<J,B,V>},
                    and @code{A} and @code{B} are disjoint or 
                    @code{Sequential<A>} and @code{V} are 
                    disjoint, or 

  
  @item @code{X} has the principal supertype instantiation 
                    @code{Tuple<I,A,U>},
                    @code{Y} has the principal supertype instantiation 
                    @code{Tuple<J,B,V>},
                    and @code{A} and @code{B} are disjoint 
                    or @code{U} and @code{V} are disjoint. 

  
  @end itemize

@smallindentedblock
  Note: the soundness of these rules is guaranteed by the 
            implementations of the @code{sealed} types @code{Sequence}, 
            @code{Sequential}, @code{Range}, and @code{Tuple}
            in the module @code{ceylon.language}. 

  
@end smallindentedblock

@node generictypeparameters
@section Generic type parameters
@cindex Generic type parameters

  
      
@menu
      
* typeparametersandvariance:: Type parameters and variance
* variancevalidation:: Variance validation
* generictypeconstraints:: Generic type constraints
@end menu

      A function, class, or interface schema may be parameterized by one or more 
        generic type parameters. A parameterized type schema defines a type constructor, 
        a function that produces a type given a tuple of compatible type arguments. A 
        parameterized class or function schema defines a function that produces the 
        signature of an invokable operation given a tuple of compatible type arguments. 

  
@verbatim
TypeParameters: "<" (TypeParameter ",")* TypeParameter ">"
@end verbatim
A declaration with type parameters is called @emph{generic} or
        @emph{parameterized}. 

  
  @itemize @bullet
  
  @item A type schema with no type parameters defines exactly one type. A 
            parameterized type schema defines a template for producing types: one type 
            for each possible combination of type arguments that satisfy the type constraints 
            specified by the type. The types of members of the this type are determined by 
            replacing every appearance of each type parameter in the schema of the 
            parameterized type definition with its type argument. 

  
  @item A function schema with no type parameters defines exactly one operation 
            per type. A parameterized function declaration defines a template for producing
            overloaded operations: one operation for each possible combination of type 
            arguments that satisfy the type constraints specified by the method declaration. 

  
  @item A class schema with no type parameters defines exactly one instantiation 
            operation. A parameterized class schema defines a template for producing 
            overloaded instantiation operations: one instantiation operation for each possible 
            combination of type arguments that satisfy the type constraints specified by the 
            class declaration. The type of the object produced by an instantiation operation is 
            determined by substituting the same combination of type arguments for the type 
            parameters of the parameterized class schema. 

  
  @end itemize

@smallindentedblock
  Note: by convention, type parameter names should be constructed from
        meaningful words. The use of single-letter type parameter names is discouraged. The 
        name of a type parameter should be chosen so that declarations within the body of 
        the parameterized declaration read naturally. For example, 
        @code{class Entry<Key,Item>} is reasonable, since
        @code{Key key} and @code{Item item} read naturally within 
        the body of the @code{Entry} class. The following identifier names 
        usually refer to a type parameter: @code{Element}, @code{Other},
        @code{This}, @code{Value}, @code{Key}, 
        @code{Item}, @code{Absent}, @code{Argument}, 
        @code{Args} and @code{Result}. Avoid, where reasonable, using 
        these names for interfaces and classes. 

  
@end smallindentedblock

@node typeparametersandvariance
@subsection Type parameters and variance
@cindex Type parameters and variance

  A @emph{type parameter} allows a declaration to be abstracted 
            over a constrained set of types. 

  
@verbatim
TypeParameter: Variance TypeName ("=" Type)?
@end verbatim
Every type parameter has a name and a @emph{variance}. 

  
@verbatim
Variance: ("out" | "in")?
@end verbatim

  @itemize @bullet
  
  @item A @emph{covariant} type parameter is indicated using the
                    keyword @code{out}. 

  
  @item A @emph{contravariant} type parameter is indicated using 
                    the keyword @code{in}. 

  
  @item By default, a type parameter is @emph{invariant}. 

  
  @end itemize
A type parameter may, optionally, have a @emph{default type argument}. 
            A type parameter with a default type argument must occur after every type parameter 
            with no default type argument in the type parameter list. 

  The default type argument for a type parameter must satisfy the constraints on 
            the type parameter. 

  
@smallindentedblock
  TODO: this restriction could be relaxed, and the assignability of the
            default type argument to the type constraints checked at use-sites where the default 
            type argument is used in type expressions. 

  
@end smallindentedblock
A default type argument expression for a type parameter of a generic declaration
            may not involve: 

  
  @itemize @bullet
  
  @item the type parameter itself, 

  
  @item any type parameter of the declaration that occurs later in the list 
                    of type parameters, nor 

  
  @item the generic declaration. 

  
  @end itemize
Within the body of the schema it parameterizes, a type parameter is itself a 
            type. The type parameter is a subtype of every upper bound of the type parameter. 
            However, a class or interface may not extend or satisfy a type parameter. 

  
@example
<Key, out Item>
@end example

@example
<in Message>
@end example

@example
<out Element=Object>
@end example

@example
<in Left, in Right, out Result>
@end example

@node variancevalidation
@subsection Variance validation
@cindex Variance validation

  A covariant type parameter may only appear in @emph{covariant positions} 
            of the parameterized schema. A contravariant type parameter may only appear in 
            @emph{contravariant positions} of the parameterized schema. An 
            invariant type parameter may appear in any position. 

  Furthermore, a type with a contravariant type parameter may only appear in a
            covariant position in an extended type, satisfied type, case type, or upper bound
            type constraint. 

  
@smallindentedblock
  Note: this restriction exists to eliminate certain undecidable cases
            described in the paper Taming Wildcards in Java's Type System, by Tate et al. 

  
@end smallindentedblock
To determine if a type expression occurs in a covariant or contravariant 
            position, we first consider how the type occurs syntactically. 

  For a generic function we examine the return type of the function, which
            is a covariant position. 

  For a generic type schema we examine each @code{shared} 
            member, along with extended/satisfied types and case types. 

  
@smallindentedblock
  Note: since the visibility rules are purely lexical in nature, it is 
            legal for a member expression occurring in the body of a class or interface to have 
            a receiver expression other that is not a self-reference, as defined in 
            @ref{selfreferences, ,Self references}, and refer to an un-@code{shared} member 
            of the class or interface. In this special case, the member is treated as if it were 
            @code{shared} for the purposes of the following variance validation 
            rules. 

  
@end smallindentedblock

  @itemize @bullet
  
  @item An extended type, satisfied type, or case type of the type schema 
                    itself is a covariant position. 

  
  @end itemize
In a @code{shared} method declaration of the parameterized 
            type schema: 

  
  @itemize @bullet
  
  @item The return type of the method is a covariant position. 

  
  @item Any parameter type of the method is a contravariant position. 

  
  @item Any upper bound of a type parameter of the method is a contravariant 
                    position. 

  
  @end itemize
In a @code{shared} attribute declaration that is not
            variable: 

  
  @itemize @bullet
  
  @item The type of the attribute is a covariant position. 

  
  @end itemize
In a @code{shared} reference declaration that is 
            variable: 

  
  @itemize @bullet
  
  @item The type of the attribute is an invariant position. 

  
  @end itemize
In a @code{shared} nested class declaration of the 
            parameterized type schema: 

  
  @itemize @bullet
  
  @item Any initializer parameter type of the class is a contravariant 
                    position. 

  
  @item Any callable constructor parameter type of the class is an 
                    invariant position of the class itself, but a contravariant position of 
                    any outer containing type. 

  
  @item Any upper bound of a type parameter of the class is a contravariant 
                    position. 

  
  @item An extended type, satisfied type, or case type of the nested class
                    is a covariant position. 

  
  @item Every covariant position of the nested class schema is a covariant
                    position of the containing type schema. Every contravariant position of 
                    the nested class schema is a contravariant position of the containing type 
                    schema. 

  
  @end itemize
In a @code{shared} nested interface declaration of the 
            parameterized type schema: 

  
  @itemize @bullet
  
  @item An extended type, satisfied type, or case type of the nested interface 
                    is a covariant position. 

  
  @item Every covariant position of the nested interface schema is a covariant
                    position of the containing type schema. Every contravariant position of 
                    the nested interface schema is a contravariant position of the containing 
                    type schema. 

  
  @end itemize
For parameters of callable parameters, we first determine if the callable
            parameter itself is covariant or contravariant: 

  
  @itemize @bullet
  
  @item A callable parameter of a method or nested class is contravariant. 

  
  @item A callable parameter of a covariant parameter is contravariant. 

  
  @item A callable parameter of a contravariant parameter is covariant. 

  
  @end itemize
Then: 

  
  @itemize @bullet
  
  @item The return type of a covariant callable parameter is a covariant 
                    position. 

  
  @item The return type of a contravariant callable parameter is a 
                    contravariant position. 

  
  @item The type of a parameter of a covariant callable parameter is a 
                    contravariant position. 

  
  @item The type of a parameter of a contravariant callable parameter is a 
                    covariant position. 

  
  @end itemize
Finally, to determine if a type parameter that occurs as a type argument occurs
            in a covariant or contravariant position, we must consider the declared variance
            of the corresponding type parameter: 

  
  @itemize @bullet
  
  @item A type argument of a covariant type parameter of a type in a covariant 
                    position is a covariant position. 

  
  @item A type argument of a contravariant type parameter of a type in a 
                    covariant position is a contravariant position. 

  
  @item A type argument of a covariant type parameter of a type in a 
                    contravariant position is a contravariant position. 

  
  @item A type argument of a contravariant type parameter of a type in a 
                    contravariant position is a covariant position. 

  
  @item A type argument of an invariant type parameter of a type in any position 
                    is an invariant position. 

  
  @item A type argument of any type parameter of a type in an invariant position 
                    is an invariant position. 

  
  @end itemize

@node generictypeconstraints
@subsection Generic type constraints
@cindex Generic type constraints

  A parameterized method, class, or interface declaration may declare constraints 
            upon ordinary type parameters using the @code{given} clause. 

  
@verbatim
TypeConstraints: TypeConstraint+
@end verbatim
There may be at most one @code{given} clause per type parameter. 

  
@verbatim
TypeConstraint: "given" TypeName TypeConstraintInheritance
@end verbatim

@verbatim
TypeConstraintInheritance: CaseTypes? SatisfiedTypes?
@end verbatim

@smallindentedblock
  
            Note that the syntax for a type constraint is essentially the same syntax 
            used for other type declarations such as class and interface declarations. 

  
            
@end smallindentedblock
There are two different kinds of type constraint: 

  
  @itemize @bullet
  
  @item An @emph{upper bound}, @code{given X satisfies T}, 
                    specifies that the type parameter @code{X} is a subtype of 
                    a given type @code{T}. 

  
  @item An @emph{enumerated bound}, @code{given X of T|U|V}
                    specifies that the type parameter @code{X} represents one 
                    of the enumerated types. 

  
  @end itemize
The types listed in an enumerated bound must be mutually disjoint, and each
            type must be a class or interface type. 

  
@smallindentedblock
  TODO: Should we allow unions in upper bounds? Should we allow 
            intersections in enumerated bounds? 

  
@end smallindentedblock
A single @code{given} clause may specify multiple constraints on 
            a certain type parameter. In particular, it may specify multiple upper bounds
            together with an enumerated bound. If multiple upper bounds are specified, at most
            one upper bound may be a class, and at most one upper bound may be a type parameter. 

  
@smallindentedblock
  Note: in Ceylon 1.0, a type parameter with multiple upper bounds may 
            not have an upper bound which is another type parameter. 

  
@end smallindentedblock

@example
given Value satisfies Ordinal<Value> & Comparable<Value>
@end example

@example
given Argument of String | Integer | Float
@end example
A type parameter is a subtype of its upper bounds. 

  
@example
class Holder<Value>(shared Value element) 
        extends Object()
        given Value satisfies Object @{
    shared actual Boolean equals(Object that) @{
        return if (is Holder<Value> that
            then element==that.element
            else false;
    @}
    shared actual Integer hash => element.hash;
@}
@end example
Every type parameter has an implicit upper bound of type 
            @code{Anything}. 

  An enumerated bound allows the use of an exhaustive @code{switch}
            with expressions of the parameter type. 

  
@example
Characters uppercase<Characters>(Characters chars) 
       given Characters of String | Range<Character> @{ 
    switch (Characters)
    case (satisfies String) @{ 
        return chars.uppercased;
    @}
    case (satisfies Range<Character>) @{ 
        return chars.first.uppercased..chars.last.uppercased;
    @}
@}
@end example

@smallindentedblock
  TODO: Do we need lower bound type constraints? The syntax would be: 

  
            
@example
given T abstracts One|Two
@end example
With union types
            they don't appear to be anywhere near as useful. However, perhaps they are useful
            when combined with contravariant types. (A lower bound on a parameter which occurs 
            as the argument of a contravariant type is more like an upper bound). 

  
@end smallindentedblock

@smallindentedblock
  Note: since we have reified types, it would be possible to support
            a type constraint that allows instantiation of the type parameter. 

  
            
@example
given T(Object arg)
@end example

            The problem with this is that then inferring @code{T} is fragile.
            And if we don't let it be inferred, we may as well pass @code{T} as an
            ordinary parameter. So Ceylon, unlike C#, doesn't support this. 

  
@end smallindentedblock

@node generictypearguments
@section Generic type arguments
@cindex Generic type arguments

  
      
@menu
      
* typeargumentvariance:: Type arguments and variance
* typeargumentsubstitution:: Type argument substitution
* typeargumentsandconstraints:: Type arguments and type constraints
* producedtypes:: Applied types and and variance
* typeargumentinference:: Type argument inference
@end menu

      A list of @emph{type arguments} produces a new type schema 
        from a parameterized type schema, or a new function schema from a from a
        parameterized function schema. In the case of a type schema, this new schema is
        the schema of an applied type, and is called an instantiation of the parameterized 
        type schema. 

  A type argument list is a list of type arguments. 

  
@verbatim
TypeArguments: "<" ((TypeArgument ",")* TypeArgument)? ">"
@end verbatim
A type argument is a type with a variance. 

  
@verbatim
TypeArgument: Variance Type
@end verbatim
A type argument may itself be an applied type, or type parameter, or may 
        involve unions and intersections. 

  
@example
<Key, List<Item>>
@end example

@example
<String, Person?>
@end example

@example
<String[](Integer), [@{Object*@}]>
@end example

@example
<out Object, in Nothing>
@end example
Type arguments are assigned to type parameters according to the positions
        they occur in the list. 

  
@node typeargumentvariance
@subsection Type arguments and variance
@cindex Type arguments and variance

  Every type argument has a variance: 

  
  @itemize @bullet
  
  @item if the type argument is annotated @code{out}
                    then it must be assigned to an invariant type parameter, and 
                    it is @emph{covariant}, 

  
  @item if the type argument is annotated @code{in}
                    then it must be assigned to an invariant type parameter, and 
                    it is @emph{contravariant}, or, 

  
  @item otherwise, the type argument has the same variance 
                    as the type parameter to which it is assigned. 

  
  @end itemize
It is illegal for both the type parameter and its type argument
            to have an explicit variance. 

  
@node typeargumentsubstitution
@subsection Type argument substitution
@cindex Type argument substitution

  Given the schema of a generic declaration, we form the new schema by 
            @emph{type argument substitution}. Each type argument is 
            substituted for every appearance of the corresponding type parameter in the 
            schema of the generic declaration, including: 

  
  @itemize @bullet
  
  @item attribute types, 

  
  @item function or method return types, 

  
  @item function or method parameter types, 

  
  @item class initializer and callable constructor parameter types, 
                    and 

  
  @item type arguments of extended classes and satisfied interfaces. 

  
  @end itemize
When a type argument @code{A} with no explicit variance 
            annotation is substituted for a type parameter @code{T}, all
            occurrences of @code{T} in the schema of the generic declaration
            are replaced with @code{A}. 

  For type arguments with explicit variance of a type parameter 
            @code{T}, substitution of the type argument depends upon whether
            an occurrence of @code{T} is a covariant or contravariant position
            in the schema of the generic declaration, as defined above in 
            @ref{variancevalidation, ,Variance validation}. 

  When a type argument @code{out A} explicitly marked 
            covariant is substituted for a type parameter @code{T}: 

  
  @itemize @bullet
  
  @item Every occurrence of @code{T} in a covariant position
                    as a type argument of an invariant type parameter is replaced by 
                    @code{out A}. 

  
  @item Every other occurrence of @code{T} in a covariant
                    position is replaced by @code{A}. 

  
  @item Every occurrence of @code{T} in a contravariant
                    position is replaced by @code{Nothing}. 

  
  @item Every applied type expression @code{E} involving
                    @code{A}, and occurring as a type argument of an 
                    invariant type parameter, and which was replaced by @code{F}
                    according to the previous rules is replaced by @code{out F}. 

  
  @end itemize
When a type argument @code{in A} explicitly marked 
            contravariant is substituted for a type parameter @code{T}: 

  
  @itemize @bullet
  
  @item Every occurrence of @code{T} in a contravariant 
                    position as a type argument of an invariant type parameter is 
                    replaced by @code{in A}. 

  
  @item Every other occurrence of @code{T} in a 
                    contravariant position is replaced by @code{A}. 

  
  @item Every occurrence of @code{T} in a covariant
                    position is replaced by the intersection of the upper bound type
                    constraints on @code{T} in which @code{T}
                    itself does not occur covariantly, or by @code{Anything}
                    if there are no such constraints. 

  
  @item Every applied type expression @code{E} involving
                    @code{A}, and occurring as a type argument of an 
                    invariant type parameter, and which was replaced by @code{F}
                    according to the previous rules is replaced by @code{out F}. 

  
  @end itemize

@node typeargumentsandconstraints
@subsection Type arguments and type constraints
@cindex Type arguments and type constraints

  A generic type constraint affects the type arguments that can be assigned 
            to a type parameter in any type argument list belonging directly to: 

  
  @itemize @bullet
  
  @item a base expression or member expression 

  
  @item an applied type expression that occurs directly in a 
                    @code{satisfies}, @code{of}, or 
                    @code{extends} clause, or 

  
  @item a metamodel expression, as defined by
                    @ref{metamodelexpressions, ,Metamodel expressions}. 

  
  @end itemize
A type constraint does @emph{not} apply to any type 
            argument list belonging to an applied type expression that occurs: 

  
  @itemize @bullet
  
  @item outside of the @code{satisfies}, @code{of}, 
                    and @code{extends} clauses, or 

  
  @item as a type argument within these clauses. 

  
  @end itemize
In locations where type constraints apply: 

  
  @itemize @bullet
  
  @item A type argument to a type parameter @code{T} with an 
                    upper bound must be a type which is a subtype of all upper bounds of
                    @code{T} in the realization of the generic declaration, as
                    defined in @ref{realizations, ,Realizations}. 

  
  @item A type argument to a type parameter @code{T} with an 
                    enumerated bound must be a subtype of one of the enumerated types of the
                    bound on @code{T} in the realization of the generic declaration, 
                    or it must be a type parameter @code{A} with an enumerated bound 
                    where every enumerated type of the bound on @code{A} is a subtype 
                    of one of the enumerated types of the bound on @code{T} in the 
                    realization of the generic declaration. 

  
  @end itemize
A type argument list @emph{conforms} to a type parameter list 
            if, for every type parameter in the list, either: 

  
  @itemize @bullet
  
  @item there is a type argument to the type parameter, and either the type 
                    argument satisfies the constraints of the type parameter, or the type
                    argument list occurs in a location where type constraints do not apply,
                    or, alternatively, 

  
  @item there is no explicit type argument but the type parameter has a 
                    default type argument, in which case the type argument is defaulted by
                    substituting the arguments of all type parameters that occur earlier in
                    the list of type parameters of the declaration into this default type
                    argument. 

  
  @end itemize
There must be at least as many type parameters as type arguments. There must 
            be at least as many type arguments as type parameters without default values. 

  
@node producedtypes
@subsection Applied types and and variance
@cindex Applied types and and variance

  If a type argument list conforms to a type parameter list, the combination
            of the parameterized type together with the type argument list is itself a type,
            called an @emph{applied type}. We also call the applied type an 
            @emph{instantiation} of the generic type. 

  For a generic type @code{X}, the instantiations @code{Y} 
            and @code{Z} of @code{X} represent the same type if and 
            only if for every @code{A} in the list of type arguments specified
            in @code{Y} and corresponding @code{B} in the list of type 
            arguments specified in @code{Z}, @code{A} is exactly the 
            same type as @code{B}, and the variance of @code{A} is
            the same as @code{B}. 

  For a generic type @code{G}, and instantiations 
            @code{Y} and @code{Z} of @code{G}, 
            @code{Y} is a subtype of @code{Z} if and only if, 
            for every type parameter @code{T} of @code{G}, and 
            corresponding arguments @code{A} specified in @code{Y} 
            and @code{B} specified in @code{Z}: 

  
  @itemize @bullet
  
  @item 
                        @code{B} is a covariant type argument, and
                        @code{A} is contravariant, and
                        @code{T} is a subtype of @code{B},
                        or
                     

  
  @item 
                        @code{B} is a contravariant type argument, 
                        and @code{A} is covariant, and the type 
                        @code{B} is precisely @code{Nothing}, 
                        or
                     

  
  @item 
                        @code{B} is a covariant type argument, and
                        @code{A} is not contravariant, and the type
                        @code{A} is a subtype of the type 
                        @code{B},
                        or
                     

  
  @item 
                        @code{B} is a contravariant type argument, and
                        @code{A} is not covariant, and the type
                        @code{B} is a subtype of the type
                        @code{A}, or
                     

  
  @item 
                        @code{B} and @code{A} are both 
                        invariant type arguments (neither covariant nor contravariant), 
                        and @code{A} and @code{B} are exactly 
                        the same type.
                     

  
  @end itemize

@smallindentedblock
  Note that if @code{A} is an invariant type 
            argument in the instantiation @code{X<A>} of a generic type 
            @code{X<T>}, then a type @code{Z} is a subtype 
            of @code{X<A>} if and only if @code{Z} has the 
            principal instantiation @code{X<A>}. 

  
@end smallindentedblock

@node typeargumentinference
@subsection Type argument inference
@cindex Type argument inference

  When a direct invocation expression, as defined by 
            @ref{invocationexpressions, ,Invocation expressions}, does not explicitly specify type 
            arguments, the type arguments are inferred from the argument expression types. 

  
  @itemize @bullet
  
  @item In the case of a direct invocation of a function or class, type 
                    arguments are inferred for the type parameters of the function or 
                    class. 

  
  @item In the case of a direct invocation of a callable constructor, 
                    type arguments are inferred for the type parameters of the class to 
                    which the constructor belongs. 

  
  @end itemize
The types of the argument expressions and the declared types of the 
            corresponding parameters determine an @emph{inferred lower bound} 
            or @emph{inferred upper bound} for each type parameter. 

  If a list of argument expressions has types @code{A1,A2,...} 
            and the corresponding list of parameters has declared types @code{P1,P2,...}
            then: 

  
  @itemize @bullet
  
  @item The inferred lower bound for a type parameter @code{T} 
                    of the generic declaration is the conjunction of all inferred lower bounds 
                    @code{Ai} on @code{Pi} for @code{T}. 

  
  @item The inferred upper bound for a type parameter @code{T} 
                    of the generic declaration is the conjunction of all inferred upper bounds 
                    @code{Ai} on @code{Pi} for @code{T}. 

  
  @end itemize
Given types @code{A} and @code{P}, we determine the 
            @emph{inferred lower bound} @code{A} on @code{P} 
            for @code{T} according to the nature of @code{A} and 
            @code{P}: 

  
  @itemize @bullet
  
  @item If @code{P} is exactly @code{T}, and
                    the location at which @code{P} occurs in the parameter 
                    list is not a contravariant location, the inferred lower bound 
                    @code{A} on @code{P} for @code{T} 
                    is @code{T abstracts A}. 

  
  @item If @code{P} is a union type @code{Q|R}, 
                    the lower bound @code{A} on @code{P} for 
                    @code{T} is the disjunction of the lower bound 
                    @code{A} on @code{Q} for @code{T} 
                    with the lower bound @code{A} on @code{R} 
                    for @code{T}. @emph{Note: this case is special.} 

  
  @item If @code{P} is an intersection type @code{Q&R}, 
                    the lower bound @code{A} on @code{P} for 
                    @code{T} is the conjunction of the lower bound 
                    @code{A} on @code{Q} for @code{T} 
                    with the lower bound @code{A} on @code{R} 
                    for @code{T}. 

  
  @item If @code{A} is a union type @code{B|C}, 
                    the lower bound @code{A} on @code{P} for 
                    @code{T} is the conjunction of the lower bound @code{B} 
                    on @code{P} for @code{T} with the lower bound 
                    @code{C} on @code{P} for @code{T}. 

  
  @item If @code{A} is an intersection type @code{B&C}, 
                    the lower bound @code{A} on @code{P} for 
                    @code{T} is the disjunction of the lower bound @code{B} 
                    on @code{P} for @code{T} with the lower bound 
                    @code{C} on @code{P} for @code{T}. 

  
  @item If @code{P} is an applied type @code{Q<P1,P2,...>} 
                    of a parameterized type @code{Q}, and @code{A} 
                    is a subtype of an applied type @code{Q<A1,A2,..>}, 
                    the lower bound @code{A} on @code{P} for 
                    @code{T} is the conjunction of all lower bounds @code{Ai} 
                    on @code{Pi} for @code{T}. 

  
  @item Otherwise, if @code{A} is not a union or intersection, 
                    and if @code{P} is neither an applied type, a union, or an
                    intersection, nor exactly @code{T}, the lower bound 
                    @code{A} on @code{P} for @code{T}
                    is @emph{null}. 

  
  @end itemize
Where: 

  
  @itemize @bullet
  
  @item the conjunction of a lower bound @code{T abstracts A}
                    with a lower bound @code{T abstracts B} is the lower bound 
                    @code{T abstracts A|B}, 

  
  @item the disjunction of a lower bound @code{T abstracts A}
                    with a lower bound @code{T abstracts B} is the lower bound 
                    @code{T abstracts A&B}, 

  
  @item the conjunction or disjunction of a lower bound @code{T abstracts A}
                    with a null lower bound is @code{T abstracts A}, and 

  
  @item the conjunction or disjunction of two null lower bounds is null. 

  
  @end itemize
Given types @code{A} and @code{P}, we determine 
            the @emph{inferred upper bound} @code{A} on 
            @code{P} for @code{T} according to the nature of 
            @code{A} and @code{P}: 

  
  @itemize @bullet
  
  @item If @code{P} is exactly @code{T}, and
                    the location at which @code{P} occurs in the parameter 
                    list is not a covariant location, the inferred upper bound 
                    @code{A} on @code{P} for @code{T} 
                    is @code{T satisfies A}. 

  
  @item If @code{P} is a union type @code{Q|R}, 
                    the upper bound @code{A} on @code{P} for 
                    @code{T} is the disjunction of the upper bound 
                    @code{A} on @code{Q} for @code{T} 
                    with the upper bound @code{A} on @code{R} 
                    for @code{T}. @emph{Note: this case is special.} 

  
  @item If @code{P} is an intersection type @code{Q&R}, 
                    the upper bound @code{A} on @code{P} for 
                    @code{T} is the conjunction of the upper bound 
                    @code{A} on @code{Q} for @code{T} 
                    with the upper bound @code{A} on @code{R} 
                    for @code{T}. 

  
  @item If @code{A} is a union type @code{B|C}, 
                    the upper bound @code{A} on @code{P} for 
                    @code{T} is the disjunction of the upper bound @code{B} 
                    on @code{P} for @code{T} with the upper bound 
                    @code{C} on @code{P} for @code{T}. 

  
  @item If @code{A} is an intersection type @code{B&C}, 
                    the upper bound @code{A} on @code{P} for 
                    @code{T} is the conjunction of the upper bound @code{B} 
                    on @code{P} for @code{T} with the upper bound 
                    @code{C} on @code{P} for @code{T}. 

  
  @item If @code{P} is an applied type @code{Q<P1,P2,...>} 
                    of a parameterized type @code{Q}, and @code{A} 
                    is a subtype of an applied type @code{Q<A1,A2,..>}, 
                    the upper bound @code{A} on @code{P} for 
                    @code{T} is the conjunction of all upper bounds @code{Ai} 
                    on @code{Pi} for @code{T}. 

  
  @item Otherwise, if @code{A} is not a union or intersection, 
                    and if @code{P} is neither an applied type, a union, or an
                    intersection, nor exactly @code{T}, the upper bound 
                    @code{A} on @code{P} for @code{T}
                    is @emph{null}. 

  
  @end itemize
Where: 

  
  @itemize @bullet
  
  @item the conjunction of an upper bound @code{T satisfies A}
                    with an upper bound @code{T satisfies B} is the upper bound 
                    @code{T satisfies A&B}, 

  
  @item the disjunction of an upper bound @code{T satisfies A}
                    with an upper bound @code{T satisfies B} is the upper bound 
                    @code{T satisfies A|B}, 

  
  @item the conjunction or disjunction of an upper bound @code{T satisfies A}
                    with a null upper bound is @code{T satisfies A}, and 

  
  @item the conjunction or disjunction of two null upper bounds is null. 

  
  @end itemize
The inferred type argument to a covariant type parameter 
            @code{T} of the generic declaration is: 

  
  @itemize @bullet
  
  @item @code{Nothing}, if the inferred lower bound for 
                    @code{T} is null, or, otherwise, 

  
  @item the type @code{A}, where the inferred lower bound for 
                    @code{T} is @code{T abstracts A}. 

  
  @end itemize
The inferred type argument to a contravariant type parameter 
            @code{T} of the generic declaration is: 

  
  @itemize @bullet
  
  @item @code{Anything}, if the inferred upper bound for 
                    @code{T} is null, or, otherwise, 

  
  @item the type @code{A}, where the inferred upper bound for 
                    @code{T} is @code{T satisfies A}. 

  
  @end itemize
An invariant type parameter @code{T} of the generic 
            declaration is treated, for the purposes of type argument inference, as if it 
            were covariant or contravariant, depending upon how it occurs in the types of 
            parameters explicitly assigned arguments by the direct invocation, and, in the
            case of direct invocation of a generic function or class alias, upon how it 
            occurs in the return type of the function or aliased type of the class alias. 

  
  @itemize @bullet
  
  @item If the generic declaration is a function or class alias, and 
                    @code{T} occurs covariantly in its return type or aliased 
                    type, and does not occur contravariantly or invariantly in its return 
                    type or aliased type, then @code{T} is treated as 
                    covariant. 

  
  @item If the generic declaration is a function or class alias, and 
                    @code{T} occurs contravariantly in its return type or 
                    aliased type, and does not occur covariantly or invariantly in its 
                    return type or aliased type, then @code{T} is treated as 
                    contravariant. 

  
  @item Otherwise, if @code{T} occurs contravariantly in the 
                    type of any parameter to which an argument is explicity assigned by the 
                    argument list of the direct invocation, and does not occur covariantly 
                    or invariantly in the type of any parameter to which an argument is 
                    explicitly assigned, then @code{T} is treated as 
                    contravariant. 

  
  @item Finally, if none of the above cases apply, @code{T} is 
                    treated as covariant. 

  
  @end itemize
An argument expression with no type occurring in a @code{dynamic}
            block, as defined in @ref{dynamicblocks, ,Dynamic blocks}, may cause type argument inference 
            to fail. When combining bounds using union, any constituent bound with no type results 
            in a bound with no type. When combining bounds using intersection, any constituent 
            bound with no type is eliminated. If the resulting inferred upper or lower bound has no 
            type, type argument inference is impossible for the type argument, and type arguments 
            must be specified explicitly. 

  Finally, when every type parameter @code{Pi} has been assigned an 
            inferred type argument @code{Ai}, each inferred type argument is adjusted
            according to the upper bound type constraints on @code{Pi}. The final
            inferred type argument is the intersection of @code{Ai} with every type
            @code{Vj} formed by substituting all @code{Ai}s for their
            corresponding @code{Pi}s in an upper bound @code{Uj} of
            @code{Pi}. 

  If the inferred type argument does not satisfy the generic type 
            constraints on @code{T}, a compilation error results. 

  Consider the following invocation: 

  
@example
[Element+] prepend<Element>(Element head, Element[] sequence) @{ ... @}
value result = prepend(null, @{"hello", "world"@});
@end example
The inferred type of @code{Element} is the union type 
            @code{String?}. 

  Now consider: 

  
@example
class Bag<out Element>(Element* elements) @{
    shared Bag<ExtraElement> with<ExtraElement>(ExtraElement* elements) 
            given ExtraElement abstracts Element @{ ... @}
@}
Bag<String> bag = Bag("hello", "world");
value biggerBag = bag.with(1, 2, 5.0);
@end example
The inferred type of @code{ExtraElement} is the union 
            type @code{Integer|Float|String}. 

  Finally consider: 

  
@example
interface Delegate<in Value> @{ ... @}
class Consumer<in Value>(Delegate<Value>* delegates) @{ ... @}
Delegate<String> delegate1 = ... ;
Delegate<Object> delegate2 = ... ; 
value consumer = Consumer(delegate1, delegate2);
@end example
The inferred type of @code{Value} is 
            @code{Consumer<String>}. 

  
@smallindentedblock
  TODO: What about upper bounds in which the type parameter 
            itself appears (the infamous self-type problem with
            @code{Comparable} and @code{Numeric}) or in which 
            another type parameter appears? 

  
@end smallindentedblock
An inferred type argument never involves an anonymous class, as defined 
            in @ref{anonymousclasses, ,Anonymous classes}. When an inferred type would involve an 
            anonymous class type, the anonymous class is replaced by the intersection 
            of the class type it extends with all interface types it satisfies. 

  
@node principalinstantiations
@section Principal instantiations and polymorphism
@cindex Principal instantiations and polymorphism

  
      
@menu
      
* inheritedinstantiations:: Inherited instantiations
* typeargumentdistinctness:: Type argument distinctness
* principalinstantiationinheritance:: Principal instantiation inheritance
* principalinstantiationofasupertype:: Principal instantiation of a supertype
* refinement:: Refinement
* qualifiedtypes:: Qualified types
* realizations:: Realizations
@end menu

      Inheritance interacts with type parameterization to produce subtyping 
        relationships between instantiations of generic types. The notion of an
        @emph{inherited instantiation} and the notion of a 
        @emph{principal instantation} help us reason about these 
        relationships. 

  
@smallindentedblock
  Warning: this section is not for the faint of heart. Feel 
        free to skip to @ref{declarations, ,Declarations}, unless you're really, really 
        interested in precisely how the compiler reasons about inheritance of generic 
        types. 

  
@end smallindentedblock

@node inheritedinstantiations
@subsection Inherited instantiations
@cindex Inherited instantiations

  For a generic type @code{G}, inheritance produces subtypes 
            with @emph{inherited instantiations} of the generic type. 

  
  @itemize @bullet
  
  @item If a type @code{X} directly extends or satisfies an 
                instantiation @code{V} of @code{G}, then 
                @code{X} has the inherited instantiation @code{V} 
                of @code{G}. 

  
  @item If a generic type @code{H} extends or satisfies an 
                instantiation @code{V} of @code{G}, that may 
                involve the type parameters of @code{H}, then for any 
                instantiation @code{U} of @code{H}, we can 
                construct an instantiation @code{W} of @code{G} 
                by, for every type parameter @code{T} of @code{H}, 
                substituting the type argument of @code{T} given in 
                @code{U} everywhere @code{T} occurs in 
                @code{V}, and then @code{U} has the inherited 
                instantiation @code{W} of @code{G}. 

  
  @item If a type @code{X} is a subtype of a type 
                @code{Y}, and @code{Y} has an inherited 
                instantiation @code{W} of a generic type @code{G}, 
                then @code{X} also has this inherited instantiation. 

  
  @end itemize

@node typeargumentdistinctness
@subsection Type argument distinctness
@cindex Type argument distinctness

  A pair of type arguments @code{A} and @code{B}
            are considered: 

  
  @itemize @bullet
  
  @item @emph{provably distinct}, if neither 
                    @code{A} nor @code{B} involves a type 
                    parameter and either: 

  
  @itemize @bullet
  
  @item both arguments are invariant, and are not 
                            exactly the same type, 

  
  @item one argument is covariant and the other argument 
                            is invariant and is not a subtype of the covariant 
                            argument, or 

  
  @item one argument is contravariant and the other 
                            argument is invariant and is not a supertype of the 
                            contravariant argument, 

  
  @end itemize

  @item @emph{provably not distinct}, if either: 

  
  @itemize @bullet
  
  @item both arguments are invariant, and are exactly 
                            the same type, 

  
  @item both arguments are covariant, 

  
  @item both arguments are contravariant, 

  
  @item one argument is covariant and the other argument 
                            is invariant and is a subtype of the covariant 
                            argument, or 

  
  @item one argument is contravariant and the other 
                            argument is invariant and is a supertype of the 
                            contravariant argument, 

  
  @end itemize

  @item otherwise, @emph{possibly distinct}, if
                    either @code{A} or @code{B} involves a 
                    type parameter and @code{A} and @code{B} 
                    are not provably not distinct, or if @code{A} and 
                    @code{B} have opposite variances. 

  
  @end itemize

@smallindentedblock
  Note: the unfortunate case of possible distinctness is an
            incompleteness in the type system arising from the fact that Ceylon does 
            not currently allow a type argument with both an upper and a lower bound, 
            that is, a type argument of form @code{in X out Y}. 

  
@end smallindentedblock

@node principalinstantiationinheritance
@subsection Principal instantiation inheritance
@cindex Principal instantiation inheritance

  If a class or interface type @code{X} has the inherited 
            instantiations @code{V} and @code{W} of some 
            generic type @code{Y}, then: 

  
  @itemize @bullet
  
  @item for every invariant type parameter @code{T} of 
                    @code{Y}, the type argument @code{A} of 
                    @code{T} given in @code{V} and the type 
                    argument @code{B} of @code{T} given in 
                    @code{W} must be exactly the same type, and,
                    furthermore, 

  
  @item @code{X} is a subtype of an instantiation 
                     @code{U} of @code{Y} such that 
                     @code{U} is a subtype of 
                     @code{V&W}. 

  
  @end itemize
Therefore, if a type @code{X} is a subtype of the 
            instantiations @code{V} and @code{W} of some generic 
            type @code{Y}, then either: 

  
  @itemize @bullet
  
  @item for some invariant type parameter @code{T} of 
                    @code{Y}, the argument @code{A} of 
                    @code{T} given in @code{V} and the argument
                    @code{B} of @code{T} given in 
                    @code{W} are provably distinct type arguments, and then 
                    the type @code{V&W} is the bottom type 
                    @code{Nothing}, and we say that @code{V} and 
                    @code{W} are @emph{disjoint instantiations} 
                    of @code{Y}, or 

  
  @item for some invariant type parameter @code{T} of 
                    @code{Y}, the argument of @code{A} of 
                    @code{T} given in @code{V} and the argument
                    @code{B} of @code{T} given in 
                    @code{W} are possibly distinct, and then we say that
                    @code{V} and @code{W} are 
                    @emph{irreconcilable instantiations} 
                    of @code{Y}, or 

  
  @item otherwise, @code{X} must be a subtype of an 
                    instantiation @code{P} of @code{Y} formed 
                    by taking each type parameter @code{T} of 
                    @code{Y}, and constructing a type argument 
                    @code{C} for @code{T} from the type 
                    arguments @code{A} of @code{T} given in 
                    @code{V} and @code{B} of @code{T} 
                    given in @code{W}: 

  
  @itemize @bullet
  
  @item if @code{A} and @code{B} are 
                            both invariant, then they must be exactly the same type,
                            and @code{C} is the same type as 
                            @code{A} and @code{B}, 

  
  @item if both @code{A} and @code{B} 
                            are covariant, then @code{C} is 
                            @code{out A&B} 

  
  @item if both @code{A} and @code{B} 
                            are contravariant, then @code{C} is 
                            @code{in A|B}, 

  
  @item if either @code{A} or @code{B} 
                             is covariant and the other is invariant, with exact type
                             @code{D}, then @code{C} is just
                             @code{D}, or 

  
  @item if either @code{A} or @code{B} 
                            is contravariant, and the other is invariant, with exact type 
                            @code{D}, then @code{C} is just
                            @code{D}. 

  
  @end itemize

  @end itemize
Finally, the following identities result from principal instantiation 
            inheritance. For any generic type @code{X<T>}, and for any given 
            types @code{A} and @code{B}: 

  
  @itemize @bullet
  
  @item @code{X<A>&X<B>} is exactly equivalent 
                    to @code{X<A&B>} if @code{X<T>}
                    is covariant in @code{T}, unless either @code{A}
                    or @code{B} involves type parameters, and 

  
  @item @code{X<A>&X<B>} is exactly equivalent
                    to @code{X<A|B>} if @code{X<T>} is 
                    contravariant in @code{T}, unless either @code{A}
                    or @code{B} involves type parameters. 

  
  @end itemize

@node principalinstantiationofasupertype
@subsection Principal instantiation of a supertype
@cindex Principal instantiation of a supertype

  If a type @code{X} is a subtype of some instantiation 
            @code{V} of a generic type @code{Y}, then, as a 
            result of the principal instantiation inheritance restriction, we can 
            form a unique instantiation of @code{Y} that is a subtype of 
            every instantiation of @code{Y} to which @code{X} 
            is assignable. We call this type the @emph{principal instantiation of 
            Y for X}. 

  We compute principal instantiations by making use of the identities
            observed above in @ref{uniontypes, ,Union types}, @ref{intersectiontypes, ,Intersection types},
            and @ref{principalinstantiationinheritance, ,Principal instantiation inheritance}. 
            For any generic type @code{X}: 

  
  @itemize @bullet
  
  @item The principal instantiation of the union @code{U|V}
                    of two instantiations of @code{X}, @code{U} 
                    and @code{V}, is an instantiation @code{P} 
                    of @code{X} formed by taking each type parameter 
                    @code{T} of @code{X} and constructing a
                    type argument @code{C} for @code{T} from
                    the type arguments @code{A} of @code{T} 
                    given in @code{U} and @code{B} of 
                    @code{T} given in @code{V}: 

  
  @itemize @bullet
  
  @item if either @code{A} or @code{B} 
                            is covariant, and neither is contravariant, then 
                            @code{C} is the covariant type argument 
                            @code{out A|B}, 

  
  @item if either @code{A} or @code{B} 
                            is contravariant, and neither is covariant, then 
                            @code{C} is the contravariant type argument 
                            @code{in A&B}, or 

  
  @item if both @code{A} and @code{B} 
                            are invariant, and if @code{A} and 
                            @code{B} are exactly the same type, then 
                            @code{C} is this type. 

  
  @end itemize

  @item The principal instantiation of the intersection @code{U&V}
                    of two instantiations of @code{X}, @code{U} 
                    and @code{V}, is an instantiation @code{P} of
                    @code{X} formed by taking each type parameter 
                    @code{T} of @code{X} and constructing a
                    type argument @code{C} for @code{T} from
                    the type arguments @code{A} of @code{T} 
                    given in @code{U} and @code{B} of 
                    @code{T} given in @code{V}: 

  
  @itemize @bullet
  
  @item if either @code{A} or @code{B} 
                            is covariant, and neither is contravariant, then 
                            @code{C} is the covariant type argument
                            @code{out A&B}, 

  
  @item if either @code{A} or @code{B} 
                            is contravariant, and neither is covariant, then 
                            @code{C} is the contravariant type argument
                            @code{in A|B},
                            or 

  
  @item if both @code{A} and @code{B} 
                            are invariant, and if @code{A} and 
                            @code{B} are exactly the same type, then 
                            @code{C} is this type. 

  
  @end itemize

  @item Finally, the principal instantiation of a generic type @code{X} 
                    for a type @code{Y} which has one or more inherited instantiations 
                    of @code{X} is the principal instantiation of the intersection of 
                    all the inherited instantiations of @code{X}. 

  
  @end itemize

@smallindentedblock
  Note: since we do not support type arguments with both upper
            and lower bounds, there are two cases where we cannot form a principal
            instantiation for an intersection type. 

    
            
  @itemize @bullet
  
  @item Intersections such as @code{X<in A> & X<out B>}, 
            where the principal instantiation would be @code{X<in A out B>}.
             

  
  @item An intersection @code{X<A> & X<P>} 
            of two instantiations of an invariant type, @code{X<T>} where 
            one type argument @code{P} is a type parameter. The principal
            instantiation should be @code{X<in A|P out A&P>}. 

  
  @end itemize

            In these cases we simply disallow references to members of the intersection 
            type. 

  
@end smallindentedblock

@node refinement
@subsection Refinement
@cindex Refinement

  A class or interface may declare an @code{actual} member 
            with the same name as a member that it inherits from a supertype if the supertype
            member is declared @code{formal} or @code{default}.
            Then we say that the first member @emph{refines} the second
            member, and it must obey restrictions defined in 
            @ref{classrefinement, ,Member class refinement}, @ref{methodrefinement, ,Method refinement}, or
            @ref{attributerefinement, ,Attribute refinement}. 

  A declaration may not be annotated both @code{formal} 
            and @code{default}. 

  If a declaration is annotated @code{formal}, 
            @code{default}, or @code{actual} then it must 
            also be annotated @code{shared}. 

  For any class or interface @code{X}, and for every declared
            or inherited member of @code{X} that is not refined by some other
            declared or inherited member of @code{X}, and for every other member 
            declared or inherited by @code{X} that directly or indirectly refines 
            a declaration that the first member itself directly or indirectly refines, the 
            principal instantiation for @code{X} of the type that declares the 
            first member must be a subtype of the principal instantiation for @code{X} 
            of the type that declares the second member. 

  
@smallindentedblock
  Note: a related restriction is defined in 
            @ref{declarationnameuniqueness, ,Declaration name uniqueness}. 

  
@end smallindentedblock

@node qualifiedtypes
@subsection Qualified types
@cindex Qualified types

  A type declaration that directly occurs in the body of another type
            is called a @emph{nested type}. If a nested type is annotated 
            @code{shared}, it may be used in a type expression outside the 
            body in which it is declared, if and only if it occurs as a 
            @emph{qualified type}, as specified in 
            @ref{typeexpressions, ,Type expressions}. 

  The qualified types @code{X.U} and @code{Y.V} 
            are exactly the same types if and only if @code{U} is exactly 
            the same type as @code{V}, and in the case that this type is
            a member of a generic type @code{Z}, then the principal 
            instantiation of @code{Z} for @code{X} is exactly
            the same type as the principal instantiation of @code{Z} for
            @code{Y}. 

  A qualified type @code{X.U} is a subtype of a qualified
            type @code{Y.V} if @code{U} is a subtype of 
            @code{V}, and in the case that @code{V} is a member 
            of a generic type @code{Z}, then @code{X} is a 
            subtype of the principal instantiation of @code{Z} for 
            @code{Y}. 

  
@node realizations
@subsection Realizations
@cindex Realizations

  Given a member declared by @code{Y}, and a declaration that 
            refines it, we can construct a @emph{refined realization} of 
            the member or nested type: 

  
  @itemize @bullet
  
  @item first determine the principal instantiation of @code{Y}
                    for the class or interface which refines the member, and then 

  
  @item substitute the type arguments in this principal instantiation 
                    into the member schema. 

  
  @end itemize
Given an unqualified reference, as defined in 
            @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution}, to a declaration, and, in 
            the case of a generic declaration, a list of type arguments for the type 
            parameters of the declaration, we can construct an @emph{unqualified 
            realization} of the declaration: 

  
  @itemize @bullet
  
  @item if the declaration is a member declared by a type 
                    @code{Y}, first determine the principal instantiation 
                    of @code{Y} for the inheriting or declaring class or 
                    interface, and then 

  
  @item again, only if the declaration is a member declared by a 
                    type, substitute the type arguments in this principal 
                    instantiation into the declaration schema, and, finally, 

  
  @item substitute the type arguments into the declaration schema. 

  
  @end itemize
Given a qualified reference, as defined in 
            @ref{qualifiedreferenceresolution, ,Qualified reference resolution}, with a qualifying type 
            @code{X}, to a member or nested type declared by @code{Y}, 
            and, in the case of a generic member or generic nested type, a list of 
            type arguments for the type parameters of the member, we can construct a 
            @emph{qualified realization} of the member or nested type: 

  
  @itemize @bullet
  
  @item first determining the principal instantiation of 
                    @code{Y} for @code{X}, and then 

  
  @item substituting the type arguments in this principal 
                    instantiation into the declaration schema, and, finally, 

  
  @item in the case of a generic member or generic nested type, 
                    substituting the type arguments into the declaration schema. 

  
  @end itemize
If, for any given qualified or unqualified reference, it is impossible 
            to form the principal instantiation of the type that declares the referenced 
            declaration, due to the hole described above in 
            @ref{principalinstantiationofasupertype, ,Principal instantiation of a supertype}, it is impossible to 
            form a realization, and the reference to the declaration is illegal. 

  
@node declarations
@chapter Declarations
@cindex Declarations

@menu
  
* compilationunitstructure:: Compilation unit structure
* imports:: Imports
* parameters:: Parameters
* interfaces:: Interfaces
* classes:: Classes
* typealiasedeclarations:: Type aliases
* functions:: Functions
* values:: Values
* constructors:: Constructors
@end menu

  Ceylon is a statically typed language. Classes, interfaces, functions, values 
    and aliases must be declared before use. The declaration of a function or value must 
    include an explicit type, or allow the type to be inferred. Static typing allows the 
    compiler to detect many errors, including: 

  
  @itemize @bullet
  
  @item typing errors in identifier names, 

  
  @item references to types which do not exist or are not 
        visible, 

  
  @item references to type members which do not exist or are not 
        visible, 

  
  @item argument lists which do not match parameter lists, 

  
  @item type argument lists which do not match type parameter 
        lists, 

  
  @item operands to which an operator cannot apply, 

  
  @item incompatible assignment of an expression of one type to a
        program element of a different type, 

  
  @item evaluation of a value before it has been explicitly specified 
        or assigned, 

  
  @item assignment to a non-@code{variable} value, 

  
  @item failure to refine a @code{formal} member of a 
        supertype, 

  
  @item refinement of a non-@code{formal}, 
        non-@code{default} member of a supertype, 

  
  @item @code{switch} statements which do not exhaust all
        cases of an enumerated type. 

  
  @end itemize
All declarations follow a general pattern: 

  
@example
Annotations
(keyword | Type) (TypeName | MemberName) TypeParameters? Parameters*
CaseTypes? ExtendedType? SatisfiedTypes?
TypeConstraints?
(Definition | ";")
@end example
A type parameter does not need an explicit declaration of this form unless it has 
    constraints. In the case that it does have constraints, the constraint declaration does 
    follow the general pattern. 

  This consistent pattern for declarations, together with the strict block structure
    of the language, makes Ceylon a highly regular language. 

  
@node compilationunitstructure
@section Compilation unit structure
@cindex Compilation unit structure

  
      
@menu
      
* topleveldeclarations:: Toplevel and nested declarations
* packages:: Packages
@end menu

      A @emph{compilation unit} is a text file, with the filename 
        extension @code{.ceylon}. 

  
@smallindentedblock
  Note: it is recommended that source file names contain only 
        characters from the ASCII character set. This minimizes problems when 
        transferring Ceylon source between operating systems. 

  
@end smallindentedblock
There are three kinds of compilation unit: 

  
  @itemize @bullet
  
  @item A regular compilation unit contains a list of toplevel type, 
                value, or function definitions. 

  
  @item A @emph{module descriptor}, defined in
                @ref{moduledescriptors, ,Module descriptors}, contains a 
                @code{module} declaration. The file must be named
                @code{module.ceylon}. 

  
  @item A @emph{package descriptor}, defined in
                @ref{packagedescriptors, ,Package descriptors}, contains a 
                @code{package} declaration. The file must be named
                @code{package.ceylon}. 

  
  @end itemize
Any compilation unit may begin with a list of imported types, values, 
        and functions. 

  
@verbatim
Import* (ModuleDescriptor | PackageDescriptor | Declaration*)
@end verbatim

@node topleveldeclarations
@subsection Toplevel and nested declarations
@cindex Toplevel and nested declarations

  A @emph{toplevel declaration} defines a type---a class 
            or interface---or a type alias, or a function or value. 

  
@verbatim
Declaration: FunctionValueDeclaration | TypeDeclaration | ParameterDeclaration
@end verbatim

@verbatim
FunctionValueDeclaration: FunctionDeclaration | ValueDeclaration | SetterDeclaration
@end verbatim

@verbatim
TypeDeclaration: ClassDeclaration | ObjectDeclaration | InterfaceDeclaration | TypeAliasDeclaration
@end verbatim
A toplevel declaration is not polymorphic and so may not be annotated 
            @code{formal}, @code{default}, or 
            @code{actual}. 

  
@smallindentedblock
  Note: in a future release of the language, we might relax this 
            restriction and support package extension with toplevel member refinement. This
            can be viewed as a regularization of the language. The practical application is
            that it would make toplevel invocations and instantiations polymorphic, obviating
            the need for things like dependency injection. 

  
@end smallindentedblock
Most toplevel declarations contain nested declarations. 

  Nested declarations are often mixed together with executable statements. 

  
@node packages
@subsection Packages
@cindex Packages

  Each compilation unit belongs to exactly one @emph{package}.
            Every toplevel declaration of the compilation unit also belongs directly to this 
            package. The package is identified by the location of the text file on the file 
            system, relative to a root @emph{source directory}, as defined in 
            @ref{sourcelayout, ,Source layout}. 

  A package is a namespace. A full package name is a period-separated list of 
            all-lowercase identifiers. 

  
@verbatim
FullPackageName: PackageName ("." PackageName)*
@end verbatim

@smallindentedblock
  Note: it is recommended that package names contain only characters
            from the ASCII character set. 

  
@end smallindentedblock
There is also a @emph{default package} whose name is empty.
            It is impossible to import declarations from this package. 

  Every package belongs to exactly one module, as specified in 
            @ref{modules, ,Module architecture}. The default package belongs to the default
            module. 

  
@node imports
@section Imports
@cindex Imports

  
      
@menu
      
* typeimports:: Type imports
* anonymousclassimports:: Anonymous class imports
* methodattributeimports:: Function and value imports
* aliasimports:: Alias imports
* wildcardimports:: Wildcard imports
* importedname:: Imported name
@end menu

      Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a declaration defined in a compilation unit in another package 
        only if it explicitly @emph{imports} the declaration using the 
        @code{import} statement. 

  An @code{import} statement specifies the name of a package to
        import from, and a list of declarations to import from that package. 

  
@verbatim
Import: "import" FullPackageName ImportElements
@end verbatim
For a given package, there may be at most one @code{import}
        statement per compilation unit. 

  An @code{import} statement may import from a package if and 
        only if: 

  
  @itemize @bullet
  
  @item the package belongs to the same module as the compilation unit 
                containing the @code{import} statement, as specified by 
                @ref{sourcelayout, ,Source layout}, or 

  
  @item the package is declared @code{shared} in its
                package descriptor, and the module descriptor of the module to which
                the compilation unit containing the @code{import} statement 
                belongs, as specified by @ref{sourcelayout, ,Source layout}, explicitly or 
                implicitly imports the module containing the package, as defined by 
                @ref{moduledescriptors, ,Module descriptors}. 

  
  @end itemize
Each @code{import} statement imports one or more toplevel 
        declarations from the given package, specifying a list of @emph{import
        elements}. 

  
@verbatim
ImportElements: "{" (ImportElement ",")* (ImportElement | ImportWildcard) "}"
@end verbatim

@verbatim
ImportElement: ImportTypeElement | ImportObjectElement | ImportFunctionValueElement
@end verbatim
An import element is a reference to either: 

  
  @itemize @bullet
  
  @item a single toplevel type (a class, interface, or alias) of the 
                package, 

  
  @item a single toplevel function or value of the package, or 

  
  @item all toplevel declarations of the package. 

  
  @end itemize
An import element may either: 

  
  @itemize @bullet
  
  @item import a name into the @emph{toplevel namespace} 
                of the compilation unit in which it occurs, or 

  
  @item result in an alias for a member of a type within the 
                compilation unit in which it occurs. 

  
  @end itemize
Every import element belonging directly to an @code{import} 
        statement imports into the @emph{toplevel namespace} of the 
        compilation unit. 

  An import element may not refer to a declaration that is not visible to
        the compilation unit, as defined by @ref{visibility, ,Visibility}. 

  An @code{import} statement may not contain two import elements
        which refer to the same declaration. 

  Note that toplevel declarations in the package @code{ceylon.language} 
        never need to be explicitly imported. They are implicitly imported by every 
        compilation unit. 

  An imported function or value may not hide, as defined in 
        @ref{hiddendeclarations, ,Hidden declarations}, any of the modifiers declared in 
        @code{ceylon.language} listed in @ref{declarationmodifiers, ,Declaration modifiers},
        unless the modifier itself has an alias import in the compilation unit. 

  
@smallindentedblock
  Note: an unused import results in a compiler warning. 

  
@end smallindentedblock

@node typeimports
@subsection Type imports
@cindex Type imports

  An import element that specifies a type name imports the toplevel type 
            with that name from the imported package or type. 

  
@verbatim
ImportTypeElement: TypeAlias? TypeName ImportElements?
@end verbatim
The specified name must be the name of a type declaration belonging to 
            the imported package or type. 

  
@example
import ceylon.collection @{ MutableSet, MutableList, MutableMap @}
@end example
The import element may be followed by a list of nested import elements: 

  
  @itemize @bullet
  
  @item if the import element imports into the toplevel namespace of 
                    the compilation unit, and if a nested import element is a reference 
                    to a constructor, the nested import element imports into the toplevel 
                    namespace of the compilation unit, and need not specify an alias, or,
                    otherwise 

  
  @item the nested import element only defines an alias for the 
                    referenced member of the imported type, and this alias must be 
                    specified explicitly. 

  
  @end itemize

@smallindentedblock
  Note: an import element referring to a @code{static}
            member of a Java class imports the static member into the toplevel namespace of
            the compilation unit. However, this behavior is outside the scope of this 
            specification. 

  
@end smallindentedblock

@node anonymousclassimports
@subsection Anonymous class imports
@cindex Anonymous class imports

  An import element that specifies the name of an anonymous class, as 
            defined in @ref{anonymousclasses, ,Anonymous classes}, imports the anonymous class 
            with that name from the imported package or type. 

  
@verbatim
ImportObjectElement: FunctionValueAlias? MemberName ImportElements?
@end verbatim
The specified name must be the name of an anonymous class declaration 
            belonging to the imported package or type. 

  
@example
import ceylon.file @{ home, current @}
@end example
The import element may be followed by a list of nested import elements: 

  
  @itemize @bullet
  
  @item if the import element imports into the toplevel namespace of 
                    the compilation unit, a nested import element imports into the 
                    toplevel namespace of the compilation unit, and need not specify 
                    an alias, or, otherwise 

  
  @item the nested import element only defines an alias for the 
                    referenced member of the imported type, and this alias must be 
                    specified explicitly. 

  
  @end itemize

@node methodattributeimports
@subsection Function and value imports
@cindex Function and value imports

  An import element that specifies a function or value name imports the 
            toplevel function or value with that name from the imported package or type. 

  
@verbatim
ImportFunctionValueElement: FunctionValueAlias? MemberName
@end verbatim
The specified name must be the name of a function or value declaration
            belonging to the imported package or type. 

  
@example
import ceylon.math.float @{ sqrt, e, pi @}
@end example

@node aliasimports
@subsection Alias imports
@cindex Alias imports

  The optional alias clause in a fully-explicit import allows resolution 
            of cross-namespace declaration name collisions. 

  
@verbatim
TypeAlias: TypeName "="
@end verbatim

@verbatim
FunctionValueAlias: MemberName "="
@end verbatim
An alias assigns a different name to the imported declaration, or to a
            member of the imported declaration. This name is visible within the compilation
            unit in which the @code{import} statement occurs. 

  
@example
import java.util @{ JavaMap = Map @}
@end example

@example
import my.math @{ fib = fibonnacciNumber @}
@end example

@example
import java.lang @{ 
    Math @{ sin, cos, ln=log @}, 
    System @{ sysprops=properties @},
    Char=Character @{ upper=toUpperCase, lower=toLowerCase, char=charValue @} 
@}
@end example

@node wildcardimports
@subsection Wildcard imports
@cindex Wildcard imports

  The elipsis @code{...} acts as a wildcard in 
            @code{import} statements. An @code{import} statement 
            that specifies a wildcard imports every toplevel declaration of the imported 
            package, except for any declaration whose name collides with the name of a 
            toplevel declaration in the compilation unit in which the @code{import} 
            statement appears. 

  
@verbatim
ImportWildcard: "..."
@end verbatim
An @code{import} statement may specify a list of alias imports 
            followed by a wildcard. In this case, the alias imports are imported with the 
            specified names, and all other toplevel declarations are imported with their 
            declared names. 

  
@example
import ceylon.collection @{ ... @}
@end example

@example
import my.math @{ fib = fibonnacciNumber, ... @}
@end example

@smallindentedblock
  Note: overuse of wildcard imports is discouraged. 

  
@end smallindentedblock

@node importedname
@subsection Imported name
@cindex Imported name

  Inside a compilation unit which imports a declaration, the declaration
            may be referred to, as specified in @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution} 
            and @ref{qualifiedreferenceresolution, ,Qualified reference resolution}, by its @emph{imported 
            name}: 

  
  @itemize @bullet
  
  @item For an import element with an alias, the imported name is the 
                    alias. 

  
  @item For an import element with no alias, or for a wildcard import, 
                    the imported name is the original name of the declaration. 

  
  @end itemize
An import element may not result in an imported name that is the same
            as the name of a toplevel declaration contained in the compilation unit in
            which the import element occurs. 

  Two import elements occurring in the same compilation unit, which import 
            into the toplevel namespace of the compilation unit, may not result in the same 
            imported name. 

  Two nested import elements belonging to the same import element may not 
            result in the same imported name. 

  @emph{Note: if an imported declaration is already referenceable within 
            a compilation unit without the import statement, for example, 
            if it is defined in the same package, or in ceylon.language, 
            then, even with the import statement, it is still referenceable 
            via its declared name, as well as via the imported name.}
@node parameters
@section Parameters
@cindex Parameters

  
      
@menu
      
* parameterlists:: Parameter lists
* requiredparameters:: Required parameters
* defaultedparameters:: Defaulted parameters
* valueparameters:: Value parameters
* callableparameters:: Callable parameters
* sequencedparameters:: Variadic parameters
@end menu

      A function, class, or callable constructor declaration may declare 
        @emph{parameters}. A parameter is a value or function belonging to the 
        declaration it parameterizes. Parameters are distinguished from other values or 
        functions because they occur in a @emph{parameter list}. A value or 
        function is a parameter of a function, class, or constructor if it is: 

  
  @itemize @bullet
  
  @item declared inline in a parameter list of the function, class, or 
                callable constructor, or 

  
  @item declared normally, within the body of the class, function, or 
                callable constructor, but named in a parameter list of the class, function, 
                or callable constructor. 

  
  @end itemize
A parameter list of a function, class, or constructor may have one or more 
        elements without explicit type declarations. Each such element is interpreted as the 
        name of a parameter declaration occurring in the body of the class, function, or 
        constructor, and there must be a value or function declaration with that name.
        For a function, such an element is only allowed in the last parameter list of the
        function. 

  As a special exception, if a parameter of an anonymous function has no explicit 
        type declaration, and there is no declaration with the given name occurring in the body 
        of the anonymous function, then the type of the parameter must be inferable, according 
        to @ref{parametertypeinference, ,Anonymous function parameter type inference}. 

  Conversely, every parameter declaration that occurs outside a parameter list must 
        have the same name as a parameter with no explicit type that occurs in the parameter 
        list of the function, class, or constructor in whose body the parameter declaration 
        directly occurs, and its default argument, if any, must be specified in the parameter 
        list. 

  A parameter declaration may only occur in a parameter list, or directly, as
        defined by @ref{blockstructure, ,Block structure and references}, in the body of a class, function, or
        callable constructor. A parameter declaration may not occur directly in the body of a 
        getter, setter, or value constructor, nor in the body of a control structure. Nor may a 
        parameter declaration appear as a toplevel declaration in a compilation unit. 

  
@verbatim
ParameterDeclaration: (ValueParameter | CallableParameter | VariadicParameter) ";"
@end verbatim
The following class definitions are semantically identical: 

  
@example
class Person(shared String name, shared variable Integer age=0, Address* addresses) @{@}
@end example

@example
class Person(name, age=0, addresses) @{
    shared String name;
    shared variable Integer age;
    Address* addresses;
@}
@end example

@node parameterlists
@subsection Parameter lists
@cindex Parameter lists

  A parameter list is a list of parameter declarations and of names of parameters
            declared in the body of the class or function to which the parameter list belongs. A 
            parameter list may include, optionally: 

  
  @itemize @bullet
  
  @item one or more @emph{required parameters}, 

  
  @item one or more @emph{defaulted parameters} (parameters with 
                    default values), and/or 

  
  @item a @emph{variadic parameter}. 

  
  @end itemize
In a parameter list, defaulted parameters, if any, must occur after required 
            parameters, if any. The variadic parameter, if any, must occur last. 

  
@verbatim
Parameters: "(" ( (Required ",")* ( Required | (Defaulted ",")* (Defaulted | Variadic) ) )? ")"
@end verbatim
Every parameter list has a type, which captures the types of the individual 
            parameters in the list, whether they are defaulted, and whether the last parameter 
            is variadic. This type is always an subtype of @code{Anything[]}. The 
            type of an empty parameter list with no parameters is @code{[]}. 

  A parameter may not be annotated @code{formal}, but it may be
            annotated @code{default}. 

  
@node requiredparameters
@subsection Required parameters
@cindex Required parameters

  A required parameter is a value or callable parameter without a default 
            argument. 

  A required parameter in a parameter list may be a parameter declaration, 
            or the name of a non-variadic parameter declared in the body of the function or 
            class. 

  
@verbatim
Required: ValueParameter | CallableParameter | MemberName
@end verbatim
Required parameters must occur before any other parameters in the parameter 
            list. 

  
@node defaultedparameters
@subsection Defaulted parameters
@cindex Defaulted parameters

  A defaulted parameter is a value or callable parameter that specifies an 
            expression that produces a @emph{default argument}. A defaulted 
            parameter may be either: 

  
  @itemize @bullet
  
  @item a non-variadic parameter declaration, together with a default 
                    argument expression, or 

  
  @item the name of a non-variadic parameter declared in the body of the 
                    function or class, together with its default argument expression. 

  
  @end itemize

@verbatim
Defaulted: ValueParameter Specifier | CallableParameter LazySpecifier | MemberName Specifier
@end verbatim
The @code{=} and @code{=>} specifiers are used 
            throughout the language. In a parameter list they are used to specify a default
            argument. 

  
@verbatim
Specifier: "=" Expression
@end verbatim

@verbatim
LazySpecifier: "=>" Expression
@end verbatim
The default argument expression may involve other parameters declared 
            earlier in the parameter list or lists. It may not involve parameters declared 
            later in the parameter list or lists. 

  The default argument expression may not involve an assignment, compound
            assignment, increment, or decrement operator. 

  Defaulted parameters must occur after required parameters in the parameter 
            list. 

  
@example
(Product product, Integer quantity=1, Price pricing(Product p) => p.price)
@end example
A parameter of a method or class annotated @code{actual} may 
            not specify a default argument. Instead, it inherits the default argument, if 
            any, of the corresponding parameter of the method it refines. 

  If two parameter lists are almost identical, differing only in that the 
            first parameter of one list is defaulted, and the first parameter of the second 
            list is required, and @code{P} is the the type of the second 
            parameter list, then the type of the first parameter list is 
            @code{[]|P}. 

  
@smallindentedblock
  Note: in Ceylon 1.0, for a function with multiple parameter lists, 
            defaulted parameters may only occur in the first parameter list. This restriction
            will be removed. 

  
@end smallindentedblock

@smallindentedblock
  TODO: Should we, purely for consistency, let you write 
            @code{f(Float x) => x} in a parameter list, when the callable 
            parameter is declared in the body of the function or class? 

  
@end smallindentedblock

@node valueparameters
@subsection Value parameters
@cindex Value parameters

  A @emph{value parameter} is a reference, as specified in
            @ref{references, ,References}, that is named or defined in a parameter list. 
            Like any other value declaration, it has a name, type, and, optionally, 
            annotations. 

  
@verbatim
ValueParameter: Annotations ValueParameterPrefix MemberName
@end verbatim

@verbatim
ValueParameterPrefix: Type | "dynamic"
@end verbatim
A value parameter may be declared using the keyword @code{dynamic} 
            in place of the parameter type, indicating that it is a partially typed declaration.
            Such a parameter has no type. 

  If a value parameter @code{x} has type @code{X}, 
            and a parameter list has type @code{P} with the principal instantiation 
            @code{Sequential<Y>}, then the type of a new parameter list 
            formed by prepending @code{x} to the first parameter list is: 

  
  @itemize @bullet
  
  @item @code{Tuple<X|Y,X,P>}, or  

  
  @item @code{[]|Tuple<X|Y,X,P>} if @code{x} is 
                defaulted. 

  
  @end itemize
The default argument expression, if any, for a callable parameter is 
            specified using an ordinary @code{=} specifier. The type of the 
            default argument expression must be assignable to the declared type of the 
            value parameter. 

  
@example
(String label, Anything() onClick)
@end example

@example
(@{Value*@} values, Comparison(Value,Value) by)
@end example

@node callableparameters
@subsection Callable parameters
@cindex Callable parameters

  A @emph{callable parameter} is a function, as specified 
            in @ref{functions, ,Functions}, named or defined in a parameter list. Like 
            any other function declaration, it has a name, type, one or more parameter 
            lists, and, optionally, annotations. 

  
@verbatim
CallableParameter: Annotations CallableParameterPrefix MemberName Parameters+
@end verbatim

@verbatim
CallableParameterPrefix: Type | "void" | "dynamic"
@end verbatim
A callable parameter may be declared using the keyword @code{dynamic} 
            in place of the return type, indicating that it is a partially typed declaration.
            Such a parameter has no return type. 

  If a callable parameter @code{f} has callable type 
            @code{X(*A)}, as specified below in 
            @ref{callabletypeoffunction, ,Callable type of a function}, and a parameter list has type 
            @code{P} with the principal instantiation 
            @code{Sequential<Y>}, then the type of a new parameter list 
            formed by prepending @code{f} to the first parameter list is: 

  
  @itemize @bullet
  
  @item @code{Tuple<Y|X(*A),X(*A),P>}, 
                or 

  
  @item @code{[]|Tuple<Y|X(*A),X(*A),P>} 
                if @code{f} is defaulted. 

  
  @end itemize
The default argument expression, if any, for a callable parameter is 
            specified using a lazy @code{=>} specifier. The type of the 
            default argument expression must be assignable to the return type of the 
            callable parameter. 

  
@example
(String label, void onClick())
@end example

@example
(@{Value*@} values, Comparison by(Value x, Value y))
@end example

@node sequencedparameters
@subsection Variadic parameters
@cindex Variadic parameters

  A @emph{variadic parameter} is a value parameter that accepts 
            multiple arguments: 

  
  @itemize @bullet
  
  @item A variadic parameter declared @code{T*} accepts zero or
                    more arguments of type @code{T}, and has type @code{[T*]}. 

  
  @item A variadic parameter declared @code{T+} accepts one or
                    more arguments of type @code{T}, and has type @code{[T+]}. 

  
  @end itemize

@verbatim
VariadicParameter: Annotations VariadicParameterPrefix MemberName
@end verbatim

@verbatim
VariadicParameterPrefix: UnionType ("*" | "+")
@end verbatim
A variadic parameter in a parameter list may be a variadic parameter 
            declaration, or the name of a variadic parameter declared in the body of
            the function or class. 

  
@verbatim
Variadic: VariadicParameter | MemberName
@end verbatim
The variadic parameter must be the last parameter in a parameter list. A
            variadic parameter may not have a default argument. A variadic parameter declared
            @code{T+} may not occur in a parameter list with defaulted parameters. 

  
@example
(Name name, Organization? org=null, Address* addresses)
@end example

@example
(Float+ floats)
@end example
The type of a parameter list containing just a variadic parameter of type
            @code{T*} is @code{[T*]} The type of a parameter list 
            containing just a variadic parameter of type @code{T+} is 
            @code{[T+]}. 

  
@smallindentedblock
  Note: in Ceylon 1.0, for a function with multiple parameter lists, 
            a variadic parameters may only occur in the first parameter list. This restriction
            will be removed. 

  
@end smallindentedblock

@node interfaces
@section Interfaces
@cindex Interfaces

  
      
@menu
      
* interfacebodies:: Interface bodies
* interfaceinheritance:: Interface inheritance
* sealedinterfaces:: Sealed interfaces
* interfaceswithcases:: Enumerated interfaces
* interfacealiases:: Interface aliases
* dynamicinterfaces:: Dynamic interfaces
@end menu

      An @emph{interface} is a type schema, together with 
        implementation details for some members of the type. Interfaces may not 
        be directly instantiated. 

  
@verbatim
InterfaceDeclaration: Annotations InterfaceHeader (InterfaceBody | TypeSpecifier ";")
@end verbatim
An interface declaration may optionally specify a list of type 
        parameters. An interface declaration may also have a list of interfaces 
        is satisfies, a self type or an enumerated list of cases, and/or a list 
        of type constraints. 

  
@verbatim
InterfaceHeader: ("interface"|"dynamic") TypeName TypeParameters? InterfaceInheritance TypeConstraints?
@end verbatim

@verbatim
InterfaceInheritance: CaseTypes? SatisfiedTypes?
@end verbatim
To obtain a concrete instance of an interface, it is necessary to 
        define and instantiate a class that satisfies the interface, or define 
        an anonymous class that satisfies the interface. 

  The body of an interface contains: 

  
  @itemize @bullet
  
  @item member (method, attribute, and member class) declarations,
                 

  
  @item specification statements interpretable as attribute or method
                refinement, as defined in @ref{attributerefinement, ,Attribute refinement} and
                @ref{methodrefinement, ,Method refinement}, and 

  
  @item nested interface, type alias, and @code{abstract} 
                class declarations. 

  
  @end itemize

@verbatim
InterfaceBody: "{" (Declaration | Specification)* "}"
@end verbatim
Unlike the body of a class, method, or attribute, the body of an 
        interface is not executable, and does not directly contain procedural 
        code. 

  
@example
shared interface Comparable<Other> @{
    shared formal Comparison compare(Other other);
    shared Boolean largerThan(Other other) => compare(other)==larger;
    shared Boolean smallerThan(Other other) => compare(other)==smaller;
@}
@end example
An interface may declare @code{formal} methods, attributes,
        and member classes, and concrete methods, getters, setters, and member classes.
        A reference declaration, as defined in @ref{references, ,References}, or 
        anonymous class declaration, as defined in @ref{anonymousclasses, ,Anonymous classes},
        may not directly occur in the body of an interface. 

  A non-@code{abstract } nested class declaration is called a
        @emph{member class} of the interface. A nested interface or 
        @code{abstract} class declaration is not part of the schema of the 
        interface type, and is therefore not considered a member of the interface. 

  
@node interfacebodies
@subsection Interface bodies
@cindex Interface bodies

  The body of an interface consists purely of declarations. The following 
            constructs may not occur sequentially in the body of an interface: 

  
  @itemize @bullet
  
  @item a statement or control structure (except for specification
                    statements interpretable as attribute or method refinement), 

  
  @item a reference declaration, 

  
  @item a forward-declared method or attribute declaration, or 

  
  @item an @code{object} declaration. 

  
  @end itemize
Within an interface body, a @emph{super reference} 
            is any occurrence of the expression @code{super}, unless it also
            occurs in the body of a nested class or interface declaration. A statement or 
            declaration contained in the interface body may not: 

  
  @itemize @bullet
  
  @item pass a super reference as an argument of an instantiation, 
                  function invocation, or @code{extends} clause expression 
                  or as the value of a value assignment or specification, 

  
  @item use a super reference as an operand of any operator except the
                  member selection operator, or the @code{of} operator as 
                  specified in @ref{super, ,super}, 

  
  @item return a super reference, or 

  
  @item narrow the type of a super reference using an assignability 
                  condition, as defined in @ref{assignabilityconditions, ,Assignability conditions}. 

  
  @end itemize

@node interfaceinheritance
@subsection Interface inheritance
@cindex Interface inheritance

  An interface may satisfy any number of other interfaces, as defined in @ref{satisfiedinterfaces, ,Satisfaction}. 

  
@example
shared interface List<Element>
        satisfies Collection<Element> & Correspondence<Integer,Element>
        given Element satisfies Object @{
    ...
@}
@end example
Every type listed in the @code{satisfies} clause must 
            be an interface. An interface may not satisfy the same interface twice 
            (not even with distinct type arguments). 

  
@smallindentedblock
  Note: this second restriction is not strictly necessary.
            In fact, @code{satisfies List<One>&List<Two>}
            means the same thing as @code{satisfies List<One&Two>},
            and the compiler already needs to be able to figure that out when it 
            comes to multiple instantiations of the same interface inherited 
            indirectly. Still, the restriction seems harmless enough. 

  
@end smallindentedblock
The interface is a subtype of every type listed in the 
            @code{satisfies} clause. The interface is also a subtype of 
            the type @code{Object} defined in 
            @code{ceylon.language}. 

  An interface inherits all members (methods, attributes and member 
            types) of every supertype. That is, every member of every supertype of the 
            interface is also a member of the interface.  Furthermore, 
            the interface inherits all nested types (interfaces and 
            @code{abstract} classes) of every supertype. 

  The schema of the inherited members is formed by substituting type 
            arguments specified in the @code{satisfies} clause. 

  An interface that satisfies a nested interface must be a member of 
            the type that declares the nested interface or of a subtype of the type 
            that declares the nested interface. 

  A user-defined interface may not satisfy the interface 
            @code{Callable} defined in @code{ceylon.language}
            nor directly satisfy the interface @code{ConstrainedAnnotation}
            defined in @code{ceylon.language}. 

  
@node sealedinterfaces
@subsection Sealed interfaces
@cindex Sealed interfaces

  A toplevel or nested interface may be annotated @code{sealed}
            and is called a @code{sealed} interface. 

  An interface annotated @code{sealed} may not be satisfied 
            by a class or interface outside the module in which it is defined. 

  
@node interfaceswithcases
@subsection Enumerated interfaces
@cindex Enumerated interfaces

  An interface declaration may enumerate a list of cases of the interface, 
            as defined in @ref{cases, ,Cases}. 

  
@example
shared interface Node<Element> 
            of Root<Element> | Branch<Element> | Leaf<Element> @{ ... @}
@end example
The cases may be interfaces, classes, or toplevel anonymous classes. A 
            case may be an @code{abstract} class. Each case must be a direct 
            subtype of the interface type. An interface may not be a case of itself. An 
            interface declaration may not list the same case twice. 

  If an interface has an @code{of} clause, then every interface 
            or class which directly inherits the interface must occur as exactly one of the 
            enumerated cases of the interface. Furthermore, any interface or class which
            indirectly inherits the interface must inherit exactly one of the enumerated 
            cases of the interface. 

  
@node interfacealiases
@subsection Interface aliases
@cindex Interface aliases

  An @emph{interface alias} is an interface declaration which 
            specifies another type. 

  
@verbatim
TypeSpecifier: "=>" Type
@end verbatim
The specified type must be an @emph{interface type}, that 
            is, a reference to an interface with no type parameters or an instantiation of 
            a generic interface, and is called the @emph{aliased type}. 

  An interface alias simply assigns an alternative name to the aliased type. 
            A reference to the alias may occur anywhere a reference to an interface may occur. 

  
@example
shared interface PeopleByName => Map<String,Person>;
@end example

@example
interface Compare<Value> => Comparison(Value,Value);
@end example
If the aliased interface is a parameterized type, the aliased type must
            explicitly specify type arguments. 

  A class or interface may satisfy an interface alias, in which case, the
            class or interface inherits the aliased interface type. 

  Interface aliases are not reified types. The metamodel reference for an 
            interface alias type---for example, @code{PeopleByName}---returns 
            the metamodel object for the aliased interface---in this case, 
            @code{Map<String,Person>}, as specified in 
            @ref{reification, ,Type argument reification}. 

  
@node dynamicinterfaces
@subsection Dynamic interfaces
@cindex Dynamic interfaces

  A @emph{dynamic interface} is an interface declared with the 
            keyword @code{dynamic}. Dynamic interfaces may be used to model the 
            type of objects defined in dynamically typed native code. 

  Every declaration nested inside a dynamic interface must be declared 
            @code{formal}. A dynamic interface may not satisfy any interface 
            that is not also a dynamic interface. 

  Within a dynamic block, defined in @ref{dynamicblocks, ,Dynamic blocks}, 
            assignment of a value with no Ceylon type to a dynamic interface type does not 
            result in an @code{AssertionError}, as defined in 
            @ref{dynamictypechecking, ,Dynamic type checking}. Instead, the value is coerced to the
            dynamic interface type. 

  
@node classes
@section Classes
@cindex Classes

  
      
@menu
      
* callabletypeofclass:: Callable type of a class
* initializersection:: Initializer section
* declarationsection:: Declaration section
* classinheritance:: Class inheritance
* abstractandformalclasses:: Abstract, final, sealed, formal, and default classes
* classrefinement:: Member class refinement
* anonymousclasses:: Anonymous classes
* classeswithcases:: Enumerated classes
* classaliases:: Class aliases
@end menu

      A @emph{class} is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type. 

  
@verbatim
ClassDeclaration: Annotations ClassHeader (ClassBody | ClassSpecifier ";")
@end verbatim
An ordinary class declaration may specify, optionally, a list of parameters 
        required to instantiate the type, and, also optionally, a list of type parameters.
        A class declaration may have a superclass, a list of interfaces it satisfies, a 
        self type or an enumerated list of cases, and/or a list of type constraints. 

  
@verbatim
ClassHeader: "class" TypeName TypeParameters? Parameters? ClassInheritance TypeConstraints?
@end verbatim

@verbatim
ClassInheritance: CaseTypes? ExtendedType? SatisfiedTypes?
@end verbatim
To obtain an instance of a class, it is necessary to instantiate the
        class, or a subclass of the class. 

  The body of a class contains: 

  
  @itemize @bullet
  
  @item member (method, attribute, and member class) declarations, 

  
  @item nested interface, type alias, and @code{abstract} 
                class declarations, and 

  
  @item instance initialization code and, if the class does not have
                a parameter list, constructors. 

  
  @end itemize

@verbatim
ClassBody: "{" (Declaration | Statement | ConstructorDeclaration)* "}"
@end verbatim
The body of a class may contain executable code. 

  
@example
shared class Counter(Integer initialCount=0) @{
    
    variable Integer n = initialCount;
    
    print("Initial count: ``n``");
    
    shared Integer count => n;
    
    shared void increment() @{
        n++;
        print("Count: ``n``");
    @}
    
@}
@end example
A non-@code{abstract } nested class declaration is called a
        @emph{member class} of the class. A nested interface or 
        @code{abstract} class declaration is not part of the schema of the 
        class type, and is therefore not considered a member of the class. 

  A class is not required to have a separate nested constructor declaration.
        Instead, the body of the class may itself declare its
        @emph{initializer parameters}. An initializer parameter may be 
        used anywhere in the class body, including in method and attribute definitions. 

  
@example
shared class Key(Lock lock) @{
    shared void lock() @{
        lock.engage(this);
        print("Locked.");
    @}
    shared void unlock() @{
        lock.disengage(this);
        print("Unlocked.");
    @}
    shared Boolean locked => lock.engaged;
@}
@end example
An initializer parameter may be @code{shared}. 

  
@example
shared class Point(shared Float x, shared Float y) @{ ... @}
@end example

@example
shared class Counter(count=0) @{
    shared variable Integer count;
    shared void increment() => count++;
@}
@end example
If a class does not specify an initializer parameter list, it must have
        at least one shared constructor, as defined below in @ref{constructors, ,Constructors}. 

  
@node callabletypeofclass
@subsection Callable type of a class
@cindex Callable type of a class

  The @emph{callable type} of a class with an initializer
            parameter list captures the type and initializer parameter types of the class. 
            The callable type is @code{T(*P)}, where @code{T} is 
            the applied type formed by the class with its own type parameters as type 
            arguments, and @code{P} is the type of the initializer parameter 
            list of the class. 

  The callable type of a class with a default constructor is the callable
            type of the default constructor. 

  A class with no initializer parameter list and no default constructor
            does not have a callable type. 

  An @code{abstract} class is not callable, except from the 
            @code{extends} clause of a subclass, or the class specifier of a
            class alias. 

  
@node initializersection
@subsection Initializer section
@cindex Initializer section

  The initial part of the body of a class is called the 
            @emph{initializer} of the class and contains a mix of declarations, 
            statements, and control structures. The initializer is executed every time the 
            class is instantiated. If the class does not have an initializer parameter list, 
            the initializer section may include one or more constructor declarations, as 
            defined in @ref{constructors, ,Constructors}. 

  A class initializer is responsible for initializing the state of the new 
            instance of the class, before a reference to the new instance is available to 
            clients. 

  
@example
shared abstract class Point() @{
    shared formal Float x;
    shared formal Float y;
@}
@end example

@example
shared class DiagonalPoint(Float distance) 
        extends Point() @{
    
    value d = distance / 2^0.5;
    x => d;
    y => d;
    
    "must have correct distance from origin" 
    assert (x^2 + y^2 == distance^2);
    
@}
@end example

@example
shared object origin 
        extends Point() @{
    x => 0.0;
    y => 0.0;
@}
@end example
Within a class initializer, a @emph{self reference to the instance 
            being initialized} is: 

  
  @itemize @bullet
  
  @item any occurrence of the expression @code{this}, as 
                    defined in @ref{this, ,this}, or @code{super}, as 
                    defined in @ref{super, ,super}, unless it also occurs in the 
                    body of a nested class or interface declaration, 

  
  @item any occurrence of the expression @code{outer}, as 
                    defined in @ref{outer, ,outer}, in the body of a class or 
                    interface declaration immediately contained by the class, 

  
  @item any reference to an anononymous class that inherits the class,
                    or, if the class is an anonymous class, to the anonymous class itself,
                    or 

  
  @item any reference to a value constructor of the class or of a class 
                    which inherits the class. 

  
  @end itemize
A statement or declaration contained in the initializer of a class may 
            not evaluate an attribute, invoke a method, or instantiate a member class upon 
            the instance being initialized, including upon a self reference to the instance 
            being initialized, if the attribute, method, or member class: 

  
  @itemize @bullet
  
  @item occurs later in the body of the class, 

  
  @item is annotated @code{formal} or @code{default},
                  or 

  
  @item is inherited from an interface or superclass, and is not refined 
                  by a declaration occurring earlier in the body of the class. 

  
  @end itemize
A member class contained in the initializer of a class may not 
            @code{extend} a member or nested class of an interface or 
            superclass of the class. 

  Furthermore, a statement or declaration contained in the initializer 
            of a class may not: 

  
  @itemize @bullet
  
  @item pass a self reference to the instance being initialized as an 
                  argument of an instantiation, function invocation, or @code{extends} 
                  clause expression or as the value of a value assignment or specification, 

  
  @item use a self reference to the instance being initialized as an 
                  operand of any operator except the member selection operator, or
                  the @code{of} operator, 

  
  @item return a self reference to the instance being initialized, or 

  
  @item narrow the type of a self reference to the instance being 
                  initialized using an assignability condition, as defined in 
                  @ref{assignabilityconditions, ,Assignability conditions}. 

  
  @end itemize
Nor may the class pass a self reference to the instance being 
            initialized as an argument of its own @code{extends} clause 
            expression, if any. 

  As a special exception to these rules, a statement contained in an 
            initializer may assign a self-reference to the instance being initialized
            to a reference annotated @code{late}. 

  For example, the following code fragments are not legal: 

  
@example
class Graph() @{
    OpenList<Node> nodes = ArrayList<Node>();
    class Node() @{
        nodes.add(this);    //error: self reference in initializer
    @}
@}
@end example

@example
class Graph() @{
    class Node() @{@}
    Node createNode() @{
        Node node = Node();
        nodes.add(node);    //error: forward reference in initializer
        return node;
    @}
    OpenList<Node> nodes = ArrayList<Node>();
@}
@end example
But this code fragment is legal: 

  
@example
class Graph() @{
    OpenList<Node> nodes = ArrayList<Node>();
    Node createNode() @{
        Node node = Node();
        nodes.add(node);
        return node;
    @}
    class Node() @{@}
@}
@end example

@node declarationsection
@subsection Declaration section
@cindex Declaration section

  The remainder of the body of the class consists purely of declarations, 
            similar to the body of an interface. The following constructs may not occur 
            sequentially in the declaration section: 

  
  @itemize @bullet
  
  @item a statement or control structure, defined in 
                    @ref{controlstructures, ,Control structures and assertions}, 

  
  @item a reference declaration, as defined below in
                    @ref{references, ,References}, 

  
  @item a constructor declaration, as defined below in 
                    @ref{constructors, ,Constructors}, 

  
  @item a forward-declared function or value declaration not
                    annotated @code{late}, as defined below in 
                    @ref{functionforwarddeclaration, ,Forward declaration of functions} and 
                    @ref{valueforwarddeclaration, ,Forward declaration of values}, 

  
  @item an @code{object} declaration with a non-empty 
                    initializer section, or 

  
  @item an @code{object} declaration that directly extends 
                    a class other than @code{Object} or @code{Basic} 
                    in @code{ceylon.language}. 

  
  @end itemize
However, the declarations in this second section may freely use 
            @code{this} and @code{super}, and may invoke any method,
            evaluate any attribute, or instantiate any member class of the class or its 
            superclasses. 

  Within the declaration section of a class body, a @emph{super 
            reference} is any occurrence of the expression @code{super}, 
            unless it also occurs in the body of a nested class or interface declaration. A 
            statement or declaration contained in the declaration section of a class body may 
            not: 

  
  @itemize @bullet
  
  @item pass a super reference as an argument of an instantiation, 
                  function invocation, or @code{extends} clause expression 
                  or as the value of a value assignment or specification, 

  
  @item use a super reference as an operand of any operator except the
                  member selection operator, or the @code{of} operator as 
                  specified in @ref{super, ,super}, 

  
  @item return a super reference, or 

  
  @item narrow the type of a super reference using an assignability 
                  condition, as defined in @ref{assignabilityconditions, ,Assignability conditions}. 

  
  @end itemize

@node classinheritance
@subsection Class inheritance
@cindex Class inheritance

  A class may extend another class, as defined in 
            @ref{extendedclass, ,Extension}. 

  
@example
shared class Customer(Name name, Organization? org = null) 
        extends Person(name, org) @{ 
    ... 
@}
@end example
The class is a subtype of the type specified by the @code{extends} 
            clause. If a class does not explicitly specify a superclass using @code{extends},
            its superclass is the class @code{Basic} defined in 
            @code{ceylon.language}.
             

  A class may satisfy any number of interfaces, as defined in 
            @ref{satisfiedinterfaces, ,Satisfaction}. 

  
@example
class Token() 
        extends Datetime()
        satisfies Comparable<Token> & Identifier @{
    ... 
@}
@end example
The class is a subtype of every type listed in the @code{satisfies} 
            clause. A class may not satisfy the same interface twice (not even with distinct 
            type arguments). 

  A class inherits all members (methods, attributes, and member types) of every 
            supertype. That is, every member of every supertype of the class is also a member 
            of the class.  Furthermore, the class inherits all nested types (interfaces and 
            @code{abstract} classes) of every supertype. 

  Unless the class is declared @code{abstract} or 
            @code{formal}, the class: 

  
  @itemize @bullet
  
  @item must declare or inherit a member that refines each 
                    @code{formal} member of every interface it satisfies directly 
                    or indirectly, and 

  
  @item must declare or inherit a member that refines each 
                    @code{formal} member of its superclass. 

  
  @end itemize
The schema of the inherited members is formed by substituting type arguments
            specified in the @code{extends} or @code{satisfies} clause. 

  A subclass with an initializer parameter list must pass arguments to 
            each superclass initialization parameter or callable constructor parameter 
            in the @code{extends} clause. A subclass with no initializer 
            parameter list may not pass arguments in the @code{extends} 
            clause. 

  
@example
shared class SpecialKey1()
        extends Key( SpecialLock() ) @{
    ...
@}
@end example

@example
shared class SpecialKey2(Lock lock) 
        extends Key(lock) @{
    ...
@}
@end example
A subclass of a nested class must be a member of the type that declares 
             the nested class or of a subtype of the type that declares the nested class. 
             A class that satisfies a nested interface must be a member of the type that 
             declares the nested interface or of a subtype of the type that declares the 
             nested interface. 

  A user-defined class may not satisfy the interface 
             @code{Callable} defined in @code{ceylon.language} nor 
             directly satisfy the interface @code{ConstrainedAnnotation} 
             defined in @code{ceylon.language}. 

  
@node abstractandformalclasses
@subsection Abstract, final, sealed, formal, and default classes
@cindex Abstract, final, sealed, formal, and default classes

  A toplevel or nested class may be annotated @code{abstract}
            and is called an @code{abstract} class. 

  A toplevel or nested class may be annotated @code{final}
            and is called a @code{final} class. 

  A toplevel or nested class may be annotated @code{sealed}
            and is called a @code{sealed} class. 

  If a class annotated @code{shared} is a member of a containing 
            class or interface, then the class may be annotated @code{formal}
            and is called a @code{formal} member class, or, sometimes, an 
            @emph{abstract member class}. 

  An @code{abstract} class or @code{formal} member
            class may have @code{formal} members. 

  An @code{abstract} class may not be instantiated. 

  A @code{formal} member class may be instantiated. 

  A class which is not annotated @code{formal} or 
            @code{abstract} is called a @emph{concrete} class. 

  A concrete class may not have @code{formal} members. 

  A class annotated @code{final} must be a concrete class. 

  A class annotated @code{final} may not have 
            @code{default} members. 

  If a concrete class annotated @code{shared} is a member 
            of a containing class or interface, then the class may be annotated 
            @code{default} and is called a @code{default} 
            member class. 

  A toplevel class may not be annotated @code{formal} or 
            @code{default}. 

  An un-@code{shared} class may not be annotated 
            @code{formal} or @code{default}. 

  A class annotated @code{sealed} may not be instantiated 
            or extended outside the module in which it is defined. 

  A class with no parameter list may not be annotated 
            @code{sealed}. 

  A member class annotated @code{sealed formal} must 
            belong to a @code{sealed} class or interface. 

  
@smallindentedblock
  Note: a @code{formal} member class would be a
            reasonable syntax for declaring virtual types. We think we don't need 
            virtual types because they don't offer much that type parameters don't
            already provide. For example: 

  
            
@example
shared formal class Buffer(Character...) 
        satisfies Sequence<Character>;
@end example

@end smallindentedblock

@node classrefinement
@subsection Member class refinement
@cindex Member class refinement

  Member class refinement is a unique feature of Ceylon, akin to 
            the "factory method" pattern of many other languages. 

  
  @itemize @bullet
  
  @item A member class annotated @code{formal} or
                    @code{default} may be refined by any class or 
                    interface which is a subtype of the class or interface which 
                    declares the member class. 

  
  @item A member class annotated @code{formal} 
                    @emph{must} be refined by every concrete class 
                    which is a subtype of the class or interface that declares the 
                    member class, unless the class inherits a concrete member class 
                    from a superclass that refines the @code{formal} 
                    member class. 

  
  @end itemize
A member class of a subtype @emph{refines} a member 
            class of a supertype if the member class of the supertype is
            @code{shared} and the two classes have the same name. The 
            first class is called the @emph{refining} class, and the 
            second class is called the @emph{refined} class. 

  Then, given the refined realization of the class it refines, as 
            defined in @ref{realizations, ,Realizations}, and, after substituting the 
            type parameters of the refined class for the type parameters of the 
            refining class in the schema of the refining class, the refining class 
            must: 

  
  @itemize @bullet
  
  @item have the same number of type parameters as the refined 
                    schema, and for each type parameter the intersection of its
                    upper bounds must be a supertype of the intersection of the 
                    upper bounds of the corresponding type parameter of the 
                    realization, 

  
  @item have a parameter list with the same signature as the 
                    realization, and 

  
  @item directly or indirectly extend the class it refines. 

  
  @end itemize
Furthermore: 

  
  @itemize @bullet
  
  @item the refining class must be annotated @code{actual}, 
                    and 

  
  @item the refined class must be annotated @code{formal}
                    or @code{default}. 

  
  @end itemize
If a member class is annotated @code{actual}, it must 
            refine some member class of a supertype. 

  A member class may not, directly or indirectly, refine two different
            member classes not themselves annotated @code{actual}. 

  Then instantiation of the member class is polymorphic, and the actual
            subtype instantiated depends upon the concrete type of the containing class
            instance. 

  
@example
shared abstract class Reader() @{
    shared formal class Buffer(Character* chars) 
            satisfies Character[] @{@}
    ...
@}
@end example

@example
shared class FileReader(File file) 
        extends Reader() @{
    shared actual class Buffer(Character* chars) 
            extends super.Buffer(chars) @{
        ...
    @}
    ...
@}
@end example
All of the above rules apply equally to member classes which are 
            aliases. 

  
@example
shared abstract class Reader() @{
    shared formal class Buffer(Character* chars) => AbstractBuffer(*chars);
    ...
@}
@end example

@example
shared class FileReader(File file) 
        extends Reader() @{
    shared actual class Buffer(Character* chars) => FileBuffer(*chars);
    ...
@}
@end example

@node anonymousclasses
@subsection Anonymous classes
@cindex Anonymous classes

  An @code{object} or @emph{anonymous class}
            declaration is a compact way to define a class with a single value 
            constructor, together with a getter aliasing this value constructor. 

  
@verbatim
ObjectDeclaration: Annotations ObjectHeader ClassBody
@end verbatim
An @code{object} has an initial lowercase identifier.
            An @code{object} declaration does not specify parameters or
            type parameters. 

  
@verbatim
ObjectHeader: "object" MemberName ObjectInheritance
@end verbatim

@verbatim
ObjectInheritance: ExtendedType? SatisfiedTypes?
@end verbatim
An @code{object} declaration specifies the name of the
            value and the schema, supertypes, and implementation of the class. It does 
            not explicitly specify a type name. Instead, the type name is formed by 
            prefixing the value name with @code{\I}, turning it into an 
            initial uppercase identifier, as specified by 
            @ref{identifiersandkeywords, ,Identifiers and keywords}. 

  An @code{object} class: 

  
  @itemize @bullet
  
  @item satisfies and/or extends the types specified by the 
                    @code{object} declaration, 

  
  @item has no initializer parameter list, 

  
  @item has a single @code{shared} value constructor 
                    with the same name as the @code{object}, with an 
                    empty body and the same @code{extends} clause as 
                    the @code{object} declaration, which is the single 
                    enumerated case of the class, 

  
  @item is @code{shared}, if and only if the
                    @code{object} is annotated 
                    @code{shared}, 

  
  @item is neither @code{abstract} nor 
                    @code{formal}, 

  
  @item is implicitly @code{final}. 

  
  @end itemize
Therefore, members of an @code{object} may not be
            declared @code{formal} nor @code{default}. 

  The body of the @code{object} declaration is the body 
            of the class. 

  This class never appears in types inferred by local declaration type 
            inference or generic type argument inference. Instead, occurrences of the 
            class are replaced with the intersection of the extended type with all 
            satisfied types. 

  An @code{object} value is a getter, as defined in
            @ref{getters, ,Getters}, that simply returns a reference to the value
            constructor of the class. The value: 

  
  @itemize @bullet
  
  @item is @code{shared}, if and only if the
                    @code{object} is annotated 
                    @code{shared}, 

  
  @item may refine a member of a supertype, if and only if the 
                    @code{object} is annotated 
                    @code{actual}, and 

  
  @item is neither @code{default} nor 
                    @code{formal}. 

  
  @end itemize
Therefore, the @code{object} may not be annotated 
            @code{default} nor @code{formal}. 

  Annotations applying to an @code{object} declaration 
            are considered annotations of the @code{object} value, and 
            are accessible via its @code{ValueDeclaration}, as defined 
            in @ref{referenceexpressions, ,Reference expressions}. 

  The following declaration: 

  
@example
shared my object red extends Color('FF0000') @{
     string => "Red";
@}
@end example
Is exactly equivalent to: 

  
@example
shared final class \Ired of red extends Color @{
     shared new red extends Color('FF0000') @{@}
     string => "Red";
@}

shared my \Ired red => \Ired.red;
@end example
Where @code{\Ired} is the type name assigned by the 
            compiler. 

  
@example
shared object sql @{
    shared String escape(String string) @{ ... @}
@}

...

String escapedSearchString = sql.escape(searchString);
@end example

@node classeswithcases
@subsection Enumerated classes
@cindex Enumerated classes

  A class declaration may enumerate a list of cases of the class, as
            defined in @ref{cases, ,Cases}. 

  
  @itemize @bullet
  
  @item For an @code{abstract} class, the cases may be 
		            classes or toplevel anonymous classes. Each case must be a direct 
		            subclass of the enumerated class. A case may itself be an 
		            @code{abstract} class. 

  
  @item For a non-@code{abstract} toplevel class, the 
                    cases must be value constructors of the class. 

  
  @end itemize
The cases listed in the @code{of} clause must exhaust
            every means by which an instance of the class may be instantiated: 

  
  @itemize @bullet
  
  @item if an @code{abstract} class has an 
		            @code{of} clause, then every class that directly 
		            extends the class must occur as exactly one of the enumerated 
		            cases of the class listed in the @code{of} clause
		            and, furthermore, every class that indirectly inherits the 
		            @code{abstract} class must inherit one of the
		            enumerated cases of the class, or 

  
  @item if a non-@code{abstract} class has an 
		            @code{of} clause, then every non-partial constructor 
		            of the class must occur as exactly one of the enumerated cases of 
		            the class listed in the @code{of} clause. 

  
  @end itemize

@example
shared abstract class Boolean() 
        of true | false @{@}
        
shared object true extends Boolean() @{ string => "true"; @}
shared object false extends Boolean() @{ string => "false"; @}
@end example

@example
shared abstract class Node<Element>(String name) 
        of Branch<Element> | Leaf<Element> @{ ... @}
        
shared class Leaf<Element>(String name, Element element) 
        extends Node<Element>(name) @{ ... @}
        
shared class Branch<Element>(String name, Node<Element> left, Node<Element> right) 
        extends Node<Element>(name) @{ ... @}
@end example

@example
shared class Status of enabled | disabled @{
    shared actual String string;
    shared new enabled @{ string => "enabled"; @}
    shared new disabled @{ string => "disabled"; @}
@}
@end example
A non-@code{abstract} class with an initializer parameter 
            list or a callable constructor may not specify an @code{of} 
            clause. 

  A non-@code{abstract}, non-toplevel class may not specify 
            an @code{of} clause. 

  A class declaration may not list the same case twice. 

  
@smallindentedblock
  Note: in a future release of the language, we may introduce 
            an abbreviated syntax like: 

  
            
@example
shared abstract class Boolean(shared actual String string) 
        of object true ("true") | 
           object false ("false") @{@}
@end example

            
@end smallindentedblock

@node classaliases
@subsection Class aliases
@cindex Class aliases

  A @emph{class alias} is a class declaration which specifies 
            a reference to a class or callable constructor of a class, followed by a 
            positional argument list, as defined in @ref{positionalarguments, ,Positional argument lists}. 

  
@verbatim
ClassSpecifier: "=>" (Extension | Construction)
@end verbatim
The specification of the class or callable constructor is treated as a 
            value expression, as in @ref{extendedclass, ,Extension}. The type of this value 
            expression must be a @emph{class type}, that is, a reference to a 
            class with no type parameters or an instantiation of a generic class, and is 
            called the @emph{aliased type}. 

  A class alias simply assigns an alternative name to the aliased type. A 
            reference to the alias may occur anywhere a reference to a class may occur. 

  
@example
shared class People(Person* people) => ArrayList<Person>(*people);
@end example

@example
class Named<Value>(String name, Value val) 
        given Value satisfies Object
        => Entry<String,Value>(name, val);
@end example
Arguments to the initializer parameters of the aliased class must be
            specified. 

  If the aliased class is a parameterized type, the aliased type must
            explicitly specify type arguments. 

  The type arguments may not be inferred from the initializer arguments. 

  
@smallindentedblock
  Note: currently the compiler imposes a restriction that the 
            callable type of the aliased class must be assignable to the callable type 
            of the class alias. This restriction will be removed in future. 

  
@end smallindentedblock
If a toplevel class alias or un-@code{shared} class alias
            aliases an @code{abstract} class, the alias must be annotated 
            @code{abstract}, and it may not be directly instantiated. 

  If a @code{shared} class alias nested inside the body of a 
            class or interface aliases an @code{abstract} class, the alias 
            must be annotated @code{abstract} or @code{formal}.
            If it is annotated @code{formal}, it is considered a member 
            class of the containing class or interface. If it is annotated 
            @code{abstract}, it is considered an abstract nested class of the 
            containing class or interface. 

  A class alias may not alias a partial constructor. A 
            @code{shared} class alias may not alias an 
            un-@code{shared} constructor. 

  A class may extend a class alias, in which case, the class inherits the 
            aliased class type. 

  Class aliases are not reified types. The metamodel reference for a 
            class alias type---for example, @code{People}---returns 
            the metamodel object for the aliased class---in this case, 
            @code{ArrayList<Person>}, as specified in 
            @ref{reification, ,Type argument reification}. 

  
@node typealiasedeclarations
@section Type aliases
@cindex Type aliases

  A type alias declaration assigns a name to an arbitrary type expression,
        usually involving a union and/or intersection of types. 

  
@verbatim
TypeAliasDeclaration: Annotations AliasHeader TypeSpecifier ";"
@end verbatim

@verbatim
AliasHeader: "alias" TypeName TypeParameters? TypeConstraints?
@end verbatim
The specified type may be any kind of type. A reference to the alias 
        may be used anywhere a union or intersection type may be used. The alias may
        not appear in an @code{extends} or @code{satisfies}
        clause. The alias may not be instantiated. 

  
@example
shared alias Number => Integer|Float|Decimal|Whole;
@end example

@example
alias ListLike<Value> => List<Value>|Map<Integer,Value>;
@end example

@example
alias Numbered<Num,Value> given Num satisfies Ordinal<Num> 
        => Correspondence<Num,Value>;
@end example

@smallindentedblock
  Note: class, interface, and type aliases use a "fat arrow" lazy 
        specifier @code{=>} instead of @code{=} because the
        type parameters declared on the left of the specifier are in scope on the right
        of the specifier. An alias is in general a type constructor. 

  
@end smallindentedblock
A class or interface may not extend or satisfy a type alias. 

  Type aliases are not reified types. The metamodel reference for a type 
        alias type---for example, @code{Number}---returns the 
        metamodel object for the aliased type---in this case, 
        @code{Integer|Float|Decimal|Whole}, as specified in 
        @ref{reification, ,Type argument reification}. 

  
@node functions
@section Functions
@cindex Functions

  
      
@menu
      
* callabletypeoffunction:: Callable type of a function
* functionswithblocks:: Functions with blocks
* functionswithspecifiers:: Functions with specifiers
* returntypeinference:: Function return type inference
* functionforwarddeclaration:: Forward declaration of functions
* multipleparameterlists:: Functions with multiple parameter lists
* formalmethods:: Formal and default methods
* methodrefinement:: Method refinement
@end menu

      A @emph{function} is a callable block of code. A function 
        may have parameters and may return a value. If a function belongs to a type,
        it is called a @emph{method}. 

  
@verbatim
FunctionDeclaration: Annotations FunctionHeader (Block | LazySpecifier? ";")
@end verbatim
All function declarations specify the function name, one or more parameter 
        lists, and, optionally, a list of type parameters. A generic function declaration 
        may have a list of type constraints. 

  
@verbatim
FunctionHeader: FunctionPrefix MemberName TypeParameters? Parameters+ TypeConstraints?
@end verbatim
A function declaration may specify a type, called the @emph{return 
        type}, to which the values the method returns are assignable, or it may
        specify that the function is a @code{void} function---a function 
        which does not return a useful value, and only useful for its effect. 

  
@verbatim
FunctionPrefix: Type | "function" | "dynamic" | "void"
@end verbatim
Instead of an explicit return type, a function may be declared using: 

  
  @itemize @bullet
  
  @item the keyword @code{dynamic}, indicating that it is a
                partially typed declaration with no return type, or 

  
  @item the keyword @code{function}, indicating that its return
		        type is inferred. 

  
  @end itemize
A function implementation may be specified using either: 

  
  @itemize @bullet
  
  @item a block of code, or 

  
  @item a lazy specifier. 

  
  @end itemize
If a function is a parameter, it must not specify any implementation. 

  The return type of a @code{void} function is considered to be 
        @code{Anything} defined in @code{ceylon.language}. 

  
@smallindentedblock
  Note: a @code{void} function with a concrete 
        implementation returns the value @code{null}. However, since a
        @code{void} function may be a reference to a non-@code{void} 
        function, or a method refined by a non-@code{void} function, 
        this behavior can not be depended upon and is not implied by the semantics 
        of @code{void}. 

  
@end smallindentedblock

@node callabletypeoffunction
@subsection Callable type of a function
@cindex Callable type of a function

  The @emph{callable type} of a function captures the return
            type and parameter types of the function. 

  
  @itemize @bullet
  
  @item The callable type of a function with a single parameter list is 
                @code{R(*P)} where @code{R} is the return type 
                of the method, or @code{Anything} if the function is 
                @code{void}, and @code{P} is the type of the
                parameter list. 

  
  @item The callable type of a function with multiple parameter lists is 
                @code{O(*P)}, where @code{O} is the callable 
                type of a method produced by eliminating the first parameter list, and 
                @code{P} is the type of the first parameter list of the
                function. 

  
  @end itemize

@smallindentedblock
  Note: the identification of @code{void} with
            @code{Anything} instead of @code{Null} or some other
            unit type will probably be contraversial. This approach allows a 
            non-@code{void} method to refine a @code{void}
            method or a non-@code{void} function to be assigned to a 
            @code{void} functional parameter. Thus, we avoid rejecting 
            perfectly well-typed code. 

  
@end smallindentedblock

@node functionswithblocks
@subsection Functions with blocks
@cindex Functions with blocks

  A function implementation may be a block. 

  
  @itemize @bullet
  
  @item If the function is declared @code{void}, the block 
                    may not contain a @code{return} directive that specifies 
                    an expression. 

  
  @item Otherwise, every conditional execution path of the block must 
                    end in a @code{return} directive that specifies an 
                    expression assignable to the return type of the function, or in a 
                    @code{throw} directive, as specified in 
                    @ref{definitereturn, ,Definite return}. 

  
  @end itemize

@example
shared Integer add(Integer x, Integer y) @{
    return x + y;
@}
@end example

@example
shared void printAll(Object* objects) @{
    for (obj in objects) @{
        print(obj);
    @}
@}
@end example

@example
shared void addEntry(Key->Item entry) @{
    map.put(entry.key,entry.item);
@}
@end example

@example
shared Set<Element> singleton<Element>(Element element) 
        given Element satisfies Comparable<Element> @{
    return TreeSet @{ element @};
@}
@end example

@node functionswithspecifiers
@subsection Functions with specifiers
@cindex Functions with specifiers

  Alternatively, a function implementation may be a lazy specifier, that
            is, an expression specified using @code{=>}. The type of the 
            specified expression must be assignable to the return type of the function.
            In the case of a function declared @code{void}, the expression
            must be a legal statement. 

  
@example
shared Integer add(Integer x, Integer y) => x + y;
@end example

@example
shared void addEntry(Key->Item entry) => map.put(entry.key,entry.item);
@end example

@example
shared Set<Element> singleton<Element>(Element element) 
            given Element satisfies Comparable<Element>
        => TreeSet @{ element @};
@end example

@node returntypeinference
@subsection Function return type inference
@cindex Function return type inference

  A non-@code{void}, un-@code{shared}  function with 
            a block or lazy specifier may be declared using the keyword @code{function} 
            in place of the explicit return type declaration. Then the function return type is 
            inferred: 

  
  @itemize @bullet
  
  @item if the function implementation is a lazy specifier, then the 
                    return type of the function is the type of the specified expression, 

  
  @item if the function implementation is a block, and the function contains 
                    no @code{return} directive, then the return type of the method 
                    is @code{Nothing} (this is the case where the method always 
                    terminates in a @code{throw} directive), or, 

  
  @item otherwise, the return type of the function is the union of all 
                    returned expression types of @code{return} directives
                    of the method body. 

  
  @end itemize
This function has inferred return type @code{Integer}. 

  
@example
function add(Integer x, Integer y) => x + y;
@end example
This function has inferred return type @code{Float|Integer}. 

  
@example
function unit(Boolean floating) @{
    if (floating) @{
        return 1.0;
    @}
    else @{
        return 1;
    @}
@}
@end example
This function has inferred return type @code{Nothing}. 

  
@example
function die() @{
    throw;
@}
@end example

@node functionforwarddeclaration
@subsection Forward declaration of functions
@cindex Forward declaration of functions

  The declaration of a function may be separated from the specification of 
            its implementation. If a function declaration does not have a lazy specifier, 
            or a block, and is not annotated @code{formal}, and is not a 
            parameter, it is a @emph{forward-declared} function. 

  A forward-declared function may later be specified using a specification
            statement, as defined in @ref{specificationstatements, ,Specification statements}. The 
            specification statement for a forward-declared function may be: 

  
  @itemize @bullet
  
  @item a lazy specification statement with parameter lists of exactly
                    the same types as the function, and a specified expression assignable
                    to the declared type of the function, or 

  
  @item an ordinary specification statement with a specified expression
                    assignable to the callable type of the function. 

  
  @end itemize

@example
Comparison order(String x, String y);
if (reverseOrder) @{
    order(String x, String y) => y<=>x;
@}
else @{
    order(String x, String y) => x<=>y;
@}
@end example

@example
Comparison format(Integer x);
switch (base)
case (decimal) @{
    format = (Integer i) => i.string; 
@}
case (binary) @{
    format = formatBin;
@}
case (hexadecimal) @{
    format = formatHex;
@}
@end example
Every forward-declared function must explicitly specify a type. It may 
            not be declared using the keyword @code{function}. 

  A toplevel function may not be forward-declared. A method of an interface
            may not be forward-declared. A method annotated @code{default} may 
            not be forward-declared. 

  If a @code{shared} method is forward-declared, its 
            implementation must be definitely specified by all conditional paths in the
            class initializer. 

  
@node multipleparameterlists
@subsection Functions with multiple parameter lists
@cindex Functions with multiple parameter lists

  A function may declare multiple lists of parameters. A function with 
            more than one parameter list returns instances of @code{Callable}
            in @code{ceylon.language} when invoked. Every function with 
            multiple parameter lists is exactly equivalent to a function with a single
            parameter list that returns an anonymous function. 

  This function declaration: 

  
@example
Boolean greaterThan<Element>(Element val)(Element element)
        given Element satisfies Comparable<Element> => 
                element>val;
@end example
is equivalent to the following: 

  
@example
Boolean(Element) greaterThan<Element>(Element val)
        given Element satisfies Comparable<Element> => 
                (Element element) => element>val;
@end example
For a function with @code{n} parameter lists, there are 
            @code{n-1} inferred anonymous functions. The @code{i}th 
            inferred function: 

  
  @itemize @bullet
  
  @item has a callable type formed by eliminating the first @code{i}
                    parameter lists of the original declared function, 

  
  @item has the @code{i+1}th parameter list of the original
                    declared function, and 

  
  @item if @code{i<n}, returns the @code{i+1}th 
                    inferred function, or 

  
  @item otherwise, if @code{i==n}, has the implementation 
                    of the original declared function. 

  
  @end itemize
Then the original function returns the first inferred anonymous function. 

  This method declaration: 

  
@example
function fullName(String firstName)(String middleName)(String lastName)
        => firstName + " " + middleName + " " + lastName;
@end example
Is equivalent to: 

  
@example
function fullName(String firstName) =>
        (String middleName) =>
                (String lastName) =>
                        firstName + " " + middleName + " " + lastName;
@end example

@node formalmethods
@subsection Formal and default methods
@cindex Formal and default methods

  If a function declaration does not have a lazy specifier, or a block, 
            and is annotated @code{shared}, and is a method of either: 

  
  @itemize @bullet
  
  @item an interface, or 

  
  @item a class annotated @code{abstract} or 
                    @code{formal}, 

  
  @end itemize
then the function declaration may be annotated @code{formal}, 
            and is called a @code{formal} method, or, sometimes, an 
            @emph{abstract method}. 

  
@example
shared formal Item? get(Key key);
@end example
A method which is not annotated @code{formal} is called 
            a @emph{concrete} method. 

  If a concrete method is annotated @code{shared}, and is 
            a member of a class or interface, then it may be annotated @code{default}
            and is called a @code{default} method. 

  
@example
shared default void writeLine(String line) @{
    write(line);
    write("\n");
@}
@end example
A method annotated @code{formal} may not specify an
            implementation (a lazy specifier, or a block). 

  A method annotated @code{default} must specify an
            implementation (a lazy specifier, or a block), and may not be 
            forward-declared. 

  Every @code{formal} method must explicitly specify a type. 
            It may not be declared using the keyword @code{function}. 

  A toplevel method may not be annotated @code{formal} or
            @code{default}. 

  An un-@code{shared}  method may not be annotated 
            @code{formal} or @code{default}. 

  
@node methodrefinement
@subsection Method refinement
@cindex Method refinement

  Methods may be refined, just like in other object-oriented languages. 

  
  @itemize @bullet
  
  @item A class or interface may refine any @code{formal} 
                or @code{default} method it inherits, unless it inherits 
                a non-@code{formal} non-@code{default} method 
                that refines the method. 

  
  @item A concrete class must refine every @code{formal} 
                method it inherits, unless it inherits a non-@code{formal}
                method that refines the method. 

  
  @end itemize
A method of a subtype @emph{refines} a method of a 
            supertype if the method of the supertype is @code{shared} 
            and the two methods have the same name. The first method is called the
            @emph{refining} method, and the second method is called
            the @emph{refined} method. 

  Then, given the refined realization of the method it refines, as 
            defined in @ref{realizations, ,Realizations}, and, after substituting the
            type parameters of the refined method for the type parameters of the
            refining method in the schema of the refining method, the refining method 
            must: 

  
  @itemize @bullet
  
  @item have the same number of type parameters as the refined 
                    schema, and for each type parameter the intersection of its 
                    upper bounds must be a supertype of the intersection of the 
                    upper bounds of the corresponding type parameter of the 
                    realization, 

  
  @item have the same number of parameter lists, with the same
                    signatures, as the realization, and 

  
  @item have a return type that is assignable to the return type 
                    of the realization, or 

  
  @item if it has no return type, the refined method must also 
                    have no return type. 

  
  @end itemize

@smallindentedblock
  Note: in a future release of the language, we would like 
            to support contravariant refinement of method parameter types. 

  
@end smallindentedblock
Furthermore: 

  
  @itemize @bullet
  
  @item the refining method must be annotated @code{actual}, 
                    and 

  
  @item the refined method must be annotated @code{formal}
                    or @code{default}. 

  
  @end itemize
If a method is annotated @code{actual}, it must refine 
            some method defined by a supertype. 

  A method may not, directly or indirectly, refine two different 
            methods not themselves annotated @code{actual}. 

  Then invocation of the method is polymorphic, and the actual method 
            invoked depends upon the concrete type of the class instance. 

  
@example
shared abstract class AbstractSquareRooter() @{
    shared formal Float squareRoot(Float x);
@}
@end example

@example
class ConcreteSquareRooter()
        extends AbstractSquareRooter() @{
    shared actual Float squareRoot(Float x) => x^0.5;
@}
@end example
Alternatively, a subtype may refine a method using a specification
            statement, as defined in @ref{specificationstatements, ,Specification statements}. The 
            specification statement must satisfy the requirements of
            @ref{functionforwarddeclaration, ,Forward declaration of functions} above for specification 
            of a forward-declared function. 

  
@example
class ConcreteSquareRooter()
        extends AbstractSquareRooter() @{
    squareRoot(Float x) => x^0.5;
@}
@end example

@node values
@section Values
@cindex Values

  
      
@menu
      
* references:: References
* getters:: Getters
* setters:: Setters
* valuetypeinference:: Value type inference
* valueforwarddeclaration:: Forward declaration of values
* formalattributes:: Formal and default attributes
* attributerefinement:: Attribute refinement
@end menu

      There are two basic kinds of @emph{value}: 

  
  @itemize @bullet
  
  @item A @emph{reference} defines state. It has a persistent 
                value, determined at the moment it is specified or assigned. 

  
  @item A @emph{getter} defines how a value is evaluated. It 
                is defined using a block or lazy specifier, which is executed every time 
                the value is evaluated. A getter may have a matching 
                @emph{setter}. 

  
  @end itemize
If a value belongs to a type, it is called an @emph{attribute}. 

  
@verbatim
ValueDeclaration: Annotations ValueHeader (Block | (Specifier | LazySpecifier)? ";")
@end verbatim
All value declarations specify the value name. 

  
@verbatim
ValueHeader: ValuePrefix MemberName
@end verbatim
A value declaration may specify a type. 

  
@verbatim
ValuePrefix: Type | "value" | "dynamic"
@end verbatim
Instead of an explicit return type, a value may be declared using: 

  
  @itemize @bullet
  
  @item the keyword @code{dynamic}, indicating that it is a
                partially typed declaration with no type, or 

  
  @item the keyword @code{value}, indicating that its type 
                is inferred. 

  
  @end itemize

@smallindentedblock
  Note: syntactically a value declaration looks like a function 
        declaration with zero parameter lists. It is often helpful, in thinking about the 
        syntax and semantics of Ceylon, to take the perspective that a value is a function 
        with zero parameter lists, or, alternatively, that a function is a value of type 
        @code{Callable}. 

  
@end smallindentedblock
A value may be @emph{variable}, in which case it may be freely 
        assigned using the assignment and compound assignment operators defined in 
        @ref{operators, ,Operators}. This is the case for a reference annotated 
        @code{variable}, or for a getter with a matching setter. 

  
@node references
@subsection References
@cindex References

  The lifecycle and scope of the persistent value of a reference depends upon 
            where the reference declaration occurs: 

  
  @itemize @bullet
  
  @item A toplevel reference represents global state associated with the 
                    lifecyle of a module, as defined by 
                    @ref{toplevelinitialization, ,Initialization of toplevel references}. 

  
  @item A reference declared directly inside the body of a class represents 
                    a persistent value associated with every instance of the class, as defined 
                    by @ref{currentinstanceofaclassorinterface, ,Current instance of a class or interface}. Repeated evaluation 
                    of the attribute of a particular instance of the class produces the same 
                    result until the attribute of the instance is assigned a new value. 

  
  @item A reference declared inside a block represents state associated with 
                    a frame, that is, with a particular execution of the containing block of 
                    code, as defined in @ref{currentframeofablock, ,Current frame of a block}. 

  
  @end itemize
The persistent value of a reference may be specified or initialized as part 
            of the declaration of the reference, or via a later specification statement, as
            defined in @ref{specificationstatements, ,Specification statements}, or assignment expression, as
            defined in @ref{operators, ,Operators}, or, if it is a parameter, by an argument 
            to an invocation expression, as defined in @ref{invocationexpressions, ,Invocation expressions}. 

  A reference annotated @code{variable} has a persistent value that 
            can be assigned multiple times. A reference not annotated @code{variable} 
            has a persistent value that can be specified exactly once and not subsequently 
            modified. 

  
@example
variable Integer count = 0;
@end example

@example
shared Decimal pi = calculatePi();
@end example

@example
shared Integer[] evenDigits = [0,2,4,6,8];
@end example
A reference declaration may have a specifier which specifies its persistent 
            value or, in the case of a variable reference, its initial persistent value. The type 
            of the specified expression must be assignable to the type of the reference. 

  If the specified expression has no type, and the declaration occurs within a 
            @code{dynamic} block, then the specification is not type-checked at 
            compile time. 

  If a reference is a parameter, it must not specify a persistent value. 

  A reference belonging to a class may be annotated @code{late}, in 
            which case the initializer of the class is not required to initialize its persistent
            value. Furthermore, a self-reference to an instance being initialized may be
            assigned to the reference. 

  A reference annotated @code{late} may not be initialized or 
            assigned a value by the class initializer. A parameter may not be annotated 
            @code{late}. A reference not belonging to a class may not be annotated 
            @code{late}. 

  If a class declares or inherits a @code{variable} reference, it 
            must (directly or indirectly) extend the class @code{Basic} defined in 
            @code{ceylon.language}. 

  
@node getters
@subsection Getters
@cindex Getters

  A getter implementation may be a block. 

  
@example
shared Float total @{
    variable Float sum = 0.0;
    for (li in lineItems) @{
        sum += li.amount;
    @}
    return sum;
@}
@end example
Every conditional execution path of the block must end in a
            @code{return} directive that specifies an expression assignable 
            to the type of the value, or in a @code{throw} directive, as
            specified in @ref{definitereturn, ,Definite return}. 

  Alternatively, a getter implementation may be a lazy specifier, that
            is, an expression specified using @code{=>}. The type of the 
            specified expression must be assignable to the type of the value. 

  
@example
Name name => Name(firstName, initial, lastName);
@end example

@node setters
@subsection Setters
@cindex Setters

  A setter defines how the value of a getter is assigned. 

  
@verbatim
SetterDeclaration: Annotations "assign" MemberName (Block | LazySpecifier)
@end verbatim
The name specified in a setter declaration must be the name of a
            matching getter that directly occurs earlier in the body containing the 
            setter declaration. If a getter has a setter, we say that the value is 
            @emph{variable}. 

  Within the body of the setter, a value reference to the getter 
            evaluates to the value being assigned. 

  A setter implementation may be a block. The block may not contain 
            a return directive that specifies an expression. 

  
@example
shared String name @{ return join(firstName, lastName); @}
assign name @{ firstName=first(name); lastName=last(name); @}
@end example
Alternatively, a setter implementation may be a lazy specifier. 
            The specified expression must be a legal statement. 

  
@example
shared String name => join(n[0], n[1]);
assign name => n = [first(name), last(name)];
@end example
A setter may not be annotated @code{shared}, 
            @code{default} or @code{actual}. The visibility 
            and refinement modifiers of an attribute with a setter are specified by 
            annotating the matching getter. 

  
@node valuetypeinference
@subsection Value type inference
@cindex Value type inference

  An un-@code{shared}  value with a block, specifier, or lazy 
            specifier may be declared using the keyword @code{value} in place of 
            the explicit type declaration. Then the value's type is inferred: 

  
  @itemize @bullet
  
  @item if the value is a reference with a specifier, then the type of the 
                    value is the type of the specified expression, 

  
  @item if the value is a getter, and the getter implementation is a lazy 
                    specifier, then the type of the value is the type of the specified 
                    expression, 

  
  @item if the value is a getter, and the getter implementation is a block, 
                    and the getter contains no @code{return} directive, then the 
                    type of the value is @code{Nothing} (this is the case where 
                    the getter always terminates in a @code{throw} directive), or 

  
  @item otherwise, the type of the value is the union of all returned 
                    expression types of @code{return} directives of the getter 
                    body. 

  
  @end itemize

@example
value names = List<String>();
@end example

@example
variable value count = 0;
@end example

@example
value name => Name(firstName, initial, lastName);
@end example

@node valueforwarddeclaration
@subsection Forward declaration of values
@cindex Forward declaration of values

  The declaration of a reference may be separated from the specification 
            or initialization of its persistent value. The declaration of a getter may be 
            separated from the specification of its implementation. If a value declaration 
            does not have a specifier, lazy specifier, or a block, and is not annotated 
            @code{formal}, it is a @emph{forward-declared} 
            value. 

  A forward-declared value may later be specified using a specification
            statement, as defined in @ref{specificationstatements, ,Specification statements}. 

  
  @itemize @bullet
  
  @item The specification statement for a forward-declared getter is
                    a lazy specification statement with no parameter list, and a specified
                    expression assignable to the type of the value. 

  
  @item The specification statement for a forward-declared reference is
                    an ordinary specification statement with a specified expression
                    assignable to the type of the value. 

  
  @end itemize

@example
String greeting;
switch (language)
case (en) @{
    greeting = "Hello";
@}
case (es) @{
    greeting = "Hola";
@}
else @{
    throw LanguageNotSupported();
@}
print(greeting);
@end example
Every forward-declared value must explicitly specify a type. It may 
            not be declared using the keyword @code{value}. 

  A toplevel value may not be forward-declared. An attribute of an 
            interface may not be forward-declared. An attribute annotated 
            @code{default} may not be forward-declared. 

  A forward-declared getter may not have a setter. 

  If a @code{shared} value is forward-declared, its 
            implementation must be definitely specified by all conditional paths in the 
            class initializer. 

  
@node formalattributes
@subsection Formal and default attributes
@cindex Formal and default attributes

  If a value declaration does not have a specifier, lazy specifier, or 
            a block, and is annotated @code{shared}, and is a member of 
            either: 

  
  @itemize @bullet
  
  @item an interface, or 

  
  @item a class annotated @code{abstract} or 
                    @code{formal}, 

  
  @end itemize
then the value declaration may be annotated @code{formal}, 
            and is called a @code{formal} attribute, or, sometimes, an 
            @emph{abstract attribute}. 

  
@example
shared formal variable String firstName;
@end example
An attribute which is not annotated @code{formal} is called 
            a @emph{concrete} attribute. 

  If a concrete attribute is annotated @code{shared}, and is 
            a member of a class or interface, then it may be annotated @code{default}
            and is called a @code{default} attribute. 

  
@example
shared default String greeting = "Hello";
@end example
An attribute annotated @code{formal} may not specify an
            implementation (a specifier, lazy specifier, or a block). Nor may there be 
            a setter for a formal attribute. 

  An attribute annotated @code{default} must specify an
            implementation (a specifier, lazy specifier, or a block), and may not be 
            forward-declared. 

  Every @code{formal} attribute must explicitly specify a type. 
            It may not be declared using the keyword @code{function}. 

  A toplevel attribute may not be annotated @code{formal} or
            @code{default}. 

  An un-@code{shared} attribute may not be annotated 
            @code{formal} or @code{default}. 

  
@node attributerefinement
@subsection Attribute refinement
@cindex Attribute refinement

  Ceylon allows attributes to be refined, just like methods. This helps
            eliminate the need for Java-style getter and setter methods. 

  
  @itemize @bullet
  
  @item A class or interface may refine any @code{formal} 
                or @code{default} attribute it inherits, unless it inherits 
                a non-@code{formal} non-@code{default} 
                attribute that refines the attribute. 

  
  @item A concrete class must refine every @code{formal} 
                attribute it inherits, unless it inherits a non-@code{formal}
                attribute that refines the attribute. 

  
  @end itemize
Any non-variable attribute may be refined by a reference or getter. A 
            variable attribute may be refined by a @code{variable} refernce 
            or by a getter and setter pair. 

  
@smallindentedblock
  TODO: are you allowed to refine a getter or setter without also 
            refining its matching setter or getter? 

  
@end smallindentedblock
An attribute of a subtype @emph{refines} an attribute
            of a supertype if the attribute of the supertype is @code{shared} 
            and the two attributes have the same name. The first attribute is called the 
            @emph{refining} attribute, and the second attribute is called 
            the @emph{refined} attribute. 

  Then, given the refined realization of the attribute it refines, as 
            defined in @ref{realizations, ,Realizations}, the refining attribute must: 

  
  @itemize @bullet
  
  @item be variable, if the attribute it refines is variable, and 

  
  @item have @emph{exactly the same type} as the 
                    realization, if the attribute it refines is variable, 

  
  @item have a type that is assignable to the type of the refined 
                    schema, if the attribute it refines is not variable, or 

  
  @item if it has no type, the refined attribute must also have no 
                    type. 

  
  @end itemize
Furthermore: 

  
  @itemize @bullet
  
  @item the refining attribute must be annotated @code{actual}, 
                    and 

  
  @item the refined attribute must be annotated @code{formal}
                    or @code{default}. 

  
  @end itemize
If an attribute is annotated @code{actual}, it must 
            refine some attribute defined by a supertype. 

  An attribute may not, directly or indirectly, refine two different
            attributes not themselves annotated @code{actual}. 

  A non-variable attribute may be refined by a variable attribute. 

  
@smallindentedblock
  TODO: Is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you refine an interface
            attribute, but not when you refine a superclass attribute? 

  
@end smallindentedblock
Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance. 

  
@example
shared abstract class AbstractPi() @{
    shared formal Float pi;
@}
@end example

@example
class ConcretePi() 
        extends AbstractPi() @{
    shared actual Float pi = calculatePi();
@}
@end example
Alternatively, a subtype may refine an attribute using a specification 
            statement, as defined in @ref{specificationstatements, ,Specification statements}. The 
            specification statement must satisfy the requirements of 
            @ref{valueforwarddeclaration, ,Forward declaration of values} above for specification of a 
            forward-declared attribute. 

  
@example
class ConcretePi() 
        extends AbstractPi() @{
    pi = calculatePi();
@}
@end example

@node constructors
@section Constructors
@cindex Constructors

  
      
@menu
      
* callabletypeofaconstructor:: Callable type of a constructor
* partialconstructors:: Partial constructors
* constructordelegation:: Constructor delegation
@end menu

      A @emph{constructor} is a callable block of code that
        produces a new instance of the class to which the constructor belongs.
        Every constructor must occur directly in the initializer section of a class. 
        A constructor may have parameters. Every constructor implementation is a 
        block of code. 

  
@verbatim
ConstructorDeclaration: Annotations ConstructorHeader Block
@end verbatim
The are two basic kinds of constructor: 

  
  @itemize @bullet
  
  @item A @emph{callable constructor} declaration 
                specifies the constructor name, if any, and exactly one parameter 
                list. 

  
  @item A @emph{value constructor} declaration 
                specifies just the constructor name. 

  
  @end itemize
Any constructor declaration may, optionally, have an @code{extends} 
        clause. 

  A constructor name must be an initial lowercase identifier. 

  
@verbatim
ConstructorHeader: ValueConstructorHeader | CallableConstructorHeader
@end verbatim

@verbatim
CallableConstructorHeader: "new" MemberName? Parameters ExtendedType?
@end verbatim

@verbatim
ValueConstructorHeader: "new" MemberName ExtendedType?
@end verbatim
If two constructors belong to the same class, then the constructors 
        must have distinct names. A class may have at most one constructor with no
        name. 

  If a constructor has no name, then the constructor is called the 
        @emph{default constructor} of the class to which it belongs.
        The default constructor is always a callable constructor. 

  Every default constructor must be annotated @code{shared}. 

  
@smallindentedblock
  Note: from the point of view of a client, a class with a default
        constructor and no named constructors is indistinguishable from a class with an
        initializer parameter list. 

  
@end smallindentedblock

@example
shared class Point @{
    shared Float x;
    shared Float y;
    
    shared new origin @{
        x = 0.0;
        y = 0.0;
    @}
    shared new cartesian(Float x, Float y) @{
        this.x = x; 
        this.y = y;
    @}
    shared new polar(Float r, Float theta) @{
        this.x = r * cos(theta);
        this.y = r * sin(theta);
    @}
    shared new (Float x, Float y) 
            extends cartesian(x, y) @{@}
    
    string => "(``x``, ``y``)";
@}
@end example
A class with an initializer parameter list may not declare constructors. 

  A generic class may not declare value constructors. 

  A class nested directly inside an interface may not declare value constructors. 

  A member class annotated @code{formal}, @code{default},
        or @code{actual} may not declare constructors. 

  
@smallindentedblock
  Note: in a future release of the language, we might relax this 
        restriction, and simply require that every @code{actual} class 
        provide a constructor with the same signature as the constructor of its 
        superclass. 

  
@end smallindentedblock
A constructor annotated @code{sealed} may not be invoked 
        outside the module in which it is defined. 

  
@node callabletypeofaconstructor
@subsection Callable type of a constructor
@cindex Callable type of a constructor

  For a callable constructor, the @emph{callable type} 
            of the constructor captures the type of the class, and parameter types of 
            the constructor. The callable type is @code{T(*P)}, where 
            @code{T} is the applied type formed by the class with its own 
            type parameters as type arguments, and @code{P} is the type of 
            the parameter list of the constructor. 

  A constructor of an @code{abstract} class is not 
            callable, except from the @code{extends} clause of a subclass, 
            or the class specifier of a class alias. 

  A partial constructor is not callable, except from the 
            @code{extends} clause of another constructor of the same
            class. 

  The type of a value constructor is simply @code{T},
            where @code{T} is the class to which it belongs. 

  
@node partialconstructors
@subsection Partial constructors
@cindex Partial constructors

  A callable constructor annotated @code{abstract} is 
            called a @emph{partial constructor}. 

  A partial constructor may not be annotated @code{shared}. 

  A default constructor may not be annotated @code{abstract}. 

  A value constructor may not be annotated @code{abstract}. 

  
@node constructordelegation
@subsection Constructor delegation
@cindex Constructor delegation

  Every constructor of any class which does not directly extend
            @code{Basic} defined in @code{ceylon.language}
            must explicitly delegate, as defined in @ref{extendedclass, ,Extension}, 
            to either: 

  
  @itemize @bullet
  
  @item a different callable constructor of the same class, 
                    specifying arguments for the parameters of the constructor, 
                    or, 

  
  @item a callable constructor of its immediate superclass, 
                    specifying arguments for the parameters of the superclass 
                    constructor, if the superclass declares constructors, or, 
                    otherwise 

  
  @item the initializer of its immediate superclass, specifying
                    arguments for the initializer parameters, if the superclass 
                    has an initializer parameter list. 

  
  @end itemize
If the constructor of a class which directly extends 
            @code{Basic} does not have an @code{extends}
            clause, the constructor implicitly delegates to the initializer of
            @code{Basic}. 

  
@node statementblocks
@chapter Statements, blocks, and control structures
@cindex Statements, blocks, and control structures

@menu
  
* blockstructure:: Block structure and references
* patternsandvariables:: Patterns and variables
* blocksandstatements:: Blocks and statements
* controlstructureconditions:: Conditions
* controlstructures:: Control structures and assertions
@end menu

  Function, value, and class bodies contain procedural code that is executed 
    when the function is invoked, the value evaluated, or the class instantiated. The 
    code contains expressions and control directives and is organized using blocks 
    and control structures. 

  
@smallindentedblock
  Note: the Ceylon language has a recursive block structure---statements 
    and declarations that are syntactically valid in the body of a toplevel declaration 
    are, in general, also syntactically valid in the body of a nested declaration or 
    of a control structure, and vice-versa. 

  
@end smallindentedblock

@node blockstructure
@section Block structure and references
@cindex Block structure and references

  
      
@menu
      
* declarationnameuniqueness:: Declaration name uniqueness
* scopeofdeclaration:: Scope of a declaration
* visibility:: Visibility
* hiddendeclarations:: Hidden declarations
* referenceabilityofdeclaration:: References and block structure
* typeinferenceandblockstructure:: Type inference and block structure
* unqualifiedreferenceresolution:: Unqualified reference resolution
* qualifiedreferenceresolution:: Qualified reference resolution
@end menu

      A @emph{body} is a block, defined in 
        @ref{blocksandstatements, ,Blocks and statements}, class body, defined in 
        @ref{classes, ,Classes}, interface body, defined in 
        @ref{interfaces, ,Interfaces}, or comprehension clause, defined in
        @ref{comprehensions, ,Comprehensions}. Every body (except for a comprehension clause) 
        is list of semicolon-delimited statements, control structures, and declarations, 
        surrounded by braces. Some bodies end in a control directive. Every program 
        element in the list is said to @emph{directly occur} in the body. 
        A program element @emph{directly occurs earlier} than a second 
        program element if both program elements directly occur in a body and the first 
        program element occurs (lexically) earlier in the list than the second program 
        element. 

  A program element @emph{(indirectly) occurs} in a body if: 

  
  @itemize @bullet
  
  @item the program element directly occurs in the body, or 

  
  @item the program element indirectly occurs inside the body of a 
                declaration or control structure that occurs directly in the body. 

  
  @end itemize
We sometimes say that the body @emph{contains} the program 
        element if the program element (indirectly) occurs in the body. 

  A program element @emph{(indirectly) occurs earlier} than a 
        second program element if: 

  
  @itemize @bullet
  
  @item the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or 

  
  @item the second program element indirectly occurs inside the body of a 
                declaration or control structure, and the first program element directly 
                occurs earlier than the declaration or control structure. 

  
  @end itemize
Then we also say that the second program element @emph{(indirectly) occurs 
        later} than the first. The set of program elements that occur later than a 
        program element is sometimes called the @emph{lexical scope} of the 
        program element. 

  A program element @emph{sequentially occurs} in a body if: 

  
  @itemize @bullet
  
  @item the program element directly occurs in the body, or 

  
  @item the program element sequentially occurs inside the body of a control 
                structure or constructor that occurs directly in the body. 

  
  @end itemize
A program element @emph{sequentially occurs earlier} than a 
        second program element if: 

  
  @itemize @bullet
  
  @item the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or 

  
  @item the second program element sequentially occurs inside the body of a 
                control structure or constructor, and the first program element directly 
                occurs earlier than the control structure or constructor. 

  
  @end itemize
If a program element sequentially occurs earlier than a second program element, 
        the @emph{sequence of statements} from the first program element to the
        second program element comprises: 

  
  @itemize @bullet
  
  @item the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the second program element, if the second program 
                element occurs directly in the same body as the first program element, or 

  
  @item the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the control structure or constructor in whose body 
                the second program element sequentially occurs, followed by the sequence of 
                statements from the first statement of the declaration whose body contains 
                the second program element to the second program element itself, otherwise. 

  
  @end itemize

@node declarationnameuniqueness
@subsection Declaration name uniqueness
@cindex Declaration name uniqueness

  A program element is contained within the @emph{namespace} 
            of a declaration if either: 

  
  @itemize @bullet
  
  @item the declaration is a toplevel declaration, and the program 
                    element is a toplevel declaration of the same package, 

  
  @item the declaration directly occurs in a body, the program 
                    element occurs in the same body, and the declaration sequentially 
                    occurs earlier than the program element, 

  
  @item the declaration is a parameter or type parameter, and the
                    program element sequentially occurs in the body of the parameterized 
                    declaration, or 

  
  @item the program element is a control structure variable or 
                    iteration variable of a control structure that sequentially occurs 
                    in the namespace of the declaration. 

  
  @end itemize
The namespace of a declaration may not contain a second declaration with 
            the same name. For example, the following is illegal: 

  
@example
function fun(Float number) @{
    if (number<0.0) @{
        Float number = 1.0; //error
        ...
    @}
    ...
@}
@end example
As an exception to this rule, the namespace of a declaration annotated
            @code{native} may contain a second declaration with the same name
            if: 

  
  @itemize @bullet
  
  @item the second declaration has exactly the same schema, as defined
                    in @ref{type, ,Types}, 

  
  @item the second declaration is also annotated @code{native},
                    and 

  
  @item the two @code{native} annotations have distinct 
                    arguments for the @code{backend} parameter. 

  
  @end itemize
A class or interface may not inherit a declaration with the same name as 
            a declaration it contains unless either: 

  
  @itemize @bullet
  
  @item the contained declaration directly or indirectly refines the 
                    inherited declaration, 

  
  @item the contained declaration is not @code{shared}, or 

  
  @item the inherited declaration is not @code{shared}. 

  
  @end itemize
A class or interface may not inherit two declarations with the same name 
            unless either: 

  
  @itemize @bullet
  
  @item the class or interface contains a declaration that directly or 
                    indirectly refines both the inherited declarations (in which case both 
                    the inherited declarations directly or indirectly refine some member 
                    of a common supertype, as required by @ref{classrefinement, ,Member class refinement},
                    @ref{attributerefinement, ,Attribute refinement}, and 
                    @ref{methodrefinement, ,Method refinement}), 

  
  @item one of the inherited declarations directly or indirectly refines 
                    the other inherited declaration, or 

  
  @item at least one of the inherited declarations is not 
                    @code{shared}. 

  
  @end itemize

@node scopeofdeclaration
@subsection Scope of a declaration
@cindex Scope of a declaration

  The scope of a declaration is governed by the body or package in which it 
            occurs. A declaration is @emph{in scope} at a program element if
            and only if either: 

  
  @itemize @bullet
  
  @item the declaration is a parameter or type parameter of a declaration 
                    whose body contains the program element, 

  
  @item the declaration is a control structure variable or iteration 
                    variable belonging to a block of a control structure that contains the 
                    program element, 

  
  @item the program element belongs to or is contained in the body of the 
                    declaration itself, 

  
  @item the program element belongs to or is contained in the body of a 
                    class or interface which inherits the declaration, 

  
  @item the declaration directly occurs in a body containing the program
                    element, 

  
  @item the declaration is imported by the compilation unit containing the 
                    program element and is visible to the program element, or 

  
  @item the declaration is a toplevel declaration in the package containing 
                    the program element. 

  
  @end itemize
Where: 

  
  @itemize @bullet
  
  @item A control structure variable or iteration variable @emph{belongs} 
                    to a block of a control structure if the block immediately follows the declaration 
                    of the variable. 

  
  @item A program element @emph{belongs} to a declaration if it occurs
                    in the @code{extends}, @code{satisfies}, @code{of},
                    or @code{given} clause of the declaration. 

  
  @end itemize
Furthermore: 

  
  @itemize @bullet
  
  @item A condition variable of a condition belonging to a condition list is 
                    in scope in any condition of the same condition list that occurs lexically 
                    later. 

  
  @item A resource expression variable of a @code{try} statement 
                    is in scope in any resource expression of the same resource expression list 
                    that occurs lexically later. 

  
  @item An iteration variable or condition variable of a comprehension is in 
                    scope in any clause of the comprehension that occurs lexically later, since
                    comprehension clauses are viewed as nested bodies. 

  
  @end itemize
And finally, there are special rules for annotation lists, defined in 
            @ref{annotationlists, ,Annotation lists}: 

  
  @itemize @bullet
  
  @item An annotation argument list belongs to the annotated declaration. 

  
  @item An annotation name is considered to occur directly in the compilation 
                    unit containing the program element. 

  
  @end itemize

@smallindentedblock
  Note: if no reference to an un-@code{shared} declaration 
            occurs within the scope of the declaration, a compiler warning is produced. 

  
@end smallindentedblock

@node visibility
@subsection Visibility
@cindex Visibility

  Classes, interfaces, functions, values, aliases, and type parameters 
            have names. Occurrence of a name in code implies a hard dependency from the 
            code in which the name occurs to the schema of the named declaration. We say 
            that a class, interface, value, function, alias, or type parameter is 
            @emph{visible} to a certain program element if its name may 
            occur in the code that belongs to that program element. 

  The visibility of a declaration depends upon where it occurs, and upon 
            whether it is annotated @code{shared}. A toplevel or member 
            declaration may be annotated @code{shared}: 

  
  @itemize @bullet
  
  @item If a toplevel declaration is annotated @code{shared}, 
                    it is visible wherever the package that contains it is visible.
                    Otherwise, a toplevel declaration is visible only to code in the 
                    package containing its compilation unit. 

  
  @item If a member declaration is annotated @code{shared}, 
                    it is visible wherever the class or interface that contains it is 
                    visible. Otherwise, a declaration that occurs directly inside a class 
                    or interface body is visible only inside the class or interface 
                    declaration. 

  
  @end itemize

@smallindentedblock
  Note: the Ceylon compiler enforces additional visibility
            restrictions for members of Java classes, since Java's visibility modifiers
            can express restrictions that cannot be reproduced within Ceylon's visibility
            model. These restrictions are outside the scope of this specification. 

  
@end smallindentedblock
A type parameter or a declaration that occurs directly inside a block 
            (the body of a function, getter, setter, or control structure) may not be 
            annotated @code{shared}. 

  
  @itemize @bullet
  
  @item A type parameter is visible only inside the declaration to which 
                    it belongs. 

  
  @item A declaration that occurs directly inside a block is visible 
                    only inside the block. 

  
  @end itemize

@smallindentedblock
  TODO: Should we allow you to limit the effect of the 
            @code{shared} annotation by specifying a containing program 
            element or package? 

  
@end smallindentedblock
We say that a type is @emph{visible} to a certain 
            program element if it is formed from references to classes, interfaces,
            type parameters, and type aliases whose declarations are visible to the 
            program element. For @code{shared} declarations: 

  
  @itemize @bullet
  
  @item The type of a value must be visible everywhere the value 
                    itself is visible. 

  
  @item The return type of a function must be visible everywhere 
                    the function itself is visible. 

  
  @item The satisfied interfaces of a class or interface must be 
                    visible everywhere the class or interface itself is visible. 

  
  @item The superclass of a class must be visible everywhere the 
                    class itself is visible. 

  
  @item The aliased type of a class alias, interface alias, or 
                    type alias must be visible everywhere the alias itself is 
                    visible. 

  
  @end itemize

@node hiddendeclarations
@subsection Hidden declarations
@cindex Hidden declarations

  If two declarations with the same name or imported name, as defined in 
            @ref{importedname, ,Imported name}, are both in scope at a certain program element, then 
            one declaration may @emph{hide} the other declaration. 

  
  @itemize @bullet
  
  @item If an inner body is contained (directly or indirectly) in an outer 
                    body, a declaration that is in scope in the inner body but is not in 
                    scope in the outer body hides a declaration that is in scope in the outer 
                    body. (In particular, a declaration inherited by a nested class or 
                    interface hides a declaration of the containing body.) 

  
  @item An un-@code{shared} declaration occurring directly in 
                    the body of a class containing the program element hides a declaration 
                    inherited by the class. 

  
  @item An @code{actual} declaration hides the declaration it
                    refines. 

  
  @item A declaration occurring in a body containing the program element 
                    hides a declaration imported by the compilation unit containing the body
                    or implicitly imported from the module @code{ceylon.language}. 

  
  @item A toplevel declaration of the package containing the program element 
                    hides a declaration implicitly imported from the module 
                    @code{ceylon.language}. 

  
  @item A declaration explicitly imported by the compilation unit containing
                    the program element hides a declaration implicitly imported from the module 
                    @code{ceylon.language}. 

  
  @item A declaration explicitly imported by the compilation unit containing 
                    the program element hides a toplevel declaration of  the package containing the compilation unit. 

  
  @item A declaration explicity imported by name in the compilation unit 
                    containing the program element hides a declaration explicitly imported 
                    by wildcard in the compilation unit. 

  
  @end itemize
For example, the following code is legal: 

  
@example
class Person(name) @{
    String name;
    shared String lowerCaseName @{
        String name = this.name.lowercased;
        return name;
    @}
@}
@end example
As is this code: 

  
@example
class Point(x, y) @{
    shared Float x; 
    shared Float y;
@}

class Complex(Float x, Float y=0.0) 
        extends Point(x, y) @{@}
@end example
When a member of a class is hidden by a nested declaration, the member 
            may be accessed via the self reference @code{this}, defined in
            @ref{this, ,this}, or via the outer instance reference @code{outer},
            defined in @ref{outer, ,outer}. 

  
@example
shared class Item(name) @{
    variable String name;
    shared void changeName(String name) @{
        this.name = name;
    @}
@}
@end example

@example
class Catalog(name) @{
    shared String name;
    class Schema(name) @{
        shared String name;
        Catalog catalog => outer;
        String catalogName => outer.name;
        class Table(name) @{
            shared String name;
            Schema schema => outer;
            String schemaName => outer.name;
            String catalogName => catalog.name;
        @}
    @}
@}
@end example
When a toplevel declaration of a package is hidden by another declaration, 
            the toplevel declaration may be accessed via the containing package reference 
            @code{package}, as defined in 
            @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution}. 

  
@example
Integer n => 0;
Integer f(Integer n) => n+package.n;
@end example

@node referenceabilityofdeclaration
@subsection References and block structure
@cindex References and block structure

  A declaration may be in scope at a program element, but not 
            @emph{referenceable} at the program element. A declaration 
            is referenceable at a program element if the declaration is in scope at 
            the program element and either: 

  
  @itemize @bullet
  
  @item the program element occurs within the lexical scope of the 
                    declaration, 

  
  @item the declaration is a parameter and the program element occurs 
                    within the @code{extends} clause of the declaration it
                    parameterizes, or 

  
  @item the declaration does not directly occur in a block, nor in 
                    the initializer section of a class body. 

  
  @end itemize
Note that these rules have very different consequences for: 

  
  @itemize @bullet
  
  @item a declaration that occurs in a block, as specified in 
                    @ref{blocksandstatements, ,Blocks and statements}, or in an class initializer section, as
                    specified in @ref{initializersection, ,Initializer section}, and
                     

  
  @item a toplevel declaration, as specified in 
                    @ref{topleveldeclarations, ,Toplevel and nested declarations}, or a declaration that occurs in a 
                    class declaration sectiony, as specified in @ref{declarationsection, ,Declaration section}, 
                    or interface body, as specified in @ref{interfacebodies, ,Interface bodies}. 

  
  @end itemize
Declarations that occurs in a block or class initializer section are interspersed
            with procedural code that initializes references. Therefore, a program element in a 
            block or initializer may not refer to a declaration that occurs later in the block or 
            class body. This restriction does not apply to declarations that occur in an interface 
            body or class declaration section. Nor does it apply to toplevel declarations, which
            are not considered to have a well-defined order. 

  The following toplevel function declarations, belonging to the same package, 
            are legal: 

  
@example
Float x => y;
@end example

@example
Float y => x;
@end example
This code is not legal, since the body of a function is an ordinary block: 

  
@example
Float->Float xy() @{
    Float x => y;  //error: y is not referenceable
    Float y => x;
    return x->y;
@}
@end example
This code is not legal, since all three statements occur in the initializer 
            section of the class body: 

  
@example
class Point() @{
    Float x => y;  //error: y is not referenceable
    Float y => x;
    Float->Float xy = x->y;
@}
@end example
However, this code @emph{is} legal, since the statements occur 
            in the declaration section of the class body: 

  
@example
class Point() @{
    Float x => y;
    Float y => x;
@}
@end example
Likewise, this code is legal, since the statements occur in an interface 
            body: 

  
@example
interface Point @{
    Float x => y;
    Float y => x;
@}
@end example

@node typeinferenceandblockstructure
@subsection Type inference and block structure
@cindex Type inference and block structure

  A value declared using the keyword @code{value} or a
            function declared using the keyword @code{function} may be 
            in scope at a program element, but its type may not be 
            @emph{inferable}, as defined by 
            @ref{typeinference, ,Type inference}, from the point of view of that program 
            element. 

  The type of a value or function declared using the keyword 
            @code{value} or @code{function} is inferable 
            to a program element if the declaration is in scope at the program 
            element and the program element occurs within the lexical scope of the 
            declaration. 

  
@smallindentedblock
  Note: the type of a value or function declared using
            the keyword @code{value} or @code{function} is
            not inferable within the body of the value or function 
            itself. 

  
@end smallindentedblock
For any other declaration, including any declaration which 
            explicitly specifies its type, the type is considered inferable to a 
            program element if the declaration is in scope at the program 
            element. 

  The following code is not legal: 

  
@example
interface Point @{
    value x => y;  //error: type of y is not inferable
    value y => x;
@}
@end example
However, this code is legal: 

  
@example
interface Point @{
    value x => y;
    Float y => x;
@}
@end example

@node unqualifiedreferenceresolution
@subsection Unqualified reference resolution
@cindex Unqualified reference resolution

  An @emph{unqualified reference} is: 

  
  @itemize @bullet
  
  @item the type name in an unqualified type declaration or type 
                    argument, as defined by @ref{typeexpressions, ,Type expressions}, for 
                    example @code{String} and @code{Sequence} 
                    in @code{Sequence<String>}, 

  
  @item the value, function, constructor, or type name in a base 
                    expression, as defined by @ref{baseexpressions, ,Base expressions}, 
                    for example 
                    @code{counter} in @code{counter.count}, 
                    @code{entries} and @code{people} in 
                    @code{entries(people*.name)}, or 
                    @code{Entry}, @code{name}, and
                    @code{item} in @code{Entry(name,item)}, 
                    or 

  
  @item the type name in an unqualified type in a static expression, 
                    as defined by @ref{staticexpressions, ,Static expressions}, or constructor
                    expression, as defined by @ref{constructorexpressions, ,Constructor expressions}, 
                    for example @code{Sequence} in 
                    @code{Sequence.iterator}. 

  
  @end itemize
If a program element contains an unqualified reference: 

  
  @itemize @bullet
  
  @item there must be at least one declaration with the given name or 
                    imported into the toplevel namespace of the compilation unit, as
                    defined in @ref{imports, ,Imports}, and aliased to the given 
                    imported name, as defined in @ref{importedname, ,Imported name}, in scope 
                    at the program element, and 

  
  @item if multiple declarations with the given name or imported name 
                    are in scope at the program element where the given name occurs, then 
                    it is guaranteed by the type system and 
                    @ref{declarationnameuniqueness, ,Declaration name uniqueness} that there is exactly one 
                    such declaration which is not hidden by any other declaration. 

  
  @end itemize
As an exception to this, if the expression or type expression begins
            with the qualifier keyword @code{package}, then there must be a
            toplevel declaration with the given name defined in the package to which the
            compilation unit belongs. 

  Then the reference is to this unique unhidden declaration, and: 

  
  @itemize @bullet
  
  @item the declaration must be referenceable at the program element, 

  
  @item the type of the declaration must be inferable to the program 
                    element, and 

  
  @item if the declaration is forward-declared, it must be definitely
                    initialized at the program element. 

  
  @end itemize
As a special exception to the above, if there is no declaration with the 
            given name or imported name in scope at the program element and the program element 
            occurs inside a @code{dynamic} block, then the unqualified reference 
            does not refer to any statically typed declaration. 

  If an unqualified reference refers to a member declaration of a type, then
            there is a unique @emph{inheriting or declaring class or interface} 
            for the unqualified reference, that is, the unique class or interface in whose 
            body the unqualified reference occurs, and which declares or inherits the member
            declaration, and for which the member is not hidden at the program element where
            the unqualified reference occurs. 

  
@node qualifiedreferenceresolution
@subsection Qualified reference resolution
@cindex Qualified reference resolution

  A @emph{qualified reference} is: 

  
  @itemize @bullet
  
  @item the type name in a qualified type declaration or type argument, 
                    as defined by @ref{typeexpressions, ,Type expressions}, for example 
                    @code{Buffer} in
                    @code{BufferedReader.Buffer}, 

  
  @item the value, function, or type name in a member expression, as 
                    defined by @ref{memberexpressions, ,Member expressions}, for example 
                    @code{count} in @code{counter.count},
                    @code{split} in @code{text.split()}, or 
                    @code{Buffer} in @code{br.Buffer()}, 

  
  @item the constructor name in a constructor expression, as 
                    defined by @ref{constructorexpressions, ,Constructor expressions}, or 

  
  @item the type name in a qualified type in a static expression, as 
                    defined by @ref{staticexpressions, ,Static expressions}, for example 
                    @code{Buffer} in
                    @code{BufferedReader.Buffer.size}, or the member name 
                    in a static expression, for example @code{iterator} in 
                    @code{Sequence.iterator}, or @code{size} in 
                    @code{BufferedReader.Buffer.size}. 

  
  @end itemize
Every qualified reference has a qualifying type: 

  
  @itemize @bullet
  
  @item For a type declaration, the qualifying type is the full
                    qualified type the qualifies the type name. 

  
  @item For a value reference or callable reference, the 
                    qualifying type is the type of the receiver expression. 

  
  @item For a constructor reference, the qualifying type is the 
                    type of the qualifying base or member expression. 

  
  @item For a static reference, the qualifying type is the full 
                    qualified type the qualifies the type or member name. 

  
  @end itemize
A qualified reference may not have @code{Nothing} as the
            qualifying type. 

  If a program element contains a qualified reference: 

  
  @itemize @bullet
  
  @item the qualifying type must have or inherit at least one member 
                    or nested type with the given name or aliased to the given imported 
                    name, as defined in @ref{importedname, ,Imported name}, which is visible 
                    at the program element, and 

  
  @item if there are multiple visible members with the given name or 
                    imported name, then it is guaranteed by the type system and
                    @ref{declarationnameuniqueness, ,Declaration name uniqueness} that there is exactly 
                    one such member which is not refined by another member, except 

  
  @item if the qualifying type inherits a class or interface that
                    contains the program element, and an un-@code{shared}
                    declaration contained directly in the body of this class or 
                    interface has the same name as a @code{shared} member 
                    of the qualifying type, in which case the un-@code{shared}
                    declaration hides the @code{shared} member, or 

  
  @item if the qualifying type is an intersection type, in which case 
                    there may be multiple members which are not refined by another 
                    member, but where there is exactly one such member that is refined 
                    by each of these members, but is not refined by another member that 
                    is refined by all of these members, except 

  
  @item in the case of certain pathological intersection types, where 
                    two of the intersected types declare distinct members with the same 
                    name, that do not refine any member of a common supertype (in which 
                    case what we actually have are disjoint types that are nevertheless 
                    not considered provably disjoint within the rules of the typesystem), 
                    and in this case the qualified reference is considered illegal. 

  
  @end itemize
Then the reference is to the unique member or nested class. If the 
            program element is contained in the body of a class or interface, and the 
            member declaration directly occurs in the body of the class or interface, 
            and the qualified reference is a value reference or callable reference, and 
            the receiver expression is a self reference to the instance being 
            initialized, then: 

  
  @itemize @bullet
  
  @item the member declaration must be referenceable at the program
                    element, 

  
  @item the type of the member must be inferable to the program 
                    element, and 

  
  @item if the member declaration is forward-declared, it must be 
                    definitely initialized at the program element. 

  
  @end itemize
As a special exception to the above, if the program element occurs inside 
            a @code{dynamic} block, and the the receiver expression has no type, 
            then the qualified reference does not refer to any statically typed declaration. 

  
@node patternsandvariables
@section Patterns and variables
@cindex Patterns and variables

  
      
@menu
      
* controlstructurevariables:: Variables
* patterns:: Patterns
* patternvariables:: Pattern variables
* tuplepatterns:: Tuple patterns
* entrypatterns:: Entry patterns
@end menu

      Destructuring statements, assertions, and some control structures allow inline 
        declaration of a @emph{variables}, which often occur as part of a more
        complex @emph{pattern}. 

  
@smallindentedblock
  Note: the use of the term variable here does not imply any connection
        to the @code{variable} annotation for values. A variable in a destructuring
        statement, assertion, or control structure may not be assigned using a specification
        or assignment statement. 

  
@end smallindentedblock

@node controlstructurevariables
@subsection Variables
@cindex Variables

  A variable is a streamlined form of reference declaration, as defined by 
            @ref{references, ,References}. 

  
@verbatim
TypedVariable: Type MemberName
@end verbatim
In most cases, the explicit type be omitted. 

  
@verbatim
Variable: (Type | "value")? MemberName
@end verbatim
If the explicit type is missing from the declaration, the type of the variable 
            is inferred, according to rules that depend upon the control structure to which 
            the variable belongs. 

  A variable declared by a destructuring statement is a reference scoped to the 
            body in which the destructuring statement occurs. 

  A variable declared by an assertion is a reference scoped to the body in which 
            the @code{assert} statement occurs. 

  A variable declared by a control structure is a reference scoped to the block 
            that immediately follows the variable declaration: 

  
  @itemize @bullet
  
  @item For a variable in an @code{if} condition, the scope of the
                    variable is the @code{if} block. 

  
  @item For a variable in a @code{while} condition, the scope of the
                    variable is the @code{while} block. 

  
  @item For a variable in a @code{for} iterator, the scope of the
                    variable is the @code{for} block. 

  
  @item For a variable in a @code{try} clause, the scope of the 
                    variable is the @code{try} block. 

  
  @item For a variable in a @code{catch} clause, the scope of the 
                    variable is the @code{catch} block. 

  
  @item For a variable in an @code{assert} statement, the scope of the 
                    variable is the body containing the @code{assert} statement. 

  
  @end itemize

@node patterns
@subsection Patterns
@cindex Patterns

  An expression whose type is an instantiation of @code{Sequential}, 
            @code{Sequence}, @code{Tuple}, or @code{Entry} 
            may be assigned to a @emph{pattern}. The type of an expression 
            assigned to a pattern is called the @emph{patterned type}. 

  
@smallindentedblock
  TODO: actually, the following section does not do justice to 
            the compiler, which can actually handle subtypes of these types, including
            type parameters upper bounded by these types. 

  
@end smallindentedblock
Patterns are formed from: 

  
  @itemize @bullet
  
  @item pattern variables, 

  
  @item tuple patterns, and 

  
  @item entry patterns. 

  
  @end itemize

@verbatim
Pattern: Variable | TuplePattern | EntryPattern
@end verbatim

@smallindentedblock
  Note: in a future release of the language, we might introduce
            a more general pattern matching system, allowing pattern matching against
            arbitrary classes. 

  
@end smallindentedblock

@node patternvariables
@subsection Pattern variables
@cindex Pattern variables

  A @emph{pattern variable} is just a variable, as 
            defined above, that occurs as in a pattern. 

  If the variable has an explicit type, then the patterned type
            must be assignable to this type. Otherwise, the type of the variable
            is inferred to be the patterned type. 

  A @emph{variadic pattern variable} is indicated
            with an asterisk. 

  
@verbatim
VariadicVariable: UnionType? "*" MemberName
@end verbatim
Variadic pattern variables only occur in tuple patterns. 

  
@node tuplepatterns
@subsection Tuple patterns
@cindex Tuple patterns

  A tuple pattern comprises a list of @emph{element 
            patterns}, ending in, optionally, a variadic pattern 
            variable called a @emph{variadic} element pattern. 
            Tuple patterns are enclosed in brackets. 

  
@verbatim
TuplePattern: "[" (Pattern ",")* (Pattern | VariadicVariable) "]"
@end verbatim
The patterned type must be an instantiation of the type
            @code{Tuple}, @code{Sequential}, or 
            @code{Sequence} in @code{ceylon.language}.
            Then: 

  
  @itemize @bullet
  
  @item If the tuple pattern has only one element pattern, 
                    and it is variadic, then the patterned type of this variadic 
                    element pattern is just the patterned type of the surrounding 
                    tuple pattern. 

  
  @item Or, if the tuple pattern has only one element pattern, 
                    and it is not variadic, then the patterned type must be a 
                    single-element instantiation @code{[T]} of 
                    @code{Tuple}, and the patterned type of the
                    element pattern is @code{T}. 

  
  @item Otherwise, if the patterned type is an instantiation 
                    @code{Tuple<T,F,R>} of @code{Tuple},
                    then the patterned type of the first element pattern is 
                    @code{F}, and the patterned types of the 
                    remaining element patterns, if any, are determined by 
                    forming a new tuple pattern with patterned type 
                    @code{R} by removing the first element pattern 
                    from the list of element patterns. 

  
  @item Or, if the patterned type is an instantiation 
                    @code{[T+]} of @code{Sequence}, 
                    then there must be exactly two element patterns, and the 
                    second element pattern must be variadic. Then the patterned 
                    type of the first element pattern is @code{T}, 
                    and the patterned type of the second element pattern is 
                    @code{[T*]}. 

  
  @end itemize

@example
value [x, y, z] = [1.0, 2.0, 0.0];
@end example

@example
value [first, *rest] = sequence;
@end example

@smallindentedblock
  Note: Ceylon does not support parallel assignment 
            statements of form @code{value x, y, z = 1.0, 2.0, 0.0;}
            since the infix @code{=} symbol has a higher precedence 
            than the comma @code{,} throughout the language. 

  
@end smallindentedblock

@node entrypatterns
@subsection Entry patterns
@cindex Entry patterns

  An entry pattern comprises a @emph{key pattern},
            followed by an @emph{item pattern}. 

  
@verbatim
EntryPattern: KeyOrItemPattern "->" KeyOrItemPattern
@end verbatim

@verbatim
KeyOrItemPattern: Variable | TuplePattern
@end verbatim
The patterned type must be an instantiation 
            @code{K->V} of the type @code{Entry} in 
            @code{ceylon.language}. Then: 

  
  @itemize @bullet
  
  @item the patterned type of the key pattern is 
                    @code{K}, and 

  
  @item the patterned type of the item pattern is 
                    @code{V}. 

  
  @end itemize

@example
value name->[lat,long] = observatory;
@end example

@node blocksandstatements
@section Blocks and statements
@cindex Blocks and statements

  
      
@menu
      
* expressionstatements:: Expression statements
* controldirectives:: Control directives
* specificationstatements:: Specification statements
* destructuringstatements:: Destructuring statements
* dynamicblocks:: Dynamic blocks
* definitereturn:: Definite return
* definiteinitialization:: Definite initialization
* definiteuninitialization:: Definite uninitialization
@end menu

      A @emph{block} is list of semicolon-delimited statements, 
        control structures, and declarations, surrounded by braces. 

  
@verbatim
Block: "{" (Declaration | Statement)* "}"
@end verbatim
A @emph{statement} is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a destructuring statement,
        a control structure, a control directive, or an assertion. 

  
@verbatim
Statement: ExpressionStatement | Specification | Destructure | Directive | ControlStructure | Dynamic
@end verbatim
A statement or declaration contained in a block may not evaluate a value, 
        invoke a function, instantiate a class, or extend a class whose declaration 
        occurs later in the block. 

  
@node expressionstatements
@subsection Expression statements
@cindex Expression statements

  Only certain expressions are valid statements: 

  
  @itemize @bullet
  
  @item assignment, 

  
  @item prefix or postfix increment or decrement, 

  
  @item invocation of a method, 

  
  @item instantiation of a class. 

  
  @end itemize

@verbatim
ExpressionStatement: ( Assignment | IncrementOrDecrement | Invocation ) ";"
@end verbatim
For example: 

  
@example
x += 1;
@end example

@example
x++;
@end example

@example
print("Hello");
@end example

@example
Main(process.arguments);
@end example

@node controldirectives
@subsection Control directives
@cindex Control directives

  A @emph{control directive} statement ends execution of the 
            current block and forces the flow of execution to resume in some outer scope. 
            They may only occur as the lexically last statement of a block. 

  There are four control directives: 

  
  @itemize @bullet
  
  @item the @code{return} directive---to return a value from 
                a getter or non-@code{void} function or terminate execution of a 
                setter, class initializer, or @code{void} method,
  @item the @code{break} directive---to terminate a loop,
  @item the @code{continue} directive---to jump to the next 
                iteration of a loop, and
  @item the @code{throw} directive---to raise an exception.
  @end itemize

@verbatim
Directive: (Return | Throw | Break | Continue) ";"
@end verbatim
For example: 

  
@example
throw Exception();
@end example

@example
return x+y;
@end example

@example
break;
@end example

@example
continue;
@end example
The @code{return} directive must sequentially occur in the body 
            of a function, getter, setter, or class initializer. In the case of a 
            setter, class initializer, or @code{void} function, no expression may 
            be specified. In the case of a getter or non-@code{void} function, an 
            expression must be specified. The expression type must be assignable to the return 
            type of the function or the type of the value. When the directive is executed, the 
            expression is evaluated to determine the return value of the function or getter. 

  
@verbatim
Return: "return" Expression?
@end verbatim
If the specified expression has no type, or if the function or getter has
            no type, and the directive occurs within a @code{dynamic} block, then 
            the directive is not type-checked at compile time. 

  
@smallindentedblock
  Note: a @code{return} statement returns only from the
            innermost function, getter, setter, or class initializer, even in the case of a
            nested or anonymous function. There are no "non-local returns" in the language. 

  
@end smallindentedblock
The @code{break} directive must sequentially occur in the body 
            of a loop. 

  
@verbatim
Break: "break"
@end verbatim
The @code{continue} directive must sequentially occur in the body 
            of a loop. 

  
@verbatim
Continue: "continue"
@end verbatim
A @code{throw} directive may appear anywhere and may specify an 
            expression, whose type must be a subtype of type @code{Throwable} 
            defined in @code{ceylon.language}. When the directive is executed, the 
            expression is evaluated and the resulting exception is thrown. If no expression is 
            specified, the directive is equivalent to @code{throw Exception()}. 

  
@verbatim
Throw: "throw" Expression?
@end verbatim
If the specified expression has no type, and the directive occurs within a 
            @code{dynamic} block, then the directive is not type-checked at compile 
            time. 

  
@node specificationstatements
@subsection Specification statements
@cindex Specification statements

  A @emph{specification} statement may specify or initialize the 
            persistent value of a forward-declared reference, or specify the implementation of 
            a forward-declared getter or function. 

  
@verbatim
Specification: ValueSpecification | LazySpecification
@end verbatim
The persistent value of a forward-declared reference or the implementation 
            of a forward-declared function may be specified by a @emph{value specification 
            statement}. The value specification statement consists of an unqualified 
            value reference, or a qualified value reference where the receiver expression is
            @code{this}, and an ordinary @code{=} specifier. The value 
            reference must refer to a declaration which sequentially occurs earlier in the body 
            in which the specification statement occurs. 

  
@verbatim
ValueSpecification: ("this" ".")? MemberName Specifier ";"
@end verbatim
The type of the specified expression must be assignable to the type of the 
            reference, or to the callable type of the function. 

  If the specified expression has no type, or if the reference or function has 
            no type, and the specification occurs within a @code{dynamic} block, 
            then the specification is not type-checked at compile time. 

  
@example
String greeting;
if (exists name) @{
    greeting = "hello ``name``";
@}
else @{
    greeting = "hello world";
@}
@end example

@example
String process(String input);
if (normalize) @{
    process = String.normalized;
@}
else @{
    process = (String s) => s;
@}
@end example

@smallindentedblock
  Note: there is an apparent ambiguity here. Is the statement
            @code{x=1;} a value specification statement, or an assignment 
            expression statement? The language resolves this ambiguity by favoring the
            interpretation as a specification statement whenever that interpretation is
            viable. This is a transparent solution, since it accepts strictly more code 
            than the alternative interpretation, and for ambiguous cases the actual 
            semantics are identical between the two interpretations. 

  
@end smallindentedblock
The implementation of forward-declared getter or function may be
            specified using a @emph{lazy specification statement}. The 
            specification statement consists of either: 

  
  @itemize @bullet
  
  @item an unqualified value reference, or a qualified value reference 
                    where the receiver expression is `this`, and a lazy 
                    @code{=>} specifier, or 

  
  @item a unqualified callable reference, or a qualified value reference 
                    where the receiver expression is `this`, one or more parameter lists, 
                    and a lazy specifier. 

  
  @end itemize
The value reference or callable reference must refer to a declaration 
            which sequentially occurs earlier in the body in which the specification 
            statement occurs. 

  A callable reference followed by a parameter list is itself considered 
            a callable reference, called a @emph{parameterized reference}. 
            If the parameter list has type @code{P} then the callable reference 
            must have the exact type @code{R(*P)} for some type 
            @code{R}. Then the type of the parameterized reference is
            @code{R}. 

  
@verbatim
ParameterizedReference: ("this" ".")? MemberName Parameters+
@end verbatim
Thus, the specification statement consists of a parameterized reference
            followed by a lazy specifier. 

  
@verbatim
LazySpecification: (MemberName | ParameterizedReference) LazySpecifier ";"
@end verbatim
The type of the specified expression must be assignable to the type of 
            the parameterized reference, or to the type of the value reference. 

  
@example
String greeting;
if (exists name) @{
    greeting => "hello ``name``";
@}
else @{
    greeting => "hello world";
@}
@end example

@example
String process(String input);
if (normalize) @{
    process(String input) => input.normalized;
@}
else @{
    process(String s) => s;
@}
@end example

@node destructuringstatements
@subsection Destructuring statements
@cindex Destructuring statements

  A @emph{destructuring statement} assigns an expression 
            to a pattern, as defined above in @ref{patterns, ,Patterns}. 

  
@verbatim
Destructure: "value" (TuplePattern | EntryPattern) Specifier ";"
@end verbatim
The type of the specified expression is the patterned type of the
            tuple or entry pattern. 

  
@node dynamicblocks
@subsection Dynamic blocks
@cindex Dynamic blocks

  A @code{dynamic} block allows interoperation with 
            dynamically typed native code. 

  
@verbatim
Dynamic: "dynamic" Block
@end verbatim
Inside a @code{dynamic} block an expression may have 
            no type, as specified in @ref{expressions, ,Expressions}. 

  An expression with no type: 

  
  @itemize @bullet
  
  @item may be specified or assigned to a typed value, as defined
                    in @ref{specificationstatements, ,Specification statements}, 

  
  @item may be passed as the argument of a typed parameter in an
                    invocation expression, as defined in 
                    @ref{directinvocations, ,Direct invocations}, 

  
  @item may be the invoked expression of an invocation, as defined
                    in @ref{invocationexpressions, ,Invocation expressions}, 

  
  @item may be returned by a typed function or getter, or
                    thrown as an exception, as defined in 
                    @ref{controldirectives, ,Control directives}, 

  
  @item may be the operand of an operator expression, as defined in
                    @ref{compoundexpressions, ,Compound expressions}, or 

  
  @item may be the subject of a control structure condition, as 
                    defined in @ref{controlstructureconditions, ,Conditions}, a 
                    @code{switch}, as defined in @ref{switchcaseelse, ,switch/case/else}, 
                    or a @code{for} iterator, as defined in @ref{forelse, ,for/else}.
                     

  
  @end itemize
Furthermore: 

  
  @itemize @bullet
  
  @item a qualified or unqualified reference may not refer to a
                    statically typed declaration, as defined by 
                    @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution} and
                    @ref{qualifiedreferenceresolution, ,Qualified reference resolution}. 

  
  @end itemize
These situations result in @emph{dynamic type checking},
            as defined in @ref{dynamictypechecking, ,Dynamic type checking}, since the usual static
            type checks are impossible. 

  
@smallindentedblock
  Note: within a @code{dynamic} block, Ceylon behaves like
            a language with optional static typing, performing static type checks where possible,
            and dynamic type checking where necessary. 

  
@end smallindentedblock

@node definitereturn
@subsection Definite return
@cindex Definite return

  A sequence of statements may @emph{definitely return.} 

  
  @itemize @bullet
  
  @item A sequence of statements definitely returns if it ends in a 
                    @code{return} or @code{throw} directive, or 
                    in a control structure that definitely returns, or contains an
                    assertion with a condition list that is never satisfied. 

  
  @item A body definitely returns if it contains a list of statements
                    that definitely returns. 

  
  @item An @code{if} conditional definitely returns if it has
                    an @code{else} block and both the @code{if}
                    and @code{else} blocks definitely return, or if its 
                    condition list is always satisfied and the @code{if} block
                    definitely returns, or if its condition list is never satisfied and it 
                    has an @code{else} block that definitely returns. 

  
  @item A @code{switch} conditional definitely returns if all
                    @code{case} blocks definitely return and the @code{else} 
                    block, if any, definitely returns. 

  
  @item A @code{for} loop definitely returns if it has an
                    @code{else} block that definitely returns, and there is
                    no @code{break} directive in the @code{for}
                    block, or if the iterated expression type is a nonempty type, and
                    the @code{for} block definitely returns. 

  
  @item A @code{while} loop definitely returns if its
                    condition list is always satisfied and the @code{while} 
                    block definitely returns. 

  
  @item A @code{try/catch} exception manager definitely 
                    returns if the @code{try} block definitely returns and
                    all @code{catch} blocks definitely return or if the
                    @code{finally} block definitely returns. 

  
  @end itemize
The body of a non-@code{void} method or getter must definitely 
            return. 

  A body may not contain an additional statement, control structure, or
            declaration following a sequence of statements that definitely returns. Such a 
            statement, control structure, or declaration is considered 
            @emph{unreachable}. 

  
@node definiteinitialization
@subsection Definite initialization
@cindex Definite initialization

  A sequence of statements may @emph{definitely initialize} a
            forward-declared declaration. 

  
  @itemize @bullet
  
  @item A sequence of statements definitely initializes a declaration if 
                    one of the statements is a specification statement or assigment 
                    expression for the declaration or a control structure that definitely 
                    initializes the declaration, or if the sequence of statements ends in 
                    a @code{return} or @code{throw} directive, or 
                    contains an assertion with a condition list that is never satisfied. 

  
  @item An @code{if} conditional definitely initializes a 
                    declaration if it has an @code{else} block and both the 
                    @code{if} and @code{else} blocks definitely
                    initialize the declaration, of if its condition list is always satisfied
                    and the @code{if} block definitely initializes the declaration,
                    of if its condition list is never satisfied and it has an 
                    @code{else} block that definitely initializes the 
                    declaration. 

  
  @item A @code{switch} conditional definitely initializes a
                    declaration if all @code{case} blocks definitely initialize 
                    the declaration and the @code{else} block, if any, definitely 
                    initializes the declaration. 

  
  @item A @code{for} loop definitely initializes a declaration 
                    if it has an @code{else} block that definitely initializes 
                    the declaration, and there is no @code{break} directive in 
                    the @code{for} block, or if the iterated expression type is 
                    a nonempty type, and the @code{for} block definitely 
                    initializes the declaration. 

  
  @item A @code{while} loop definitely initializes a declaration
                    if its condition list is always satisfied and the @code{while}
                    block definitely initializes the declaration. 

  
  @item A @code{try/catch} exception manager definitely initializes 
                    a declaration if the @code{try} block definitely initializes the 
                    declaration and all @code{catch} blocks definitely initialize the 
                    declaration or if the @code{finally} block definitely initializes 
                    the declaration. 

  
  @item A constructor of a class definitely initializes a declaration if the 
                    body of the constructor definitely initializes the declaration, or if the 
                    constructor delegates to a constructor which definitely initializes the 
                    declaration. 

  
  @item The constructors of a class definitely initialize a declaration if
                    every non-partial constructor of the class definitely initializes the 
                    declaration. 

  
  @end itemize

@smallindentedblock
  TODO: an assignment expression occurring within a containing expression
            may or may not definitely initialize a value. Specify this! 

  
@end smallindentedblock
If a function or value declaration is referenceable at a certain statement or 
            declaration, it may additionally be considered @emph{definitely initialized} 
            at that statement or declaration. 

  If a function declaration is definitely initialized at a certain statement or 
            declaration if it is referenceable at that statement or declaration and: 

  
  @itemize @bullet
  
  @item it is a parameter, 

  
  @item it is not forward-declared, or 

  
  @item it is forward-declared and is definitely initialized by the sequence of 
                    statements from its declaration to the given statement or declaration. 

  
  @end itemize
As an exception, a member of a class is not considered definitely initialized
            within the @code{extends} clause of the class or of any of its 
            constructors. 

  If a value declaration is definitely initialized at a certain statement or 
            declaration if it is referenceable at that statement or declaration and: 

  
  @itemize @bullet
  
  @item it is a parameter, 

  
  @item it is not forward-declared and the given statement or declaration is not 
                    the value declaration itself, and does not occur within the body of the value 
                    declaration, or 

  
  @item it is forward-declared and is definitely initialized by the sequence of 
                    statements from its declaration to the given statement or declaration. 

  
  @end itemize
A function or value declaration must be definitely initialized wherever any 
            value reference or callable reference to it occurs as an expression within the body 
            in which it is declared. 

  A @code{shared} forward-declared declaration belonging to a class 
            and not annotated @code{late} must be definitely initialized: 

  
  @itemize @bullet
  
  @item at every @code{return} statement of the initializer of the 
                    containing class, and 

  
  @item at the end of the very last expression statement, directive statement, 
                    constructor, or specification statement of the initializer of the containing 
                    class. 

  
  @end itemize
A specification statement for a method or non-@code{variable} 
            reference, getter, or function may not (indirectly) occur in a @code{for} 
            or @code{while} block unless the declaration itself occurs within the same
            @code{for} or @code{while} block. 

  
@smallindentedblock
  TODO: Furthermore, the typechecker does some tricky analysis to
            determine that code like the following can be accepted: 

  
            
@example
Boolean minors;
for (p in people) @{
    if (p.age<18) @{
        minors = true;
        break;
    @}
@}
else @{
    minors = false;
@}
@end example

@end smallindentedblock

@node definiteuninitialization
@subsection Definite uninitialization
@cindex Definite uninitialization

  A sequence of statements may @emph{possibly initialize} a 
            forward-declared declaration. 

  
  @itemize @bullet
  
  @item A sequence of statements possibly initializes a declaration if one of 
                    the statements is a specification statement for the declaration or a control 
                    structure that possibly initializes the declaration. 

  
  @item An @code{if} conditional possibly initializes a declaration 
                    if either the @code{if} block possibly initializes the declaration 
                    and the condition list is not never satisfied, or if the @code{else} 
                    block, if any, possibly initializes the declaration and the condition list is 
                    not always satisfied. 

  
  @item A @code{switch} conditional possibly initializes a declaration 
                    if one of the @code{case} blocks possibly initializes the declaration 
                    or the @code{else} block, if any, possibly initializes the 
                    declaration. 

  
  @item A @code{for} loop possibly initializes a declaration if the 
                    @code{for} block possibly initializes the declaration or if it has 
                    an @code{else} block that possibly initializes the declaration. 

  
  @item A @code{while} loop possibly initializes a declaration if the 
                    @code{while} block possibly initializes the declaration and the
                    condition list is not never satisfied. 

  
  @item A @code{try/catch} exception manager possibly initializes a 
                    declaration if the @code{try} block possibly initializes the 
                    declaration, if one of the @code{catch} blocks possibly initializes 
                    the declaration, or if the @code{finally} block possibly initializes 
                    the declaration. 

  
  @item A constructor of a class possibly initializes a declaration if the body 
                    of the constructor possibly initializes the declaration, or if the constructor 
                    delegates to a constructor which possibly initializes the declaration. 

  
  @item The constructors of a class possibly initialize a declaration if at least 
                    one constructor of the class possibly initializes the declaration. 

  
  @end itemize
A forward-declared declaration is considered @emph{definitely uninitialized} 
            at a certain statement or declaration if: 

  
  @itemize @bullet
  
  @item it is not possibly initialized by the sequence of statements from its declaration 
                    to the given statement or declaration, 

  
  @item the statement does not (indirectly) occur in the @code{for} block or
                    @code{else} block of a @code{for} loop with a @code{for} 
                    block that possibly initializes it, 

  
  @item the statement does not (indirectly) occur in the @code{while} block of 
                    a @code{while} loop with a @code{while} block that possibly 
                    initializes it, 

  
  @item the statement does not (indirectly) occur in a @code{catch} block 
                    of a @code{try/catch} exception manager with a @code{try} block 
                    that possibly initializes it, and 

  
  @item the statement does not (indirectly) occur in the @code{finally} block 
                    of a @code{try/catch} exception manager with a @code{try} block 
                    or @code{catch} block that possibly initializes it. 

  
  @end itemize
A function or non-@code{variable} value declaration must be definitely 
            uninitialized wherever any value reference or callable reference to it occurs as a specification 
            statement within the body in which it is declared. 

  
@node controlstructureconditions
@section Conditions
@cindex Conditions

  
      
@menu
      
* booleanconditions:: Boolean conditions
* assignabilityconditions:: Assignability conditions
* existencenonemptinessconditions:: Existence and nonemptiness conditions
* caseconditions:: Case conditions
@end menu

      Assertions and certain control structures have a @emph{condition list}. 
        A condition list has one or more @emph{conditions}. 

  
@verbatim
ConditionList: "(" Condition ("," Condition)* ")"
@end verbatim
Any condition in the list may refer to a variable defined in a condition that occurs
        earlier in the list. 

  A condition list is considered to be @emph{always satisfied} if
        every condition in the list is always satisfied. A condition list is considered to be 
        @emph{never satisfied} if some condition in the list is never satisfied. 

  There are four kinds of condition: 

  
  @itemize @bullet
  
  @item a @emph{boolean condition} is satisfied when a boolean expression
                evaluates to @code{true}, 

  
  @item an @emph{assignabilty condition} is satisfied when an expression
                 evaluates to an instance of a specified type, 

  
  @item an @emph{existence condition} is satisfied when an expression 
                evaluates to a non-null value, and 

  
  @item a @emph{nonemptiness condition} is satisfied when an expression 
                evaluates to a non-null, non-empty value. 

  
  @end itemize

@verbatim
Condition: BooleanCondition | IsCondition | ExistsOrNonemptyCondition
@end verbatim

@smallindentedblock
  TODO: are we going to support @code{satisfies} conditions on 
        type parameters, for example, @code{if (Element satisfies Object)}, to allow
        refinement of its upper bounds? 

  
@end smallindentedblock

@node booleanconditions
@subsection Boolean conditions
@cindex Boolean conditions

  A boolean condition is just an expression. 

  
@verbatim
BooleanCondition: Expression
@end verbatim
The expression must be of type @code{Boolean}. 

  A boolean condition is considered to be @emph{always satisfied}
            if it is a value reference to @code{true}. A boolean condition is 
            considered to be @emph{never satisfied} if it is a value reference 
            to @code{false}. 

  
@smallindentedblock
  TODO: Should we do some more sophisticated static analysis to 
            determine if a condition is always/never satisfied? 

  
@end smallindentedblock

@node assignabilityconditions
@subsection Assignability conditions
@cindex Assignability conditions

  An assignability condition may contain either: 

  
  @itemize @bullet
  
  @item an unqualified value reference to a non-@code{variable},
                    non-@code{default} reference, or 

  
  @item an inline variable declaration together with an expression. 

  
  @end itemize

@verbatim
IsCondition: "!"? "is" (TypedVariable Specifier | Type MemberName)
@end verbatim
A @emph{negated} assignability condition is one which starts 
            with @code{!}. 

  
@smallindentedblock
  Note: the prefix form @code{is Type val} reads a 
            little unnaturally in English. But for a condition with a specifier, the 
            form @code{is Type val = expression} is much less ambiguous than
            @code{val = expression is Type}, which looks like an assignment
            of a boolean value. 

  
@end smallindentedblock

@smallindentedblock
  TODO: are we going to allow @code{is Type this} and 
            @code{is Type outer} to narrow the type of a self reference? 

  
@end smallindentedblock
The type of the value reference or expression in an assignability condition 
            must be: 

  
  @itemize @bullet
  
  @item in the case of a condition which is not negated, a type which is not 
                    a subtype of the specified type, but whose intersection with the specified 
                    type is not exactly @code{Nothing}, except 

  
  @item in the case of a negated condition, a type whose intersection with the 
                    specified type is not exactly @code{Nothing}, and which is not a 
                    supertype of the specified type, or 

  
  @end itemize

@smallindentedblock
  Note: an assignability condition may narrow to an intersection or union 
            type. 

  
            
@example
if (is Printable&Identifiable obj) @{ ... @}
@end example

            
@example
if (is Integer|Float num) @{ ... @}
@end example

@end smallindentedblock
For an assignability condition with a conditional expression of type 
            @code{T} and specified type @code{X}: 

  
  @itemize @bullet
  
  @item if the condition contains a value reference, the value will be treated 
                    by the compiler as having type @code{T&X} inside the block or 
                    expression that immediately follows the condition, and, if this is the only 
                    condition in the condition list, as having type @code{T~X} inside 
                    the following @code{else} block or expression if any, unless 

  
  @item it is a @code{!is} negated assignability condition, in which 
                    case the value will be treated by the compiler as having type @code{T~X} 
                    inside the block or expression that immediately follows the condition, and, if 
                    this is the only condition in the condition list, as having type 
                    @code{T&X} inside the following @code{else} block 
                    or expression if any. 

  
  @end itemize
Where, for any given types @code{T} and @code{X}, the type
            @code{T~X} is determined as follows: 

  
  @itemize @bullet
  
  @item if @code{X} covers @code{T}, as defined by
                    @ref{coverage, ,Coverage}, then @code{T~X} is 
                    @code{Nothing}, 

  
  @item if @code{T} is an intersection type, then @code{T~X} 
                    is the intersection of all @code{U~X} for every type @code{U} 
                    in the intersection, 

  
  @item if @code{T} is a union type, then @code{T~X} is 
                    the union of all @code{U~X} for every type @code{U} in 
                    the union, 

  
  @item if @code{T} is a type parameter, then @code{T~X} 
                    is @code{T&<U~X>} when @code{U} is the 
                    intersection of all upper bounds on @code{T}, or @code{Anything} 
                    if @code{T} has no declared upper bounds, 

  
  @item if @code{T} is an enumerated type or an instantiation of a 
                    generic enumerated type, then @code{T~X} is the union of all 
                    @code{C~X} for every case @code{C} of 
                    @code{T}, or, 

  
  @item otherwise, @code{T~X} is @code{T}. 

  
  @end itemize
If you prefer, you can think of the following: 

  
@example
Transaction tx = ...
if (is Usable tx) @{ ... @}
@end example
As an abbreviation of: 

  
@example
if (is Transaction&Usable tx = tx) @{ ... @}
@end example
Where the @code{tx} declared by the condition hides the outer 
            declaration of @code{tx} inside the block that follows. 

  As a special exception to the above, if a condition occurs in a 
            @code{dynamic} block, and the conditional expression has no type, 
            and the condition contains a value reference, 
            then: 

  
  @itemize @bullet
  
  @item if the condition is not negated, the value will be treated by the 
                    compiler as having type @code{X} where @code{X} 
                    is the specified type, inside the block or expression that immediately 
                    follows the condition, or, otherwise 

  
  @item if the condition is negated, the value will be treated by the compiler 
                    as having no type. 

  
  @end itemize

@node existencenonemptinessconditions
@subsection Existence and nonemptiness conditions
@cindex Existence and nonemptiness conditions

  An existence or nonemptiness condition may contain either: 

  
  @itemize @bullet
  
  @item an unqualified value reference to a non-@code{variable},
                    non-@code{default} reference, or 

  
  @item a pattern together with an expression. 

  
  @end itemize

@verbatim
ExistsOrNonemptyCondition: "!"? ("exists" | "nonempty") (Pattern Specifier | MemberName)
@end verbatim
A @emph{negated} condition is one which starts with 
            @code{!}. 

  The type of the value reference or expression must be: 

  
  @itemize @bullet
  
  @item in the case of an existence condition or negated existence condition, 
                    a type whose intersection with @code{Null} is not exactly 
                    @code{Nothing} and whose intersection with @code{Object} 
                    is not exactly @code{Nothing}, or 

  
  @item in the case of a nonemptiness condition or a negated nonemptiness 
                    condition, a subtype of @code{Anything[]?} whose intersection with 
                    @code{[]} is not exactly @code{Nothing}, and whose 
                    intersection with @code{[Nothing+]} is not exactly 
                    @code{Nothing}. 

  
  @end itemize
Every existence or nonemptiness condition is equivalent to---and may be 
            considered an abbreviation of---an assignability condition: 

  
  @itemize @bullet
  
  @item @code{exists x} is equivalent to @code{is Object x}, 
                    and 

  
  @item @code{!exists x} is equivalent to @code{is Null x}, 

  
  @item @code{nonempty x} is equivalent to @code{is [E+] x}
                    where @code{x} is an expression whose type has the principal 
                    instantiation @code{E[]?}, and 

  
  @item @code{!nonempty x} is equivalent to @code{is [] x}. 

  
  @end itemize
For an existence condition which is not negated: 

  
  @itemize @bullet
  
  @item if the condition has a pattern, the patterned type is 
                    @code{T&Object}, where the specifier expression is of type 
                    @code{T}, and, if the pattern is a pattern variable, the declared 
                    type of the variable, if any, must be a subtype of @code{Object}, 
                    or 

  
  @item if the condition contains a value reference, the value will be treated 
                    by the compiler as having type @code{T&Object} inside the block 
                    or expression that immediately follows the condition, where the conditional 
                    expression is of type @code{T}, and, if this is the only condition 
                    in the condition list, as having the type @code{T&Null} inside 
                    the following @code{else} block or expression if any. 

  
  @end itemize
For a negated existence condition: 

  
  @itemize @bullet
  
  @item if the condition has a pattern, it must be a pattern variable, and the
                    patterned type is @code{T&Null}, where the specifier expression 
                    is of type @code{T}, and the declared type of the variable, if any, 
                    must be @code{Null}, or 

  
  @item if the condition contains a value reference, the value will be treated 
                    by the compiler as having type @code{T&Null} inside the block 
                    or expression that immediately follows the condition, where the conditional 
                    expression is of type @code{T}, and, if this is the only condition 
                    in the condition list, as having the type @code{T&Object} 
                    inside the following @code{else} block or expression if any. 

  
  @end itemize
For a nonemptiness condition which is not negated: 

  
  @itemize @bullet
  
  @item if the condition has a pattern, the patterned type is
                    @code{T&[E+]}, where the specifier expression is of type 
                    @code{T} and @code{T} has the principal instantiation 
                    @code{E[]?}, and, if the pattern is a pattern variable, the declared 
                    type of the variable, if any, must be a subtype of @code{[Anything+]}, 
                    or 

  
  @item if the condition contains a value reference, the value will be treated 
                    by the compiler as having type @code{T&[E+]} inside the block 
                    or expression that immediately follows the condition, where the conditional 
                    expression is of type @code{T} and @code{T} has the 
                    principal instantiation @code{E[]?}, and, if this is the only 
                    condition in the condition list, as having the type @code{T&[]} 
                    inside the following @code{else} block or expression if any. 

  
  @end itemize
For a negated nonemptiness condition: 

  
  @itemize @bullet
  
  @item if the condition has a pattern, it must be a pattern variable, and the
                    patterned type is @code{T&[]}, where the specifier expression is 
                    of type @code{T} and @code{T} has the principal 
                    instantiation @code{E[]?}, and the declared type of the variable,
                    if any, must be @code{[]}, or 

  
  @item if the condition contains a value reference, the value will be treated 
                    by the compiler as having type @code{T&[]} inside the block or 
                    expression that immediately follows the condition, where the conditional 
                    expression is of type @code{T} and @code{T} has the 
                    principal instantiation @code{E[]?}, and, if this is the only 
                    condition in the condition list, as having the type @code{T&[E+]} 
                    inside the following @code{else} block or expression if any. 

  
  @end itemize
If you prefer, you can think of the following: 

  
@example
if (exists name) @{ ... @}
@end example
As an abbreviation of: 

  
@example
if (exists String name = name) @{ ... @}
@end example
Where the @code{name} declared by the condition hides the outer 
            declaration of @code{name} inside the block that follows. 

  As a special exception to the above, if a condition occurs in a @code{dynamic} 
            block, and the conditional expression has no type, and the condition contains a value reference, 
            then the value will be treated by the compiler as having no type. 

  
@node caseconditions
@subsection Case conditions
@cindex Case conditions

  The branches of a @code{switch} conditional each belong to a 
            @emph{case condition}. There are two kinds of case condition: 

  
  @itemize @bullet
  
  @item a @emph{value case}---a list of string literals, 
                    character literals, integer literals, negated integer literals, value 
                    references to value constructors, and/or value references to anonymous 
                    classes, or 

  
  @item a @emph{type case}---an assignability condition 
                    of form @code{is V} for some type @code{V}. 

  
  @end itemize
For a value case, each value reference must be to an anonymous class that
            is a subtype of @code{Identifiable|Null} or to a value constructor 
            for a class that is a subtype of @code{Identifiable}. 

  
@verbatim
CaseCondition: "(" (ValueCase | TypeCase) ")"
@end verbatim

@verbatim
ValueCase: CaseValue ("|" CaseValue)*
@end verbatim

@verbatim
TypeCase: "is" Type
@end verbatim

@verbatim
CaseValue: LiteralCase | BaseExpression
@end verbatim

@verbatim
LiteralCase: "-"? IntegerLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral
@end verbatim
Every case condition has a type: 

  
  @itemize @bullet
  
  @item for a value case, the type is the union of the types of the values, 
                    and 

  
  @item for a type case, the type is the specified type. 

  
  @end itemize

@smallindentedblock
  Note: to each value constructor, the compiler assigns an internal
            type which is a subtype of the type of the class to which the constructor belongs.
            The union of all internal value constructor types for value constructors listed 
            in the @code{of} clause of the class declaration covers the class 
            type. 

  
@end smallindentedblock
For a case of type @code{U} of a @code{switch} with 
            switched type @code{V}, as defined below in 
            @ref{switchcaseelse, ,switch/case/else}: 

  
  @itemize @bullet
  
  @item the intersection type @code{V&U} must not be exactly 
                    @code{Nothing}, and 

  
  @item if the case is a type case, the @code{switch} variable, 
                    or, if there is no inline variable declared by the @code{switch}, 
                    the value referred by the @code{switch} expression, will be 
                    treated by the compiler as having the type @code{V&U} inside 
                    the @code{case} block. 

  
  @end itemize
As a special exception to the above, if a @code{switch} occurs 
            in a @code{dynamic} block, and there is no switched type, the 
            @code{switch} variable, or the value referred by the 
            @code{switch} expression will be treated by the compiler as having 
            the type @code{V} inside the @code{case} block. 

  
@smallindentedblock
  Note: a type case may narrow to an intersection or union type. 

  
            
@example
case (is Persistent & Serializable) @{ ... @}
@end example

            
@example
case (is Integer | Float) @{ ... @}
@end example

@end smallindentedblock

@node controlstructures
@section Control structures and assertions
@cindex Control structures and assertions

  
      
@menu
      
* ifelse:: if/else
* switchcaseelse:: switch/case/else
* forelse:: for/else
* while:: while
* trycatchfinally:: try/catch/finally
* assertions:: Assertions
@end menu

      Control of execution flow may be achieved using control directives and 
        @emph{control structures}. Control structures include conditionals, 
        loops, and exception management. 

  Ceylon provides the following control structures: 

  
  @itemize @bullet
  
  @item the @code{if/else} conditional---for controlling 
                execution based on a boolean condition, type condition, or check for a 
                non-null or non-empty value, 

  
  @item the @code{switch/case/else} conditional---for 
                controlling execution using an enumerated list of values or types, 

  
  @item the @code{while} loop---for loops which terminate 
                based on a boolean condition, type condition, or check for a non-null or 
                non-empty value, 

  
  @item the @code{for/else} loop---for looping over elements 
                of an iterable object, and 

  
  @item the @code{try/catch/finally} exception manager---for 
                managing exceptions and controlling the lifecycle of objects which require 
                explicit destruction. 

  
  @end itemize

@verbatim
ControlStructure: IfElse | SwitchCaseElse | While | ForFail | TryCatchFinally | Assertion
@end verbatim

@smallindentedblock
  Control structures are not considered to be expressions, and therefore 
        do not evaluate to a value. However, comprehensions, specified in 
        @ref{comprehensions, ,Comprehensions}, and conditional expressions, specified in 
        @ref{miscexpressions, ,Conditional expressions, let expressions, and anonymous class expressions} are part of the expression syntax and share much of 
        the syntax and semantics of the control structures they resemble. 

  
@end smallindentedblock
@emph{Assertions} are runtime checks upon program invariants, or 
        function preconditions and postconditions. An assertion failure represents a bug in
        the program, and is not considered recoverable. Therefore, assertions should not be 
        used to control "normal" execution flow. 

  
@smallindentedblock
  Note: of course, in certain circumstances, it is appropriate to handle
        the exception that results from an assertion failure, for example, to display a message
        to the user, or in a testing framework to aggregate and report the failures that occurred
        in test assertions. A test failure may be considered "normal" occurrence from the point 
        of view of a testing framework, but it's not "normal" in the sense intended above.
         

  
@end smallindentedblock

@node ifelse
@subsection if/else
@cindex if/else

  The @code{if/else} conditional has the following form: 

  
@verbatim
IfElse: If Else?
@end verbatim

@verbatim
If: "if" ConditionList Block
@end verbatim

@verbatim
Else: "else" (Block | IfElse)
@end verbatim
Every @code{if/else} conditional construct has an 
            @code{if} clause. The construct may optionally include: 

  
  @itemize @bullet
  
  @item a chain of an arbitrary number of child 
                    @code{else if} clauses, and/or 

  
  @item an @code{else} clause. 

  
  @end itemize

@example
if (payment.amount <= account.balance) @{
    account.balance -= payment.amount;
    payment.paid = true;
@}
else @{
    throw NotEnoughMoneyException();
@}
@end example

@example
shared void welcome(User? user) @{
    if (exists user) @{
        print("Welcome back, ``user.name``!");
    @}
    else @{
        print("Welcome to Ceylon!");
    @}
@}
@end example

@example
if (is CardPayment p = order.payment, 
        !p.paid) @{
    p.card.charge(total);
@}
@end example

@node switchcaseelse
@subsection switch/case/else
@cindex switch/case/else

  The @code{switch/case/else} conditional has the following 
            form: 

  
@verbatim
SwitchCaseElse: Switch Case+ Else?
@end verbatim
Every @code{switch} conditional has a
            @code{switch} clause. 

  
@verbatim
Switch: "switch" "(" SwitchVariableOrExpression ")"
@end verbatim
The @code{switch} clause has a @emph{switched
            expression}, either: 

  
  @itemize @bullet
  
  @item an expression, or 

  
  @item an inline variable declaration together with a specified 
                    expression. 

  
  @end itemize

@verbatim
SwitchVariableOrExpression: Expression | Variable Specifier
@end verbatim
The @emph{switched type} is the type of the expression or 
            inline variable. 

  
@smallindentedblock
  Note: there is an ambiguity here between assignment expressions
            and inline variable declarations. This ambiguity is resolved in favor of 
            interpreting the switched expression as a variable declaration. Therefore, a
            switched expression in a @code{switch} clause may not be an 
            assignment expression. 

  
@end smallindentedblock
If a @code{switch} has a type case condition, and does not
            declare an inline variable, then the switched expression must be an unqualified 
            value reference to a non-@code{variable}, non-@code{default} 
            reference. 

  In addition, every @code{switch} conditional must include: 

  
  @itemize @bullet
  
  @item a chain of one or more child @code{case} clauses, 
                    and, 

  
  @item optionally, a chain of an arbitrary number of child 
                    @code{else if} clauses, and/or 

  
  @item optionally, an @code{else} clause. 

  
  @end itemize

@verbatim
Case: "case" CaseCondition Block
@end verbatim
Two @code{case}s are said to be @emph{disjoint} 
            if: 

  
  @itemize @bullet
  
  @item the intersection of the types of their case conditions is 
                    exactly @code{Nothing}, as defined by 
                    @ref{disjointtypes, ,Disjoint types}, or 

  
  @item if they are both value cases with no literal value or 
                    anonymous class value reference in common. 

  
  @end itemize
In every @code{switch} statement, all @code{case}s 
            must be mutually disjoint. 

  A @code{switch} is @emph{exhaustive} if there 
            are no literal values in its @code{case}s, and the union type formed 
            by the types of the case conditions of the @code{switch} covers the 
            switched type, as defined by @ref{coverage, ,Coverage}. If no @code{else} 
            block is specified, the @code{switch} must be exhaustive. 

  
@smallindentedblock
  Note: On the other hand, even if the @code{switch} 
            @emph{is} exhaustive, an @code{else} block may be 
            specified, in order to allow a @code{switch} that accommodates 
            additional cases without resulting in a compilation error. 

  
@end smallindentedblock
As a special exception to the above, if a @code{switch} occurs 
            in a @code{dynamic} block, and the switched expression has no type, 
            the cases are not statically type-checked for exhaustion. 

  If an @code{else} block is specified, then the @code{switch} 
            variable or, if there is no inline variable declared by the @code{switch}, 
            the value referred by the @code{switch} expression, will be treated 
            by the compiler as having the type @code{V~U} inside the 
            @code{else} block, where @code{V} is the switched type, 
            and @code{U} is the union type formed by the types of the case 
            conditions of the @code{switch}. 

  
@example
Boolean? maybe = ... ;
switch (maybe) 
case (null | false) @{
    return false;
@}
case (true) @{ 
    return true;
@}
@end example

@example
Integer|Float number = ... ;
switch (number)
case (is Integer) @{ 
    return sqrt(number.float);
@} 
case (is Float) @{ 
    return sqrt(number);
@}
@end example

@node forelse
@subsection for/else
@cindex for/else

  The @code{for/else} loop has the following form: 

  
@verbatim
ForFail: For Fail?
@end verbatim

@verbatim
For: "for" ForIterator Block
@end verbatim

@verbatim
Fail: "else" Block
@end verbatim
Every @code{for/else} conditional construct has an 
            @code{for} clause. The construct may optionally include an 
            @code{else} clause, as specified in 
            @ref{executionofloops, ,Execution of loops}. 

  The @code{for} iterator has an @emph{iterator 
            pattern} and an @emph{iterated expression} 
            that contains the range of values to be iterated. 

  
@verbatim
ForIterator: "(" Pattern "in" Expression ")"
@end verbatim
The type of the iterated expression must have some principal 
            supertype instantiation @code{@{T*@}} or @code{@{T+@}} 
            of @code{Iterable} in @code{ceylon.language}. 
            Then the patterned type of the iterator pattern is @code{T}. 

  As a special exception to the above, if a @code{for} 
            occurs in a @code{dynamic} block, and the iterated expression 
            has no type, the iterator is not statically type-checked. If the iteration 
            variable does not declare an explicit type, the iteration variable has no 
            type. 

  
@example
for (p in people) @{ 
    print(p.name);
@}
@end example

@example
variable Float sum = 0.0;
for (i in -10..10) @{
    sum += x[i] else 0.0;
@}
@end example

@example
for (word -> freq in wordFrequencyMap) @{ 
    print("The frequency of ``word`` is ``freq``."); 
@}
@end example

@example
for (p in group) @{
    if (p.age >= 18) @{
        log.info("Found an adult: ``p.name``.");
        break;
    @}
@}
else @{
    log.info("No adult in group.");
@}

@end example

@node while
@subsection while
@cindex while

  The @code{while} loop has the form: 

  
@verbatim
While: LoopCondition Block
@end verbatim
The loop condition list determines when the loop terminates. 

  
@verbatim
LoopCondition: "while" ConditionList
@end verbatim

@smallindentedblock
  TODO: does @code{while} need an @code{else} 
            block? Python has it, but what is the real usecase? 

  
@end smallindentedblock

@example
variable Integer n=0;
variable [Integer*] seq = [];
while (n<=max) @{
    seq=seq.withTrailing(n);
    n+=step(n);
@}
@end example

@node trycatchfinally
@subsection try/catch/finally
@cindex try/catch/finally

  The @code{try/catch/finally} exception manager has the 
            form: 

  
@verbatim
TryCatchFinally: Try Catch* Finally?
@end verbatim

@verbatim
Try: "try" ResourceList? Block
@end verbatim

@verbatim
ResourceList: "(" Resource ("," Resource)* ")"
@end verbatim

@verbatim
Catch: "catch" "(" Variable ")" Block
@end verbatim

@verbatim
Finally: "finally" Block
@end verbatim
Every @code{try} conditional construct has a
            @code{try} clause. The construct may optionally include: 

  
  @itemize @bullet
  
  @item a chain of an arbitrary number of child 
                    @code{catch} clauses, and/or 

  
  @item a @code{finally} clause, as 
                    specified in @ref{exceptionhandling, ,Exception handling}. 

  
  @end itemize
Each @code{catch} block defines a variable. The type 
            of the variable must be assignable to @code{Throwable} in
            @code{ceylon.language}. If no type is explicitly specified, 
            the type is inferred to be @code{Exception}. 

  
@smallindentedblock
  Note: a @code{catch} block type may be a union 
            or intersection type: 

  
            
@example
catch (NotFoundException|DeletedException e) @{ ... @}
@end example

@end smallindentedblock
If there are multiple @code{catch} blocks in a certain
            control structure, then: 

  
  @itemize @bullet
  
  @item The type of a @code{catch} variable may not be 
                    a subtype of any catch variable of an earlier @code{catch} 
                    block belonging to the same control structure. 

  
  @item If the type of a @code{catch} variable is a union
                    type @code{E1|E2|...|En} then no member @code{Ei}
                    of the union may be a subtype of any catch variable of an earlier 
                    @code{catch} block belonging to the same control 
                    structure. 

  
  @end itemize
The @code{try} block may have a list of @emph{resource
            expressions}, each of which may produce either: 

  
  @itemize @bullet
  
  @item a @emph{destroyable resource}, or 

  
  @item an @emph{obtainable resource}. 

  
  @end itemize

@verbatim
Resource: Expression | Variable Specifier
@end verbatim

@smallindentedblock
  Note: there is an ambiguity here between assignment expressions
            and inline variable declarations. This ambiguity is resolved in favor of 
            interpreting the resource expression as a variable declaration. Therefore, a
            resource expression in a @code{try} clause may not be an 
            assignment expression. 

  
@end smallindentedblock
A destroyable resource expression is: 

  
  @itemize @bullet
  
  @item an instantiation expression, or 

  
  @item an inline variable declaration together with 
                an instantiation expression. 

  
  @end itemize
The instantiation expression must be of type assignable to
            @code{Destroyable} in @code{ceylon.language}. 

  An obtainable resource expression is: 

  
  @itemize @bullet
  
  @item an expression, or 

  
  @item an inline variable declaration together with 
                an expression. 

  
  @end itemize
The expression must be of type assignable to 
            @code{Obtainable} in @code{ceylon.language}. 

  If no type is explicitly specified for a resource variable, the 
            type of the variable is inferred to be the type of the expression. 

  
@example
try (File(path).lock) @{
    file.open(write);
    ...
@}
catch (FileNotFoundException fnfe) @{
    print("file not found: ``path``");
@}
catch (FileReadException fre) @{
    print("could not read from file: ``path``");
@}
finally @{
    assert (file.closed);
@}
@end example

@example
try (Transaction()) @{
    try (s = Session()) @{
        return s.get(Person, id);
    @}
    catch (NotFoundException|DeletedException e) @{
        return null;
    @}
@}
@end example

@node assertions
@subsection Assertions
@cindex Assertions

  An assertion has an asserted condition list and, optionally, 
            an annotation list. 

  
@verbatim
Assertion: Annotations "assert" ConditionList ";"
@end verbatim
The message carried by the assertion failure may be specified
            using a @code{doc} annotation. 

  
@example
"total must be less than well-defined bound"
assert (exists bound, total<bound);
@end example
If the assertion contains an assignability, existence, or 
            nonemptiness condition containing a value reference then the compiler 
            treats the referenced value as having a narrowed type at program 
            elements that occur in the lexical scope of the assertion. 

  
@example
@{Element*@} elements = ... ;
assert (nonempty elements);
Element first = elements.first;
@end example

@smallindentedblock
  TODO: how can we support interpolation in the assertion
            failure message? 

  
            
@example
assert (total<bound) 
else "total must be less than ``bound``";
@end example

            
@end smallindentedblock

@node expressions
@chapter Expressions
@cindex Expressions

@menu
  
* literalvalues:: Literal values
* stringtemplates:: String templates
* selfreferences:: Self references
* anonymousfunctions:: Anonymous functions
* compoundexpressions:: Compound expressions
* invocationexpressions:: Invocation expressions
* miscexpressions:: Conditional expressions, let expressions, and anonymous class expressions
* operators:: Operators
* metamodelexpressions:: Metamodel expressions
* referenceexpressions:: Reference expressions
@end menu

  An @emph{expression} produces a value when executed. An 
    algorithm expressed using functions and expressions, rather than sequences 
    of statements is often easier to understand and refactor. Therefore, Ceylon
    has a highly flexible expressions syntax. Expressions are formed from: 

  
  @itemize @bullet
  
  @item literal values, string templates, and self references, 

  
  @item evaluation and assignment of values, 

  
  @item invocation of functions and instantiation of classes, 

  
  @item callable references, static references, and anonymous functions, 

  
  @item comprehensions, 

  
  @item metamodel references, 

  
  @item enumeration of iterables and tuples, and 

  
  @item operators. 

  
  @end itemize
Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    a value or parameter, Ceylon considers the @emph{type} of the 
    expression (the type of the objects that are produced when the expression 
    is evaluated). An expression is assignable to a program element if the type 
    of the expression is assignable to the declared type of the program 
    element. 

  Within a @code{dynamic} block, an expression may have no 
    type, in the sense that its type can not be determined using static analysis
    of the code. 

  
@node literalvalues
@section Literal values
@cindex Literal values

  
      
@menu
      
* naturalnumber:: Integer number literals
* floatnumber:: Floating point number literals
* character:: Character literals
* string:: Character string literals
@end menu

      Ceylon supports literal values of the following types: 

  
  @itemize @bullet
  
  @item @code{Integer} and @code{Float}, 

  
  @item @code{Character}, and 

  
  @item @code{String}. 

  
  @end itemize
The types @code{Integer}, @code{Float}, 
        @code{Character}, and @code{String} are defined in the 
        module @code{ceylon.language}. 

  
@smallindentedblock
  Note: Ceylon does not need a special syntax for @code{Boolean} 
        literal values, since @code{Boolean} is just a class with the cases 
        @code{true} and @code{false}. Likewise, @code{null} 
        is just the singleton value of an anonymous class. 

  
@end smallindentedblock

@verbatim
Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral
@end verbatim
All literal values are instances of immutable types. The value of a literal 
        expression is an instance of the type. How this instance is produced is not specified 
        here. 

  
@node naturalnumber
@subsection Integer number literals
@cindex Integer number literals

  An integer literal, as defined in 
            @ref{numericliterals, ,Numeric literals}, is an expression of type 
            @code{Integer}, representing a numeric integer. 

  
@example
Integer five = 5;
@end example

@example
Integer mask = $1111_0000;
@end example

@example
Integer white = #FFFF;
@end example

@node floatnumber
@subsection Floating point number literals
@cindex Floating point number literals

  A floating point literal, as defined in 
            @ref{numericliterals, ,Numeric literals}, is an expression of type 
            @code{Float}, a floating-point representation of 
            a numeric value. 

  
@example
shared Float pi = 3.14159;
@end example

@node character
@subsection Character literals
@cindex Character literals

  A single character literal, as defined in 
            @ref{characterliterals, ,Character literals}, is an expression of type 
            @code{Character}, representing a single 32-bit
            Unicode character. 

  
@example
if (exists ch=string[i], ch == '+') @{ ... @}
@end example

@node string
@subsection Character string literals
@cindex Character string literals

  A character string literal or verbatim string, as defined 
            in @ref{stringliterals, ,String literals}, is an expression of type
            @code{String}, representing a sequence of Unicode
            characters. 

  
@example
person.name = "Gavin King";
@end example

@example
print("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");
@end example

@example
String verbatim = """A verbatim string can have \ or a " in it."""";
@end example

@node stringtemplates
@section String templates
@cindex String templates

  A character @emph{string template} contains interpolated 
        expressions, surrounded by character string fragments. 

  
@verbatim
StringTemplate: StringStart Expression (StringMid Expression)* StringEnd
@end verbatim
Each interpolated expression contained in the string template must have 
        a type assignable to @code{Object} defined in 
        @code{ceylon.language}. 

  
@example
print("Hello, ``person.firstName`` ``person.lastName``, the time is ``Time()``.");
@end example

@example
print("1 + 1 = ``1 + 1``");
@end example
A string template is an expression of type @code{String}. 

  
@node selfreferences
@section Self references
@cindex Self references

  
      
@menu
      
* this:: this
* outer:: outer
* super:: super
@end menu

      The type of the following expressions depends upon the context in which 
        they appear. 

  
@verbatim
SelfReference: "this" | "super" | "outer"
@end verbatim
A self reference expression may not occur outside of a class or 
        interface body. 

  The @emph{immediately containing class or interface} for
        a program element is the class or interface in which the program element 
        occurs, and which contains no other class or interface in which the program 
        element occurs. If there is no such class or interface, the program element
        has no immediately containing class or interface. 

  A @code{this}, @code{outer}, or 
        @code{super} self reference must have an immediately containing 
        class or interface. An @code{outer} self reference must have
        an immediately containing class or interface for its immediately containing 
        class or interface. 

  
@smallindentedblock
  
        Note: the keyword @code{package} is not an expression, and 
        thus does not have a well-defined type. However, it may be used to qualify 
        and disambiguate a value reference or callable reference. A value reference or 
        callable reference qualified by the keyword @code{package} always 
        refers to a toplevel member of the containing package, never to an imported 
        declaration or nested declaration, as defined by 
        @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution}. 

  
        
@end smallindentedblock

@node this
@subsection this
@cindex this

  The keyword @code{this} refers to the current instance,
            as defined in @ref{currentinstanceofaclassorinterface, ,Current instance of a class or interface}, of the 
            immediately containing class or interface (the class or interface in which 
            the expression appears). Its type is the applied type formed by the 
            immediately containing class or interface with its own type parameters as
            type arguments. 

  
@node outer
@subsection outer
@cindex outer

  The keyword @code{outer} refers to the current instance,
            as defined in @ref{currentinstanceofaclassorinterface, ,Current instance of a class or interface}, of the 
            class or interface which immediately contains the immediately containing 
            class or interface. Its type is the applied type formed by this class or 
            interface with its own type parameters as type arguments. 

  
@node super
@subsection super
@cindex super

  The keyword @code{super} refers to the current instance 
            of the immediately containing class or interface. Its type is the 
            intersection of the principal instantiation of the immediate superclass 
            for the immediately containing class or interface, as defined in
            @ref{principalinstantiationofasupertype, ,Principal instantiation of a supertype}, with all principal 
            instantiations of immediate superinterfaces of the immediately containing 
            class or interface. A member reference such as @code{super.x} 
            may not resolve to a @code{formal} declaration, nor to any 
            member inherited from more than one supertype of the intersection type. 

  As an exception to this, when the keyword @code{super} 
            occurs in an @code{extends} clause, as specified in 
            @ref{extendedclass, ,Extension}, it refers to the current instance of
            the class or interface which immediately contains the declaration to which
            the @code{extends} clause belongs. Its type is the 
            intersection of the principal instantiation of the immediate superclass 
            of this containing class or interface, with all principal instantiations 
            of immediate superinterfaces of this containing class or interface. 

  The keyword @code{super} may occur as the first operand
            of an @code{of} operator, in which case the second operand is
            the principal instantiation of some supertype of the class for the 
            immediately containing class or interface. The expression 
            @code{(super of Type)} has type @code{Type}. A 
            member reference such as @code{(super of Type).x} may not 
            resolve to a @code{formal} member, nor to any member inherited 
            from more than one supertype of @code{Type}, nor to any member 
            that is refined by the class or any intermediate supertype of the class. 

  
@node anonymousfunctions
@section Anonymous functions
@cindex Anonymous functions

  
      
@menu
      
* parametertypeinference:: Anonymous function parameter type inference
@end menu

      An anonymous function is a function, as specified in 
        @ref{functions, ,Functions}, with no name, defined within an 
        expression. It comprises one or more parameter lists, followed by 
        an expression or a block of code. 

  
@verbatim
FunctionExpression: ("function" | "void")? Parameters+ (LazySpecifier | Block)
@end verbatim
The parameters are the parameters of the function. The lazy 
        specifier or block of code is the implementation of the function. 

  An anonymous function may be considered @code{void}: 

  
  @itemize @bullet
  
  @item if the @code{void} keyword is specified, 
                the function is a @code{void} function, or 

  
  @item if the @code{function} keyword is specified,
                the function is not a @code{void} function, or,
                 

  
  @item otherwise, the function is @code{void} if 
                and only if it is defined using a block in which no 
                @code{return} statement with an expression occurs 
                sequentially, as defined in @ref{blockstructure, ,Block structure and references}. 

  
  @end itemize
If the function is not considered @code{void}, 
        then its return type is inferred. 

  The type of an anonymous function expression is the callable 
        type of the function, as specified in 
        @ref{callabletypeoffunction, ,Callable type of a function}. 

  
@example
(Value x, Value y) => x<=>y
@end example

@example
void (String name) => print(name)
@end example

@example
(String string) @{
    value mid = string.size / 2;
    return [string[...mid],string[mid+1...]];
@}
@end example
An anonymous function occurring in an @code{extends}
        clause may not contain a reference to a variable value. 

  
@smallindentedblock
  Note: evaluation of an anonymous function expression,
        as defined in @ref{anonymousfunctionevaluation, ,Evaluation of anonymous functions} results
        in instantiation of an object of type @code{Callable}.
        However, the members of this object are never in scope, do not hide
        other declarations, and are not referenceable from within the 
        anonymous function. 

  
@end smallindentedblock

@smallindentedblock
  Note: there is almost no semantic difference between the
        following function declarations: 

  
        
@example
Float f(Float x)(Float y) => x*y;
@end example

        
@example
Float(Float) f(Float x) => (Float y) => x*y;
@end example

        The first form is strongly preferred. 

  
@end smallindentedblock

@node parametertypeinference
@subsection Anonymous function parameter type inference
@cindex Anonymous function parameter type inference

  If the type of a parameter of an anonymous function is 
            not declared explicitly, then the type of the parameter may in 
            certain cases be inferred if the anonymous function occurs: 

  
  @itemize @bullet
  
  @item as a listed argument, as defined in 
                    @ref{listedarguments, ,Listed arguments}, in a positional 
                    argument list, or 

  
  @item as a specified argument, anonymous argument, or
                    listed argument, as defined in 
                    @ref{namedarguments, ,Named argument lists}, in a named argument 
                    list. 

  
  @end itemize
Suppose the type of the @code{i}th parameter 
            @code{p} of an anonymous function is not declared 
            explicitly, and further suppose that the anonymous function
            occurs as the argument to a parameter @code{x} of
            some function or class in a direct invocation expression, as 
            defined in @ref{directinvocations, ,Direct invocations}. 

  Then the type of @code{p} may be inferred if 
            either: 

  
  @itemize @bullet
  
  @item the function or class has no type parameters, or 
                    the invocation has an explicit type argument list, and 
                    @code{x} is a callable parameter with the 
                    same number of parameters as the anonymous function, and 
                    with @code{i}th parameter @code{q},
                     

  
  @item the function or class has at least one type parameter, 
                    and the invocation has no explicit type argument list, and 
                    @code{x} is a callable parameter with the same 
                    number of parameters as the anonymous function, and the type 
                    of the @code{i}th parameter @code{q}
                    of @code{x} does not involve any of the type 
                    parameters of the generic function or class, or 

  
  @item @code{x} is a value parameter whose type 
                    does not involve any of the type parameters of the generic 
                    function or class and represents a function with the same 
                    number of parameters as the anonymous function, and with 
                    @code{i}th parameter @code{q}, 
                    according to @ref{callabletypeoffunction, ,Callable type of a function}. 

  
  @end itemize
Then the type of @code{p} is inferred to be the 
            type of @code{q} in the realization of the function or 
            class, as defined in @ref{realizations, ,Realizations}. 

  Otherwise, suppose the type of the @code{i}th
            parameter @code{p} of an anonymous function is not
            declared explicitly, and further suppose that the anonymous function
            occurs as the @code{n}th argument in the positional
            argument list of an indirect invocation expression. 

  Then if the callable type of the invoked expression represents
            a function whose @code{n}th parameter is a callable
            parameter with the same number of parameters as the anonymous
            function, according to @ref{callabletypeoffunction, ,Callable type of a function},
            then the type of @code{p} is inferred to be the type of 
            the corresponding @code{i}th parameter of this callable 
            parameter. 

  That is, if the type of the invoked expression is 
            @code{R(*T)} where @code{T}
            is a tuple type whose @code{n}th element type is 
            @code{P(*S)} and @code{S} is 
            in turn a tuple type whose @code{i}th element type is 
            @code{Q}, then @code{Q} is the inferred type 
            of @code{p}. 

  
@node compoundexpressions
@section Compound expressions
@cindex Compound expressions

  
      
@menu
      
* baseexpressions:: Base expressions
* memberexpressions:: Member expressions
* constructorexpressions:: Constructor expressions
* valuereferences:: Value references
* callablereferences:: Callable references
* staticexpressions:: Static expressions
* staticvaluereferences:: Static value references
* staticcallablereferences:: Static callable references
@end menu

      An @emph{atom} is a literal or self reference, a
        string template, a base expression, an iterable or tuple enumeration, 
        an anonymous class expression, a metamodel or reference expression, or 
        a parenthesized expression. 

  
@verbatim
Atom: LiteralExpression | BaseExpression | DelimitedExpression | MetaExpression | SelfReference
@end verbatim

@verbatim
LiteralExpression: Literal | StringTemplate
@end verbatim

@verbatim
DelimitedExpression: GroupedExpression | Enumeration | ObjectExpression
@end verbatim

@verbatim
MetaExpression: Meta | Dec
@end verbatim
A @emph{primary} is formed by recursively forming 
        member expressions, static expressions, invocation expressions, and 
        index expressions from an initial atom, using the operators in the
        first row of the table of operator precedence and associativity in
        @ref{operatorprecedence, ,Operator precedence}. 

  
@verbatim
Primary: Atom | QualifiedExpression | Invocation | IndexedExpression
@end verbatim

@verbatim
QualifiedExpression: MemberExpression | ConstructorExpression | StaticExpression
@end verbatim
More complex expressions are formed by combining expressions using 
        operators, including assignment operators, as defined in @ref{operators, ,Operators}, 
        and using inline conditional expressions and anonymous functions. 

  
@verbatim
ValueExpression: Primary | OperatorExpression
@end verbatim

@verbatim
Expression: ValueExpression | FunctionExpression | LetExpression | ConditionalExpression
@end verbatim

@smallindentedblock
  Note: the grammar of operator expressions is defined by
        the table of operator precedence and associativity in 
        @ref{operatorprecedence, ,Operator precedence}. Thus, the rules
        @code{OperatorExpression} and @code{IndexedExpression}
        are not defined in BNF. 

  
@end smallindentedblock
Parentheses are used for grouping: 

  
@verbatim
GroupedExpression: "(" Expression ")"
@end verbatim
A compound expression occurring in a @code{dynamic} 
        block, and involving a qualified or unqualified reference with no type,
        or a reference to a declaration with no type, may also have no type. 

  In particular, if an operand expression has no type, and the type 
        of the operator expression depends upon the type of the operand, and the 
        operator expression occurs within a @code{dynamic} block, 
        then the whole operator expression has no type. 

  
@node baseexpressions
@subsection Base expressions
@cindex Base expressions

  A @emph{base expression} is an identifier,
            optionally qualified by the keyword @code{package}, 
            with an optional list of type arguments: 

  
@verbatim
BaseExpression: PackageQualifier? (MemberName | TypeName) TypeArguments?
@end verbatim
A base expression is either: 

  
  @itemize @bullet
  
  @item a reference to a toplevel function, toplevel value, or 
                    toplevel class, 

  
  @item a reference within the lexical scope of the referenced 
                    function, value, constructor, or class, or 

  
  @item a reference within the body of the referenced function,
                    value, constructor, or class. 

  
  @end itemize
The referenced declaration is determined by resolving the unqualified 
            reference as defined by @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution}.
            The unqualified realization for the unqualified reference is determined
            according to @ref{realizations, ,Realizations}. 

  The type argument list, if any, must conform, as defined by
            @ref{typeargumentsandconstraints, ,Type arguments and type constraints}, to the type parameter list
            of the unqualified realization. 

  If a base expression is a reference to an attribute, method, member 
            class, or member class constructor of a class, the receiving instance is the 
            current instance of that class, as defined by 
            @ref{currentinstanceofaclassorinterface, ,Current instance of a class or interface}. Otherwise, there is no 
            receiving instance. 

  
@node memberexpressions
@subsection Member expressions
@cindex Member expressions

  A @emph{member expression} is a @emph{receiver
            expression}, followed by an identifier, with an optional list
            of type arguments. 

  
@verbatim
MemberExpression: (Primary ".") (MemberName | TypeName) TypeArguments?
@end verbatim
A member expression is a reference to a member of a type: an
            attribute, method, or member class. 

  The referenced member is determined by resolving the qualified 
            reference as defined by @ref{qualifiedreferenceresolution, ,Qualified reference resolution}.
            The qualified realization for the qualified reference is determined
            according to @ref{realizations, ,Realizations}. 

  The type argument list, if any, must conform, as defined by
            @ref{typeargumentsandconstraints, ,Type arguments and type constraints}, to the type parameter list
            of the qualified realization. 

  The receiver expression produces the instance upon which the member 
            is invoked or evaluated. When a member expression is executed, the receiver 
            expression is evaluated to produce the receiving instance which is held 
            until the member is invoked or evaluated, as defined in 
            @ref{evaluationinvocationandassignment, ,Evaluation, invocation, and assignment}. 

  
@node constructorexpressions
@subsection Constructor expressions
@cindex Constructor expressions

  A @emph{constructor expression} is a base or member
            expression that references a class with constructors, followed by an
            identifier, with an optional list of type arguments. 

  
@verbatim
ConstructorExpression: (BaseExpression | MemberExpression) "." MemberName TypeArguments?
@end verbatim
A constructor expression is a reference to a constructor of a 
            class. 

  The referenced member is determined by resolving the qualified 
            reference as defined by @ref{qualifiedreferenceresolution, ,Qualified reference resolution}.
            The qualified realization for the qualified reference is determined
            according to @ref{realizations, ,Realizations}. 

  The type argument list, if any, must conform, as defined by
            @ref{typeargumentsandconstraints, ,Type arguments and type constraints}, to the type parameter list
            of the qualified realization. 

  If the constructor expression is qualified by a member expression,
            its receiver expression produces the instance upon which the constructor
            is invoked. When a constructor expression is executed, the receiver 
            expression is evaluated to produce the receiving instance which is held 
            until the constructor is invoked or evaluated, as defined in 
            @ref{evaluationinvocationandassignment, ,Evaluation, invocation, and assignment}. 

  
@node valuereferences
@subsection Value references
@cindex Value references

  A @emph{value reference} is a base expression or 
            member expression that references a value declaration or value constructor
            declaration. 

  The type of a value reference expression is the type of the 
            realization of the referenced value or value constructor. 

  A value or value constructor declaration is never generic, so a value 
            reference never has a type argument list. 

  A value reference that does not occur within any @code{dynamic}
            block may not refer to a value declaration or value parameter with no type. 

  A value reference which occurs within a @code{dynamic} 
            block and which does not reference any statically typed declaration, or
            which references a value declaration or value parameter with no type, 
            has no type. 

  If a base expression or member expression does not reference any 
            statically typed declaration, and occurs within a @code{dynamic} 
            block, then it is considered a value reference. 

  
@node callablereferences
@subsection Callable references
@cindex Callable references

  A @emph{callable reference} is a base expression,
            member expression, or constructor expression that references something---a 
            function, class, or callable constructor---that can be @emph{invoked} 
            or @emph{instantiated} by specifying a list of arguments. 

  If a callable reference refers to a class with a default constructor,
            the callable reference is considered a reference to the default constructor. 

  A callable reference may be invoked immediately, or it may be passed 
            to other code which may invoke the reference. A callable reference captures 
            the return type and parameter list types of the function or class it refers 
            to, allowing compile-time validation of argument types when the callable 
            reference is invoked. 

  The type of a callable reference expression is the callable type of
            the realization of the referenced function, class, or callable constructor. 

  If a callable reference expression refers to a generic declaration, 
            it must either: 

  
  @itemize @bullet
  
  @item have an explicit type argument list, 

  
  @item be immediately followed by an argument list, allowing the 
                    compiler to infer the type arguments, as defined in
                    @ref{typeargumentinference, ,Type argument inference}, or, 

  
  @item be the immediate child of a constructor expression that is 
                    immediately followed by an argument list, allowing the compiler to 
                    infer the type arguments, as defined in
                    @ref{typeargumentinference, ,Type argument inference}, or 

  
  @item occur as a listed argument, as defined in
                    @ref{listedarguments, ,Listed arguments} in a positional argument 
                    list, or as a specified argument, anonymous argument, or
                    listed argument, as defined in @ref{namedarguments, ,Named argument lists},
                    in a named argument list, and its type arguments must be
                    inferable as defined below. 

  
  @end itemize
A callable reference may not occur as the receiver expression of a 
            member expression. 

  
@smallindentedblock
  Note: this restriction exists to eliminate an ambiguity in
            the interpretation of static expressions such as @code{Person.string}
            and @code{Person.equals}. 

  
@end smallindentedblock
A callable reference that does not occur within any @code{dynamic}
            block may not refer to a function declaration with no return type. 

  A callable reference which occurs within a @code{dynamic} 
            block and which references a function declaration with no return type, has 
            no type. 

  
@smallindentedblock
  Note: in a future release of the language, we would like to 
            add a syntax for obtaining a callable reference to an attribute, something
            like @code{person.@@name}, to allow attributes to be passed by 
            reference. This would also allow static references like
            @code{Person.@@name}. 

  
@end smallindentedblock
If a callable reference @code{f} with no explicit type 
            argument list occurs as the argument to a callable parameter @code{p}
            of a function or class in a direct invocation expression, as defined below in 
            @ref{directinvocations, ,Direct invocations}, then the type arguments of @code{f} 
            are inferred according to the rules defined in @ref{typeargumentinference, ,Type argument inference} 
            as if the types of the parameters of @code{p} were the types of 
            listed arguments of @code{f} in a positional argument list, unless 
            the invoked function or class is generic, and the invocation expression does 
            not itself specify explicit type arguments, in which case any parameter whose 
            type involves a type argument of the invoked function or class is ignored. 

  If a callable reference @code{f} with no explicit type 
            argument list occurs as the argument to a value parameter @code{p}
            of type @code{Return(*Args)} in a direct or indirect 
            invocation expression, then the type arguments of @code{f} are 
            inferred according to the rules defined in @ref{typeargumentinference, ,Type argument inference} 
            as if @code{Args} were the type of a positional argument list, unless 
            the invocation is a direct invocation expression, and the invoked function or 
            class is generic, and @code{Args} involves type parameters of the
            invoked function or class. 

  
@node staticexpressions
@subsection Static expressions
@cindex Static expressions

  A @emph{static expression} is a type, optionally qualifier by 
            the keyword @code{package}, followed by an identifier, with an optional 
            list of type arguments. 

  
@verbatim
StaticExpression: PackageQualifier? (TypeName TypeArguments? ".")+ (MemberName | TypeName) TypeArguments?
@end verbatim
A static expression is a reference to a member of a type: an attribute, method, 
            or member class, or to a constructor of a member class of the type. 

  The referenced member is determined by resolving the qualified reference as defined 
            by @ref{qualifiedreferenceresolution, ,Qualified reference resolution}. The qualified realization for the 
            qualified reference is determined according to @ref{realizations, ,Realizations}. 

  The type argument list, if any, must conform, as defined by
            @ref{typeargumentsandconstraints, ,Type arguments and type constraints}, to the type parameter list of the 
            qualified realization. 

  Unlike member expressions, a static expression does not have a receiver expression. 
            All static expressions are callable expressions which accept an argument of the specified 
            type. 

  A static expression must reference a statically typed declaration with no missing 
            types, even within a @code{dynamic} block. 

  If the qualifying type in a static expression refers to a generic declaration, then 
            either: 

  
  @itemize @bullet
  
  @item it must have an explicit type argument list, or 

  
  @item the static expression must occur as a listed argument, as defined in
                    @ref{listedarguments, ,Listed arguments} in a positional argument list, or as a 
                    specified argument, anonymous argument, or listed argument, as defined in 
                    @ref{namedarguments, ,Named argument lists}, in a named argument list, and its type 
                    arguments must be inferable as defined below. 

  
  @end itemize
If a static expression @code{T.m} for a generic type @code{T} 
            with no explicit type argument list occurs as the argument to a parameter @code{p}
            of type @code{Return(*Arg)} in a direct or indirect invocation expression, 
            then the type arguments of @code{T} are inferred according to the rules defined 
            in @ref{typeargumentinference, ,Type argument inference} as if @code{Arg} were the type of a 
            positional argument list, and @code{[T]} were the type of a parameter list, 
            unless the invocation is a direct invocation expression, and the invoked function or class 
            is generic, and @code{Arg} involves type parameters of the invoked function or 
            class. 

  
@node staticvaluereferences
@subsection Static value references
@cindex Static value references

  A @emph{static value reference} is a static expression that 
            references an attribute declaration or member class value constructor declaration.
             

  
@example
List<Anything>.size
@end example
The type of a static value reference expression is: 

  
  @itemize @bullet
  
  @item @code{X(T)} for an attribute whose realization is of 
		            type @code{X}, and with qualifying type @code{T},
		            or 

  
  @item @code{T.X(T)} for a member class value constructor whose 
		            realization is of type @code{T.X}, and with qualifying type 
		            @code{T.X}. 

  
  @end itemize
A value or value constructor declaration is never generic, so a static value 
            reference never ends in a type argument list. 

  
@node staticcallablereferences
@subsection Static callable references
@cindex Static callable references

  A @emph{static callable reference} is a static expression that 
            references something---a method or member class, or a callable constructor of
            a member class---that can be @emph{invoked} or 
            @emph{instantiated}. 

  
@example
List<String>.filter
@end example

@example
Iterable<Integer>.map<String>
@end example
The type of a static callable reference expression is: 

  
  @itemize @bullet
  
  @item @code{R(*A)(T)} for a method, member class, or member class 
                    constructor whose realization has callable type @code{R(*A)}, and 
                    with qualifying type @code{T}, or 

  
  @item @code{T.X(*A)(T)} for a member class constructor whose 
                    realization has callable type @code{T.X(*A)}, and with qualifying 
                    type @code{T.X}. 

  
  @end itemize
If a callable reference expression refers to a generic declaration, it must 
            end in an explicit type argument list. 

  
@node invocationexpressions
@section Invocation expressions
@cindex Invocation expressions

  
      
@menu
      
* directinvocations:: Direct invocations
* defaultarguments:: Default arguments
* tupletypeofarglist:: The type of a list of arguments
* listedarguments:: Listed arguments
* spreadarguments:: Spread arguments
* comprehensions:: Comprehensions
* positionalarguments:: Positional argument lists
* namedarguments:: Named argument lists
* anonymousarguments:: Anonymous arguments
* specifiedarguments:: Specified arguments
* inlinedeclarationarguments:: Inline declaration arguments
* enumeration:: Iterable and tuple enumeration
* dynamicenumerations:: Dynamic enumerations
@end menu

      A callable expression---any expression of type 
        @code{Callable}---is @emph{invokable}. An 
        @emph{invocation} consists of an @emph{invoked expression}, 
        together with an argument list and, optionally, an explicit type argument list. 

  
@verbatim
Invocation: Primary Arguments
@end verbatim
The invoked expression must be of type @code{R(*P)}
        for some types @code{R} and @code{P}. Then the type of the 
        invocation expression is simply @code{R}. 

  If the invoked expression has no type, and occurs within a @code{dynamic} 
        block, then the whole invocation expression has no type, and the argument list is 
        not type-checked at compile time, unless it is a direct invocation expression. 

  An invocation expression must specify arguments for parameters of the callable 
        object, either as a positional argument list, or as a named argument list. 

  
@verbatim
Arguments: PositionalArguments | NamedArguments
@end verbatim
Every argument list has a type, as specified below in 
        @ref{positionalarguments, ,Positional argument lists} and @ref{namedarguments, ,Named argument lists}. If an 
        invocation is formed from a callable expression of type exactly 
        @code{R(*P)} and an argument list of type 
        @code{A}, then @code{A} must be a subtype of 
        @code{P}. 

  
@node directinvocations
@subsection Direct invocations
@cindex Direct invocations

  Any invocation expression where the invoked expression is a callable 
            reference expression is called a @emph{direct invocation expression} 
            of the function, class, or callable constructor to which the callable reference 
            refers. 

  
@smallindentedblock
  TODO: Should we consider @code{x@{y=1;@}@{z=2;@}} a legal
            direct invocation if @code{x} has multiple parameter lists? 

  
@end smallindentedblock
In a direct invocation expression: 

  
  @itemize @bullet
  
  @item the compiler has one item of additional information about the schema 
                    of the method or class that is not reified by the @code{Callable} 
                    interface: the names of the parameters of the function, class, or callable
                    constructor, and therefore named arguments may be used, and 

  
  @item type argument inference is possible, as defined in 
                    @ref{typeargumentinference, ,Type argument inference}, since the compiler has access to 
                    the type parameters and constraints of the function or class, or of the class
                    to which the callable constructor belongs. 

  
  @end itemize
If an invocation expression has a named argument list, it must be a direct
            invocation. 

  The type of a direct invocation expression is the return type of the
            realization of the function, or the type of the realization of the class, as 
            defined in @ref{realizations, ,Realizations}. 

  If the function has no return type, and occurs within a @code{dynamic} 
            block, then the whole direct invocation expression has no type. 

  In a direct invocation expression of a function, class, or callable 
            constructor, the restriction above on the argument list type is equivalent to the 
            following requirements. Given the parameter list of the realization of the function, 
            class, or callable constructor, and the arguments of the direct invocation: 

  
  @itemize @bullet
  
  @item for each required parameter, an argument must be given, 

  
  @item for each defaulted parameter, an argument may optionally be 
                    given, 

  
  @item if the parameter list has a variadic parameter of type 
                    @code{T+}, one or more arguments must be given, 

  
  @item if the parameter list has a variadic parameter of type 
                    @code{T*}, one or more arguments may optionally be 
                    given, 

  
  @item no additional arguments may be given, 

  
  @item for a required or defaulted parameter of type @code{T}, 
                    the type of the corresponding argument expression must be assignable to 
                    @code{T}, and 

  
  @item for a variadic parameter of type @code{T*} or 
                    @code{T+}, the type of every corresponding argument 
                    expression must be assignable to @code{T}. 

  
  @end itemize
Furthermore, if type argument are inferred, then the inferred type 
            arguments must conform, as defined by @ref{typeargumentsandconstraints, ,Type arguments and type constraints}, 
            to the type parameter list of the realization of the function or class, or
            class to which the callable constructor belongs. 

  If an argument expression has no type, or if its parameter has no type, 
            and the invocation occurs within a @code{dynamic} block, then the 
            argument is not type-checked at compile time. 

  An invocation expression that does not occur within any @code{dynamic}
            block may not assign an argument to a value parameter with no type. 

  
@node defaultarguments
@subsection Default arguments
@cindex Default arguments

  When no argument is assigned to a defaulted parameter by the caller, 
            the default argument defined by the parameter declaration of the realization,
            as defined by @ref{typeargumentsandconstraints, ,Type arguments and type constraints}, of the function, 
            class, or callable constructor is used. The default argument expression is 
            evaluated every time the method is invoked with no argument specified for the 
            defaulted parameter. 

  This class: 

  
@example
shared class Counter(Integer initialCount=0) @{ ... @}
@end example
May be instantiated using any of the following invocations: 

  
@example
Counter()
@end example

@example
Counter(1)
@end example

@example
Counter @{@}
@end example

@example
Counter @{ initialCount=10; @}
@end example

@node tupletypeofarglist
@subsection The type of a list of arguments
@cindex The type of a list of arguments

  A list of arguments may be formed from: 

  
  @itemize @bullet
  
  @item any number of @emph{listed arguments},
                    optionally followed by either 

  
  @item a @emph{spread argument}, or 

  
  @item a @emph{comprehension}. 

  
  @end itemize

@verbatim
ArgumentList: ((ListedArgument ",")* (ListedArgument | SpreadArgument | Comprehension))?
@end verbatim
Every such list of arguments has a type, which captures the types of 
            the individual arguments in the list. This type is always a subtype of 
            @code{Anything[]}. The type of an empty list of arguments is 
            @code{[]}. 

  
@node listedarguments
@subsection Listed arguments
@cindex Listed arguments

  A listed argument is an expression. 

  
@verbatim
ListedArgument: Expression
@end verbatim
If a listed argument is an expression of type @code{T}, and 
            a list of arguments has type @code{P} with principal instantiation 
            @code{Sequential<Y>}, then the type of a new argument list 
            formed by prepending the expression to the first parameter list is 
            @code{Tuple<T|Y,T,P>}. 

  
@node spreadarguments
@subsection Spread arguments
@cindex Spread arguments

  A spread argument is an expression prefixed by the 
            @emph{spread operator} @code{*}. 

  
@verbatim
SpreadArgument: "*" ValueExpression
@end verbatim
The spread operator is parsed with a precedence just lower than 
            the multiplication operator @code{*} and just higher than 
            the set union and complement operators @code{|} and
            @code{~}, and is not associative. 

  
@smallindentedblock
  Note: this restriction means that the symbol @code{*}
            always has the same precedence, wherever it occurs in the language. 

  
@end smallindentedblock
The expression type @code{T} must have the principal 
            instantiation @code{@{X*@}} for some type @code{X}. 
            We form the @emph{sequential type of a spread argument} as 
            follows: 

  
  @itemize @bullet
  
  @item if the expression type @code{T} is an invariant 
                    subtype of @code{X[]}, for some type @code{X} 
                    then the sequential type of the spread argument is 
                    @code{T}, or, if not, 

  
  @item if the expression type @code{T} is an invariant 
                    subtype of @code{@{X+@}}, for some type @code{X} 
                    then the sequential type of the spread argument is 
                    @code{[X+]}, or, otherwise, 

  
  @item the expression type @code{T} is an invariant 
                    subtype of @code{@{X*@}}, for some type @code{X}
                    and the sequential type of the spread argument is 
                    @code{X[]}. 

  
  @end itemize
When a spread argument with an expression type not assignable to 
            @code{Anything[]} is evaluated, the elements of the iterable
            automatically are packaged into a sequence. 

  
@smallindentedblock
  Note: the spread "operator" is not truly an operator in the
            sense of @ref{operators, ,Operators}, and so a spread argument is not an 
            expresson. An expression, when evaluated, produces a single value. The
            spread operator produces multiple values. It is therefore more correct to 
            view the spread operator as simply part of the syntax of an argument list.
             

  
@end smallindentedblock
The type of a list of arguments containing only a spread argument of 
            sequential type @code{S} is simply @code{S}. 

  
@node comprehensions
@subsection Comprehensions
@cindex Comprehensions

  A @emph{comprehension} accepts one or more streams of values 
            and produces a new stream of values. Any instance of @code{Iterable}
            is considered a stream of values. The comprehension has two or more
            @emph{clauses}: 

  
  @itemize @bullet
  
  @item A @code{for} clause specifies a source stream and an 
                    iterator pattern, as defined in @ref{forelse, ,for/else}, representing 
                    the values produced by the stream. 

  
  @item An @code{if} clause specifies a condition list, as
                    defined in @ref{controlstructureconditions, ,Conditions}, used to filter
                    the values produced by the source stream or streams. 

  
  @item An expression clause produces the values of the resulting stream. 

  
  @end itemize
Every comprehension begins with a @code{for} or @code{if}
            clause, and ends with an expression clause. There may be any number of intervening 
            @code{for} or @code{if} clauses. Each clause in the
            comprehension is considered a child of the clause that immediately precedes 
            it. 

  
@verbatim
Comprehension: ForComprehensionClause | IfComprehensionClause
@end verbatim

@verbatim
ForComprehensionClause: "for" ForIterator ComprehensionClause
@end verbatim

@verbatim
IfComprehensionClause: "if" ConditionList ComprehensionClause
@end verbatim

@verbatim
ComprehensionClause: ForComprehensionClause | IfComprehensionClause | Expression
@end verbatim
An expression that occurs in a child clause may refer to iteration 
            variables and condition variables declared by parent clauses. The types
            of such variables are specified in @ref{controlstructures, ,Control structures and assertions}. 

  
@smallindentedblock
  Note: each child clause can be viewed as a body nested inside 
            the parent clause. The scoping rules for variables declared by comprehension
            clauses reflects this model. 

  
@end smallindentedblock
The type of a list of arguments containing only a comprehension is 
            @code{[T*]} where @code{T} is the type of the
            expression which terminates the comprehension, or @code{[T+]}
            if there are no @code{if} clauses, and if every 
            @code{for} clause has an iterated expression of nonempty
            type. 

  An comprehension occurring in an @code{extends} clause may 
            not contain a reference to a variable value. 

  
@smallindentedblock
  Note: a comprehension, like a spread argument, is not considered an 
            expression. An expression, when evaluated, produces a single value. A comprehension
            produces multiple values, like a spread argument, or like a series of listed 
            arguments. Therefore, a comprehension may only appear in an argument list or an 
            enumeration expression. This is, however, no limitation; we can simply wrap the
            comprehension in braces in order to get an expression of type @code{@{T*@}},
            or in brackets to get an expression of type @code{[T*]}. 

  
@end smallindentedblock

@smallindentedblock
  TODO: properly define how expressions with no type occurring in a
            @code{dynamic} block affect comprehensions. 

  
@end smallindentedblock

@node positionalarguments
@subsection Positional argument lists
@cindex Positional argument lists

  When invocation arguments are listed positionally, the argument list is 
            enclosed in parentheses. 

  
@verbatim
PositionalArguments: "(" ArgumentList ")"
@end verbatim
The type of the positional argument list is the type of the list of arguments 
            it contains. 

  
@node namedarguments
@subsection Named argument lists
@cindex Named argument lists

  When invocation arguments are listed by name, the argument list is enclosed 
            in braces. 

  
@verbatim
NamedArguments: "{" NamedArgument* ArgumentList "}"
@end verbatim
Named arguments may be listed in a different order to the corresponding
            parameters. 

  Each named argument in a named argument list is either: 

  
  @itemize @bullet
  
  @item an @emph{anonymous argument}---an expression, with
                    no parameter name explicitly specified, 

  
  @item a @emph{specified argument}---a specification 
                    statement where name of the value of function being specified is interpreted
                    as the name of a parameter, or 

  
  @item an inline getter, function, or anonymous class declaration, whose name 
                    is interpreted as the name of a parameter. 

  
  @end itemize

@verbatim
NamedArgument: AnonymousArgument | SpecifiedArgument | InlineDeclarationArgument
@end verbatim
Additionally, a named argument list has an ordinary list of arguments, which 
            may be empty. This argument list is interpreted as a single argument to a parameter 
            of type @code{Iterable}. 

  
@example
@{ initialCapacity=2; "hello", "world" @}
@end example

@example
@{ initialCapacity=people.size; loadFactor=0.8; for (p in people) p.name->p @}
@end example

@smallindentedblock
  Note: in a future release of the language, we would like to be able 
            to assign a local name to an anonymous argument or listed argument, allowing it to 
            be referenced later in the argument list. We might consider this a kind of "let"
            expression, perhaps. 

  
@end smallindentedblock
Given a parameter list, and a named argument list, we may attempt to construct 
            an @emph{equivalent positional argument list} as follows: 

  
  @itemize @bullet
  
  @item Taking each argument in the named argument list in turn, on the order 
                    they occur lexically: 

  
  @itemize @bullet
  
  @item if the argument is anonymous, assign it to the first unassigned
                            parameter of the parameter list, or 

  
  @item if the argument is named, assign it to the parameter with that
                            name in the parameter list. 

  
  @end itemize
If for any argument, there is no unassigned parameter, no parameter with
                    the given name, or the parameter with the given name has already been assigned
                    an argument, construction of the positional argument list fails, and the 
                    invocation is not well-typed. 

  
  @item Next, if the parameter list has an unassigned parameter of type exactly
                    @code{Iterable<T,N>} for some types @code{T} and
                    @code{N}, then an iterable enumeration expression, as defined in
                    @ref{enumeration, ,Iterable and tuple enumeration}, is formed from the ordinary list of arguments, 
                    and assigned to that parameter. 

  If there is no such parameter, and the ordinary list of arguments is
                    nonempty, then construction of the positional argument list fails, and the 
                    invocation is not well-typed. 

  
  @item Finally, we assign each unassigned defaulted parameter its default 
                    argument. 

  
  @end itemize
The resulting equivalent positional argument list is formed by ordering
            the arguments according to the position of their corresponding parameters in
            the parameter list, and then replacing any inline value, function, or object
            declarations with a reference to the declaration. 

  The type of a named argument list is the type of the equivalent positional 
            argument list. 

  
@node anonymousarguments
@subsection Anonymous arguments
@cindex Anonymous arguments

  An anonymous argument is just an expression followed by a semicolon. 

  
@verbatim
AnonymousArgument: Expression ";"
@end verbatim
The type of the argument is the type of the expression. 

  
@example
@{
    Head @{ title="Hello"; @};
    Body @{
        Div @{ "Hello ``name``!" @};
    @};
@}
@end example

@node specifiedarguments
@subsection Specified arguments
@cindex Specified arguments

  A specified argument is a value specification statement or lazy specification 
            statement, as defined in @ref{specificationstatements, ,Specification statements}, where the value
            reference or callable reference is treated as the name of a parameter of the invoked 
            function or class instead of using the usual rules for resolving unqualified names. 

  
@verbatim
SpecifiedArgument: Specification
@end verbatim

  @itemize @bullet
  
  @item If a specified argument is a value specification statement, its type 
                    is the type of the specified expression. 

  
  @item If a specified argument is a lazy specification statement with no 
                    parameter lists, its type is the type of the specified expression. 

  
  @item Otherwise, if it is a lazy specification statement with a parameter 
                    list, its type is the callable type formed from the type of the expression,
                    interpreted as a function return type, and the types of its parameter lists, 
                    according to @ref{callabletypeoffunction, ,Callable type of a function}. 

  
  @end itemize

@smallindentedblock
  Note: there is an ambiguity here between assignment expressions 
            and specified arguments. This ambiguity is resolved in favor of interpreting the
            argument as a specified argument. Therefore an anonymous argument in a named 
            argument list may not be an assignment expression. 

  
@end smallindentedblock

@example
@{ 
    product = getProduct(id); 
    quantity = 1; 
@}
@end example

@example
@{ 
    by(Value x, Value y) => x<=>y;
@}
@end example

@node inlinedeclarationarguments
@subsection Inline declaration arguments
@cindex Inline declaration arguments

  An @emph{inline declaration argument} defines a getter,
            function, or anonymous class, and assigns it to a parameter. 

  
@verbatim
InlineDeclarationArgument: ValueArgument | FunctionArgument | ObjectArgument
@end verbatim
An inline getter argument is a streamlined value declaration, as defined
            in @ref{values, ,Values}. The type of the argument is the declared or inferred 
            type of the value. 

  
@verbatim
ValueArgument: ValueHeader (Block | (Specifier | LazySpecifier) ";")
@end verbatim
An inline function argument is a streamlined function declaration, as
            defined in @ref{functions, ,Functions}. The type of the argument is the callable 
            type of the function, as defined by @ref{callabletypeoffunction, ,Callable type of a function}. 

  
@verbatim
FunctionArgument: FunctionHeader (Block | LazySpecifier ";")
@end verbatim
An inline anonymous class argument is a streamlined anonymous class 
            declaration, as defined in @ref{anonymousclasses, ,Anonymous classes}. The type of the 
            argument is the anonymous class type. 

  
@verbatim
ObjectArgument: ObjectHeader ClassBody
@end verbatim
A named argument may not have type parameters or annotations. 

  
@example
@{
    description = "Total";
    value amount @{ 
        variable Float total = 0.0;
        for (Item item in items) @{
            sum += item.amount;
        @}
        return total;
    @}
@}
@end example

@example
@{ 
    label = "Say Hello"; 
    void onClick() @{ 
        say("Hello!"); 
    @} 
@}
@end example

@example
@{ 
    function by(Value x, Value y) => x<=>y;
@}
@end example

@example
@{
    object iterator 
            satisfies Iterator<Order> @{
        variable value done = false;
        shared actual Order|Finished next() @{
            if (done) @{
                return finished;
            @}
            else @{
                done=true;
                return order; 
            @}
        @}
    @}   
@}
@end example

@node enumeration
@subsection Iterable and tuple enumeration
@cindex Iterable and tuple enumeration

  An @emph{enumeration expression} is an abbreviation for
            tuple and iterable object instantiation. Iterable enumerations are delimited
            using braces. Tuple enumerations are delimited by brackets. 

  
@verbatim
Enumeration: Iterable | Tuple | DynamicValue
@end verbatim

@verbatim
Iterable: "{" ArgumentList "}"
@end verbatim

@verbatim
Tuple: "[" ArgumentList "]"
@end verbatim
The type of an iterable enumeration expression is: 

  
  @itemize @bullet
  
  @item @code{Iterable<Nothing,Null>} if there are no 
                    argument expressions, or 

  
  @item @code{Iterable<U,Nothing>} where 
                    @code{U}, the argument expression list is an invariant 
                    suptype of @code{U[]}. 

  
  @end itemize
The type of a tuple enumeration expression is the type of the list of
            arguments it contains. 

  
@example
@{String+@} = @{ "hello", "world" @};
@end example

@example
[] none = [];
@end example

@example
[Float,Float] xy = [x, y];
@end example

@example
[Float,Float, String*] xy = [x, y, *labels];
@end example
Every argument expression must have a type, even if the enumeration expression
            occurs in a @code{dynamic} block. 

  
@node dynamicenumerations
@subsection Dynamic enumerations
@cindex Dynamic enumerations

  A @emph{dynamic enumeration expression} creates a new 
            object with no class by enumerating its members, allowing interoperation 
            with dynamically typed native code. 

  
@verbatim
DynamicValue: "dynamic" "[" NamedArgument* ArgumentList "]"
@end verbatim
A dynamic enumeration expression has no type. 

  Any argument names may be specified in the named argument list. 

  A dynamic enumeration expression must occur inside a
            @code{dynamic} block. 

  
@smallindentedblock
  The semantics of this construct are platform-dependent and
            beyond the scope of this specification. 

  
@end smallindentedblock

@node miscexpressions
@section Conditional expressions, let expressions, and anonymous class expressions
@cindex Conditional expressions, let expressions, and anonymous class expressions

  
      
@menu
      
* ifexpressions:: if/then/else expressions
* switchexpressions:: switch/case/else expressions
* letexpressions:: Let expressions
* inlineanonymousclassexpressions:: Inline anonymous class expressions
@end menu

      A @emph{conditional expression} resembles a control 
        structure but is part of the expression syntax, and evaluates to a value. 
        A conditional expression comes in one of two forms: 

  
  @itemize @bullet
  
  @item an @code{if/then/else} expression resembles 
                the @code{if/else} conditional defined in 
                @ref{ifelse, ,if/else}, and 

  
  @item a @code{switch/case/else} expression resembles 
                the @code{switch/case/else} conditional defined in 
                @ref{switchcaseelse, ,switch/case/else}. 

  
  @end itemize

@verbatim
ConditionalExpression: IfElseExpression | SwitchCaseElseExpression
@end verbatim
A @emph{let expression} allows inline definition of a 
        reference within an expression. 

  An @emph{inline class} is an anonymous class defined 
        within an expression. 

  
@node ifexpressions
@subsection if/then/else expressions
@cindex if/then/else expressions

  An @code{if/then/else} expression has a condition 
            list, as defined in @ref{controlstructureconditions, ,Conditions}, a
            @code{then} expression, and an @code{else} 
            expression. The @code{else} expression is not optional. 

  
@verbatim
IfElseExpression: "if" ConditionList ThenExpression ElseExpression
@end verbatim
The type of an @code{if/then/else} expression with
            @code{then} expression of type @code{X} and
            @code{else} or @code{else if} expression of 
            type @code{Y} is @code{X|Y}. 

  
@verbatim
ThenExpression: "then" Expression
@end verbatim

@verbatim
ElseExpression: "else" Expression
@end verbatim
The expression following @code{then} or 
            @code{else} is parsed with precedence just higher than the 
            @code{||} operator, and just lower than the 
            @code{then} and @code{else} operators, that is, 
            between the layers 3 and 4 defined in
            @ref{operatorprecedence, ,Operator precedence}. 

  Alternatively, the expression following @code{then}
            or @code{else} may be an @code{if/then/else} 
            expression or a let expression. 

  
@smallindentedblock
  Note: the expression following @code{then}
            or @code{else} may not be a @code{switch/case/else} 
            expression, since that would introduce an ambiguity related to the optional 
            @code{else} clause of the @code{switch/case/else} 
            expression. 

  
@end smallindentedblock

@example
if (exists lang) then lang.name else "Ceylon"
@end example

@node switchexpressions
@subsection switch/case/else expressions
@cindex switch/case/else expressions

  A @code{switch/case/else} expression has a 
            @code{switch} expression or inline variable, a list of 
            @code{case} expressions, and, optionally, an 
            @code{else} expression. 

  
@verbatim
SwitchCaseElseExpression: Switch CaseExpression+ ElseExpression
@end verbatim
The type of a @code{switch/case/else} expression 
            with @code{case} expressions of type @code{X1},
            @code{X2}, ..., @code{Xn} and
            @code{else} expression of type @code{Y} is
            @code{X1|X2|...|Xn|Y}. 

  
@verbatim
CaseExpression: "case" CaseCondition Expression
@end verbatim
The expression following @code{case} or 
            @code{else} is parsed with precedence just higher than the 
            @code{||} operator, and just lower than the 
            @code{then} and @code{else} operators, that is, 
            between the layers 3 and 4 defined in
            @ref{operatorprecedence, ,Operator precedence}. 

  Alternatively, the expression following @code{then}
            or @code{else} may be an @code{if/then/else} 
            expression or a let expression. 

  Each @code{case} expression includes a value case or
            type case, as defined in @ref{caseconditions, ,Case conditions}. Just like
            in a @code{switch/case/else} conditional statement: 

  
  @itemize @bullet
  
  @item all cases must be disjoint, and 

  
  @item if there is no @code{else} expression,
                    the cases must be exhaustive. 

  
  @end itemize

@example
switch (seq) case (null) "null" case (is []) "empty" else "nonempty"
@end example

@node letexpressions
@subsection Let expressions
@cindex Let expressions

  A let expression comprises a pattern list, followed by an 
            expression involving the pattern variables that occur in the listed
            patterns. 

  
@verbatim
LetExpression: "let" PatternList Expression
@end verbatim
The expression is parsed with precedence just higher than the 
            @code{||} operator, and just lower than the 
            @code{then} and @code{else} operators, that 
            is, between the layers 3 and 4 defined in
            @ref{operatorprecedence, ,Operator precedence}. 

  Alternatively, the expression may be an @code{if/then/else} 
            expression or another let expression. 

  A pattern list is enclosed in parentheses. 

  
@verbatim
PatternList: "(" PatternListElement ("," PatternListElement)* ")"
@end verbatim
Each element of the pattern list is a pattern, as defined in
            @ref{patterns, ,Patterns}, followed by a specified expression. The
            patterned type is the type of the specified expression. 

  
@verbatim
PatternListElement: Pattern Specifier
@end verbatim
The pattern variables that occur in the pattern list are 
            considered in scope in the expression that follows the pattern
            list. Furthermore, a specified expression in the pattern list 
            may refer to a pattern variable declared by an earlier element
            in the pattern list. 

  
@example
let ([x,y] = loc, d = sqrt(x^2+y^2)) [x/d, y/d]
@end example

@node inlineanonymousclassexpressions
@subsection Inline anonymous class expressions
@cindex Inline anonymous class expressions

  An inline anonymous class expression resembles an anonymous
            class declaration as defined in @ref{anonymousclasses, ,Anonymous classes}.
            The expression defines the schema, supertypes, and implementation 
            of a class. It does not specify a type name. Instead, the type has 
            a name assigned internally by the compiler that is not available at 
            compilation time. 

  
@verbatim
ObjectExpression: "object" ObjectInheritance ClassBody
@end verbatim
The class: 

  
  @itemize @bullet
  
  @item is implicitly @code{final}, and 

  
  @item may not declare @code{default} members. 

  
  @end itemize
The type of an inline anonymous class expression is the 
            intersection of the class type it extends with all interface types 
            it satisfies. The type of the inline anonymous class itself is not 
            accessible outside the body of the inline anonymous class expression. 

  
@example
object 
        satisfies @{Integer+@} @{
    iterator() => object 
            satisfies Iterator<Integer> @{
        variable value current = 0;
        next() => current++;
    @};
@}
@end example

@node operators
@section Operators
@cindex Operators

  
      
@menu
      
* operatorprecedence:: Operator precedence
* operatordefinition:: Operator definition
* basic:: Basic invocation and assignment operators
* equalitycomparison:: Equality and comparison operators
* logical:: Logical operators
* nullvalues:: Operators for handling null values
* listmap:: Correspondence, subrange, and stream operators
* creation:: Operators for creating objects
* conditionals:: Conditional operators
* arithmetic:: Arithmetic operators
* sets:: Set operators
@end menu

      Operators are syntactic shorthand for more complex expressions involving 
    invocation, evaluation, or instantiation. There is no support for user-defined 
    @emph{operator overloading}: 

  
  @itemize @bullet
  
  @item new operator symbols may not be defined outside of the operators
            specified below, and 

  
  @item the definition of the operators specified below may not be changed 
            or overloaded. 

  
  @end itemize
However, many of the operators below are defined in terms of 
    @code{default} or @code{formal} methods or attributes.
    So, within well-defined limits a concrete implementation may customize the  
    behavior of an operator. This approach is called 
    @emph{operator polymorphism}. 

  Some examples: 

  
@example
Float z = x * y + 1.0;
@end example

@example
even = n % 2 == 0;
@end example

@example
++count;
@end example

@example
Integer j = i++;
@end example

@example
if ( x > 100 || x < 0 ) @{ ... @}
@end example

@example
User user = users[userId] else guest;
@end example

@example
List<Item> firstPage = results[0..20];
@end example

@example
for (n in 0:length) @{ ... @}
@end example

@example
if (char in 'A'..'Z') @{ ... @}
@end example

@example
String[] names = people*.name;
@end example

@example
this.total += item.price * item.quantity;
@end example

@example
Float vol = length^3;
@end example

@example
Vector scaled = scale ** vector;
@end example

@example
map.contains(person.name->person);
@end example

@example
if (!document.internal || user is Employee) @{ ... @}
@end example

@node operatorprecedence
@subsection Operator precedence
@cindex Operator precedence

  There are 19 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict. 

  
  @itemize @bullet
  
  @item Operators in layer 1 produce, transform, and combine
            values. 

  
  @item Operators in layer 2 compare or predicate values, producing
            a @code{Boolean} result. 

  
  @item Operators in layer 3 are logical operators that operate
            upon @code{Boolean} arguments to produce a @code{Boolean}
            value. 

  
  @item Operators in layer 4 perform assignment and conditional
            evaluation. 

  
  @end itemize
Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators. 

  There is a single exception to this principle: the binary 
        exponentiation operator @code{^} has a higher precedence than 
        the prefix operators @code{+} and @code{-}. The 
        reason for this is that the following expressions should be equivalent: 

  
@example
-x^2       //means -(x^2)
@end example

@example
0 - x^2    //means 0 - (x^2)
@end example
This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules: 

  
@multitable {Comparison, containment, assignability, inheritance:} {@code{=}, @code{+=}, @code{-=}, @code{*=}, @code{/=}, @code{%=}, @code{&=}, @code{|=}, @code{~=}, @code{&&=}, @code{||=}} {Binary (and ternary)} {Associativity}
    
@headitem
    Operations
@tab Operators
@tab Type
@tab Associativity
@item
    @emph{Layer 1}
@item
    Member invocation and selection, index, subrange:
@tab @code{.},
                @code{*.}, 
                @code{?.}, 
                @code{()},
                @code{@{@}},
                @code{[]},
                @code{[:]}, 
                @code{[..]}, 
                @code{[...]}
@tab Binary / N-ary
@tab Left
@item
    Postfix increment and decrement:
@tab @code{++}, 
                @code{--}
@tab Unary postfix
@tab Left
@item
    Prefix increment and decrement:
@tab @code{++}, 
                @code{--}
@tab Unary prefix
@tab Right
@item
    Exponentiation:
@tab @code{^}
@tab Binary
@tab Right
@item
    Negation:
@tab @code{+},
                @code{-}
@tab Unary prefix
@tab Right
@item
    Set intersection:
@tab @code{&}
@tab Binary
@tab Left
@item
    Set union and complement:
@tab @code{|},
                @code{~}
@tab Binary
@tab Left
@item
    Multiplication, division, remainder:
@tab @code{*}, 
                @code{/}, 
                @code{%}
@tab Binary
@tab Left
@item
    Scale:
@tab @code{**}
@tab Binary
@tab Right
@item
    Addition, subtraction:
@tab @code{+}, 
                @code{-}
@tab Binary
@tab Left
@item
    Range and entry construction:
@tab @code{..},
                @code{:},  
                @code{->}
@tab Binary
@tab None
@item
    @emph{Layer 2}
@item
    Existence, emptiness:
@tab @code{exists}, @code{nonempty}
@tab Unary postfix
@tab None
@item
    Comparison, containment,
                assignability, inheritance:
@tab @code{<=>},
                @code{<}, 
                @code{>}, 
                @code{<=}, 
                @code{>=},
                @code{in},
                @code{is},
                @code{of}
@tab Binary (and ternary)
@tab None
@item
    Equality, identity:
@tab @code{==}, 
                @code{!=}, 
                @code{===}
@tab Binary
@tab None
@item
    @emph{Layer 3}
@item
    Logical not:
@tab @code{!}
@tab Unary prefix
@tab Right
@item
    Logical and:
@tab @code{&&}
@tab Binary
@tab Left
@item
    Logical or:
@tab @code{||}
@tab Binary
@tab Left
@item
    @emph{Layer 4}
@item
    Conditionals:
@tab @code{then}, 
                @code{else}
@tab Binary
@tab Left
@item
    Assignment:
@tab @code{=}, 
                @code{+=}, 
                @code{-=}, 
                @code{*=}, 
                @code{/=}, 
                @code{%=}, 
                @code{&=}, 
                @code{|=}, 
                @code{~=}, 
                @code{&&=}, 
                @code{||=}
@tab Binary
@tab Right
@end multitable
It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator @code{!} has a very low
        precedence. The following expressions are equivalent: 

  
@example
!x.y == 0.0  //means !(x.y == 0.0)
@end example

@example
x.y != 0.0
@end example

@node operatordefinition
@subsection Operator definition
@cindex Operator definition

  The following tables define the semantics of the Ceylon operators. 
        There are six basic operators which do not have a definition in terms of 
        other operators or invocations: 

  
  @itemize @bullet
  
  @item the @emph{member selection} operator
                @code{.} separates the receiver expression and member 
                name in a member expression, as defined above in
                @ref{memberexpressions, ,Member expressions}, 

  
  @item the @emph{argument specification} operators
                @code{()} and @code{@{@}} specify the 
                argument list of an invocation, as defined in
                @ref{invocationexpressions, ,Invocation expressions} and 
                @ref{invocation, ,Invocation}, 

  
  @item the @emph{assignment} operator
                @code{=} assigns a new value to a variable and 
                returns the new value after assignment, as defined in
                @ref{assignment, ,Assignment}, 

  
  @item the @emph{identity} operator
                @code{===} evaluates to @code{true} 
                if its argument expressions evaluate to references to the same 
                object, as defined in @ref{objectinstancesidentity, ,Object instances, identity, and reference passing},
                or to @code{false} otherwise, 

  
  @item the @emph{assignability} operator
                @code{is} evaluates to @code{true} if 
                its argument expression evaluates to an instance of a class, as 
                defined in @ref{objectinstancesidentity, ,Object instances, identity, and reference passing}, that is a 
                subtype of the specified type, or to @code{false} 
                otherwise, and 

  
  @item the @emph{coverage} operator
                @code{of} narrows or widens the type of an expression 
                to any specified type that covers the expression type, as defined
                by @ref{coverage, ,Coverage}, without affecting the value of the
                expression. 

  
  @end itemize
All other operators are defined below in terms of other operators 
        and/or invocations. 

  
@node basic
@subsection Basic invocation and assignment operators
@cindex Basic invocation and assignment operators

  These operators support method invocation and attribute evaluation and
        assignment. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Invocation}
@item
    @code{lhs.member}
@tab member
@tab 
@tab @code{X}
@tab a member of @code{X}, of type
            @code{T}
@tab @code{T}
@item
    @code{lhs(x,y,z)} or 
            @code{lhs@{a=x;b=y;@}}
@tab invoke
@tab 
@tab @code{T(*P)}
@tab argument list of type @code{P}
@tab @code{T}
@item
    @emph{Assignment}
@item
    @code{lhs = rhs}
@tab assign
@tab @code{}
@tab variable of type @code{X}
@tab @code{X}
@tab @code{X}
@item
    @emph{Coverage}
@item
    @code{lhs of Type}
@tab of
@tab @code{}
@tab @code{X}
@tab a literal type @code{T} that covers 
            @code{X}
@tab @code{T}
@end multitable

@node equalitycomparison
@subsection Equality and comparison operators
@cindex Equality and comparison operators

  These operators compare values for equality, order, magnitude, or membership,
        producing boolean values. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Equality and identity}
@item
    @code{lhs === rhs}
@tab identical
@tab @code{}
@tab @code{X given X satisfies Identifiable}
@tab @code{Y given Y satisfies Identifiable}
            where @code{X&Y} is not @code{Nothing}
@tab @code{Boolean}
@item
    @code{lhs == rhs}
@tab equal
@tab @code{lhs.equals(rhs)}
@tab @code{Object}
@tab @code{Object}
@tab @code{Boolean}
@item
    @code{lhs != rhs}
@tab not equal
@tab @code{!lhs.equals(rhs)}
@tab @code{Object}
@tab @code{Object}
@tab @code{Boolean}
@item
    @emph{Comparison}
@item
    @code{lhs <=> rhs}
@tab compare
@tab @code{lhs.compare(rhs)}
@tab @code{Comparable <T>}
@tab @code{T}
@tab @code{Comparison}
@item
    @code{lhs < rhs}
@tab smaller
@tab @code{lhs.compare(rhs)==smaller}
@tab @code{Comparable <T>}
@tab @code{T}
@tab @code{Boolean}
@item
    @code{lhs > rhs}
@tab larger
@tab @code{lhs.compare(rhs)==larger}
@tab @code{Comparable <T>}
@tab @code{T}
@tab @code{Boolean}
@item
    @code{lhs <= rhs}
@tab small as
@tab @code{lhs.compare(rhs)!=larger}
@tab @code{Comparable <T>}
@tab @code{T}
@tab @code{Boolean}
@item
    @code{lhs >= rhs}
@tab large as
@tab @code{lhs.compare(rhs)!=smaller}
@tab @code{Comparable <T>}
@tab @code{T}
@tab @code{Boolean}
@item
    @emph{Containment}
@item
    @code{lhs in rhs}
@tab in
@tab @code{let (x=lhs) rhs.contains(x)}
@tab @code{Object}
@tab @code{Category}
@tab @code{Boolean}
@item
    @emph{Assignability}
@item
    @code{rhs is Type}
@tab is
@tab 
@tab any type which is not a subtype of 
            @code{T}, whose intersection with 
            @code{T} is not @code{Nothing}
@tab any literal type @code{T}
@tab @code{Boolean}
@end multitable

@smallindentedblock
  TODO: Should we have allow the operators @code{<=} 
        and @code{>=} to handle partial orders? A particular usecase is
        @code{Set} comparison. 

  
@end smallindentedblock
A @emph{bounded comparison} is an abbreviation 
        for two binary comparisons: 

  
  @itemize @bullet
  
  @item @code{l<x<u} means 
                @code{let (t=x) l<t && t<u}, 

  
  @item @code{l<=x<u} means 
                @code{let (t=x) l<=t && t<u}, 

  
  @item @code{l<x<=u} means 
                @code{let (t=x) l<t && t<=u}, and 

  
  @item @code{l<=x<=u} means 
                @code{let (t=x) l<=t && t<=u} 

  
  @end itemize
for expressions @code{l}, @code{u}, 
        and @code{x}. 

  These abbreviations have the same precedence as the binary 
        @code{<} and @code{<=} operators, and, 
        like the binary forms, are not associative. 

  
@node logical
@subsection Logical operators
@cindex Logical operators

  These are the usual logical operations for boolean values. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Logical operators}
@item
    @code{!rhs}
@tab not
@tab @code{if (rhs) then false else true}
@tab 
@tab @code{Boolean}
@tab @code{Boolean}
@item
    @code{lhs || rhs}
@tab conditional or
@tab @code{if (lhs) then true else rhs}
@tab @code{Boolean}
@tab @code{Boolean}
@tab @code{Boolean}
@item
    @code{lhs && rhs}
@tab conditional and
@tab @code{if (lhs) then rhs else false}
@tab @code{Boolean}
@tab @code{Boolean}
@tab @code{Boolean}
@item
    @emph{Logical assignment}
@item
    @code{lhs ||= rhs}
@tab conditional or
@tab @code{if (lhs) then true else lhs=rhs}
@tab variable of type @code{Boolean}
@tab @code{Boolean}
@tab @code{Boolean}
@item
    @code{lhs &&= rhs}
@tab conditional and
@tab @code{if (lhs) then lhs=rhs else false}
@tab variable of type @code{Boolean}
@tab @code{Boolean}
@tab @code{Boolean}
@end multitable

@node nullvalues
@subsection Operators for handling null values
@cindex Operators for handling null values

  These operators make it easy to work with optional expressions. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Existence}
@item
    @code{lhs exists}
@tab exists
@tab @code{if (exists lhs) then true else false}
@tab any type whose intersections with @code{Object}
            and @code{Null} are not @code{Nothing}
@tab 
@tab @code{Boolean}
@item
    @code{lhs nonempty}
@tab nonempty
@tab @code{if (nonempty lhs) then true else false}
@tab any subtype of @code{Anything[]?}
            whose intersections with @code{[]} and 
            @code{[Nothing+]} are not @code{Nothing}
@tab 
@tab @code{Boolean}
@item
    @emph{Nullsafe invocation}
@item
    @code{lhs?.member}
@tab nullsafe attribute
@tab @code{if (exists lhs) then lhs.member else null}
@tab @code{X?}
@tab an attribute of type @code{T}
            of @code{X}
@tab @code{T?}
@item
    @code{lhs?.member}
@tab nullsafe method
@tab 
@tab @code{X?}
@tab a method of callable type 
            @code{T(*P)} 
            of @code{X}
            with exactly one parameter list
@tab @code{T?(*P)}
@end multitable

@node listmap
@subsection Correspondence, subrange, and stream operators
@cindex Correspondence, subrange, and stream operators

  These operators provide a simplified syntax for accessing values 
        of a @code{Correspondence}, for obtaining subranges of 
        @code{Ranged} objects, and for spreading member access
        over a stream. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Keyed item access}
@item
    @code{lhs[index]}
@tab lookup
@tab @code{lhs.get(index)}
@tab @code{Correspondence<X,Y>}
@tab @code{X}
@tab @code{Y?}
@item
    @emph{Subranges}
@item
    @code{lhs[from:length]}
@tab measured subrange
@tab @code{lhs.measure(from,length)}
@tab @code{Ranged<X,Y,Z>}
@tab @code{X}, @code{Integer}
@tab @code{Z}
@item
    @code{lhs[from..to]}
@tab spanned subrange
@tab @code{lhs.span(from,to)}
@tab @code{Ranged<X,Y,Z>}
@tab @code{X}, @code{X}
@tab @code{Z}
@item
    @code{lhs[from...]}
@tab upper spanned subrange
@tab @code{lhs.spanFrom(from)}
@tab @code{Ranged<X,Y,Z>}
@tab @code{X}
@tab @code{Z}
@item
    @code{lhs[...to]}
@tab lower spanned subrange
@tab @code{lhs.spanTo(to)}
@tab @code{Ranged<X,Y,Z>}
@tab @code{X}
@tab @code{Z}
@item
    @emph{Spread invocation}
@item
    @code{lhs*.attribute}
@tab spread attribute
@tab @code{[*lhs.map(X.attribute)]}
@tab @code{Iterable<X,N>}
@tab attribute of @code{X} of
            type @code{T}
@tab @code{[T*]} or @code{[T+]}
@item
    @code{lhs*.method}
@tab spread method
@tab @code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}
@tab @code{Iterable<X,N>}
@tab method of @code{X} of
            callable type @code{T(*P)}
            with exactly one parameter list
@tab @code{[T*](*P)} or
            @code{[T+](*P)}
@item
    @emph{Spread multiplication}
@item
    @code{lhs ** rhs}
@tab scale
@tab @code{rhs.scale(lhs)}
@tab @code{X}
@tab @code{Scalable<X,Y>}
@tab @code{Y}
@end multitable
There are two special cases related to sequences. A type @code{X}
    is a @emph{sequence type} if @code{X} is a subtype of 
    @code{Sequential<Anything>}. 

  For any sequence type @code{X} with principal instantiation
    @code{[E*]} and integer @code{n}, we can form the 
    @emph{nth tail type, Xn, of 
    X} as follows: 

  
  @itemize @bullet
  
  @item for every @code{i<=0}, @code{Xi} 
            is @code{X}, 

  
  @item for every @code{i>0}, if @code{Xi} 
            has the principal instantiation @code{Tuple<Ui,Fi,Ti>} 
            then @code{X(i+1)} is @code{Ti}, or, if 
            @code{Xi} has principal instantiation @code{[Fi*]}
            then @code{X(i+1)} is @code{[Fi*]}, or, otherwise,
            if @code{Xi} is @code{[]}, then @code{X(i+1)} 
            is also @code{[]}. 

  
  @end itemize
For any sequence type @code{X} and integer @code{n}, 
    we can form the @emph{nth element type, En, 
    of X} as follows: 

  
  @itemize @bullet
  
  @item if @code{n>=0} and @code{Xn} 
            has the principal instantiation @code{[Fn+]} then 
            @code{En} is @code{Fn}, or, 

  
  @item otherwise, @code{Xn} has the principal 
            instantiation @code{[Fn*]} and @code{En} 
            is @code{Fn?}. 

  
  @end itemize
Then the two special cases are: 

  
  @itemize @bullet
  
  @item The type of an expression of form @code{x[i]} where
            @code{x} is of the sequence type @code{X} and 
            @code{n} is an integer literal is @code{En}. 

  
  @item The type of an expression of form @code{x[i...]} where
            @code{x} is of the sequence type @code{X} and 
            @code{n} is an integer literal is @code{Xn} if
            @code{Xn} is an instantiation of @code{Tuple},
            @code{[Fn+]} if @code{Xn} has the principal 
            instantiation @code{[Fn+]}, or @code{[Fn*]}
            if @code{Xn} has the principal instantiation 
            @code{[Fn*]}. 

  
  @end itemize

@node creation
@subsection Operators for creating objects
@cindex Operators for creating objects

  These operators simplify the syntax for instantiating certain 
        commonly used built-in types. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Range and entry constructors}
@item
    @code{lhs..rhs}
@tab spanned range
@tab @code{span(lhs, rhs)}
@tab @code{T given T satisfies Enumerable<T>}
@tab @code{T}
@tab @code{Range<T>}
@item
    @code{lhs:rhs}
@tab measured range
@tab @code{measure(lhs,rhs)}
@tab @code{T given T satisfies Enumerable<T>}
@tab @code{Integer}
@tab @code{Range<T>|[]}
@item
    @code{lhs->rhs}
@tab entry
@tab @code{Entry(lhs, rhs)}
@tab @code{U given U satisfies Object}
@tab @code{V}
@tab @code{Entry<U,V>}
@end multitable

@node conditionals
@subsection Conditional operators
@cindex Conditional operators

  Two special operators allow emulation of the famous ternary
        operator of C-like languages. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Conditionals}
@item
    @code{lhs then rhs}
@tab then
@tab @code{if (lhs) then rhs else null}
@tab @code{Boolean}
@tab @code{T given T satisfies Object}
@tab @code{T?}
@item
    @code{lhs else rhs}
@tab else
@tab @code{if (exists lhs) then lhs else rhs}
@tab @code{U} such that @code{null is U}
@tab @code{V}
@tab @code{U&Object|V}
@end multitable

@node arithmetic
@subsection Arithmetic operators
@cindex Arithmetic operators

  These are the usual mathematical operations for all kinds of
        numeric values. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Increment, decrement}
@item
    @code{++rhs}
@tab successor
@tab @code{rhs=rhs.successor}
@tab 
@tab variable of type @code{Ordinal<T>}
@tab @code{T}
@item
    @code{--rhs}
@tab predecessor
@tab @code{rhs=rhs.predecessor}
@tab 
@tab variable of type @code{Ordinal<T>}
@tab @code{T}
@item
    @code{lhs++}
@tab increment
@tab 
@tab variable of type @code{Ordinal<T>}
@tab 
@tab @code{T}
@item
    @code{lhs--}
@tab decrement
@tab 
@tab variable of type @code{Ordinal<T>}
@tab 
@tab @code{T}
@item
    @emph{Numeric operators}
@item
    @code{+rhs}
@tab 
@tab @code{rhs}
@tab 
@tab @code{Invertible <I>}
@tab @code{I}
@item
    @code{-rhs}
@tab negation
@tab @code{rhs.negated}
@tab 
@tab @code{Invertible <I>}
@tab @code{I}
@item
    @code{lhs + rhs}
@tab sum
@tab @code{lhs.plus(rhs)}
@tab @code{Summable<X>}
@tab @code{X}
@tab @code{X}
@item
    @code{lhs - rhs}
@tab difference
@tab @code{lhs.minus(rhs)}
@tab @code{Invertible <X>}
@tab @code{X}
@tab @code{X}
@item
    @code{lhs * rhs}
@tab product
@tab @code{lhs.times(rhs)}
@tab @code{Numeric<X>}
@tab @code{X}
@tab @code{X}
@item
    @code{lhs / rhs}
@tab quotient
@tab @code{lhs.divided(rhs)}
@tab @code{Numeric<X>}
@tab @code{X}
@tab @code{X}
@item
    @code{lhs % rhs}
@tab remainder
@tab @code{lhs.remainder(rhs)}
@tab @code{Integral<X>}
@tab @code{X}
@tab @code{X}
@item
    @code{lhs ^ rhs}
@tab power
@tab @code{lhs.power(rhs)}
@tab @code{Exponentiable <X,Y>}
@tab @code{Y}
@tab @code{X}
@item
    @emph{Numeric assignment}
@item
    @code{lhs += rhs}
@tab add
@tab @code{lhs=lhs.plus(rhs)}
@tab variable of type @code{Summable<N>}
@tab @code{N}
@tab @code{N}
@item
    @code{lhs -= rhs}
@tab subtract
@tab @code{lhs=lhs.minus(rhs)}
@tab variable of type @code{Invertible <N>}
@tab @code{N}
@tab @code{N}
@item
    @code{lhs *= rhs}
@tab multiply
@tab @code{lhs=lhs.times(rhs)}
@tab variable of type @code{Numeric<N>}
@tab @code{N}
@tab @code{N}
@item
    @code{lhs /= rhs}
@tab divide
@tab @code{lhs=lhs.divided(rhs)}
@tab variable of type @code{Numeric<N>}
@tab @code{N}
@tab @code{N}
@item
    @code{lhs %= rhs}
@tab remainder
@tab @code{lhs=lhs.remainder(rhs)}
@tab variable of type @code{Integral<N>}
@tab @code{N}
@tab @code{N}
@end multitable
The postfix increment and decrement operators are defined as follows: 

  
  @itemize @bullet
  
  @item @code{x++} means the value of @code{result}
            after executing @code{X result=x; ++x;}, and 

  
  @item @code{x--} means the value of @code{result}
            after executing @code{X result=x; --x;}. 

  
  @end itemize
Arithmetic operators automatically widen from @code{Integer} 
        to @code{Float} when necessary. If one operand expression is 
        of static type @code{Integer}, and the other is of type 
        @code{Float}, the operand of type @code{Integer} 
        is widened to a @code{Float} in order to make the operator 
        expression well-typed. Widening is performed by evaluating the attribute 
        @code{float} defined by @code{Integer}. 

  
@smallindentedblock
  Note: this is the only circumstance in the language where 
        implicit type conversion occurs. In fact, it is more correct to view this 
        behavior as an instance of operator overloading than as an implicit type 
        conversion. Implicit widening does not occur when an expression of type 
        @code{Integer} is merely assigned to the type 
        @code{Float}, since such behavior would result in ambiguities 
        when generics come into play. 

  
@end smallindentedblock

@node sets
@subsection Set operators
@cindex Set operators

  These operators provide traditional mathematical operations for sets. 

  
@multitable {@code{lhs[from:length]}} {lower spanned subrange} {@code{compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))}} {any subtype of @code{Anything[]?} whose intersections with @code{[]} and @code{[Nothing+]} are not @code{Nothing}} {@code{Y given Y satisfies Identifiable} where @code{X&Y} is not @code{Nothing}} {@code{[T*](*P)} or @code{[T+](*P)}}
    
@headitem
    Example
@tab Name
@tab Definition
@tab LHS type
@tab RHS type
@tab Return type
@item
    @emph{Set operators}
@item
    @code{lhs | rhs}
@tab union
@tab @code{lhs.union(rhs)}
@tab @code{Set<X>}
@tab @code{Set<Y>}
@tab @code{Set<X|Y>}
@item
    @code{lhs & rhs}
@tab intersection
@tab @code{lhs.intersection(rhs)}
@tab @code{Set<X>}
@tab @code{Set<Y>}
@tab @code{Set<X&Y>}
@item
    @code{lhs ~ rhs}
@tab complement
@tab @code{lhs.complement(rhs)}
@tab @code{Set<X>}
@tab @code{Set<Object>}
@tab @code{Set<X>}
@item
    @emph{Set assignment}
@item
    @code{lhs |= rhs}
@tab union
@tab @code{lhs=lhs|rhs}
@tab variable of type @code{Set<X>}
@tab @code{Set<X>}
@tab @code{Set<X>}
@item
    @code{lhs &= rhs}
@tab intersection
@tab @code{lhs=lhs&rhs}
@tab variable of type @code{Set<X>}
@tab @code{Set<Object>}
@tab @code{Set<X>}
@item
    @code{lhs ~= rhs}
@tab complement
@tab @code{lhs=lhs~rhs}
@tab variable of type @code{Set<X>}
@tab @code{Set<Object>}
@tab @code{Set<X>}
@end multitable

@node metamodelexpressions
@section Metamodel expressions
@cindex Metamodel expressions

  
      
@menu
      
* typeofametamodelexpression:: Type of a metamodel expression
@end menu

      A @emph{metamodel expression} is a reference to
        a type, a class, a function, a value, or a constructor. It evaluates 
        to a metamodel object whose static type captures, respectively: 

  
  @itemize @bullet
  
  @item the type itself, 

  
  @item the callable type of the class, 

  
  @item the callable type of the function, 

  
  @item the type of the value, 

  
  @item the type of the value constructor, or 

  
  @item the callable type of the callable constructor. 

  
  @end itemize

@verbatim
Meta: TypeMeta | BaseMeta | MemberMeta | ConstructorMeta
@end verbatim
A @emph{type metamodel expression} is a type, as
        defined by @ref{type, ,Types}, surrounded by backticks. 

  
@verbatim
TypeMeta: "`" Type "`"
@end verbatim
The type may or may not be a reference to a class or interface. 

  
@example
Class<Person,[Name]> personClass = `Person`;
@end example

@example
Interface<List<String>> stringListInterface = `List<String>`;
@end example

@example
UnionType<Integer|Float> numberType = `Number`;
@end example

@example
Type<Element> elementType = `Element`;
@end example
A @emph{base metamodel expression} is a member name, 
        with an optional list of type arguments, surrounded by backticks. 

  
@verbatim
BaseMeta: "`" PackageQualifier? MemberName TypeArguments? "`"
@end verbatim
A base metamodel expression is a reference to a value or function. 
        The referenced declaration is determined according to
        @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution}. 

  A @emph{member metamodel expression} is a qualifier, 
        followed by a member name, with an optional list of type arguments, 
        surrounded by backticks. 

  
@verbatim
MemberMeta: "`" PrimaryType "." MemberName TypeArguments? "`"
@end verbatim
The member metamodel expression is qualified by a type, as defined 
        by @ref{type, ,Types}. 

  A member metamodel expression is a reference to an attribute or 
        method of the type identified by the qualifier. The member is resolved 
        as a member of the type according to 
        @ref{qualifiedreferenceresolution, ,Qualified reference resolution}. 

  
@example
Function<Float,[@{Float+@}]> sumFunction = `sum<Float>`;
@end example

@example
Attribute<Person,String> personNameAttribute = `Person.name`;
@end example

@example
Method<Person,Anything,[String]> personSayMethod = `Person.say`;
@end example

@example
Attribute<\Isystem,Integer> systemMillis = `\Isystem.milliseconds`;
@end example
A @emph{constructor metamodel expression} is a qualifier, 
        followed by a constructor name, with an optional list of type arguments, 
        surrounded by backticks. 

  
@verbatim
ConstructorMeta: "`" PrimaryType "." ()MemberName | TypeName) TypeArguments? "`"
@end verbatim
The constructor metamodel expression qualifier is a type that is an
        instantiation of a class. 

  A constructor metamodel expression is a reference to a constructor or 
        of the class identified by the qualifier. The constructor is resolved as a 
        member of the class according to 
        @ref{qualifiedreferenceresolution, ,Qualified reference resolution}. 

  Type argument inference is impossible in a metamodel expression,
        so type arguments must be explicitly provided for every generic 
        declaration. 

  
@node typeofametamodelexpression
@subsection Type of a metamodel expression
@cindex Type of a metamodel expression

  The type of a metamodel expression depends upon the kind of 
            declaration referenced: 

  
  @itemize @bullet
  
  @item for a toplevel value of type @code{R}, 
                    the type is @code{Value<R>}, 

  
  @item for a toplevel function of callable type 
                    @code{R(*P)}, the type is 
                    @code{Function<R,P>}, 

  
  @item for a toplevel class of callable type 
                    @code{R(*P)}, the type is 
                    @code{Class<R,P>}, 

  
  @item for a callable constructor of a toplevel class of 
                    callable type @code{R(*P)}, the type is 
                    @code{CallableConstructor<R,P>}, 

  
  @item for a value constructor of a toplevel class of 
                    type @code{R}, the type is 
                    @code{ValueConstructor<R>}, 

  
  @item for a class nested in a block of callable type 
                    @code{R(*P)}, the type is 
                    @code{Class<R,Nothing>}, and 

  
  @item for a toplevel interface or interface nested 
                    in a block of type @code{R}, the type is 
                    @code{Interface<R>}. 

  
  @end itemize

@smallindentedblock
  Note: members of anonymous classes are treated as 
            toplevels here. 

  
@end smallindentedblock
Furthermore, given a member of a type @code{T}: 

  
  @itemize @bullet
  
  @item for an attribute of type @code{R}, the 
                    type is @code{Attribute<T,R>}, 

  
  @item for a method of callable type 
                    @code{R(*P)}, the type is 
                    @code{Method<T,R,P>}, 

  
  @item for a member class of callable type 
                    @code{R(*P)}, the type is 
                    @code{MemberClass<T,R,P>}, and 

  
  @item for a callable constructor of a member class of 
                    callable type @code{R(*P)}, the type is 
                    @code{MemberClassCallableConstructor<T,R,P>}, 
                    and 

  
  @item for a value constructor of a member class of 
                    type @code{R}, the type is 
                    @code{MemberClassValueConstructor<T,R>}, 
                    and 

  
  @item for a value of a member class of type 
                    @code{R}, the type is 
                    @code{Attribute<T,R>}, 
                    and 

  
  @item for a nested interface of type 
                    @code{R}, the type is 
                    @code{MemberInterface<T,R>}. 

  
  @end itemize
Finally: 

  
  @itemize @bullet
  
  @item for a union type @code{T}, the type is
                    @code{UnionType<T>}, 

  
  @item for an intersection type @code{T}, the 
                    type is @code{IntersectionType<T>}, 

  
  @item for the type @code{Nothing}, the type is 
                    @code{Type<Nothing>}, and 

  
  @item for a type parameter @code{T}, the type is
                    @code{Type<T>}. 

  
  @end itemize
If a type alias occurs inside a typed metamodel expression, it 
            is replaced by its definition, after substituting type arguments, 
            before determining the type of the metamodel expression. 

  
@node referenceexpressions
@section Reference expressions
@cindex Reference expressions

  
      
@menu
      
* declarationreferences:: Declaration references
* packageandmodulereferences:: Package and module references
* typeofareferenceexpression:: Type of a reference expression
@end menu

      A @emph{reference expression} is a reference to
        a program element and evaluates to a detyped metamodel of the program 
        element. Reference expressions are used primarily in annotations, 
        especially the documentation annotations listed in 
        @ref{documentation, ,Documentation}. A reference expression may refer to: 

  
  @itemize @bullet
  
  @item a class, interface, type alias, or type parameter, 

  
  @item a function or value, 

  
  @item a constructor, or 

  
  @item a package or module. 

  
  @end itemize

@verbatim
Dec: TypeDec | MemberDec | ConstructorDec | PackageDec | ModuleDec
@end verbatim

@node declarationreferences
@subsection Declaration references
@cindex Declaration references

  Declaration reference expressions may be qualified by a
            @emph{member declaration qualifier}, a sequence
            of identifiers identifying a class or interface declaration or 
            an anonymous class declaration: 

  
@verbatim
MemberDecQualifier: ( (TypeName | MemberName) "." )+
@end verbatim
Each identifier in the member declaration qualifier is 
            the name of a class, interface, or anonymous class. 

  A @emph{class reference expression}, 
            @emph{interface reference expression},
            @emph{alias reference expression}, or
            @emph{type parameter reference expression} is an
            optional member declaration qualifier, followed by the name of
            a class or anonymous class, interface, alias, or type parameter,
            with the keyword @code{class}, @code{interface}, 
            @code{alias}, or @code{given}, respectively, 
            surrounded by backticks. 

  
@verbatim
TypeKeyword: "class" | "interface" | "alias" | "given"
@end verbatim

@verbatim
TypeDec: "`" TypeKeyword ( PackageQualifier? MemberDecQualifier? (TypeName | MemberName) )? "`"
@end verbatim
For a class or interface reference expression, the name of 
            the class or interface is optional. In this case, the class or
            interface reference is to the immediately containing class or
            interface, if any, as defined in @ref{selfreferences, ,Self references}. 
            For alias or type parameter reference expressions, the name of 
            the alias or type parameter is required. 

  
@example
ClassDeclaration thisClass = `class`;
@end example

@example
ClassDeclaration personClass = `class Person`;
@end example

@example
ClassDeclaration thisInterface = `interface`;
@end example

@example
InterfaceDeclaration stringListInterface = `interface List`;
@end example

@example
AliasDeclaration numberAlias = `alias Number`;
@end example

@example
TypeParameter elementTypeParameter = `given Element`;
@end example

@example
CallableConstructorDeclaration arrayOfSizeConstructor = `new Array.ofSize`;
@end example
A @emph{value reference expression} or
            @emph{function reference expression} is an optional 
            member declaration qualifier, followed by the name of a function,
            value, value constructor, or anonymous class, with the keyword 
            @code{value} or @code{function}, surrounded 
            by backticks. 

  
@verbatim
MemberKeyword: "value" | "function"
@end verbatim

@verbatim
MemberDec: "`" MemberKeyword PackageQualifier? MemberDecQualifier? MemberName "`"
@end verbatim
A @emph{constructor reference expression} is a 
            member declaration qualifier, followed by the name of a callable 
            constructor, with the keyword @code{new}, surrounded by 
            backticks. 

  
@verbatim
ConstructorKeyword: "new"
@end verbatim

@verbatim
ConstructorDec: "`" ConstructorKeyword PackageQualifier? MemberDecQualifier TypeName "`"
@end verbatim
A reference expression is a reference to a declaration. The 
            referenced declaration is determined according to
            @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution} and
            @ref{qualifiedreferenceresolution, ,Qualified reference resolution}. The kind of the
            referenced declaration must match the kind of reference indicated
            by the keyword. 

  
@example
ValueDeclaration personNameAttribute = `value Person.name`;
@end example

@example
FunctionDeclaration personSayMethod = `function Person.say`;
@end example

@example
FunctionDeclaration processWriteMethod = `function process.write`;
@end example

@example
ClassDeclaration processClass = `class process`;
@end example

@node packageandmodulereferences
@subsection Package and module references
@cindex Package and module references

  A @emph{package reference expression} is a package
            name, as defined by @ref{packages, ,Packages}, with the keyword
            @code{package}, surrounded by backticks. 

  
@verbatim
PackageDec: "`" "package" FullPackageName? "`"
@end verbatim
The package name must refer to a package from which an 
            @code{import} statement in the same compilation unit may 
            import declarations, as defined by @ref{imports, ,Imports}. 

  If there is no explicit package name, the package reference
            is to the package in which the package reference expression occurs. 

  
@example
Package currentPackage = `package`;
Package modelPackage = `package ceylon.language.meta.model`;
@end example
A @emph{module reference expression} is a module
            name, as defined by @ref{modulenamesandversionidentifiers, ,Module names and version identifiers}, 
            with the keyword @code{module}, surrounded by backticks. 

  
@verbatim
ModuleDec: "`" "module" FullPackageName? "`"
@end verbatim
The module name must refer to the module to which the 
            compilation unit belongs, as specified by @ref{sourcelayout, ,Source layout}, 
            or to a module imported by the module to which the compilation unit 
            belongs, as defined by @ref{moduledescriptors, ,Module descriptors}. 

  If there is no explicit module name, the module reference
            is to the package in which the module reference expression occurs. 

  
@example
Module currentModule = `module`;
Module languageModule = `module ceylon.language`;
@end example

@node typeofareferenceexpression
@subsection Type of a reference expression
@cindex Type of a reference expression

  The type of a reference expression depends upon the kind of 
            program element referenced: 

  
  @itemize @bullet
  
  @item for a module, the type is 
                    @code{Module}, 

  
  @item for a package, the type is 
                    @code{Package}, 

  
  @item for a reference, the type is 
                    @code{ReferenceDeclaration}, 

  
  @item for any other value, the type is 
                    @code{ValueDeclaration}, 

  
  @item for a function, the type is 
                    @code{FunctionDeclaration}, 

  
  @item for a callable constructor, the type is 
                    @code{CallableConstructorDeclaration}, 

  
  @item for a value constructor, the type is 
                    @code{ValueConstructorDeclaration}, 

  
  @item for a type parameter, the type is 
                    @code{TypeParameter}, 

  
  @item for a type alias declared using the keyword
                    @code{alias}, the type is 
                    @code{AliasDeclaration}, 

  
  @item for a class with an initializer parameter list,
                    or for any class alias, the type is 
                    @code{ClassWithInitializerDeclaration},
                     

  
  @item for a class with constructors, the type is 
                    @code{ClassWithConstructorsDeclaration}, 
                    and 

  
  @item for an interface or interface alias, the type 
                    is @code{InterfaceDeclaration}. 

  
  @end itemize
For a reference to an anonymous class, the type depends
            upon the keyword, @code{class}, or @code{value}, 
            specified in the reference expression: 

  
  @itemize @bullet
  
  @item for a class reference expression, the type is 
                    @code{ClassDeclaration}, but 

  
  @item for a value reference expression, the type is 
                    @code{ValueDeclaration}. 

  
  @end itemize

@node annotations
@chapter Annotations
@cindex Annotations

@menu
  
* programelementannotations:: Annotations of program elements
* annotationdefinition:: Annotation definition
* annotationvalues:: Annotation values
* languageannotations:: Language annotations
* serialization:: Serialization
@end menu

  @emph{Annotations} allow information to be attached to a
    declaration or assertion, and recovered at runtime via the use of the Ceylon
    metamodel. Annotations are used to specify: 

  
  @itemize @bullet
  
  @item information used by the compiler while typechecking the program, 

  
  @item API documentation for the documentation compiler, 

  
  @item serialization of a class, and 

  
  @item information needed by generic frameworks and libraries. 

  
  @end itemize

@node programelementannotations
@section Annotations of program elements
@cindex Annotations of program elements

  
      
@menu
      
* annotationlists:: Annotation lists
* annotationargments:: Annotation arguments
@end menu

      Annotations occur at the very beginning of a declaration or assertion, 
        in an @emph{annotation list}. 

  
@example
"The user login action"
by ("Gavin King",
    "Andrew Haley")
throws (`class DatabaseException`,
        "if database access fails")
see (`function LogoutAction.logout`)
scope (session) 
action @{ description="Log In"; url="/login"; @}
shared deprecated
@end example

@node annotationlists
@subsection Annotation lists
@cindex Annotation lists

  An annotation is an initial lowercase identifier, optionally 
            followed by an argument list. 

  
@verbatim
Annotation: MemberName Arguments?
@end verbatim
The annotation name is a reference to an annotation constructor,
            resolved according to @ref{unqualifiedreferenceresolution, ,Unqualified reference resolution}. 

  A list of annotations does not require punctuation between the 
            individual annotations in the list. An annotation list may begin with 
            a string literal, in which case it is interpreted as the argument of a 
            @code{doc} annotation. 

  
@verbatim
Annotations: StringLiteral? Annotation*
@end verbatim
Every annotation is an invocation expression, as defined by
            @ref{invocationexpressions, ,Invocation expressions}, of an annotation constructor.
            The annotation name is interpreted as a base expression, as defined in 
            @ref{baseexpressions, ,Base expressions}. 

  
@node annotationargments
@subsection Annotation arguments
@cindex Annotation arguments

  For an annotation with no arguments, the argument list may be 
            omitted, in which case the annotation is interpreted as having an empty 
            positional argument list. Otherwise, the annotation argument list may be 
            specified using one of two forms: 

  
  @itemize @bullet
  
  @item Using a positional argument list, as defined in 
                    @ref{positionalarguments, ,Positional argument lists}: 

  
@example
doc ("the name") String name;
@end example

  @item Using a named argument list, as defined in 
                    @ref{namedarguments, ,Named argument lists}: 

  
@example
doc @{ description="the name"; @} String name;
@end example

  @end itemize
As a special case, the name of the @code{doc} annotation
            and the parenthesis around its argument may be ommitted if it is the first 
            annotation in an annotation list. 

  
@example
"the name" String name;
@end example
Operator expressions, member expressions, self references, anonymous
            functions, comprehensions, and string templates are not permitted in an 
            annotation argument. Every base expression in an annotation argument must be 
            a value reference to an anonyous class instance of an enumerated type, or 
            must occur in a direct instantiation expression for an annotation type. 

  A named argument to an annotation may not be an inline function, value,
            or anonymous class. 

  
@node annotationdefinition
@section Annotation definition
@cindex Annotation definition

  
      
@menu
      
* annotationconstructors:: Annotation constructors
* annotationtypes:: Annotation types
* constrainedannotationtypes:: Constrained annotation types
@end menu

      Annotations are typesafe. 

  
  @itemize @bullet
  
  @item An @emph{annotation constructor} defines the
                schema of an annotation as it appears at a program element. 

  
  @item An @emph{annotation type} defines constraints 
                upon which program elements can bear the annotation, and an API for 
                accessing the information carried by an annotation. 

  
  @end itemize

@node annotationconstructors
@subsection Annotation constructors
@cindex Annotation constructors

  An @emph{annotation constructor} is a toplevel function
            that defines an annotation schema. An annotation constructor must be annotated 
            @code{annotation}. An annotation constructor may not declare type 
            parameters. 

  Each parameter of an annotation constructor must have one of the following
            types: 

  
  @itemize @bullet
  
  @item @code{Integer}, @code{Float},
                    @code{Character}, or @code{String}, 

  
  @item an enumerated type whose cases are all anonymous classes,
                    such as @code{Boolean}, 

  
  @item a subtype of @code{Declaration} in
                    @code{ceylon.language.meta.declaration}, 

  
  @item an annotation type, 

  
  @item @code{T?} where @code{T} is a legal 
                    annotation constructor parameter type, 

  
  @item @code{@{T*@}}, @code{@{T+@}},
                    @code{[T*]}, or @code{[T+]} where 
                    @code{T} is a legal annotation constructor parameter 
                    type, or 

  
  @item any tuple type whose element types are legal annotation 
                    constructor parameter types. 

  
  @end itemize
A parameter of an annotation constructor may be variadic. 

  An annotation constructor must simply instantiate and return an instance
            of an annotation type. The body of an annotation constructor may not contain
            multiple statements. Operator expressions, member expressions, self references,
            anonymous functions, comprehensions, and string templates are not permitted in 
            the definition of an annotation constructor. Every base expression in the body 
            of an annotation constructor must be a reference to a parameter of the annotation 
            constructor or to an anonyous class instance of an enumerated type, or must occur 
            in a direct instantiation expression for an annotation type. 

  A named argument appearing in the definition of an annotation constructor
            may not be an inline function, value, or anonymous class. 

  
@example
shared annotation Scope scope(ScopeType s) => Scope(s);
@end example

@example
shared annotation Todo todo(String text) => Todo(text);
@end example
An annotation constructor parameter may have a default argument, which must
            be a legal annotation argument. 

  The return type of an annotation constructor must be a constrained annotation 
            type, as defined below in @ref{constrainedannotationtypes, ,Constrained annotation types}. 

  A user-defined annotation constructor may not return the same annotation 
            type as one of the modifiers listed below in @ref{declarationmodifiers, ,Declaration modifiers}. 

  
@smallindentedblock
  Note: in future releases of the language we will let an annotation 
            constructor return a sequence or tuple of annotation type instances. 

  
@end smallindentedblock

@node annotationtypes
@subsection Annotation types
@cindex Annotation types

  Annotation constructors produce instances of @emph{annotation 
            types}. An annotation type is a class annotated @code{annotation}. 
            An annotation type may not be a generic type with type parameters. An 
            annotation type must have an empty initializer section. 

  
@smallindentedblock
  Note: currently every annotation type must be a 
            @code{final} class which directly extends @code{Basic}
            in @code{ceylon.language}. 

  
@end smallindentedblock
Each initializer parameter of an annotation type must have one of the 
            following types: 

  
  @itemize @bullet
  
  @item @code{Integer}, @code{Float},
                    @code{Character}, or @code{String}, 

  
  @item an enumerated type whose cases are all anonymous classes,
                    such as @code{Boolean}, 

  
  @item a subtype of @code{Declaration} in
                    @code{ceylon.language.meta.declaration}, 

  
  @item an annotation type, 

  
  @item @code{T?} where @code{T} is a legal 
                    annotation parameter type, 

  
  @item @code{@{T*@}}, @code{@{T+@}},
                    @code{[T*]}, or @code{[T+]} where 
                    @code{T} is a legal annotation parameter type, or 

  
  @item any tuple type whose element types are legal annotation 
                    parameter types. 

  
  @end itemize
An initializer parameter of an annotation type may be variadic. 

  An initializer parameter of an annotation type may have a default argument, 
            which must be a legal annotation argument. 

  
@node constrainedannotationtypes
@subsection Constrained annotation types
@cindex Constrained annotation types

  A @emph{constrained annotation type} is an annotation type 
            that is a subtype of @code{OptionalAnnotation} or 
            @code{SequencedAnnotation} defined in the package 
            @code{ceylon.language}. 

  
  @itemize @bullet
  
  @item If @code{A} is a subtype of 
                    @code{OptionalAnnotation}, at most one annotation of 
                    annotation type @code{A} may occur at a given program 
                    element. 

  
  @item If @code{A} is a subtype of 
                    @code{SequencedAnnotation}, multiple annotations of 
                    annotation type @code{A} may occur at a given program 
                    element. 

  
  @item If @code{A} is a subtype of 
                    @code{ConstrainedAnnotation<A,B,P,T>}, then an 
                    annotation of annotation type @code{A} may not occur 
                    at a program element whose reference expression type, as defined in
                    @ref{typeofareferenceexpression, ,Type of a reference expression}, is not assignable to 
                    @code{P}. 

  
  @item If @code{A} is a subtype of 
                    @code{ConstrainedAnnotation<A,B,P,T>} where
                    @code{T} is not exactly @code{Anything}, 
                    then an annotation of annotation type @code{A} may not 
                    occur at a program element whose metamodel type, as defined in
                    @ref{typeofametamodelexpression, ,Type of a metamodel expression}, is not assignable to 
                    @code{T}. 

  
  @end itemize

@example
shared final annotation class Scope(shared ScopeType scope)
        satisfies OptionalAnnotation<Scope,ClassOrInterfaceDeclaration> @{
    string => (scope==request then "request")
         else (scope==session then "session")
         else (scope==application then "application")
         else nothing;
@}
@end example

@example
shared final annotation class Todo(String text)
        satisfies SequencedAnnotation<Todo> @{
    string => text;
@}
@end example

@smallindentedblock
  Note: it is perfectly acceptable for multiple annotation 
            constructors to return the same annotation type. 

  
@end smallindentedblock

@node annotationvalues
@section Annotation values
@cindex Annotation values

  An @emph{annotation value} is the value returned when an
        annotation constructor is invoked. We may obtain the annotation values of all 
        annotations of a given annotation type that occur at a given program element 
        by passing the annotation type metamodel, as defined in 
        @ref{metamodelexpressions, ,Metamodel expressions}, and program element reference, as 
        defined in @ref{referenceexpressions, ,Reference expressions}, to the method
        @code{annotations()} defined in the package
        @code{ceylon.language.meta.model}. 

  
@example
Scope scope = annotations(`Scope`, `class Person`) else Scope(request);
@end example

@example
Todo[] todos = annotations(`Todo`, `function method`);
@end example

@node languageannotations
@section Language annotations
@cindex Language annotations

  
      
@menu
      
* declarationmodifiers:: Declaration modifiers
* documentation:: Documentation
@end menu

      Certain important annotations are predefined in the module 
        @code{ceylon.language}. 

  
@node declarationmodifiers
@subsection Declaration modifiers
@cindex Declaration modifiers

  The following annotations, called @emph{modifiers}, 
            are compiler instructions that affect the compilation process: 

  
  @itemize @bullet
  
  @item @code{shared} specifies that a 
                    declaration is visible outside of the package or body in 
                    which it occurs, or that a package is visible outside the
                    module it belongs to. 

  
  @item @code{abstract} specifies that a class
                    cannot be instantiated, or that a constructor is a 
                    partial constructor. 

  
  @item @code{formal} specifies that a member 
                    does not specify an implementation and must therefore be 
                    refined by every concrete subclass. 

  
  @item @code{default} specifies that a method, 
                    attribute, or member class may be refined by subtypes. 

  
  @item @code{actual} indicates that a method,
                    attribute, or member type refines a method, attribute, 
                    or member type defined by a supertype. 

  
  @item @code{variable} specifies that a value 
                    may be assigned multiple times. 

  
  @item @code{late} disables definite 
                    initialization checking for a reference, allowing the 
                    reference to be initialized after the initializer of
                    the class to which it belongs has already completed. 

  
  @item @code{native} specifies that a program
                    element is implementation is specific to a certain platform,
                    and should be ignored by the compiler backend when compiling 
                    for any other platform, or that it is actually implemented 
                    in a different language, and that the program element should 
                    be completely ignored by the Ceylon compiler backend, or that
                    a module or module @code{import} statement, as 
                    defined in @ref{moduledescriptors, ,Module descriptors}, is specific 
                    to a certain platform. 

  
  @item @code{deprecated} indicates that a value, 
                    function or type is deprecated. It accepts an optional
                    @code{String} argument. The compiler produces a
                    warning when compiling code that depends upon a deprecated
                    program element. 

  
  @item @code{final} specifies that a class may not 
                    be extended, and may not declare @code{default}
                    members. 

  
  @item @code{sealed} specifies that a class may not 
                    be extended or instantiated outside the module in which it is
                    defined, that an interface may not be satisfied by a class or 
                    interface outside the module in which it is defined, or that
                    a constructor may not be invoked outside the module in which 
                    it is defined. 

  
  @item @code{annotation} specifies that a class is
                    an annotation type, or that a toplevel function is an annotation
                    constructor. 

  
  @item @code{suppressWarnings} hides compilation
                    warnings occurring at the annotated program element. 

  
  @end itemize

@smallindentedblock
  Note: annotation constraints ensure that these annotations 
            do not occur at program elements to which they do not apply. 

  
@end smallindentedblock
The following annotation is a hint to the compiler that lets the 
            compiler optimize compiled bytecode for non-64 bit architectures: 

  
  @itemize @bullet
  
  @item @code{small} specifies that a value of type
                    @code{Integer}, @code{Integer} or
                    @code{Float} contains 32-bit values. 

  
  @end itemize
By default, @code{Integer} and @code{Float} 
            are assumed to represent 64-bit values, as specified in 
            @ref{numericoperations, ,Numeric operations}. 

  
@smallindentedblock
  Note that @code{small} is not yet supported 
            in Ceylon 1.1. 

  
@end smallindentedblock

@node documentation
@subsection Documentation
@cindex Documentation

  The following annotations are instructions to the documentation
            compiler: 

  
  @itemize @bullet
  
  @item @code{doc} specifies the description of a 
                    program element, in Markdown format text. 

  
  @item @code{by} specifies the authors of a program 
                    element. 

  
  @item @code{license} specifies the URL of the
                    license under which a module or package is distributed. 

  
  @item @code{see} specifies a related member or 
                    type. 

  
  @item @code{throws} specifies a thrown exception
                    type. 

  
  @item @code{tagged} specifies classifying named 
                    tags. 

  
  @end itemize
The @code{String} arguments to the @code{deprecated}, 
            @code{doc}, @code{throws} and @code{by} 
            annotations are parsed by the documentation compiler as Markdown-format
            content. 

  These annotations are all defined in the package 
            @code{ceylon.language}. 

  
@node serialization
@section Serialization
@cindex Serialization

  
@smallindentedblock
  TODO: Define how serialization works. 

  
@end smallindentedblock

@node execution
@chapter Execution
@cindex Execution

@menu
  
* objectinstancesidentity:: Object instances, identity, and reference passing
* sequentialexecutionandclosure:: Sequential execution and closure
* executionofcontrolstructures:: Execution of control structures and assertions
* evaluationinvocationandassignment:: Evaluation, invocation, and assignment
* operatorexpressions:: Operator expressions
* comprehensionevaluation:: Evaluation of comprehensions
* concurrency:: Concurrency
@end menu

  A Ceylon program executes in a virtual machine environment, either: 

  
  @itemize @bullet
  
  @item a Java Virtual Machine (JVM), or 

  
  @item a JavaScript virtual machine. 

  
  @end itemize
In future, other virtual machine architectures may be supported. 

  Despite the obvious differences between the respective languages that these 
    virtual machines were designed for, they share very much in common in terms of 
    runtime semantics, including common notions such as object identity, primitive 
    value types, exceptions, garbage collection, dynamic dispatch, and pass by 
    reference. 

  Ceylon abstracts away many of the differences between these platforms, and
    reuses what is common between them. Inevitably there are some differences that
    can't reasonably be hidden from the Ceylon program, and the programmer must take 
    these differences into consideration. 

  In Ceylon, every value is a reference to an instance of a class, except
    within a @code{dynamic} block, where a value with no type may be
    a reference to an object which is not an instance of a class. 

  
@smallindentedblock
  Note: the semantics of objects without classes is platform-dependent
    and outside the scope of this specification. 

  
@end smallindentedblock

@node objectinstancesidentity
@section Object instances, identity, and reference passing
@cindex Object instances, identity, and reference passing

  
      
@menu
      
* valuetypeoptimizations:: Value type optimizations
* reification:: Type argument reification
@end menu

      An @emph{object} is a unique identifier, together with a 
        reference to a class, its type arguments, and a persistent value for each 
        reference declared by the class (including inherited references). The object 
        is said to be an @emph{instance} of the class. 

  A @emph{value} is a reference to an object (a copy of its 
        unique identifier). At a particular point in the execution of the program, 
        every reference of every object that exists, and every initialized reference 
        of every function, getter, setter, or initializer that is currently executing 
        has a value. Furthermore, every time an expression is executed, it produces a 
        value. 

  Two values are said to be @emph{identical} if they are
        references to the same object---if they hold the same unique identifier. 
        The program may determine if two values of type @code{Identifiable} 
        are identical using the @code{===} operator defined in
        @ref{operatordefinition, ,Operator definition}. It may not directly obtain the unique 
        identifier (which is a purely abstract construct). The program has no way of 
        determining the identity of a value which is not of type 
        @code{Identifiable}. 

  Given a value, the program may determine if the referenced object is
        @emph{assignable to a certain type} using the @code{is} 
        operator. The object is assignable to the given type if the applied type formed 
        by its class and type arguments is a subtype of the given type according to the 
        type system defined in @ref{typesystem, ,Type system}. (Therefore, the Ceylon 
        runtime must be capable of reasoning about subtyping.) 

  Invocation of a function or instantiation of a class results in execution 
        of the function body or class initializer with parameter values that are copies 
        of the value produced by executing the argument expressions of the invocation, 
        and a reference to the receiving instance that is a copy of the value produced 
        by executing the receiver expression. The value produced by the invocation 
        expression is a copy of the value produced by execution of the 
        @code{return} directive expression. 

  
@example
Person myself(Person me) @{ return me; @}
Person p = ...;
assert (myself(p)===p); //assertion never fails
@end example

@example
Semaphore s = Semaphore();
this.semaphore = s;
assert (semaphore===s); //assertion never fails
@end example
A new object is produced by execution of a class instantiation expression.
        The Ceylon compiler guarantees that if execution of a class initializer terminates
        with no uncaught exception, then every reference of the object has been initialized
        with a well-defined persistent value. The value of a reference is initialized for 
        the first time by execution of a specifier or assignment expression. Every class 
        instantiation expression results in an object with a new unique identifier shared 
        by no other existing object. The object exists from the point at which execution 
        of its initializer terminates. @emph{Conceptually}, the object exists 
        until execution of the program terminates. 

  In practice, the object exists at least until the point at which it is not 
        reachable by recursively following references from any function, getter, setter, 
        or initializer currently being executed, or from an expression in a statement 
        currently being executed. At this point, its persistent values are no longer 
        accessible to expressions which subsequently execute and the object may be 
        destroyed by the virtual machine. There is no way for the program to determine
        that an object has been destroyed by the virtual machine (Ceylon does not support 
        finalizers). 

  
@node valuetypeoptimizations
@subsection Value type optimizations
@cindex Value type optimizations

  As a special exception to the rules defined above, the compiler is permitted 
            to emit bytecode or compiled JavaScript that produces a new instance of certain 
            types in the module @code{ceylon.language} without execution of the 
            initializer of the class, whenever any expression is evaluated. These types are: 
            @code{Integer}, @code{Float}, @code{Character}, 
            @code{Range}, @code{Entry}, @code{String}, 
            @code{Array}, and @code{Tuple}. Furthermore, it is permitted 
            to use such a newly-produced instance as the value of the expression, as long as the 
            newly-produced instance is equal to the value expected according to the rules above, 
            as determined using the @code{==} operator. 

  Therefore, the types listed above directly extend @code{Object}
            instead of @code{Basic}, and are not @code{Identifiable}. 

  
@smallindentedblock
  Note: this does no justice at all to our compiler. Actually the 
            compiler infrastructure already supports value type optimization for user-defined 
            types, though we have not yet exposed this functionality as part of the language.
             

  
@end smallindentedblock

@node reification
@subsection Type argument reification
@cindex Type argument reification

  Type arguments, as defined in @ref{generictypearguments, ,Generic type arguments}, are 
            @emph{reified} in Ceylon. An instance of a generic type holds a 
            reference to each of its type arguments. Therefore, the following are possible in 
            Ceylon: 

  
  @itemize @bullet
  
  @item testing the runtime value of a type argument of an instance, for 
                    example, @code{objectList is List<Person>} or 
                    @code{case (is List<Person>)}, 

  
  @item filtering exceptions based on type arguments, for example,
                    @code{catch (NotFoundException<Person> pnfe)}, and 

  
  @item testing the runtime value of an instance against a type parameter,
                    for example @code{x is Key}, or against a type with a type 
                    parameter as an argument, for example, 
                    @code{objectList is List<Element>}. 

  
  @item obtaining a @code{Type} object representing a type with 
                    type arguments, for example, @code{`List<Person>`}, 

  
  @item obtaining a @code{Type} object representing the runtime 
                    value of a type parameter, for example, @code{`Element`}, or of 
                    a type with a type parameter as an argument, for example, 
                    @code{`List<Element>`}, and 

  
  @item obtaining a @code{Type} object representing the
                    runtime value of a type argument of an instance using reflection, for 
                    example, @code{type(objectList).typeArguments.first}. 

  
  @end itemize
At runtime, all types are @emph{concrete types} formed by: 

  
  @itemize @bullet
  
  @item recursively replacing all type aliases, class aliases, and interface
                    aliases with their definitions, which is always possible according to 
                    @ref{typealiaselimination, ,Type alias elimination}, and 

  
  @item recursively replacing all type parameters with their type arguments 

  
  @end itemize
in any type that appears in an expression or condition. 

  Therefore, every type parameter refers, at runtime, to a concrete type that
            involves no type aliases or type parameters. In particular, the type arguments
            held by an instance of a generic class are concrete types. 

  This program prints @code{String[]}. 

  
@example
class Generic<out T>(T t) @{ string=>`T`.string; @}
Generic<@{S*@}> gen<S>(S* ss) => Generic(ss);
void run() @{
    print(gen("hello", "world"));
@}
@end example
The runtime is generally permitted, as an optimization, to return a more 
            precise type in place of a less precise type when a type parameter is evaluated.
            This program may print @code{String} instead of @code{Object},
            even though @code{Object} is the type argument inferred at compile time. 

  
@example
class Generic<out T>(T t) @{ string=>`T`.string; @}
Generic<Object> gen(Object o) => Generic(o);
void run() @{
    print(gen("hello"));
@}
@end example

@node sequentialexecutionandclosure
@section Sequential execution and closure
@cindex Sequential execution and closure

  
      
@menu
      
* frames:: Frames
* currentinstancesandcurrentframes:: Current instances and current frames
* currentinstanceofaclassorinterface:: Current instance of a class or interface
* currentframeofablock:: Current frame of a block
* initialization:: Initialization
* classinstanceoptimization:: Class instance optimization
* executionofexpressionandspecificationstatements:: Execution of expression and specification statements
* executionofcontroldirectives:: Execution of control directives
* exceptionpropagation:: Exception propagation
* toplevelinitialization:: Initialization of toplevel references
* lateinitialization:: Initialization of late references
@end menu

      Ceylon programs are organized into bodies, as defined in 
        @ref{blockstructure, ,Block structure and references}, containing statements which are executed 
        sequentially and have access to declarations which occur in the surrounding 
        lexical context and to persistent values held by references, as defined in 
        @ref{references, ,References}, declared in the surrounding lexical context. 

  
@smallindentedblock
  Note: for the purposes of this section, an interface body is, 
        strictly speaking, a trivial case of a body which contains no statements or 
        persistent values, but we're primarily concerned with blocks and class bodies.
         

  
@end smallindentedblock
The statements and non-lazy specifiers that directly occur in a body are 
        executed sequentially in the lexical order in which they occcur. Execution of a 
        body begins at the first statement or non-lazy specifier. Execution of a block 
        terminates when the last statement or non-lazy specifier of the body finishes 
        executing, or when a control directive that terminates the block is executed, 
        or when an exception is thrown by an evaluation, assignment, invocation, or 
        instantiation. 

  
@node frames
@subsection Frames
@cindex Frames

  When execution of a body begins, a @emph{frame} is created.
            For each reference whose declaration directly occurs in the body, the frame
            has a value, which may or may not be initialized. The value may be initialized
            or assigned during execution of the body. 

  We can visualize a frame as a list of reference declarations with optional
            values. For example, a frame with an initialized reference named 
            @code{language} and an uninitialized reference named 
            @code{count} would be written like this: 

  
@example
@{ String language = "ceylon"; Integer count; @}
@end example
While a body is executing, all values held in the frame are considered 
            accessible. An evaluation, assignment, invocation, or instantiation may result 
            in a pause in execution of the body while the called getter, setter, function, 
            or class is executed or instantiated. However, the frame associated with the 
            calling body is retained and values held in the frame are still considered 
            accessible. When execution of the body resumes, the frame is restored. 

  When execution of a body terminates, the frame may or may not become
            inaccessible. In the case of a class body, if the initializer terminates with
            no thrown exception, the frame and its values become a new instance of the 
            class, are associated with the newly created unique identifier, and remain 
            accessible while this object is itself accessible. In the case of any other 
            kind of body, or in the case that an initializer throws an exception, the 
            frame and its values may remain accessible if: 

  
  @itemize @bullet
  
  @item a reference to a function or class declared within the body is 
                    accessible, 

  
  @item an instance of a class declared within the body is accessible, 
                    or 

  
  @item an instance of a comprehension declared within the body is 
                    accessible. 

  
  @end itemize
Otherwise, the frame becomes inaccessible and may be destroyed. 

  The principle of @emph{closure} states that a nested body
            always has access to a frame for every containing body. The set of 
            @emph{current instances} of containing classes and 
            @emph{current frames} of containing blocks forms the closure of 
            a nested declaration. 

  
@node currentinstancesandcurrentframes
@subsection Current instances and current frames
@cindex Current instances and current frames

  A frame may be the @emph{current frame} for a body. When the 
            body is executing, the created frame is the current frame. When execution of the 
            body terminates, the created frame is no longer the current frame. Invocation or 
            evaluation of a member of a class or interface, invocation of a callable reference
            or anonymous function, or evaluation of the values produced by a comprehension may 
            result in the frame being restored as the current frame. 

  A class instance, callable reference, anonymous function reference, or 
            comprehension instance packages a reference to a frame for each body containing 
            the program element, as specified below. When a member of the class instance is
            invoked or evaluated, when the callable reference or anonymous function is
            invoked, or when the comprehension instance produces a value, these frames are
            restored as the current frames of the associated bodies. When the invocation or
            evaluation terminates, or when the comprehension value has been produced, these
            frames are no longer current frames. 

  The value associated with a value reference in the current frame of the
            body to which the value reference belongs is called the @emph{current 
            value} of the value reference. 

  If a frame is the current frame for a class or interface body, we call it 
            the @emph{current instance} of the class or interface. 

  
@smallindentedblock
  TODO: in the following two sections, account for callable references,
            anonymous function references, and comprehension instances. 

  
@end smallindentedblock

@node currentinstanceofaclassorinterface
@subsection Current instance of a class or interface
@cindex Current instance of a class or interface

  If a statement is occurs directly or indirectly inside a class or interface 
            body, then there is always a current instance of the class or interface when the 
            statement is executed. The current instance is determined as follows: 

  
  @itemize @bullet
  
  @item For a statement that occurs sequentially, as defined by 
                    @ref{blockstructure, ,Block structure and references}, in the body of the class or of a 
                    constructor of the class, the current instance is the new instance 
                    being initialized. 

  
  @item For a statement that occurs sequentially in the body of a member
                    of the class or interface, the current instance is the receiving instance 
                    of the base or member expression that resulted in a reference to the 
                    member. 

  
  @item For a statement that occurs sequentially in the body of a nested 
                    class or interface that occurs in the body of the class or interface, 
                    the current instance is the same object that was the current instance 
                    when the initializer of the current instance of the nested class or 
                    interface was executed. 

  
  @item Otherwise, for any other statement that occurs sequentially in the 
                    body of a declaration that occurs in the body of the class or interface, 
                    the current instance is the same object that was the current instance when 
                    the base member expression that resulted in a reference to the declaration 
                    was executed. 

  
  @end itemize
Here, @code{innerObject} is the current instance of 
            @code{Inner} when @code{member()} is executed, and
            @code{outerObject} is the current instance of @code{Outer}: 

  
@example
Outer outerObject = Outer();
Inner innerObject = outerObject.Inner();
innerObject.member();
@end example

@node currentframeofablock
@subsection Current frame of a block
@cindex Current frame of a block

  If a statement occurs directly or indirectly inside a block, then there 
            is always a current frame of the block when the statement is executed. The current 
            frame is determined as follows: 

  
  @itemize @bullet
  
  @item If the statement occurs sequentially, as defined by 
                    @ref{blockstructure, ,Block structure and references}, in the block, the current frame is the
                    frame associated with the current execution of the block. 

  
  @item For a statement that occurs sequentially in the body of a nested 
                    class or interface that occurs in the block, the current frame is the same 
                    frame that was the current frame when the initializer of the current 
                    instance of the nested class or interface was executed. 

  
  @item Otherwise, for any other statement that occurs sequentially inside 
                    the body of a declaration that occurs in the block, and the current frame 
                    is the frame that was the current frame when the base member expression 
                    that resulted in a reference to the declaration was executed. 

  
  @end itemize
In each of the following code fragments, @code{result} refers 
            to the value @code{"hello"}: 

  
@example
String()() outerMethod(String s) @{
    String() middleMethod() @{
        String innerMethod() => s;
        return innerMethod;
    @}
    return middleMethod;
@}

String middleMethod()() => outerMethod("hello");
String innerMethod() => middleMethod();
String result = innerMethod();
@end example

@example
Object outerMethod(String s) @{
    object middleObject @{
        shared actual String string => s;
    @}
    return middleObject;
@}

Object middleObject = outerMethod("hello");
String result = middleObject.string;
@end example

@node initialization
@subsection Initialization
@cindex Initialization

  When an instance is instantiated, its initializer is executed, and the
            initializer for every class it inherits is executed. If a class has
            constructors, one of its constructors is also executed. For a class
            @code{C}: 

  
  @itemize @bullet
  
  @item First, the initializer of @code{Object} defined in
                    @code{ceylon.language} is executed. (This initializer is
                    empty and does no work.) 

  
  @item For each superclass @code{X} of @code{C}, 
                    there is exactly one other superclass @code{Y} of 
                    @code{C} that directly extends @code{X}. When
                    execution of the initializer of @code{X} terminates without 
                    a thrown exception, execution of the initializer of @code{Y} 
                    begins. When sequential execution of the initializer reaches the 
                    declaration of the invoked or delegated constructor of @code{Y}, 
                    if any, the constructor itself is executed. When execution of the 
                    constructor terminates without a thrown exception, execution of the 
                    initializer resumes at the next statement after the constructor 
                    declaration. 

  
  @item Finally, when execution of the initializer of @code{C}, 
                     terminates without a thrown exception, the new instance of 
                     @code{C} is fully-initialized and made accessible to the 
                     calling code. 

  
  @end itemize
If any initializer or constructor in the class hierarchy terminates with 
            a thrown exception, initialization terminates and the incompletely-initialized 
            instance never becomes accessible. 

  Each initializer produces a frame containing initialized values for each 
            reference declared by the corresponding class. These frames are aggregated together 
            to form the new instance of the class @code{C}. 

  
@smallindentedblock
  Note: since interfaces don't have initializers, the issue of 
            "linearization" of supertypes simply never arises in Ceylon. There is a natural,
            well-defined initialization ordering. 

  
@end smallindentedblock

@node classinstanceoptimization
@subsection Class instance optimization
@cindex Class instance optimization

  As an exception to the above, the compiler is permitted to destroy a 
            persistent value associated with a class instance when the class initializer 
            terminates, potentially rendering inaccessible the instance identified by the 
            value, if it can determine that the persistent value will never be subsequently
            accessed by the program. 

  
@smallindentedblock
  This optimization is the only source of a distinction between a 
            "field" of a class and a "local variable" of its initializer. There is no way
            for a program to observe this distinction. 

  
@end smallindentedblock

@node executionofexpressionandspecificationstatements
@subsection Execution of expression and specification statements
@cindex Execution of expression and specification statements

  When an expression statement is executed, the expression is evaluated. 

  When a non-lazy specification statement is executed, the specified 
            expression is evaluated, and the resulting value assigned to the specified
            reference within the current frame or current instance associated with the 
            body to which the specified reference belongs. 

  When a lazy specification statement is executed, the specified
            expression is associated with the specified reference within the current 
            frame or current instance associated with the body to which the specified
            reference belongs. Subsequent evaluation or invocation of the reference
            for this current frame or current instance may result in evaluation of the 
            specified expression, in which case the expression is evaluated within this 
            current frame or current instance. 

  
@node executionofcontroldirectives
@subsection Execution of control directives
@cindex Execution of control directives

  Execution of a control directive, as specified in 
            @ref{controldirectives, ,Control directives}, terminates execution of the body in which it 
            occurs, and possibly of other containing bodies. 

  
  @itemize @bullet
  
  @item A @code{return} directive that occurs sequentially in
                    the body of a function, getter, setter, or class initializer terminates
                    execution of the body of the function, getter, setter, or class initializer 
                    and of all intervening bodies. Optionally, it determines the return value of
                    the function or getter. 

  
  @item A @code{break} directive terminates execution of the
                    body of the most nested containing loop in which it occurs sequentially,
                    and of all intervening bodies. Additionally, it terminates execution of
                    the loop. 

  
  @item A @code{continue} directive terminates execution of the
                    body of the most nested containing loop in which it occurs sequentially,
                    and of all intervening bodies. It does not terminate execution of the 
                    loop. 

  
  @item A @code{throw} directive that occurs sequentially in
                    the body of a function, getter, setter, or class initializer terminates
                    execution of the body of the function, getter, setter, or class 
                    initializer and of all intervening bodies, and, furthermore, the exception 
                    propagates to the caller, as defined below, unless there is an intervening 
                    @code{try} with a @code{catch} clause matching the 
                    thrown exception, in which case it terminates execution of the body of the 
                    @code{try} statement and all intervening bodies, and execution 
                    continues from the body of the @code{catch} clause. 

  
  @end itemize

@node exceptionpropagation
@subsection Exception propagation
@cindex Exception propagation

  If execution of an evaluation, assignment, invocation, or instantiation
            terminates with an exception thrown, the exception propagates to the calling 
            code, and terminates execution of the body of the function, getter, setter, or 
            class initializer in which the expression involving the evaluation, assignment, 
            invocation, or instantiation sequentially occurs, and of all intervening bodies, 
            and, furthermore, the exception propagates to the caller unless there is an 
            intervening @code{try} with a @code{catch} clause 
            matching the thrown exception, in which case it terminates execution of the body 
            of the @code{try} statement and all intervening bodies, and execution 
            continues from the body of the @code{catch} clause. 

  
@node toplevelinitialization
@subsection Initialization of toplevel references
@cindex Initialization of toplevel references

  A toplevel reference has no associated frame. Instead, the lifecycle of 
            its persistent value is associated with the loading and unloading of a module 
            by the module runtime. The first time a toplevel reference is accessed 
            following the loading of its containing module, its initializer expression is 
            evaluated, and the resulting value is associated with the reference. This 
            association survives until the toplevel reference is reassigned, or until the 
            module is unloaded by the module runtime. 

  Initialization of a toplevel reference may result in recursive 
            initialization of other toplevel references. Therefore, it is possible that
            a cycle could occur where evaluation of a toplevel reference occurs while
            evaluating its initializer expression. When this occurs, an 
            @code{InitializationError} is thrown. 

  
@node lateinitialization
@subsection Initialization of late references
@cindex Initialization of late references

  A reference annotated @code{late} may be uninitialized in a 
            given frame. The rules of the language do not guarantee that an uninitialized 
            @code{late} reference is never evaluated at runtime. If a
            @code{late} reference which is uninitialized in the current frame 
            or current instance is evaluated, an @code{InitializationError}
            is thrown. 

  Likewise, if a non-@code{variable} @code{late} 
            reference which is already initialized in the current frame or current instance
            is assigned, an @code{InitializationError} is thrown. 

  
@node executionofcontrolstructures
@section Execution of control structures and assertions
@cindex Execution of control structures and assertions

  
      
@menu
      
* evaluationofconditions:: Evaluation of condition lists
* validationofassertions:: Validation of assertions
* executionofconditionals:: Execution of conditionals
* executionofloops:: Execution of loops
* exceptionhandling:: Exception handling
* dynamictypechecking:: Dynamic type checking
@end menu

      Control structures, as specified in @ref{controlstructures, ,Control structures and assertions}, are 
        used to organize conditional and repetitive code within a body. Assertions are 
        essentially a sophisticated sort of control directive, but for convenience are 
        categorized together with control structures. 

  
@node evaluationofconditions
@subsection Evaluation of condition lists
@cindex Evaluation of condition lists

  Execution of an @code{if}, @code{while}, or
            @code{assert} requires evaluation of a condition list, as defined
            in @ref{controlstructureconditions, ,Conditions}. 

  To determine if a condition list is satisfied, its constituent conditions 
            are evaluated in the lexical order in which they occur in the condition list. 
            If any condition is not satisfied, none of the subsequent conditions in the list 
            are evaluated. 

  
  @itemize @bullet
  
  @item A boolean condition is satisfied if its expression evaluates to 
                    @code{true} when the condition is evaluated. 

  
  @end itemize
For any other kind of condition, the condition is satisfied if its value 
             reference or expression evaluates to an instance of the required type when the 
             condition is evaluated: 

  
  @itemize @bullet
  
  @item for an assignability condition, the condition is satisfied if the 
                     expression evaluates to an instance of the specified type when the control 
                     structure is executed, 

  
  @item for an existence condition, the condition is satisfied unless the 
                     expression evaluates to @code{null} when the control structure 
                     is executed, or 

  
  @item for a nonemptiness expression, the condition is satisfied unless the 
                     expression evaluates to an instance of @code{[]|Null} when the 
                     control structure is executed. 

  
  @end itemize
A condition list is satisfied if and only if all of its constituent conditions 
             are satisfied. 

  
@node validationofassertions
@subsection Validation of assertions
@cindex Validation of assertions

  When an assertion, as specified in @ref{assertions, ,Assertions}, is 
            executed, its condition list is evaluated. If the condition list is not satisfied, 
            an exception of type @code{AssertionError} in 
            @code{ceylon.language} is thrown. 

  The information carried by the @code{AssertionError} includes: 

  
  @itemize @bullet
  
  @item the text of the Ceylon code of the condition that failed, 

  
  @item the message specified by the @code{doc} annotation of the
                    assertion, if any. 

  
  @end itemize

@node executionofconditionals
@subsection Execution of conditionals
@cindex Execution of conditionals

  The @code{if/else} and @code{switch/case/else} 
            constructs control conditional execution. 

  When the @code{if/else} construct, specified in 
            @ref{ifelse, ,if/else}, is executed, its condition list is evaluated. If the 
            condition list is satisfied, the @code{if} block is executed. 
            Otherwise, the @code{else} block, if any, is executed, or, if the 
            construct has an @code{else if}, the child @code{if}
            construct is executed. 

  When a @code{switch/case/else} construct, specified in 
            @ref{switchcaseelse, ,switch/case/else}, is executed, its @code{switch} 
            expression is evaluated to produce a value. The value is guaranteed to 
            @emph{match} at most one @code{case} of the 
            @code{switch}. If it matches a certain case, then that 
            @code{case} block is executed. Otherwise, @code{switch} 
            is guaranteed to have an @code{else}, and so the 
            @code{else} block is executed. 

  The value produced by the @code{switch} expression matches
            a case if either: 

  
  @itemize @bullet
  
  @item the case is a list of literal values and value references the 
                    value is identical to one of the value references in the list or 
                    equal to one of the literal values in the list, or if 

  
  @item the case is an assignability condition of form 
                    @code{case (is V)} and the value is an instance of
                    @code{V}. 

  
  @end itemize

@node executionofloops
@subsection Execution of loops
@cindex Execution of loops

  The @code{for/else} and @code{while} loops control
            repeated execution. 

  When a @code{while} construct, specified in @ref{while, ,while}, 
            is executed, the loop condition list is evaluated repeatedly until the first time 
            the condition list is not satisfied, or until a @code{break}, 
            @code{return}, or @code{throw} directive that terminates the
            loop is executed. Each time the condition is satisfied, the @code{while} 
            block is executed. 

  When a @code{for/else} construct, specified in @ref{forelse, ,for/else}, 
            is executed: 

  
  @itemize @bullet
  
  @item the iterated expression is evaluated to produce an an instance of
                    @code{Iterable}, 

  
  @item an @code{Iterator} is obtained by calling 
                    @code{iterator()} on the iterable object, and then 

  
  @item the @code{for} block is executed once for each value 
                    of produced by repeatedly invoking the @code{next()} method 
                    of the iterator, until the iterator produces the value @code{finished}, 
                    or until a @code{break}, @code{return}, or 
                    @code{throw} directive that terminates the loop is executed. 

  
  @end itemize
Note that: 

  
  @itemize @bullet
  
  @item if the iterated expression is also of type @code{X[]},
                    the compiler is permitted to optimize away the use of @code{Iterator}, 
                    instead using indexed element access. 

  
  @item if the iterated expression is a range constructor expression, the 
                    compiler is permitted to optimize away creation of the @code{Range}, 
                    and generate the indices using the @code{successor} operation. 

  
  @end itemize
We say that the loop @emph{exits early} if it ends via execution 
            of a @code{break}, @code{return}, or @code{throw}
            directive. Otherwise, we say that the loop @emph{completes} normally. 

  If the loop completes normally, the @code{else} block is executed. 
            Otherwise, if the loop exits early, the @code{else} block is not executed. 

  
@node exceptionhandling
@subsection Exception handling
@cindex Exception handling

  When a @code{try/catch/finally} construct, specified in 
             @ref{trycatchfinally, ,try/catch/finally}, is executed: 

  
  @itemize @bullet
  
  @item the resource expressions, if any, are evaluated in the order
                     they occur, and then @code{obtain()} is called on each 
                     resulting resource instance of type @code{Obtainable}, 
                     in the same order, then 

  
  @item the @code{try} block is executed, then 

  
  @item @code{destroy()} is called on each resource instance
                     of type @code{Destroyable}, and @code{release()} 
                     is called on each resource instance of type @code{Obtainable}, 
                     if any, in the reverse order that the resource expressions occur, 
                     passing the exception that propagated out of the @code{try} 
                     block, if any, then 

  
  @item if an exception did propagate out of the @code{try} 
                     block, the first @code{catch} block with a variable 
                     to which the exception is assignable, if any, is executed, and 
                     then 

  
  @item the @code{finally} block, if any, is executed, 
                     even in the case where an exception propagates out of the whole
                     construct. 

  
  @end itemize

@smallindentedblock
  TODO: Specify what happens if @code{close()} 
             throws an exception. (Same semantics as Java with "suppressed" exceptions.) 

  
@end smallindentedblock

@node dynamictypechecking
@subsection Dynamic type checking
@cindex Dynamic type checking

  Inside a @code{dynamic} block, a situation might occur that 
            requires dynamic type checking, as specified in @ref{dynamicblocks, ,Dynamic blocks}. 
            It is possible that: 

  
  @itemize @bullet
  
  @item the value to which an expression with no type evaluates at 
                    execution time might not be an instance of the type required where 
                    the expression occurs, 

  
  @item in particular, the value to which a @code{switch} 
                    expression with no type evaluates at execution time might be an 
                    instance of a type not covered by the @code{case}s of
                    a @code{switch} with no @code{else}, or 

  
  @item a qualified or unqualified reference which does not refer to 
                    a statically typed declaration might not resolve to any declaration
                    at all. 

  
  @end itemize
Whenever such a condition is encountered at runtime, an 
            @code{AssertionError} is immediately thrown. 

  
@smallindentedblock
  Note: in Ceylon 1.0, dynamic type checking is only supported
            on JavaScript virtual machines. 

  
@end smallindentedblock

@node evaluationinvocationandassignment
@section Evaluation, invocation, and assignment
@cindex Evaluation, invocation, and assignment

  
      
@menu
      
* dynamicdispatch:: Dynamic dispatch
* evaluation:: Evaluation
* assignment:: Assignment
* invocation:: Invocation
* anonymousfunctionevaluation:: Evaluation of anonymous functions
* enumerationevaluation:: Evaluation of enumerations
* spreadevaluation:: Evaluation of spread arguments and comprehensions
@end menu

      Evaluation of an expression may result in: 

  
  @itemize @bullet
  
  @item invocation of a function or instantiation of a class, 

  
  @item evaluation of a value, 

  
  @item instantiation of an instance of @code{Callable} 
            that packages a callable reference, or 

  
  @item assignment to a variable value. 

  
  @end itemize

@node dynamicdispatch
@subsection Dynamic dispatch
@cindex Dynamic dispatch

  @emph{Dynamic dispatch} is the process of determing
            at runtime a member declaration based upon the runtime type of an object,
            which, as a result of subtype polymorphism, may be different to its static 
            type known at compile time. 

  Any concrete class is guaranteed to have exactly one declaration of
            a member, either declared or inherited by the class, which refines all other 
            declarations of the member declared or inherited by the class. At runtime,
            this member is selected. 

  There is one exception to this rule: member expressions where the 
            receiver expression is of form @code{super} or
            @code{(super of Type)}, as defined in @ref{super, ,super},
            are dispatched based on the static type of the receiver expression: 

  
  @itemize @bullet
  
  @item Any invocation of a member of @code{super} is 
                    processed by the member defined or inherited by the supertype, 
                    bypassing any member declaration that refines this member 
                    declaration. 

  
  @item Any invocation of a member of an expression of form 
                    @code{(super of Type)} is processed by the member 
                    defined or inherited by @code{Type}, bypassing any 
                    member declaration that refines this member declaration. 

  
  @end itemize

@node evaluation
@subsection Evaluation
@cindex Evaluation

  Evaluation of a value reference, as defined in @ref{valuereferences, ,Value references}, 
            produces its current value. Evaluation of a callable reference, as defined in
            @ref{callablereferences, ,Callable references}, that does not occur as the primary of a 
            direct invocation results in a new instance of @code{Callable} that 
            packages the callable reference. 

  
@example
person.name
@end example

@example
'/'.equals
@end example
When a value reference expression is executed: 

  
  @itemize @bullet
  
  @item first, the receiver expression, if any, is evaluated to obtain a 
                    receiving instance for the evaluation, then 

  
  @item the actual declaration to be invoked is determined by considering 
                    the runtime type of the receiving instance, if any, and then 

  
  @item if the declaration is a reference, its persistent value is retrieved
                    from the receiving instance, or 

  
  @item otherwise, execution of the calling body pauses while the body 
                    of its getter is executed by the receiving instance, then, 

  
  @item finally, when execution of the getter ends, execution of the 
                    calling body resumes. 

  
  @end itemize
The resulting value is the persistent value retrieved, or the return value 
            of the getter, as specified by the @code{return} directive. 

  When a callable reference expression that does not occur as the primary of
            a direct invocation expression is executed: 

  
  @itemize @bullet
  
  @item first, the receiver expression, if any, is evaluated to obtain a 
                    receiving instance for the evaluation, then 

  
  @item the receiving instance, a reference to the declaration to be
                    invoked, or a reference to the current frame or instance of every body 
                    that contains the referenced declaration are packaged together into an 
                    instance of @code{Callable}. 

  
  @end itemize
The resulting value is the instance of @code{Callable}. The 
            concrete class of this instance is not specified here. 

  
@node assignment
@subsection Assignment
@cindex Assignment

  Given a value reference, as defined in @ref{valuereferences, ,Value references}, 
            to a variable, the assignment operator @code{=} assigns it a new 
            value. 

  
@example
person.name = "Gavin"
@end example
When an assignment expression is executed: 

  
  @itemize @bullet
  
  @item first, the receiver expression of the value reference expression 
                    is executed to obtain the receiving instance, then 

  
  @item the actual declaration to be assigned is determined by considering 
                    the runtime type of the receiving instance, and then 

  
  @item if the member is a reference, its persistent value is updated in 
                    the receiving instance, or 

  
  @item otherwise, execution of the calling body pauses while the body 
                    of its setter is executed by the receiving instance with the assigned 
                    value, then, 

  
  @item finally, when execution of the setter ends, execution of the calling 
                    body resumes. 

  
  @end itemize

@node invocation
@subsection Invocation
@cindex Invocation

  Evaluation of an invocation expression, as defined in 
            @ref{invocationexpressions, ,Invocation expressions}, results in @emph{invocation}
            of a function or callable constructor, or @emph{instantiation} of a 
            class. Every invocation has a callable expression: 

  
  @itemize @bullet
  
  @item in a direct invocation, the callable expression is a callable 
                    reference, and 

  
  @item in an indirect invocation, the callable expression is an instance of
                    @code{Callable} that packages an underlying callable reference. 

  
  @end itemize
In either case, the callable expression determines the instance and member 
            to be invoked. 

  
@example
print("Hello world!")
@end example

@example
Entry(person.name, person)
@end example
When an invocation expression is executed: 

  
  @itemize @bullet
  
  @item first, the callable expression is evaluated to obtain the receiving
                    instance, then 

  
  @item each listed argument or spread argument is evaluated in turn in the 
                    calling body, and 

  
  @item if the argument list has a comprehension, a comprehension instance, 
                    as defined in @ref{comprehensionevaluation, ,Evaluation of comprehensions}, is obtained, 
                    and then 

  
  @item the actual declaration to be invoked is determined by considering the 
                    runtime type of the receiving instance, if any, and then 

  
  @item execution of the calling body pauses while the body of the function 
                    or initializer is executed by the receiving instance with the argument values, 
                    then 

  
  @item finally, when execution of the function or initializer ends, execution 
                    of the calling body resumes. 

  
  @end itemize
A function invocation evaluates to the return value of the function, as specified 
            by the @code{return} directive. The argument values are passed to the 
            parameters of the method, and the body of the method is executed. 

  A class instantiation evaluates to a new instance of the class. The argument 
            values are passed to the initializer parameters of the class, and the initializer
            is executed. 

  
@node anonymousfunctionevaluation
@subsection Evaluation of anonymous functions
@cindex Evaluation of anonymous functions

  When an anonymous function expression, as defined in 
            @ref{anonymousfunctions, ,Anonymous functions}, is evaluated, a reference to the function and a
            reference to the current frame or instance of every containing body are packaged into an 
            instance of @code{Callable}. The instance of @code{Callable} is
            the resulting value of the expression. The concrete class of this instance is not 
            specified here. 

  
@node enumerationevaluation
@subsection Evaluation of enumerations
@cindex Evaluation of enumerations

  Evaluation of an enumeration expression, as defined in 
            @ref{enumeration, ,Iterable and tuple enumeration}, results in creation of an iterable stream or 
            tuple. 

  
@example
@{ "hello", "world" @}
@end example

@example
[ new, *elements ]
@end example
When an iterable enumeration expression is executed, a reference to the
            enumeration expression, together with a reference to the current frame or 
            instance of every containing body, together with a comprehension instance, 
            as defined in @ref{comprehensionevaluation, ,Evaluation of comprehensions}, in the case that the 
            enumeration expression has a comprehension, are packaged together into a stream. 
            Evaluation of an expression occurring in the enumeration expression occurs in 
            the context of the packaged framed associated with the stream. When the stream 
            is iterated, it produces, in turn: 

  
  @itemize @bullet
  
  @item one value for each listed argument, by evaluating the listed
                    argument expression, and then 

  
  @item if the argument list has a spread argument, each value produced 
                    by the spread argument, or 

  
  @item if the argument list has a comprehension, each value produced 
                    by the comprehension instance, or 

  
  @item if there are no arguments, and no comprehension, the 
                    stream is empty and produces no values. 

  
  @end itemize
When a tuple enumeration expression is executed: 

  
  @itemize @bullet
  
  @item first, each listed argument or spread argument is evaluated in 
                    turn in the calling body, and 

  
  @item if the argument list has a comprehension, a comprehension instance, 
                    as defined in @ref{comprehensionevaluation, ,Evaluation of comprehensions}, is obtained, 
                    and then 

  
  @item the resulting argument values are packaged into an instance of 
                    @code{Iterable} or @code{Sequence}, and this 
                    object is the resulting value of the enumeration expression, unless 

  
  @item there are no  arguments, and no comprehension, in which case 
                    the resulting value of the enumeration expression is the object 
                    @code{empty}. 

  
  @end itemize
In the case of an iterable enumeration, the concrete class of the resulting
            value is not specified here. In the case of a tuple enumeration it is always
            @code{Tuple}, @code{Empty}, or @code{Sequence}. 

  
@node spreadevaluation
@subsection Evaluation of spread arguments and comprehensions
@cindex Evaluation of spread arguments and comprehensions

  A spread argument, as defined in @ref{spreadarguments, ,Spread arguments}, produces 
            multiple values by iterating the iterable object to which the spread operator 
            is applied. 

  When a spread argument expression type is a subtype of @code{Sequential},
            the behavior does not depend upon where the spread argument occurs: 

  
  @itemize @bullet
  
  @item If it occurs as an argument, the sequence produced by evaluating 
                    the expression is passed directly to the parameter. 

  
  @item If it occurs in an enumeration expression, the sequence produced 
                    by evaluating the expression is appended directly to the resulting
                    iterable object or tuple. 

  
  @end itemize
On the other hand, when a spread argument expression type is not a subtype of 
            @code{Sequential}, the behavior depends upon where the spread argument
            occurs: 

  
  @itemize @bullet
  
  @item If it occurs as an argument to a variadic parameter in a positional
                    argument list, the values produced by a spread argument are evaluated 
                    immediately and packaged into an instance of @code{Sequence}
                    and passed to the variadic parameter, unless there are no values, in 
                    which case the object @code{empty} is passed to the variadic 
                    parameter. 

  
  @item If it occurs as an argument to a parameter of type 
                    @code{Iterable} at the end of a named argument list, the
                    iterable object produced by evaluating the expression is passed directly 
                    to the parameter. 

  
  @item If it occurs in a tuple enumeration, the values produced by a 
                    spread argument are evaluated immediately and packaged into an instance 
                    of @code{Sequence} and appended to the resulting tuple. 

  
  @item If it occurs in an iterable enumeration, the iterable object 
                    produced by evaluating the expression is chained directly to the 
                    resulting iterable object. 

  
  @end itemize
Likewise, a comprehension, as defined in @ref{comprehensions, ,Comprehensions}, 
            produces multiple values, as specified by @ref{comprehensionevaluation, ,Evaluation of comprehensions}. 
            The behavior depends upon where the comprehension occurs: 

  
  @itemize @bullet
  
  @item If it occurs as an argument to a variadic parameter in a positional
                    argument list, the values produced by the comprehension instance are 
                    evaluated immediately, packaged into an instance of @code{Sequence},
                    and passed to the variadic parameter, unless there are no values, in 
                    which case the object @code{empty} is passed to the variadic 
                    parameter. 

  
  @item If it occurs as an argument to a parameter of type 
                    @code{Iterable} at the end of a named argument list, the 
                    comprehension instance is packaged into an iterable object that produces 
                    the values of the comprehension on demand, and this iterable object is 
                    passed directly to the parameter. The concrete class of this object is 
                    not specified here. 

  
  @item If it occurs in a tuple enumeration, the values produced by the 
                    comprehension instance are evaluated immediately, packaged into an instance 
                    of @code{Sequence}, and appended to the resulting tuple. 

  
  @item If it occurs in an iterable enumeration, the comprehension instance
                    is packaged into an iterable object that produces the values of the 
                    comprehension on demand, and this iterable object is chained directly to 
                    the resulting iterable object. The concrete class of this object is not 
                    specified here. 

  
  @end itemize

@node operatorexpressions
@section Operator expressions
@cindex Operator expressions

  
      
@menu
      
* operatorexpressionoptimization:: Operator expression optimization
* numericoperations:: Numeric operations
@end menu

      Most operator expression are defined in terms of function invocation, value 
        evaluation, or a combination of invocations and evaluations, as specified in
        @ref{operators, ,Operators}. The semantics of evaluation of an operator expression 
        therefore follows from the above definitions of evaluation and invocation and from 
        its definition in terms of evaluation and invocation. 

  However, this specification allows the compiler to take advantage of the
        optimized support for primitive value types provided by the virtual machine
        environment. 

  
@node operatorexpressionoptimization
@subsection Operator expression optimization
@cindex Operator expression optimization

  As a special exception to the rules, the compiler is permitted to optimize 
            certain operations upon certain types in the module @code{ceylon.language}. 
            These types are: @code{Integer}, @code{Float}, 
            @code{Character}, @code{Range}, @code{Entry}, 
            @code{String}, @code{Array}, and @code{Tuple}. 

  Thus, the tables in the previous chapter define semantics only. The compiler 
            may emit bytecode or compiled JavaScript that produces the same value at runtime as 
            the pseudo-code that defines the operator, without actually executing any invocation, 
            for the following operators: 

  
  @itemize @bullet
  
  @item all arithmetic operators, 

  
  @item the comparison and equality operators @code{==},
                    @code{!=}, @code{<=>}, @code{<},
                    @code{>}, @code{<=}, @code{>=}
                    when the argument expression types are built-in numeric types, and 

  
  @item the @code{Range} and @code{Entry} construction 
                    operators @code{..}, @code{:}, and 
                    @code{->}. 

  
  @end itemize
In all operator expressions, the arguments of the operator must be evaluated 
            from left to right when the expression is executed. In certain cases, depending upon 
            the definition of the operator, evaluation of the leftmost argument expression results 
            in a value that causes the final value of the operator expression to be produced 
            immediately without evaluation of the remaining argument expressions. Optimizations 
            performed by the Ceylon compiler must not alter these behaviours. 

  
@smallindentedblock
  Note: this restriction exists to ensure that any effects are not 
            changed by the optimizations. 

  
@end smallindentedblock

@node numericoperations
@subsection Numeric operations
@cindex Numeric operations

  The arithmetic operations defined in @ref{arithmetic, ,Arithmetic operators} for
            values of type @code{Integer} and @code{Float} are
            defined in terms of methods of the interface @code{Numeric}. 
            However, these methods themselves make use of the native operations of the 
            underlying virtual machine. Likewise, values of type @code{Integer} 
            and @code{Float} are actually represented in terms of a format 
            native to the virtual machine. 

  It follows that the precise behavior of numeric operations depends 
            upon the virtual machine upon which the program executes. However, certain 
            behaviours are common to supported virtual machines: 

  
  @itemize @bullet
  
  @item Values of type @code{Float} are represented 
                    according to the IEEE 754 specification, @emph{IEEE Standard 
                    for Binary Floating-Point Arithmetic}, and floating point
                    numeric operations conform to this specification. Where possible,
                    a double-precision 64-bit representation is used. It is possible on 
                    both Java and JavaScript virtual machines. 

  
  @item Where possible, values of type @code{Integer} are 
                    represented in two's complement form using a fixed bit length. Where 
                    possible, a 64-bit representation is used. Overflow and underflow 
                    wrap silently. This is the case for the Java Virtual Machine. 

  
  @item Otherwise, values of type @code{Integer} are 
                    represented according to the IEEE 754 specification. This is the 
                    case for JavaScript virtual machines. 

  
  @end itemize
Platform-dependent behavior of numeric operations is defined in the
            Java Language Specification, and the ECMAScript Language Specification. 

  
@smallindentedblock
  It might be argued that having platform-dependent behavior 
            for numeric operations opens up the same portability concerns that affected
            languages like C in the past. However, the cross-platform virtual machines
            supported by Ceylon already provide a layer of indirection that substantially
            eases portability concerns. Of course, numeric code is not guaranteed to be
            completely portable between the Java and JavaScript virtual machines, but
            it's difficult to imagine how such a level of portability could reasonably 
            be achieved. 

  
@end smallindentedblock

@node comprehensionevaluation
@section Evaluation of comprehensions
@cindex Evaluation of comprehensions

  
      
@menu
      
* forclause:: for clause
* ifclause:: if clause
* expressionclause:: Expression clause
@end menu

      When a comprehension, as specified in @ref{comprehensions, ,Comprehensions}, 
        is evaluated, a reference to the comprehension, together with a reference to 
        the current frame or instance of every containing body, are packaged together 
        into a @emph{comprehension instance}. A comprehension instance 
        is not considered a value in the sense of @ref{objectinstancesidentity, ,Object instances, identity, and reference passing}. 
        Instead, it is a stream of values, each produced by evaluating the expression 
        clause of the comprehension. 

  A comprehension consists of a series of clauses. Each clause of a 
        comprehension, except for the expression clause that terminates the list of 
        clauses, produces a stream of @emph{frames}. A frame is a set 
        of values for iteration variables and condition variables declared by the 
        clause and its parent clauses. 

  
@smallindentedblock
  Note: each child clause can be viewed as a body nested inside 
        the parent clause. The lifecycle of comprehension frames reflects this model.
         

  
@end smallindentedblock
Evaluation of an expression occurring in a comprehension clause occurs
        in the context of the packaged frames associated with the comprehension
        instance together with a comprehension frame associated with the clause. 

  
@node forclause
@subsection for clause
@cindex for clause

  The expression which produces the source stream for a child 
            @code{for} clause may refer to an iteration variable of a
            parent @code{for} clause. In this case the child clause is 
            considered @emph{correlated}. Otherwise it is considered 
            @emph{uncorrelated}. 

  In either case, the child clause produces a stream of frames. 
            For each frame produced by the parent clause, and for each value
            produced by the source stream of the child clause, the child clause
            produces a frame consisting of the parent clause frame extended
            by the iteration variable value defined by the child clause. 

  This comprehension has a correlated @code{for} clause. 
            For each character @code{c} in each string @code{w} 
            in @code{words}, the child @code{for} clause 
            produces the frame @code{@{ String word=w; Character char=c; @}}. 

  
@example
for (word in words) for (char in word) char
@end example
This comprehension has an uncorrelated @code{for} clause. 
            For each string @code{n} in @code{nouns}, and each 
            string @code{a} in @code{adjectives}, the child 
            @code{for} clause produces the frame 
            @code{@{ String noun=n; String adj=a; @}}. 

  
@example
for (noun in nouns) for (adj in adjectives) adj + " " + noun
@end example

@node ifclause
@subsection if clause
@cindex if clause

  A child @code{if} clause filters its parent clause frames. 
            For every frame produced by the parent clause which satisfies the condition 
            list of the child clause, the child clause produces that frame, extended by 
            any condition variable defined by the child clause. 

  This comprehension has an @code{if} clause. For
            each object @code{o} in @code{objects} that
            is a nonempty @code{String}, the @code{if} clause 
            produces the frame @code{@{ Object obj=o; String str=o; @}}. 

  
@example
for (obj in objects) if (is String str=obj, !str.empty) str
@end example

@node expressionclause
@subsection Expression clause
@cindex Expression clause

  As specified in @ref{comprehensions, ,Comprehensions}, every comprehension ends 
            in an expression clause. An expression clause produces a single value for each 
            frame produced by its parent clause, by evaluating the expression in the frame. 
            These resulting values are the values returned by the whole comprehension. 

  
@node concurrency
@section Concurrency
@cindex Concurrency

  Neither this specification nor the module @code{ceylon.language}
        provide any facility to initiate or control concurrent execution of a program
        written in Ceylon. However, a Ceylon program executing on the Java Virtual Machine
        may interact with Java libraries (and other Ceyon modules) that make use of 
        concurrency. 

  In this scenario, the execution of a Ceylon program is governed by the rules 
        laid out by the Java programming language's execution model (Chapter 17 of the Java 
        Language Specification). Ceylon references belonging to a class or interface are 
        considered @emph{fields} in the sense of the JLS. Any such refence
        not explicitly declared @code{variable} is considered a 
        @emph{final field}. Evaluation of a reference is considered a 
        @emph{use} operation, and assignment to or specification of a variable
        reference is considered an @emph{assign} operation, again in terms of 
        the JLS. 

  
@node modulesystem
@chapter Module system
@cindex Module system

@menu
  
* moduleruntime:: The module runtime and module isolation
* sourcelayout:: Source layout
* modules:: Module architecture
@end menu

  The Ceylon module architecture enables a toolset which relieves 
    developers of many mundane tasks. The module system specifies: 

  
  @itemize @bullet
  
  @item the format of packaged deployable module archives (for
            the Java platform), module scripts (for the JavaScript platform), 
            and source archives, 

  
  @item the layout of a module repository 

  
  @item the format of the package descriptor files which contain
            information about the packages contained in a module, including
            whether a package is visible to other modules, and 

  
  @item the format of the module descriptor file which contains
            information about a module, along with a list of its
            versioned dependencies. 

  
  @end itemize
Thus, developers are never exposed to individual @code{.class}
    files, and are not required to manually manage module archives using the 
    operating system file manager. Instead, the toolset helps automate the 
    management of modules within module repositories. 

  Circular dependencies between modules are not supported. The
    Ceylon compiler detects such dependencies and produces an error. 

  
@node moduleruntime
@section The module runtime and module isolation
@cindex The module runtime and module isolation

  
      
@menu
      
* classloaders:: Module isolation for the Java platform
* requirejs:: Module isolation for the JavaScript platform
* assemblies:: Assemblies
@end menu

      At any time, there may be multiple versions of a certain module 
        available in the virtual machine. Modules execute under the control of 
        the @emph{module runtime}. The module runtime: 

  
  @itemize @bullet
  
  @item obtains modules from module repositories, 

  
  @item reads module metadata and recursively loads 
                dependencies, and 

  
  @item isolates modules that belong to different
                assemblies. 

  
  @end itemize
Execution of a module begins with a specified toplevel method or 
        class, or with an entry point specified in the module descriptor, and 
        imported modules are loaded lazily as classes they contain are needed. 
        The name and version id of the imported module containing the needed 
        class are determined from the imported package name specified by the 
        compilation unit and the imported module version specified by the 
        module descriptor. 

  The mechanism behind this is platform-dependent. 

  
@node classloaders
@subsection Module isolation for the Java platform
@cindex Module isolation for the Java platform

  In the JVM environment, each version of each module is loaded 
            using a different class loader. Classes inside a module have access 
            to other classes in the same module and to classes belonging to 
            modules that are explicitly imported in the module descriptor. 
            Classes in other modules are not accessible. 

  Ceylon supports a simplified class loader architecture: 

  
  @itemize @bullet
  
  @item The @emph{bootstrap} class loader owns
                    classes required to bootstrap the module runtime. It is the
                    direct parent of all module class loaders, and its classes
                    are visible to all module class loaders. 

  
  @item A @emph{module} class loader owns classes
                    belonging to a given version of a certain module. Its classes
                    are visible only to classes belonging to the module class 
                    loader of a module which declares an explicit dependency on 
                    the given version of the first module. 

  
  @end itemize

@smallindentedblock
  The Ceylon module runtime for the JVM is implemented
            using JBoss Modules. It is included in the Ceylon SDK. 

  
@end smallindentedblock

@node requirejs
@subsection Module isolation for the JavaScript platform
@cindex Module isolation for the JavaScript platform

  In the JavaScript environment, modules are loaded using
            the @code{require()} function defined by CommonJS 
            Modules. 

  
@smallindentedblock
  There are various implementations of the CommonJS-style 
            @code{require()} function, and Ceylon module scripts should
            work with any of them. 

  
@end smallindentedblock

@node assemblies
@subsection Assemblies
@cindex Assemblies

  
@smallindentedblock
  A future release of the language will add support for
            assemblies, that is, the ability to: 

  
            
  @itemize @bullet
  
  @item package together several interdependent versioned modules 
                    into a single archive for deployment as a single well-defined 
                    application or service, 

  
  @item specify the name and version of the application or 
                    service, and 

  
  @item override the versions of imported modules declared in 
                    @code{modules.ceylon}, as defined in 
                    @ref{moduledescriptors, ,Module descriptors}, with assembly-specific
                    module versions. 

  
  @end itemize

            An assembly archive will probably just be an archived module
            repository with an assembly descriptor. 

  
            
@end smallindentedblock

@node sourcelayout
@section Source layout
@cindex Source layout

  A @emph{source directory} contains Ceylon source 
        code in files with the extension @code{.ceylon} and Java 
        source code in files with the extension @code{.java}. 
        The module and package to which a compilation unit belongs is 
        determined by the subdirectory in which the source file is found. 

  The name of the package to which a compilation unit belongs is 
        formed by replacing every path directory separator character with a 
        period in the relative path from the root source directory to the 
        subdirectory containing the source file. In the case of a Java source 
        file, the subdirectory must agree with the package specified by the 
        Java @code{package} declaration. 

  The name of the module to which a compilation unit belongs is 
        determined by searching all containing directories for a module 
        descriptor. The name of the module is formed by replacing every path
        directory separator character with a period in the relative path 
        from the source directory to the subdirectory containing the module 
        descriptor. If no module descriptor is found, the code belongs to
        the @emph{default module}. 

  
@smallindentedblock
  Note: the default module is intended only as a 
        convenience for experimental code. 

  
@end smallindentedblock
A package or compilation unit may belong to only one module.
        No more than one module descriptor may occur in the containing
        directories of a compilation unit. 

  Thus, the structure of the source directory containing the 
        module @code{org.hello} might be the following: 

  
@quotation
 source/
    org/
        hello/
            module.ceylon      //the module descriptor
            main/
                hello.ceylon
            default/
                DefaultHello.ceylon
            personalized/
                PersonalizedHello.ceylon
@end quotation
The source code for multiple modules may be contained in a
        single source directory. 

  
@node modules
@section Module architecture
@cindex Module architecture

  
      
@menu
      
* modulenamesandversionidentifiers:: Module names and version identifiers
* modulearchivenamesjava:: Module archive names for the Java platform
* modulescriptnamesjs:: Module script names for the JavaScript platform
* sourcearchivenames:: Source archive names
* modulearchives:: Module archives
* modulescripts:: Module scripts
* sourcearchives:: Source archives
* modulerepositories:: Module repositories
* packagedescriptors:: Package descriptors
* moduledescriptors:: Module descriptors
@end menu

      Compiled code is automatically packaged into @emph{module
        archives} and @emph{module scripts} by the 
        Ceylon compiler. A @emph{module repository} is a 
        repository containing module archives, module scripts, and other
        miscellaneous artifacts. A module archive or module script is 
        automatically obtained from a module repository when code belonging 
        to the module is needed by the compiler or module runtime. 

  Modules that form part of the Ceylon SDK are found in the
        module repository in the @code{modules} directory of 
        the Ceylon distribution. 

  Red Hat maintains a central module repository at 
        @code{http://modules.ceylon-lang.org}. Read access to 
        this site is free of registration and free of charge. Ceylon projects 
        may apply for a user account which provides write access to the central 
        module repository. 

  A module belonging to the central module repository must
        satisfy the following regulations: 

  
  @itemize @bullet
  
  @item the first element of the module name must be a top-level
                internet domain name, and the second element of the module name 
                must be a second-level domain of the given top-level domain 
                owned by the organization distributing the module, and. 

  
  @item the module must be made available under a royalty-free 
                license. 

  
  @end itemize
For example, a module developed by Red Hat might be named
        @code{org.jboss.server}. 

  
@smallindentedblock
  TODO: should we require that module archives be signed 
        using the Java @code{jarsigner} tool? 

  
@end smallindentedblock

@node modulenamesandversionidentifiers
@subsection Module names and version identifiers
@cindex Module names and version identifiers

  A module @emph{name} is a period-separated
            list of initial lowercase identifiers, for example: 

  
@quotation
 ceylon.language
@end quotation

@quotation
 org.hibernate
@end quotation
It is recommended that module names follow the Java package
            naming convention embedding the organization's domain name (in
            this case, @code{hibernate.org}). The namespace
            @code{ceylon} is reserved for Ceylon SDK modules. The 
            namespace @code{java} is reserved for modules 
            belonging to the Java SDK. The namespace @code{default}
            is reserved for the default module. 

  It is highly recommended, but not required, that every 
            user-written module have at least three identifiers in its name. 
            Therefore, @code{org.hibernate.orm} is strongly
            preferred to @code{org.hibernate}. 

  Modules may not be "nested". That is, the list of identifiers 
            forming the name of a module may not be a prefix of the list of 
            identifiers forming the name of another module. 

  A package belongs to a module if the list of identifiers 
            forming the name of the module is a prefix of the list of 
            identifiers forming the name of the package. For example, the 
            packages: 

  
@quotation
 ceylon.language
@end quotation

@quotation
 ceylon.language.assertion
@end quotation

@quotation
 ceylon.language.meta
@end quotation

@quotation
 ceylon.language.meta.declaration
@end quotation
belong to the module @code{ceylon.language}. The 
            packages: 

  
@quotation
 org.hibernate
@end quotation

@quotation
 org.hibernate.impl
@end quotation

@quotation
 org.hibernate.cache
@end quotation
belong to the module @code{org.hibernate}. 

  
@smallindentedblock
  TODO: This might not work out all that well in practice, 
            unless we introduce some additional convention for "extras" modules,
            for example, modules containing examples. It could be 
            @code{org.hibernate} vs @code{org.hibernate_example}
            or @code{org.hibernate.core} vs 
            @code{org.hibernate.example}. 

  
@end smallindentedblock
The name of the default module is @code{default}. The 
            default module has no version and cannot be published to a remote repository 
            nor to the local repository cache under @file{~/.ceylon/repo}. 

  A module @emph{version identifier} is a character 
            string containing  no whitespace,
            for example: 

  
@quotation
 1.0.1
@end quotation

@quotation
 3.0.0.beta
@end quotation

@smallindentedblock
  TODO: at some stage we will probably need to add a format
            for specifying version ranges. 

  
@end smallindentedblock

@node modulearchivenamesjava
@subsection Module archive names for the Java platform
@cindex Module archive names for the Java platform

  A @emph{module archive name} is constructed from 
            the module name and version identifier. A module archive name is of 
            the following standard form: 

  
@quotation
 @emph{<module>}-@emph{<version>}.car
@end quotation
where @code{@emph{<module>}} 
            is the full name of the module, and 
            @code{@emph{<version>}} is the module 
            version identifier. For example: 

  
@quotation
 ceylon.language-1.0.1.car
@end quotation

@quotation
 org.hibernate-3.0.0.beta.car
@end quotation
The default module has no version, its module archive name is @code{default.car} 

  
@node modulescriptnamesjs
@subsection Module script names for the JavaScript platform
@cindex Module script names for the JavaScript platform

  A @emph{module script name} is likewise constructed 
            from the module name and version identifier. A module script name is of 
            the following standard form: 

  
@quotation
 @emph{<module>}-@emph{<version>}.js
@end quotation
where @code{@emph{<module>}} 
            is the full name of the module, and 
            @code{@emph{<version>}} is the module 
            version identifier. For example: 

  
@quotation
 ceylon.language-1.0.1.js
@end quotation

@quotation
 org.hibernate-3.0.0.beta.js
@end quotation
The default module has no version, its module archive name is @code{default.js} 

  
@node sourcearchivenames
@subsection Source archive names
@cindex Source archive names

  A @emph{source archive name} is of the following 
            standard form: 

  
@quotation
 @emph{<module>}-@emph{<version>}.src
@end quotation
For example: 

  
@quotation
 ceylon.language-1.0.1.src
@end quotation

@quotation
 org.hibernate-3.0.0.beta.src
@end quotation
The default module has no version, its source archive name is @code{default.src} 

  
@node modulearchives
@subsection Module archives
@cindex Module archives

  A Ceylon module archive is a Java @code{jar}
            archive which: 

  
  @itemize @bullet
  
  @item contains a Ceylon module descriptor in the
                    @emph{module directory}, 

  
  @item contains the compiled @code{.class}
                    files for all compilation units belonging to the module, 
                    and 

  
  @item has a filename which adheres to the standard for
                    module archive names. 

  
  @end itemize
The @emph{module directory} of the module archive 
            is formed by replacing each period in the fully qualified package name 
            with the directory separator character. For example, the module directory 
            for the module @code{ceylon.language} is: 

  
@quotation
 /ceylon/language
@end quotation
The module directory for the module @code{org.hibernate} 
            is: 

  
@quotation
 /org/hibernate
@end quotation
The @emph{package directory} for a package 
            belonging to the module archive is formed by replacing each period 
            in the fully qualified package name with the directory separator 
            character. For example, the package directory for the package 
            @code{org.hibernate.impl} is: 

  
@quotation
 /org/hibernate/impl
@end quotation
Inside a module archive, a @code{.class} file is
            found in the package directory of the package to which it belongs. 

  Thus, the structure of the module archive for the module
            @code{org.hello} might be the following: 

  
@quotation
 org.hello-1.0.0.car
    META-INF/
        MANIFEST.MF
    org/
        hello/
            module.class       //the module descriptor
            main/
                package.class  //a package descriptor
                hello.class
            default/
                DefaultHello.class
            personalized/
                PersonalizedHello.class
@end quotation
A module archive may not contain multiple modules. 

  
@node modulescripts
@subsection Module scripts
@cindex Module scripts

  A Ceylon module script is a JavaScript source file which: 

  
  @itemize @bullet
  
  @item complies with the CommonJS Modules specification, 
                    and 

  
  @item has a filename which adheres to the standard for
                    module script names. 

  
  @end itemize

@node sourcearchives
@subsection Source archives
@cindex Source archives

  A @emph{source archive} is a @code{zip} 
            archive which: 

  
  @itemize @bullet
  
  @item contains the source code (@code{.ceylon}
                    and @code{.java} files) for all compilation units 
                    belonging to the module, and 

  
  @item has a filename which adheres to the standard for
                    source archive names. 

  
  @end itemize
Inside a source archive, a Ceylon or Java source file is located in 
            the @emph{package directory} of the package to which the 
            compilation unit belongs. The package directory for a package belonging 
            to the source archive is formed by replacing each period in the fully 
            qualified package name with the directory separator character. 

  Thus, the structure of the source archive for the module
            @code{org.hello} might be the following: 

  
@quotation
 org.hello-1.0.0.src
    org/
        hello/
            module.ceylon       //the module descriptor
            main/
                package.ceylon  //a package descriptor
                hello.ceylon
            default/
                DefaultHello.ceylon
            personalized/
                PersonalizedHello.ceylon
@end quotation
A source archive may not contain the source of multiple modules. 

  
@node modulerepositories
@subsection Module repositories
@cindex Module repositories

  A module repository is a directory structure on the local
            filesystem or a remote HTTP server. 

  
  @itemize @bullet
  
  @item A @emph{local} module repository is 
                    identified by a filesystem path. 

  
  @item A @emph{remote} module repository is 
                    identified by a URL with protocol @code{http:} 
                    or @code{https:}. 

  
  @end itemize
A @emph{publishable} module repository is a local
            module repository, or a WebDAV-enabled remote module repository. 

  For example: 

  
@quotation
 modules
@end quotation

@quotation
 /usr/bin/ceylon/modules
@end quotation

@quotation
 http://jboss.org/ceylon/modules
@end quotation

@quotation
 https://gavin:secret@@modules.ceylon-lang.org
@end quotation
A module repository contains module archives, module scripts, 
            source archives, and documentation. The address of an artifact 
            belonging to the repository adheres to the following standard form: 

  
@quotation
 @emph{<repository>}/@emph{<module-path>}/@emph{<version>}/@emph{<artifact>}
@end quotation
where @code{@emph{<repository>}} 
            is the filesystem path or URL of the repository,
            @code{@emph{<artifact>}} is the name
            of the artifact, @code{@emph{<version>}}
            is the module version, and @code{@emph{<module-path>}} 
            is formed by replacing every period with a slash in the module name. 

  The default module having no version, its access path does not 
            contain the version. 

  
@quotation
 @emph{<repository>}/default/@emph{<archive>}
@end quotation
For example, the module archive @code{ceylon.language-1.0.1.car},
            module script, @code{ceylon.language-1.0.1.js}, and source 
            archive @code{ceylon.language-1.0.1.src}, belonging to the 
            repository included in the Ceylon SDK are obtained from the following 
            addresses: 

  
@quotation
 modules/ceylon/language/1.0.1/ceylon.language-1.0.1.car
@end quotation

@quotation
 modules/ceylon/language/1.0.1/ceylon.language-1.0.1.js
@end quotation

@quotation
 modules/ceylon/language/1.0.1/ceylon.language-1.0.1.src
@end quotation
The module archive @code{org.hibernate-3.0.0.beta.car}
            and source archive @code{org.hibernate-3.0.0.beta.src} 
            belonging to the repository @code{http://jboss.org/ceylon/modules} 
            are obtained from the following addresses: 

  
@quotation
 http://jboss.org/ceylon/modules/org/hibernate/3.0.0.beta/org.hibernate-3.0.0.beta.car
@end quotation

@quotation
 http://jboss.org/ceylon/modules/org/hibernate/3.0.0.beta/org.hibernate-3.0.0.beta.src
@end quotation
The legacy Java @code{jar} archive @code{org.h2-1.2.141.jar} 
            belonging to the repository @code{/usr/bin/ceylon/modules} is 
            obtained from the following address: 

  
@quotation
 /usr/bin/ceylon/modules/org/h2/1.2.141/org.h2-1.2.141.jar
@end quotation
For each archive, the module repository may contain a SHA-1 checksum 
            file. The checksum file is a plain text file containing just the SHA-1 checksum
            of the archive. The address of a checksum file adheres to the following standard 
            form: 

  
@quotation
 @emph{<repository>}/@emph{<module-path>}/@emph{<version>}/@emph{<archive>}.sha1
@end quotation
The compiler or module runtime verifies the checksum after downloading
            the archive from the module repository. 

  A module repository may contain documentation generated by the Ceylon
            documentation compiler in exploded form. A module's documentation resides in the
            @emph{module documentation directory}, a directory with address 
            adhering to the following standard form: 

  
@quotation
 @emph{<repository>}/@emph{<module-path>}/@emph{<version>}/module-doc/
@end quotation
For example, the home page for the documentation of the module
            @code{org.hibernate} is: 

  
@quotation
 http://jboss.org/ceylon/modules/org/hibernate/module-doc/index.html
@end quotation

@node packagedescriptors
@subsection Package descriptors
@cindex Package descriptors

  A @emph{package descriptor} is defined in a source file
            named @code{package.ceylon} in the package it describes. 

  
@verbatim
PackageDescriptor: Annotations "package" FullPackageName ";"
@end verbatim
A @code{package} may be annotated @code{shared}. 
            A @code{shared} package is visible outside the containing module,
            that is, in any module which imports the containing module. 

  The package descriptor is optional for unshared packages. 

  
@example
"The typesafe query API."
license ("http://www.gnu.org/licenses/lgpl.html")
shared package org.hibernate.query;
@end example

@node moduledescriptors
@subsection Module descriptors
@cindex Module descriptors

  A @emph{module descriptor} is defined in a source file
            named @code{module.ceylon} in the root package of the module it
            describes (the package with the same name as the module). 

  
@verbatim
ModuleDescriptor: Annotations "module" FullPackageName StringLiteral ModuleBody
@end verbatim
The literal string after the module name specifies the version of the
            module. 

  A module may import other modules. 

  
@verbatim
ModuleBody: "{" ModuleImport* "}"
@end verbatim

@verbatim
ModuleImport: Annotations "import" (FullPackageName|StringLiteral) StringLiteral ";"
@end verbatim
The name of the imported module may be specified using the usual syntax
            for a module name, or as a literal string, to allow interoperation with
            legacy module repositories existing outside the Ceylon ecosystem. 

  
@smallindentedblock
  Note: this enables interoperation with Maven. 

  
@end smallindentedblock

@smallindentedblock
  Note: in Ceylon 1.0 it is illegal to explicitly import the
            module @code{ceylon.language}. The language module is always
            implicitly imported. 

  
@end smallindentedblock
The string literal after the imported module name specifies the version 
            of the imported module. 

  An imported module may be annotated @code{optional} and/or
            @code{shared}. 

  
  @itemize @bullet
  
  @item If module @code{x} has a @code{shared} 
                    import of module @code{y}, then any module that imports
                    @code{x} implicitly imports @code{y}. 

  
  @item If module @code{x} has an @code{optional}
                    import of module @code{y}, then @code{x} may
                    be executed even if @code{y} is not available at runtime. 

  
  @end itemize
If a declaration belonging to module @code{x} is visible 
            outside the module and involves types imported from a different module
            @code{y}, then the module import of @code{y} in the
            module descriptor for @code{x} must be @code{shared}. 

  
@example
"The best-ever ORM solution!"
license ("http://www.gnu.org/licenses/lgpl.html")
module org.hibernate "3.0.0.beta" @{
    shared import ceylon.language "1.0.1";
    import javax.sql "4.0";
@}
@end example

@example
"The test suite for Hibernate"
license ("http://www.gnu.org/licenses/lgpl.html")
module org.hibernate.test "3.0.0.beta" @{
    import org.hibernate "3.0.0.beta";
    TestSuite().run();
@}
@end example

@smallindentedblock
  TODO: do we allow procedural code in the body of a 
            @code{module}? 

  
@end smallindentedblock


@node index
@unnumbered Index

@printindex cp

@bye
