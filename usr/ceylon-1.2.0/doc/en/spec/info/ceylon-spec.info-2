This is ceylon-spec.info, produced by makeinfo version 5.2 from
ceylon-spec.texi.

This is the Ceylon Language Specification, version 1.2.

   Copyright (C) 2008-2015 Gavin King and contributors

     Licensed under the Apache License, Version 2.0 (the "License"); you
     may not use this file except in compliance with the License.  You
     may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
     implied.  See the License for the specific language governing
     permissions and limitations under the License.
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Ceylon: (ceylon-spec).       The Ceylon Language Specification.
END-INFO-DIR-ENTRY


File: ceylon-spec.info,  Node: existencenonemptinessconditions,  Next: caseconditions,  Prev: assignabilityconditions,  Up: controlstructureconditions

5.4.3 Existence and nonemptiness conditions
-------------------------------------------

An existence or nonemptiness condition may contain either:

   * an unqualified value reference to a non-'variable', non-'default'
     reference, or

   * a pattern together with an expression.

ExistsOrNonemptyCondition: "!"? ("exists" | "nonempty") (Pattern Specifier | MemberName)
   A _negated_ condition is one which starts with '!'.

   The type of the value reference or expression must be:

   * in the case of an existence condition or negated existence
     condition, a type whose intersection with 'Null' is not exactly
     'Nothing' and whose intersection with 'Object' is not exactly
     'Nothing', or

   * in the case of a nonemptiness condition or a negated nonemptiness
     condition, a subtype of 'Anything[]?' whose intersection with '[]'
     is not exactly 'Nothing', and whose intersection with '[Nothing+]'
     is not exactly 'Nothing'.

   Every existence or nonemptiness condition is equivalent to--and may
be considered an abbreviation of--an assignability condition:

   * 'exists x' is equivalent to 'is Object x', and

   * '!exists x' is equivalent to 'is Null x',

   * 'nonempty x' is equivalent to 'is [E+] x' where 'x' is an
     expression whose type has the principal instantiation 'E[]?', and

   * '!nonempty x' is equivalent to 'is [] x'.

   For an existence condition which is not negated:

   * if the condition has a pattern, the patterned type is 'T&Object',
     where the specifier expression is of type 'T', and, if the pattern
     is a pattern variable, the declared type of the variable, if any,
     must be a subtype of 'Object', or

   * if the condition contains a value reference, the value will be
     treated by the compiler as having type 'T&Object' inside the block
     or expression that immediately follows the condition, where the
     conditional expression is of type 'T', and, if this is the only
     condition in the condition list, as having the type 'T&Null' inside
     the following 'else' block or expression if any.

   For a negated existence condition:

   * if the condition has a pattern, it must be a pattern variable, and
     the patterned type is 'T&Null', where the specifier expression is
     of type 'T', and the declared type of the variable, if any, must be
     'Null', or

   * if the condition contains a value reference, the value will be
     treated by the compiler as having type 'T&Null' inside the block or
     expression that immediately follows the condition, where the
     conditional expression is of type 'T', and, if this is the only
     condition in the condition list, as having the type 'T&Object'
     inside the following 'else' block or expression if any.

   For a nonemptiness condition which is not negated:

   * if the condition has a pattern, the patterned type is 'T&[E+]',
     where the specifier expression is of type 'T' and 'T' has the
     principal instantiation 'E[]?', and, if the pattern is a pattern
     variable, the declared type of the variable, if any, must be a
     subtype of '[Anything+]', or

   * if the condition contains a value reference, the value will be
     treated by the compiler as having type 'T&[E+]' inside the block or
     expression that immediately follows the condition, where the
     conditional expression is of type 'T' and 'T' has the principal
     instantiation 'E[]?', and, if this is the only condition in the
     condition list, as having the type 'T&[]' inside the following
     'else' block or expression if any.

   For a negated nonemptiness condition:

   * if the condition has a pattern, it must be a pattern variable, and
     the patterned type is 'T&[]', where the specifier expression is of
     type 'T' and 'T' has the principal instantiation 'E[]?', and the
     declared type of the variable, if any, must be '[]', or

   * if the condition contains a value reference, the value will be
     treated by the compiler as having type 'T&[]' inside the block or
     expression that immediately follows the condition, where the
     conditional expression is of type 'T' and 'T' has the principal
     instantiation 'E[]?', and, if this is the only condition in the
     condition list, as having the type 'T&[E+]' inside the following
     'else' block or expression if any.

   If you prefer, you can think of the following:

     if (exists name) { ... }
   As an abbreviation of:

     if (exists String name = name) { ... }
   Where the 'name' declared by the condition hides the outer
declaration of 'name' inside the block that follows.

   As a special exception to the above, if a condition occurs in a
'dynamic' block, and the conditional expression has no type, and the
condition contains a value reference, then the value will be treated by
the compiler as having no type.


File: ceylon-spec.info,  Node: caseconditions,  Prev: existencenonemptinessconditions,  Up: controlstructureconditions

5.4.4 Case conditions
---------------------

The branches of a 'switch' conditional each belong to a _case
condition_.  There are two kinds of case condition:

   * a _value case_--a list of string literals, character literals,
     integer literals, negated integer literals, value references to
     value constructors, and/or value references to anonymous classes,
     or

   * a _type case_--an assignability condition of form 'is V' for some
     type 'V'.

   For a value case, each value reference must be to an anonymous class
that is a subtype of 'Identifiable|Null' or to a value constructor for a
class that is a subtype of 'Identifiable'.

CaseCondition: "(" (ValueCase | TypeCase) ")"

ValueCase: CaseValue ("|" CaseValue)*

TypeCase: "is" Type

CaseValue: LiteralCase | BaseExpression

LiteralCase: "-"? IntegerLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral
   Every case condition has a type:

   * for a value case, the type is the union of the types of the values,
     and

   * for a type case, the type is the specified type.

     Note: to each value constructor, the compiler assigns an internal
     type which is a subtype of the type of the class to which the
     constructor belongs.  The union of all internal value constructor
     types for value constructors listed in the 'of' clause of the class
     declaration covers the class type.

   For a case of type 'U' of a 'switch' with switched type 'V', as
defined below in *note switch/case/else: switchcaseelse.:

   * the intersection type 'V&U' must not be exactly 'Nothing', and

   * if the case is a type case, the 'switch' variable, or, if there is
     no inline variable declared by the 'switch', the value referred by
     the 'switch' expression, will be treated by the compiler as having
     the type 'V&U' inside the 'case' block.

   As a special exception to the above, if a 'switch' occurs in a
'dynamic' block, and there is no switched type, the 'switch' variable,
or the value referred by the 'switch' expression will be treated by the
compiler as having the type 'V' inside the 'case' block.

     Note: a type case may narrow to an intersection or union type.

          case (is Persistent & Serializable) { ... }

          case (is Integer | Float) { ... }


File: ceylon-spec.info,  Node: controlstructures,  Prev: controlstructureconditions,  Up: statementblocks

5.5 Control structures and assertions
=====================================

* Menu:


* ifelse:: if/else
* switchcaseelse:: switch/case/else
* forelse:: for/else
* while:: while
* trycatchfinally:: try/catch/finally
* assertions:: Assertions

Control of execution flow may be achieved using control directives and
_control structures_.  Control structures include conditionals, loops,
and exception management.

   Ceylon provides the following control structures:

   * the 'if/else' conditional--for controlling execution based on a
     boolean condition, type condition, or check for a non-null or
     non-empty value,

   * the 'switch/case/else' conditional--for controlling execution using
     an enumerated list of values or types,

   * the 'while' loop--for loops which terminate based on a boolean
     condition, type condition, or check for a non-null or non-empty
     value,

   * the 'for/else' loop--for looping over elements of an iterable
     object, and

   * the 'try/catch/finally' exception manager--for managing exceptions
     and controlling the lifecycle of objects which require explicit
     destruction.

ControlStructure: IfElse | SwitchCaseElse | While | ForFail | TryCatchFinally | Assertion

     Control structures are not considered to be expressions, and
     therefore do not evaluate to a value.  However, comprehensions,
     specified in *note Comprehensions: comprehensions, and conditional
     expressions, specified in *note Conditional expressions: (let
     expressions)miscexpressions. are part of the expression syntax and
     share much of the syntax and semantics of the control structures
     they resemble.

   _Assertions_ are runtime checks upon program invariants, or function
preconditions and postconditions.  An assertion failure represents a bug
in the program, and is not considered recoverable.  Therefore,
assertions should not be used to control "normal" execution flow.

     Note: of course, in certain circumstances, it is appropriate to
     handle the exception that results from an assertion failure, for
     example, to display a message to the user, or in a testing
     framework to aggregate and report the failures that occurred in
     test assertions.  A test failure may be considered "normal"
     occurrence from the point of view of a testing framework, but it's
     not "normal" in the sense intended above.


File: ceylon-spec.info,  Node: ifelse,  Next: switchcaseelse,  Up: controlstructures

5.5.1 if/else
-------------

The 'if/else' conditional has the following form:

IfElse: If Else?

If: "if" ConditionList Block

Else: "else" (Block | IfElse)
   Every 'if/else' conditional construct has an 'if' clause.  The
construct may optionally include:

   * a chain of an arbitrary number of child 'else if' clauses, and/or

   * an 'else' clause.

     if (payment.amount <= account.balance) {
         account.balance -= payment.amount;
         payment.paid = true;
     }
     else {
         throw NotEnoughMoneyException();
     }

     shared void welcome(User? user) {
         if (exists user) {
             print("Welcome back, ``user.name``!");
         }
         else {
             print("Welcome to Ceylon!");
         }
     }

     if (is CardPayment p = order.payment,
             !p.paid) {
         p.card.charge(total);
     }


File: ceylon-spec.info,  Node: switchcaseelse,  Next: forelse,  Prev: ifelse,  Up: controlstructures

5.5.2 switch/case/else
----------------------

The 'switch/case/else' conditional has the following form:

SwitchCaseElse: Switch Case+ Else?
   Every 'switch' conditional has a 'switch' clause.

Switch: "switch" "(" SwitchVariableOrExpression ")"
   The 'switch' clause has a _switched expression_, either:

   * an expression, or

   * an inline variable declaration together with a specified
     expression.

SwitchVariableOrExpression: Expression | Variable Specifier
   The _switched type_ is the type of the expression or inline variable.

     Note: there is an ambiguity here between assignment expressions and
     inline variable declarations.  This ambiguity is resolved in favor
     of interpreting the switched expression as a variable declaration.
     Therefore, a switched expression in a 'switch' clause may not be an
     assignment expression.

   If a 'switch' has a type case condition, and does not declare an
inline variable, then the switched expression must be an unqualified
value reference to a non-'variable', non-'default' reference.

   In addition, every 'switch' conditional must include:

   * a chain of one or more child 'case' clauses, and,

   * optionally, a chain of an arbitrary number of child 'else if'
     clauses, and/or

   * optionally, an 'else' clause.

Case: "case" CaseCondition Block
   Two 'case's are said to be _disjoint_ if:

   * the intersection of the types of their case conditions is exactly
     'Nothing', as defined by *note Disjoint types: disjointtypes, or

   * if they are both value cases with no literal value or anonymous
     class value reference in common.

   In every 'switch' statement, all 'case's must be mutually disjoint.

   A 'switch' is _exhaustive_ if there are no literal values in its
'case's, and the union type formed by the types of the case conditions
of the 'switch' covers the switched type, as defined by *note Coverage:
coverage.  If no 'else' block is specified, the 'switch' must be
exhaustive.

     Note: On the other hand, even if the 'switch' _is_ exhaustive, an
     'else' block may be specified, in order to allow a 'switch' that
     accommodates additional cases without resulting in a compilation
     error.

   As a special exception to the above, if a 'switch' occurs in a
'dynamic' block, and the switched expression has no type, the cases are
not statically type-checked for exhaustion.

   If an 'else' block is specified, then the 'switch' variable or, if
there is no inline variable declared by the 'switch', the value referred
by the 'switch' expression, will be treated by the compiler as having
the type 'V~U' inside the 'else' block, where 'V' is the switched type,
and 'U' is the union type formed by the types of the case conditions of
the 'switch'.

     Boolean? maybe = ... ;
     switch (maybe)
     case (null | false) {
         return false;
     }
     case (true) {
         return true;
     }

     Integer|Float number = ... ;
     switch (number)
     case (is Integer) {
         return sqrt(number.float);
     }
     case (is Float) {
         return sqrt(number);
     }


File: ceylon-spec.info,  Node: forelse,  Next: while,  Prev: switchcaseelse,  Up: controlstructures

5.5.3 for/else
--------------

The 'for/else' loop has the following form:

ForFail: For Fail?

For: "for" ForIterator Block

Fail: "else" Block
   Every 'for/else' conditional construct has an 'for' clause.  The
construct may optionally include an 'else' clause, as specified in *note
Execution of loops: executionofloops.

   The 'for' iterator has an _iterator pattern_ and an _iterated
expression_ that contains the range of values to be iterated.

ForIterator: "(" Pattern "in" Expression ")"
   The type of the iterated expression must have some principal
supertype instantiation '{T*}' or '{T+}' of 'Iterable' in
'ceylon.language'. Then the patterned type of the iterator pattern is
'T'.

   As a special exception to the above, if a 'for' occurs in a 'dynamic'
block, and the iterated expression has no type, the iterator is not
statically type-checked.  If the iteration variable does not declare an
explicit type, the iteration variable has no type.

     for (p in people) {
         print(p.name);
     }

     variable Float sum = 0.0;
     for (i in -10..10) {
         sum += x[i] else 0.0;
     }

     for (word -> freq in wordFrequencyMap) {
         print("The frequency of ``word`` is ``freq``.");
     }

     for (p in group) {
         if (p.age >= 18) {
             log.info("Found an adult: ``p.name``.");
             break;
         }
     }
     else {
         log.info("No adult in group.");
     }



File: ceylon-spec.info,  Node: while,  Next: trycatchfinally,  Prev: forelse,  Up: controlstructures

5.5.4 while
-----------

The 'while' loop has the form:

While: LoopCondition Block
   The loop condition list determines when the loop terminates.

LoopCondition: "while" ConditionList

     TODO: does 'while' need an 'else' block?  Python has it, but what
     is the real usecase?

     variable Integer n=0;
     variable [Integer*] seq = [];
     while (n<=max) {
         seq=seq.withTrailing(n);
         n+=step(n);
     }


File: ceylon-spec.info,  Node: trycatchfinally,  Next: assertions,  Prev: while,  Up: controlstructures

5.5.5 try/catch/finally
-----------------------

The 'try/catch/finally' exception manager has the form:

TryCatchFinally: Try Catch* Finally?

Try: "try" ResourceList? Block

ResourceList: "(" Resource ("," Resource)* ")"

Catch: "catch" "(" Variable ")" Block

Finally: "finally" Block
   Every 'try' conditional construct has a 'try' clause.  The construct
may optionally include:

   * a chain of an arbitrary number of child 'catch' clauses, and/or

   * a 'finally' clause, as specified in *note Exception handling:
     exceptionhandling.

   Each 'catch' block defines a variable.  The type of the variable must
be assignable to 'Throwable' in 'ceylon.language'.  If no type is
explicitly specified, the type is inferred to be 'Exception'.

     Note: a 'catch' block type may be a union or intersection type:

          catch (NotFoundException|DeletedException e) { ... }

   If there are multiple 'catch' blocks in a certain control structure,
then:

   * The type of a 'catch' variable may not be a subtype of any catch
     variable of an earlier 'catch' block belonging to the same control
     structure.

   * If the type of a 'catch' variable is a union type 'E1|E2|...|En'
     then no member 'Ei' of the union may be a subtype of any catch
     variable of an earlier 'catch' block belonging to the same control
     structure.

   The 'try' block may have a list of _resource expressions_, each of
which may produce either:

   * a _destroyable resource_, or

   * an _obtainable resource_.

Resource: Expression | Variable Specifier

     Note: there is an ambiguity here between assignment expressions and
     inline variable declarations.  This ambiguity is resolved in favor
     of interpreting the resource expression as a variable declaration.
     Therefore, a resource expression in a 'try' clause may not be an
     assignment expression.

   A destroyable resource expression is:

   * an instantiation expression, or

   * an inline variable declaration together with an instantiation
     expression.

   The instantiation expression must be of type assignable to
'Destroyable' in 'ceylon.language'.

   An obtainable resource expression is:

   * an expression, or

   * an inline variable declaration together with an expression.

   The expression must be of type assignable to 'Obtainable' in
'ceylon.language'.

   If no type is explicitly specified for a resource variable, the type
of the variable is inferred to be the type of the expression.

     try (File(path).lock) {
         file.open(write);
         ...
     }
     catch (FileNotFoundException fnfe) {
         print("file not found: ``path``");
     }
     catch (FileReadException fre) {
         print("could not read from file: ``path``");
     }
     finally {
         assert (file.closed);
     }

     try (Transaction()) {
         try (s = Session()) {
             return s.get(Person, id);
         }
         catch (NotFoundException|DeletedException e) {
             return null;
         }
     }


File: ceylon-spec.info,  Node: assertions,  Prev: trycatchfinally,  Up: controlstructures

5.5.6 Assertions
----------------

An assertion has an asserted condition list and, optionally, an
annotation list.

Assertion: Annotations "assert" ConditionList ";"
   The message carried by the assertion failure may be specified using a
'doc' annotation.

     "total must be less than well-defined bound"
     assert (exists bound, total<bound);
   If the assertion contains an assignability, existence, or
nonemptiness condition containing a value reference then the compiler
treats the referenced value as having a narrowed type at program
elements that occur in the lexical scope of the assertion.

     {Element*} elements = ... ;
     assert (nonempty elements);
     Element first = elements.first;

     TODO: how can we support interpolation in the assertion failure
     message?

          assert (total<bound)
          else "total must be less than ``bound``";


File: ceylon-spec.info,  Node: expressions,  Next: annotations,  Prev: statementblocks,  Up: Top

6 Expressions
*************

* Menu:


* literalvalues:: Literal values
* stringtemplates:: String templates
* selfreferences:: Self references
* anonymousfunctions:: Anonymous functions
* compoundexpressions:: Compound expressions
* invocationexpressions:: Invocation expressions
* miscexpressions:: Conditional expressions, let expressions, and anonymous class expressions
* operators:: Operators
* metamodelexpressions:: Metamodel expressions
* referenceexpressions:: Reference expressions

An _expression_ produces a value when executed.  An algorithm expressed
using functions and expressions, rather than sequences of statements is
often easier to understand and refactor.  Therefore, Ceylon has a highly
flexible expressions syntax.  Expressions are formed from:

   * literal values, string templates, and self references,

   * evaluation and assignment of values,

   * invocation of functions and instantiation of classes,

   * callable references, static references, and anonymous functions,

   * comprehensions,

   * metamodel references,

   * enumeration of iterables and tuples, and

   * operators.

   Ceylon expressions are validated for typesafety at compile time.  To
determine whether an expression is assignable to a program element such
as a value or parameter, Ceylon considers the _type_ of the expression
(the type of the objects that are produced when the expression is
evaluated).  An expression is assignable to a program element if the
type of the expression is assignable to the declared type of the program
element.

   Within a 'dynamic' block, an expression may have no type, in the
sense that its type can not be determined using static analysis of the
code.


File: ceylon-spec.info,  Node: literalvalues,  Next: stringtemplates,  Up: expressions

6.1 Literal values
==================

* Menu:


* naturalnumber:: Integer number literals
* floatnumber:: Floating point number literals
* character:: Character literals
* string:: Character string literals

Ceylon supports literal values of the following types:

   * 'Integer' and 'Float',

   * 'Character', and

   * 'String'.

   The types 'Integer', 'Float', 'Character', and 'String' are defined
in the module 'ceylon.language'.

     Note: Ceylon does not need a special syntax for 'Boolean' literal
     values, since 'Boolean' is just a class with the cases 'true' and
     'false'.  Likewise, 'null' is just the singleton value of an
     anonymous class.

Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral
   All literal values are instances of immutable types.  The value of a
literal expression is an instance of the type.  How this instance is
produced is not specified here.


File: ceylon-spec.info,  Node: naturalnumber,  Next: floatnumber,  Up: literalvalues

6.1.1 Integer number literals
-----------------------------

An integer literal, as defined in *note Numeric literals:
numericliterals, is an expression of type 'Integer', representing a
numeric integer.

     Integer five = 5;

     Integer mask = $1111_0000;

     Integer white = #FFFF;


File: ceylon-spec.info,  Node: floatnumber,  Next: character,  Prev: naturalnumber,  Up: literalvalues

6.1.2 Floating point number literals
------------------------------------

A floating point literal, as defined in *note Numeric literals:
numericliterals, is an expression of type 'Float', a floating-point
representation of a numeric value.

     shared Float pi = 3.14159;


File: ceylon-spec.info,  Node: character,  Next: string,  Prev: floatnumber,  Up: literalvalues

6.1.3 Character literals
------------------------

A single character literal, as defined in *note Character literals:
characterliterals, is an expression of type 'Character', representing a
single 32-bit Unicode character.

     if (exists ch=string[i], ch == '+') { ... }


File: ceylon-spec.info,  Node: string,  Prev: character,  Up: literalvalues

6.1.4 Character string literals
-------------------------------

A character string literal or verbatim string, as defined in *note
String literals: stringliterals, is an expression of type 'String',
representing a sequence of Unicode characters.

     person.name = "Gavin King";

     print("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");

     String verbatim = """A verbatim string can have \ or a " in it."""";


File: ceylon-spec.info,  Node: stringtemplates,  Next: selfreferences,  Prev: literalvalues,  Up: expressions

6.2 String templates
====================

A character _string template_ contains interpolated expressions,
surrounded by character string fragments.

StringTemplate: StringStart Expression (StringMid Expression)* StringEnd
   Each interpolated expression contained in the string template must
have a type assignable to 'Object' defined in 'ceylon.language'.

     print("Hello, ``person.firstName`` ``person.lastName``, the time is ``Time()``.");

     print("1 + 1 = ``1 + 1``");
   A string template is an expression of type 'String'.


File: ceylon-spec.info,  Node: selfreferences,  Next: anonymousfunctions,  Prev: stringtemplates,  Up: expressions

6.3 Self references
===================

* Menu:


* this:: this
* outer:: outer
* super:: super

The type of the following expressions depends upon the context in which
they appear.

SelfReference: "this" | "super" | "outer"
   A self reference expression may not occur outside of a class or
interface body.

   The _immediately containing class or interface_ for a program element
is the class or interface in which the program element occurs, and which
contains no other class or interface in which the program element
occurs.  If there is no such class or interface, the program element has
no immediately containing class or interface.

   A 'this', 'outer', or 'super' self reference must have an immediately
containing class or interface.  An 'outer' self reference must have an
immediately containing class or interface for its immediately containing
class or interface.

     Note: the keyword 'package' is not an expression, and thus does not
     have a well-defined type.  However, it may be used to qualify and
     disambiguate a value reference or callable reference.  A value
     reference or callable reference qualified by the keyword 'package'
     always refers to a toplevel member of the containing package, never
     to an imported declaration or nested declaration, as defined by
     *note Unqualified reference resolution:
     unqualifiedreferenceresolution.


File: ceylon-spec.info,  Node: this,  Next: outer,  Up: selfreferences

6.3.1 this
----------

The keyword 'this' refers to the current instance, as defined in *note
Current instance of a class or interface:
currentinstanceofaclassorinterface, of the immediately containing class
or interface (the class or interface in which the expression appears).
Its type is the applied type formed by the immediately containing class
or interface with its own type parameters as type arguments.


File: ceylon-spec.info,  Node: outer,  Next: super,  Prev: this,  Up: selfreferences

6.3.2 outer
-----------

The keyword 'outer' refers to the current instance, as defined in *note
Current instance of a class or interface:
currentinstanceofaclassorinterface, of the class or interface which
immediately contains the immediately containing class or interface.  Its
type is the applied type formed by this class or interface with its own
type parameters as type arguments.


File: ceylon-spec.info,  Node: super,  Prev: outer,  Up: selfreferences

6.3.3 super
-----------

The keyword 'super' refers to the current instance of the immediately
containing class or interface.  Its type is the intersection of the
principal instantiation of the immediate superclass for the immediately
containing class or interface, as defined in *note Principal
instantiation of a supertype: principalinstantiationofasupertype, with
all principal instantiations of immediate superinterfaces of the
immediately containing class or interface.  A member reference such as
'super.x' may not resolve to a 'formal' declaration, nor to any member
inherited from more than one supertype of the intersection type.

   As an exception to this, when the keyword 'super' occurs in an
'extends' clause, as specified in *note Extension: extendedclass, it
refers to the current instance of the class or interface which
immediately contains the declaration to which the 'extends' clause
belongs.  Its type is the intersection of the principal instantiation of
the immediate superclass of this containing class or interface, with all
principal instantiations of immediate superinterfaces of this containing
class or interface.

   The keyword 'super' may occur as the first operand of an 'of'
operator, in which case the second operand is the principal
instantiation of some supertype of the class for the immediately
containing class or interface.  The expression '(super of Type)' has
type 'Type'.  A member reference such as '(super of Type).x' may not
resolve to a 'formal' member, nor to any member inherited from more than
one supertype of 'Type', nor to any member that is refined by the class
or any intermediate supertype of the class.


File: ceylon-spec.info,  Node: anonymousfunctions,  Next: compoundexpressions,  Prev: selfreferences,  Up: expressions

6.4 Anonymous functions
=======================

* Menu:


* parametertypeinference:: Anonymous function parameter type inference

An anonymous function is a function, as specified in *note Functions:
functions, with no name, defined within an expression.  It comprises one
or more parameter lists, followed by an expression or a block of code.

FunctionExpression: ("function" | "void")? Parameters+ (LazySpecifier | Block)
   The parameters are the parameters of the function.  The lazy
specifier or block of code is the implementation of the function.

   An anonymous function may be considered 'void':

   * if the 'void' keyword is specified, the function is a 'void'
     function, or

   * if the 'function' keyword is specified, the function is not a
     'void' function, or,

   * otherwise, the function is 'void' if and only if it is defined
     using a block in which no 'return' statement with an expression
     occurs sequentially, as defined in *note Block structure and
     references: blockstructure.

   If the function is not considered 'void', then its return type is
inferred.

   The type of an anonymous function expression is the callable type of
the function, as specified in *note Callable type of a function:
callabletypeoffunction.

     (Value x, Value y) => x<=>y

     void (String name) => print(name)

     (String string) {
         value mid = string.size / 2;
         return [string[...mid],string[mid+1...]];
     }
   An anonymous function occurring in an 'extends' clause may not
contain a reference to a variable value.

     Note: evaluation of an anonymous function expression, as defined in
     *note Evaluation of anonymous functions:
     anonymousfunctionevaluation. results in instantiation of an object
     of type 'Callable'.  However, the members of this object are never
     in scope, do not hide other declarations, and are not referenceable
     from within the anonymous function.

     Note: there is almost no semantic difference between the following
     function declarations:

          Float f(Float x)(Float y) => x*y;

          Float(Float) f(Float x) => (Float y) => x*y;

     The first form is strongly preferred.


File: ceylon-spec.info,  Node: parametertypeinference,  Up: anonymousfunctions

6.4.1 Anonymous function parameter type inference
-------------------------------------------------

If the type of a parameter of an anonymous function is not declared
explicitly, then the type of the parameter may in certain cases be
inferred if the anonymous function occurs:

   * as a listed argument, as defined in *note Listed arguments:
     listedarguments, in a positional argument list, or

   * as a specified argument, anonymous argument, or listed argument, as
     defined in *note Named argument lists: namedarguments, in a named
     argument list.

   Suppose the type of the 'i'th parameter 'p' of an anonymous function
is not declared explicitly, and further suppose that the anonymous
function occurs as the argument to a parameter 'x' of some function or
class in a direct invocation expression, as defined in *note Direct
invocations: directinvocations.

   Then the type of 'p' may be inferred if either:

   * the function or class has no type parameters, or the invocation has
     an explicit type argument list, and 'x' is a callable parameter
     with the same number of parameters as the anonymous function, and
     with 'i'th parameter 'q',

   * the function or class has at least one type parameter, and the
     invocation has no explicit type argument list, and 'x' is a
     callable parameter with the same number of parameters as the
     anonymous function, and the type of the 'i'th parameter 'q' of 'x'
     does not involve any of the type parameters of the generic function
     or class, or

   * 'x' is a value parameter whose type does not involve any of the
     type parameters of the generic function or class and represents a
     function with the same number of parameters as the anonymous
     function, and with 'i'th parameter 'q', according to *note Callable
     type of a function: callabletypeoffunction.

   Then the type of 'p' is inferred to be the type of 'q' in the
realization of the function or class, as defined in *note Realizations:
realizations.

   Otherwise, suppose the type of the 'i'th parameter 'p' of an
anonymous function is not declared explicitly, and further suppose that
the anonymous function occurs as the 'n'th argument in the positional
argument list of an indirect invocation expression.

   Then if the callable type of the invoked expression represents a
function whose 'n'th parameter is a callable parameter with the same
number of parameters as the anonymous function, according to *note
Callable type of a function: callabletypeoffunction, then the type of
'p' is inferred to be the type of the corresponding 'i'th parameter of
this callable parameter.

   That is, if the type of the invoked expression is 'R(*T)' where 'T'
is a tuple type whose 'n'th element type is 'P(*S)' and 'S' is in turn a
tuple type whose 'i'th element type is 'Q', then 'Q' is the inferred
type of 'p'.


File: ceylon-spec.info,  Node: compoundexpressions,  Next: invocationexpressions,  Prev: anonymousfunctions,  Up: expressions

6.5 Compound expressions
========================

* Menu:


* baseexpressions:: Base expressions
* memberexpressions:: Member expressions
* constructorexpressions:: Constructor expressions
* valuereferences:: Value references
* callablereferences:: Callable references
* staticexpressions:: Static expressions
* staticvaluereferences:: Static value references
* staticcallablereferences:: Static callable references

An _atom_ is a literal or self reference, a string template, a base
expression, an iterable or tuple enumeration, an anonymous class
expression, a metamodel or reference expression, or a parenthesized
expression.

Atom: LiteralExpression | BaseExpression | DelimitedExpression | MetaExpression | SelfReference

LiteralExpression: Literal | StringTemplate

DelimitedExpression: GroupedExpression | Enumeration | ObjectExpression

MetaExpression: Meta | Dec
   A _primary_ is formed by recursively forming member expressions,
static expressions, invocation expressions, and index expressions from
an initial atom, using the operators in the first row of the table of
operator precedence and associativity in *note Operator precedence:
operatorprecedence.

Primary: Atom | QualifiedExpression | Invocation | IndexedExpression

QualifiedExpression: MemberExpression | ConstructorExpression | StaticExpression
   More complex expressions are formed by combining expressions using
operators, including assignment operators, as defined in *note
Operators: operators, and using inline conditional expressions and
anonymous functions.

ValueExpression: Primary | OperatorExpression

Expression: ValueExpression | FunctionExpression | LetExpression | ConditionalExpression

     Note: the grammar of operator expressions is defined by the table
     of operator precedence and associativity in *note Operator
     precedence: operatorprecedence.  Thus, the rules
     'OperatorExpression' and 'IndexedExpression' are not defined in
     BNF.

   Parentheses are used for grouping:

GroupedExpression: "(" Expression ")"
   A compound expression occurring in a 'dynamic' block, and involving a
qualified or unqualified reference with no type, or a reference to a
declaration with no type, may also have no type.

   In particular, if an operand expression has no type, and the type of
the operator expression depends upon the type of the operand, and the
operator expression occurs within a 'dynamic' block, then the whole
operator expression has no type.


File: ceylon-spec.info,  Node: baseexpressions,  Next: memberexpressions,  Up: compoundexpressions

6.5.1 Base expressions
----------------------

A _base expression_ is an identifier, optionally qualified by the
keyword 'package', with an optional list of type arguments:

BaseExpression: PackageQualifier? (MemberName | TypeName) TypeArguments?
   A base expression is either:

   * a reference to a toplevel function, toplevel value, or toplevel
     class,

   * a reference within the lexical scope of the referenced function,
     value, constructor, or class, or

   * a reference within the body of the referenced function, value,
     constructor, or class.

   The referenced declaration is determined by resolving the unqualified
reference as defined by *note Unqualified reference resolution:
unqualifiedreferenceresolution.  The unqualified realization for the
unqualified reference is determined according to *note Realizations:
realizations.

   The type argument list, if any, must conform, as defined by *note
Type arguments and type constraints: typeargumentsandconstraints, to the
type parameter list of the unqualified realization.

   If a base expression is a reference to an attribute, method, member
class, or member class constructor of a class, the receiving instance is
the current instance of that class, as defined by *note Current instance
of a class or interface: currentinstanceofaclassorinterface.  Otherwise,
there is no receiving instance.


File: ceylon-spec.info,  Node: memberexpressions,  Next: constructorexpressions,  Prev: baseexpressions,  Up: compoundexpressions

6.5.2 Member expressions
------------------------

A _member expression_ is a _receiver expression_, followed by an
identifier, with an optional list of type arguments.

MemberExpression: (Primary ".") (MemberName | TypeName) TypeArguments?
   A member expression is a reference to a member of a type: an
attribute, method, or member class.

   The referenced member is determined by resolving the qualified
reference as defined by *note Qualified reference resolution:
qualifiedreferenceresolution.  The qualified realization for the
qualified reference is determined according to *note Realizations:
realizations.

   The type argument list, if any, must conform, as defined by *note
Type arguments and type constraints: typeargumentsandconstraints, to the
type parameter list of the qualified realization.

   The receiver expression produces the instance upon which the member
is invoked or evaluated.  When a member expression is executed, the
receiver expression is evaluated to produce the receiving instance which
is held until the member is invoked or evaluated, as defined in *note
Evaluation: (invocation)evaluationinvocationandassignment.


File: ceylon-spec.info,  Node: constructorexpressions,  Next: valuereferences,  Prev: memberexpressions,  Up: compoundexpressions

6.5.3 Constructor expressions
-----------------------------

A _constructor expression_ is a base or member expression that
references a class with constructors, followed by an identifier, with an
optional list of type arguments.

ConstructorExpression: (BaseExpression | MemberExpression) "." MemberName TypeArguments?
   A constructor expression is a reference to a constructor of a class.

   The referenced member is determined by resolving the qualified
reference as defined by *note Qualified reference resolution:
qualifiedreferenceresolution.  The qualified realization for the
qualified reference is determined according to *note Realizations:
realizations.

   The type argument list, if any, must conform, as defined by *note
Type arguments and type constraints: typeargumentsandconstraints, to the
type parameter list of the qualified realization.

   If the constructor expression is qualified by a member expression,
its receiver expression produces the instance upon which the constructor
is invoked.  When a constructor expression is executed, the receiver
expression is evaluated to produce the receiving instance which is held
until the constructor is invoked or evaluated, as defined in *note
Evaluation: (invocation)evaluationinvocationandassignment.


File: ceylon-spec.info,  Node: valuereferences,  Next: callablereferences,  Prev: constructorexpressions,  Up: compoundexpressions

6.5.4 Value references
----------------------

A _value reference_ is a base expression or member expression that
references a value declaration or value constructor declaration.

   The type of a value reference expression is the type of the
realization of the referenced value or value constructor.

   A value or value constructor declaration is never generic, so a value
reference never has a type argument list.

   A value reference that does not occur within any 'dynamic' block may
not refer to a value declaration or value parameter with no type.

   A value reference which occurs within a 'dynamic' block and which
does not reference any statically typed declaration, or which references
a value declaration or value parameter with no type, has no type.

   If a base expression or member expression does not reference any
statically typed declaration, and occurs within a 'dynamic' block, then
it is considered a value reference.


File: ceylon-spec.info,  Node: callablereferences,  Next: staticexpressions,  Prev: valuereferences,  Up: compoundexpressions

6.5.5 Callable references
-------------------------

A _callable reference_ is a base expression, member expression, or
constructor expression that references something--a function, class, or
callable constructor--that can be _invoked_ or _instantiated_ by
specifying a list of arguments.

   If a callable reference refers to a class with a default constructor,
the callable reference is considered a reference to the default
constructor.

   A callable reference may be invoked immediately, or it may be passed
to other code which may invoke the reference.  A callable reference
captures the return type and parameter list types of the function or
class it refers to, allowing compile-time validation of argument types
when the callable reference is invoked.

   The type of a callable reference expression is the callable type of
the realization of the referenced function, class, or callable
constructor.

   If a callable reference expression refers to a generic declaration,
it must either:

   * have an explicit type argument list,

   * be immediately followed by an argument list, allowing the compiler
     to infer the type arguments, as defined in *note Type argument
     inference: typeargumentinference, or,

   * be the immediate child of a constructor expression that is
     immediately followed by an argument list, allowing the compiler to
     infer the type arguments, as defined in *note Type argument
     inference: typeargumentinference, or

   * occur as a listed argument, as defined in *note Listed arguments:
     listedarguments. in a positional argument list, or as a specified
     argument, anonymous argument, or listed argument, as defined in
     *note Named argument lists: namedarguments, in a named argument
     list, and its type arguments must be inferable as defined below.

   A callable reference may not occur as the receiver expression of a
member expression.

     Note: this restriction exists to eliminate an ambiguity in the
     interpretation of static expressions such as 'Person.string' and
     'Person.equals'.

   A callable reference that does not occur within any 'dynamic' block
may not refer to a function declaration with no return type.

   A callable reference which occurs within a 'dynamic' block and which
references a function declaration with no return type, has no type.

     Note: in a future release of the language, we would like to add a
     syntax for obtaining a callable reference to an attribute,
     something like 'person.@name', to allow attributes to be passed by
     reference.  This would also allow static references like
     'Person.@name'.

   If a callable reference 'f' with no explicit type argument list
occurs as the argument to a callable parameter 'p' of a function or
class in a direct invocation expression, as defined below in *note
Direct invocations: directinvocations, then the type arguments of 'f'
are inferred according to the rules defined in *note Type argument
inference: typeargumentinference. as if the types of the parameters of
'p' were the types of listed arguments of 'f' in a positional argument
list, unless the invoked function or class is generic, and the
invocation expression does not itself specify explicit type arguments,
in which case any parameter whose type involves a type argument of the
invoked function or class is ignored.

   If a callable reference 'f' with no explicit type argument list
occurs as the argument to a value parameter 'p' of type 'Return(*Args)'
in a direct or indirect invocation expression, then the type arguments
of 'f' are inferred according to the rules defined in *note Type
argument inference: typeargumentinference. as if 'Args' were the type of
a positional argument list, unless the invocation is a direct invocation
expression, and the invoked function or class is generic, and 'Args'
involves type parameters of the invoked function or class.


File: ceylon-spec.info,  Node: staticexpressions,  Next: staticvaluereferences,  Prev: callablereferences,  Up: compoundexpressions

6.5.6 Static expressions
------------------------

A _static expression_ is a type, optionally qualifier by the keyword
'package', followed by an identifier, with an optional list of type
arguments.

StaticExpression: PackageQualifier? (TypeName TypeArguments? ".")+ (MemberName | TypeName) TypeArguments?
   A static expression is a reference to a member of a type: an
attribute, method, or member class, or to a constructor of a member
class of the type.

   The referenced member is determined by resolving the qualified
reference as defined by *note Qualified reference resolution:
qualifiedreferenceresolution.  The qualified realization for the
qualified reference is determined according to *note Realizations:
realizations.

   The type argument list, if any, must conform, as defined by *note
Type arguments and type constraints: typeargumentsandconstraints, to the
type parameter list of the qualified realization.

   Unlike member expressions, a static expression does not have a
receiver expression. All static expressions are callable expressions
which accept an argument of the specified type.

   A static expression must reference a statically typed declaration
with no missing types, even within a 'dynamic' block.

   If the qualifying type in a static expression refers to a generic
declaration, then either:

   * it must have an explicit type argument list, or

   * the static expression must occur as a listed argument, as defined
     in *note Listed arguments: listedarguments. in a positional
     argument list, or as a specified argument, anonymous argument, or
     listed argument, as defined in *note Named argument lists:
     namedarguments, in a named argument list, and its type arguments
     must be inferable as defined below.

   If a static expression 'T.m' for a generic type 'T' with no explicit
type argument list occurs as the argument to a parameter 'p' of type
'Return(*Arg)' in a direct or indirect invocation expression, then the
type arguments of 'T' are inferred according to the rules defined in
*note Type argument inference: typeargumentinference. as if 'Arg' were
the type of a positional argument list, and '[T]' were the type of a
parameter list, unless the invocation is a direct invocation expression,
and the invoked function or class is generic, and 'Arg' involves type
parameters of the invoked function or class.


File: ceylon-spec.info,  Node: staticvaluereferences,  Next: staticcallablereferences,  Prev: staticexpressions,  Up: compoundexpressions

6.5.7 Static value references
-----------------------------

A _static value reference_ is a static expression that references an
attribute declaration or member class value constructor declaration.

     List<Anything>.size
   The type of a static value reference expression is:

   * 'X(T)' for an attribute whose realization is of	type 'X', and with
     qualifying type 'T',	or

   * 'T.X(T)' for a member class value constructor whose	realization is
     of type 'T.X', and with qualifying type	'T.X'.

   A value or value constructor declaration is never generic, so a
static value reference never ends in a type argument list.


File: ceylon-spec.info,  Node: staticcallablereferences,  Prev: staticvaluereferences,  Up: compoundexpressions

6.5.8 Static callable references
--------------------------------

A _static callable reference_ is a static expression that references
something--a method or member class, or a callable constructor of a
member class--that can be _invoked_ or _instantiated_.

     List<String>.filter

     Iterable<Integer>.map<String>
   The type of a static callable reference expression is:

   * 'R(*A)(T)' for a method, member class, or member class constructor
     whose realization has callable type 'R(*A)', and with qualifying
     type 'T', or

   * 'T.X(*A)(T)' for a member class constructor whose realization has
     callable type 'T.X(*A)', and with qualifying type 'T.X'.

   If a callable reference expression refers to a generic declaration,
it must end in an explicit type argument list.


File: ceylon-spec.info,  Node: invocationexpressions,  Next: miscexpressions,  Prev: compoundexpressions,  Up: expressions

6.6 Invocation expressions
==========================

* Menu:


* directinvocations:: Direct invocations
* defaultarguments:: Default arguments
* tupletypeofarglist:: The type of a list of arguments
* listedarguments:: Listed arguments
* spreadarguments:: Spread arguments
* comprehensions:: Comprehensions
* positionalarguments:: Positional argument lists
* namedarguments:: Named argument lists
* anonymousarguments:: Anonymous arguments
* specifiedarguments:: Specified arguments
* inlinedeclarationarguments:: Inline declaration arguments
* enumeration:: Iterable and tuple enumeration
* dynamicenumerations:: Dynamic enumerations

A callable expression--any expression of type 'Callable'--is
_invokable_.  An _invocation_ consists of an _invoked expression_,
together with an argument list and, optionally, an explicit type
argument list.

Invocation: Primary Arguments
   The invoked expression must be of type 'R(*P)' for some types 'R' and
'P'.  Then the type of the invocation expression is simply 'R'.

   If the invoked expression has no type, and occurs within a 'dynamic'
block, then the whole invocation expression has no type, and the
argument list is not type-checked at compile time, unless it is a direct
invocation expression.

   An invocation expression must specify arguments for parameters of the
callable object, either as a positional argument list, or as a named
argument list.

Arguments: PositionalArguments | NamedArguments
   Every argument list has a type, as specified below in *note
Positional argument lists: positionalarguments. and *note Named argument
lists: namedarguments.  If an invocation is formed from a callable
expression of type exactly 'R(*P)' and an argument list of type 'A',
then 'A' must be a subtype of 'P'.


File: ceylon-spec.info,  Node: directinvocations,  Next: defaultarguments,  Up: invocationexpressions

6.6.1 Direct invocations
------------------------

Any invocation expression where the invoked expression is a callable
reference expression is called a _direct invocation expression_ of the
function, class, or callable constructor to which the callable reference
refers.

     TODO: Should we consider 'x{y=1;}{z=2;}' a legal direct invocation
     if 'x' has multiple parameter lists?

   In a direct invocation expression:

   * the compiler has one item of additional information about the
     schema of the method or class that is not reified by the 'Callable'
     interface: the names of the parameters of the function, class, or
     callable constructor, and therefore named arguments may be used,
     and

   * type argument inference is possible, as defined in *note Type
     argument inference: typeargumentinference, since the compiler has
     access to the type parameters and constraints of the function or
     class, or of the class to which the callable constructor belongs.

   If an invocation expression has a named argument list, it must be a
direct invocation.

   The type of a direct invocation expression is the return type of the
realization of the function, or the type of the realization of the
class, as defined in *note Realizations: realizations.

   If the function has no return type, and occurs within a 'dynamic'
block, then the whole direct invocation expression has no type.

   In a direct invocation expression of a function, class, or callable
constructor, the restriction above on the argument list type is
equivalent to the following requirements.  Given the parameter list of
the realization of the function, class, or callable constructor, and the
arguments of the direct invocation:

   * for each required parameter, an argument must be given,

   * for each defaulted parameter, an argument may optionally be given,

   * if the parameter list has a variadic parameter of type 'T+', one or
     more arguments must be given,

   * if the parameter list has a variadic parameter of type 'T*', one or
     more arguments may optionally be given,

   * no additional arguments may be given,

   * for a required or defaulted parameter of type 'T', the type of the
     corresponding argument expression must be assignable to 'T', and

   * for a variadic parameter of type 'T*' or 'T+', the type of every
     corresponding argument expression must be assignable to 'T'.

   Furthermore, if type argument are inferred, then the inferred type
arguments must conform, as defined by *note Type arguments and type
constraints: typeargumentsandconstraints, to the type parameter list of
the realization of the function or class, or class to which the callable
constructor belongs.

   If an argument expression has no type, or if its parameter has no
type, and the invocation occurs within a 'dynamic' block, then the
argument is not type-checked at compile time.

   An invocation expression that does not occur within any 'dynamic'
block may not assign an argument to a value parameter with no type.


File: ceylon-spec.info,  Node: defaultarguments,  Next: tupletypeofarglist,  Prev: directinvocations,  Up: invocationexpressions

6.6.2 Default arguments
-----------------------

When no argument is assigned to a defaulted parameter by the caller, the
default argument defined by the parameter declaration of the
realization, as defined by *note Type arguments and type constraints:
typeargumentsandconstraints, of the function, class, or callable
constructor is used.  The default argument expression is evaluated every
time the method is invoked with no argument specified for the defaulted
parameter.

   This class:

     shared class Counter(Integer initialCount=0) { ... }
   May be instantiated using any of the following invocations:

     Counter()

     Counter(1)

     Counter {}

     Counter { initialCount=10; }


File: ceylon-spec.info,  Node: tupletypeofarglist,  Next: listedarguments,  Prev: defaultarguments,  Up: invocationexpressions

6.6.3 The type of a list of arguments
-------------------------------------

A list of arguments may be formed from:

   * any number of _listed arguments_, optionally followed by either

   * a _spread argument_, or

   * a _comprehension_.

ArgumentList: ((ListedArgument ",")* (ListedArgument | SpreadArgument | Comprehension))?
   Every such list of arguments has a type, which captures the types of
the individual arguments in the list.  This type is always a subtype of
'Anything[]'.  The type of an empty list of arguments is '[]'.


File: ceylon-spec.info,  Node: listedarguments,  Next: spreadarguments,  Prev: tupletypeofarglist,  Up: invocationexpressions

6.6.4 Listed arguments
----------------------

A listed argument is an expression.

ListedArgument: Expression
   If a listed argument is an expression of type 'T', and a list of
arguments has type 'P' with principal instantiation 'Sequential<Y>',
then the type of a new argument list formed by prepending the expression
to the first parameter list is 'Tuple<T|Y,T,P>'.


File: ceylon-spec.info,  Node: spreadarguments,  Next: comprehensions,  Prev: listedarguments,  Up: invocationexpressions

6.6.5 Spread arguments
----------------------

A spread argument is an expression prefixed by the _spread operator_
'*'.

SpreadArgument: "*" ValueExpression
   The spread operator is parsed with a precedence just lower than the
multiplication operator '*' and just higher than the set union and
complement operators '|' and '~', and is not associative.

     Note: this restriction means that the symbol '*' always has the
     same precedence, wherever it occurs in the language.

   The expression type 'T' must have the principal instantiation '{X*}'
for some type 'X'. We form the _sequential type of a spread argument_ as
follows:

   * if the expression type 'T' is an invariant subtype of 'X[]', for
     some type 'X' then the sequential type of the spread argument is
     'T', or, if not,

   * if the expression type 'T' is an invariant subtype of '{X+}', for
     some type 'X' then the sequential type of the spread argument is
     '[X+]', or, otherwise,

   * the expression type 'T' is an invariant subtype of '{X*}', for some
     type 'X' and the sequential type of the spread argument is 'X[]'.

   When a spread argument with an expression type not assignable to
'Anything[]' is evaluated, the elements of the iterable automatically
are packaged into a sequence.

     Note: the spread "operator" is not truly an operator in the sense
     of *note Operators: operators, and so a spread argument is not an
     expresson.  An expression, when evaluated, produces a single value.
     The spread operator produces multiple values.  It is therefore more
     correct to view the spread operator as simply part of the syntax of
     an argument list.

   The type of a list of arguments containing only a spread argument of
sequential type 'S' is simply 'S'.


File: ceylon-spec.info,  Node: comprehensions,  Next: positionalarguments,  Prev: spreadarguments,  Up: invocationexpressions

6.6.6 Comprehensions
--------------------

A _comprehension_ accepts one or more streams of values and produces a
new stream of values.  Any instance of 'Iterable' is considered a stream
of values.  The comprehension has two or more _clauses_:

   * A 'for' clause specifies a source stream and an iterator pattern,
     as defined in *note for/else: forelse, representing the values
     produced by the stream.

   * An 'if' clause specifies a condition list, as defined in *note
     Conditions: controlstructureconditions, used to filter the values
     produced by the source stream or streams.

   * An expression clause produces the values of the resulting stream.

   Every comprehension begins with a 'for' or 'if' clause, and ends with
an expression clause.  There may be any number of intervening 'for' or
'if' clauses.  Each clause in the comprehension is considered a child of
the clause that immediately precedes it.

Comprehension: ForComprehensionClause | IfComprehensionClause

ForComprehensionClause: "for" ForIterator ComprehensionClause

IfComprehensionClause: "if" ConditionList ComprehensionClause

ComprehensionClause: ForComprehensionClause | IfComprehensionClause | Expression
   An expression that occurs in a child clause may refer to iteration
variables and condition variables declared by parent clauses.  The types
of such variables are specified in *note Control structures and
assertions: controlstructures.

     Note: each child clause can be viewed as a body nested inside the
     parent clause.  The scoping rules for variables declared by
     comprehension clauses reflects this model.

   The type of a list of arguments containing only a comprehension is
'[T*]' where 'T' is the type of the expression which terminates the
comprehension, or '[T+]' if there are no 'if' clauses, and if every
'for' clause has an iterated expression of nonempty type.

   An comprehension occurring in an 'extends' clause may not contain a
reference to a variable value.

     Note: a comprehension, like a spread argument, is not considered an
     expression.  An expression, when evaluated, produces a single
     value.  A comprehension produces multiple values, like a spread
     argument, or like a series of listed arguments.  Therefore, a
     comprehension may only appear in an argument list or an enumeration
     expression.  This is, however, no limitation; we can simply wrap
     the comprehension in braces in order to get an expression of type
     '{T*}', or in brackets to get an expression of type '[T*]'.

     TODO: properly define how expressions with no type occurring in a
     'dynamic' block affect comprehensions.


File: ceylon-spec.info,  Node: positionalarguments,  Next: namedarguments,  Prev: comprehensions,  Up: invocationexpressions

6.6.7 Positional argument lists
-------------------------------

When invocation arguments are listed positionally, the argument list is
enclosed in parentheses.

PositionalArguments: "(" ArgumentList ")"
   The type of the positional argument list is the type of the list of
arguments it contains.


File: ceylon-spec.info,  Node: namedarguments,  Next: anonymousarguments,  Prev: positionalarguments,  Up: invocationexpressions

6.6.8 Named argument lists
--------------------------

When invocation arguments are listed by name, the argument list is
enclosed in braces.

NamedArguments: "{" NamedArgument* ArgumentList "}"
   Named arguments may be listed in a different order to the
corresponding parameters.

   Each named argument in a named argument list is either:

   * an _anonymous argument_--an expression, with no parameter name
     explicitly specified,

   * a _specified argument_--a specification statement where name of the
     value of function being specified is interpreted as the name of a
     parameter, or

   * an inline getter, function, or anonymous class declaration, whose
     name is interpreted as the name of a parameter.

NamedArgument: AnonymousArgument | SpecifiedArgument | InlineDeclarationArgument
   Additionally, a named argument list has an ordinary list of
arguments, which may be empty.  This argument list is interpreted as a
single argument to a parameter of type 'Iterable'.

     { initialCapacity=2; "hello", "world" }

     { initialCapacity=people.size; loadFactor=0.8; for (p in people) p.name->p }

     Note: in a future release of the language, we would like to be able
     to assign a local name to an anonymous argument or listed argument,
     allowing it to be referenced later in the argument list.  We might
     consider this a kind of "let" expression, perhaps.

   Given a parameter list, and a named argument list, we may attempt to
construct an _equivalent positional argument list_ as follows:

   * Taking each argument in the named argument list in turn, on the
     order they occur lexically:

        * if the argument is anonymous, assign it to the first
          unassigned parameter of the parameter list, or

        * if the argument is named, assign it to the parameter with that
          name in the parameter list.

     If for any argument, there is no unassigned parameter, no parameter
     with the given name, or the parameter with the given name has
     already been assigned an argument, construction of the positional
     argument list fails, and the invocation is not well-typed.

   * Next, if the parameter list has an unassigned parameter of type
     exactly 'Iterable<T,N>' for some types 'T' and 'N', then an
     iterable enumeration expression, as defined in *note Iterable and
     tuple enumeration: enumeration, is formed from the ordinary list of
     arguments, and assigned to that parameter.

     If there is no such parameter, and the ordinary list of arguments
     is nonempty, then construction of the positional argument list
     fails, and the invocation is not well-typed.

   * Finally, we assign each unassigned defaulted parameter its default
     argument.

   The resulting equivalent positional argument list is formed by
ordering the arguments according to the position of their corresponding
parameters in the parameter list, and then replacing any inline value,
function, or object declarations with a reference to the declaration.

   The type of a named argument list is the type of the equivalent
positional argument list.


File: ceylon-spec.info,  Node: anonymousarguments,  Next: specifiedarguments,  Prev: namedarguments,  Up: invocationexpressions

6.6.9 Anonymous arguments
-------------------------

An anonymous argument is just an expression followed by a semicolon.

AnonymousArgument: Expression ";"
   The type of the argument is the type of the expression.

     {
         Head { title="Hello"; };
         Body {
             Div { "Hello ``name``!" };
         };
     }


File: ceylon-spec.info,  Node: specifiedarguments,  Next: inlinedeclarationarguments,  Prev: anonymousarguments,  Up: invocationexpressions

6.6.10 Specified arguments
--------------------------

A specified argument is a value specification statement or lazy
specification statement, as defined in *note Specification statements:
specificationstatements, where the value reference or callable reference
is treated as the name of a parameter of the invoked function or class
instead of using the usual rules for resolving unqualified names.

SpecifiedArgument: Specification

   * If a specified argument is a value specification statement, its
     type is the type of the specified expression.

   * If a specified argument is a lazy specification statement with no
     parameter lists, its type is the type of the specified expression.

   * Otherwise, if it is a lazy specification statement with a parameter
     list, its type is the callable type formed from the type of the
     expression, interpreted as a function return type, and the types of
     its parameter lists, according to *note Callable type of a
     function: callabletypeoffunction.

     Note: there is an ambiguity here between assignment expressions and
     specified arguments.  This ambiguity is resolved in favor of
     interpreting the argument as a specified argument.  Therefore an
     anonymous argument in a named argument list may not be an
     assignment expression.

     {
         product = getProduct(id);
         quantity = 1;
     }

     {
         by(Value x, Value y) => x<=>y;
     }


File: ceylon-spec.info,  Node: inlinedeclarationarguments,  Next: enumeration,  Prev: specifiedarguments,  Up: invocationexpressions

6.6.11 Inline declaration arguments
-----------------------------------

An _inline declaration argument_ defines a getter, function, or
anonymous class, and assigns it to a parameter.

InlineDeclarationArgument: ValueArgument | FunctionArgument | ObjectArgument
   An inline getter argument is a streamlined value declaration, as
defined in *note Values: values.  The type of the argument is the
declared or inferred type of the value.

ValueArgument: ValueHeader (Block | (Specifier | LazySpecifier) ";")
   An inline function argument is a streamlined function declaration, as
defined in *note Functions: functions.  The type of the argument is the
callable type of the function, as defined by *note Callable type of a
function: callabletypeoffunction.

FunctionArgument: FunctionHeader (Block | LazySpecifier ";")
   An inline anonymous class argument is a streamlined anonymous class
declaration, as defined in *note Anonymous classes: anonymousclasses.
The type of the argument is the anonymous class type.

ObjectArgument: ObjectHeader ClassBody
   A named argument may not have type parameters or annotations.

     {
         description = "Total";
         value amount {
             variable Float total = 0.0;
             for (Item item in items) {
                 sum += item.amount;
             }
             return total;
         }
     }

     {
         label = "Say Hello";
         void onClick() {
             say("Hello!");
         }
     }

     {
         function by(Value x, Value y) => x<=>y;
     }

     {
         object iterator
                 satisfies Iterator<Order> {
             variable value done = false;
             shared actual Order|Finished next() {
                 if (done) {
                     return finished;
                 }
                 else {
                     done=true;
                     return order;
                 }
             }
         }
     }


File: ceylon-spec.info,  Node: enumeration,  Next: dynamicenumerations,  Prev: inlinedeclarationarguments,  Up: invocationexpressions

6.6.12 Iterable and tuple enumeration
-------------------------------------

An _enumeration expression_ is an abbreviation for tuple and iterable
object instantiation.  Iterable enumerations are delimited using braces.
Tuple enumerations are delimited by brackets.

Enumeration: Iterable | Tuple | DynamicValue

Iterable: "{" ArgumentList "}"

Tuple: "[" ArgumentList "]"
   The type of an iterable enumeration expression is:

   * 'Iterable<Nothing,Null>' if there are no argument expressions, or

   * 'Iterable<U,Nothing>' where 'U', the argument expression list is an
     invariant suptype of 'U[]'.

   The type of a tuple enumeration expression is the type of the list of
arguments it contains.

     {String+} = { "hello", "world" };

     [] none = [];

     [Float,Float] xy = [x, y];

     [Float,Float, String*] xy = [x, y, *labels];
   Every argument expression must have a type, even if the enumeration
expression occurs in a 'dynamic' block.


File: ceylon-spec.info,  Node: dynamicenumerations,  Prev: enumeration,  Up: invocationexpressions

6.6.13 Dynamic enumerations
---------------------------

A _dynamic enumeration expression_ creates a new object with no class by
enumerating its members, allowing interoperation with dynamically typed
native code.

DynamicValue: "dynamic" "[" NamedArgument* ArgumentList "]"
   A dynamic enumeration expression has no type.

   Any argument names may be specified in the named argument list.

   A dynamic enumeration expression must occur inside a 'dynamic' block.

     The semantics of this construct are platform-dependent and beyond
     the scope of this specification.


File: ceylon-spec.info,  Node: miscexpressions,  Next: operators,  Prev: invocationexpressions,  Up: expressions

6.7 Conditional expressions, let expressions, and anonymous class expressions
=============================================================================

* Menu:


* ifexpressions:: if/then/else expressions
* switchexpressions:: switch/case/else expressions
* letexpressions:: Let expressions
* inlineanonymousclassexpressions:: Inline anonymous class expressions

A _conditional expression_ resembles a control structure but is part of
the expression syntax, and evaluates to a value. A conditional
expression comes in one of two forms:

   * an 'if/then/else' expression resembles the 'if/else' conditional
     defined in *note if/else: ifelse, and

   * a 'switch/case/else' expression resembles the 'switch/case/else'
     conditional defined in *note switch/case/else: switchcaseelse.

ConditionalExpression: IfElseExpression | SwitchCaseElseExpression
   A _let expression_ allows inline definition of a reference within an
expression.

   An _inline class_ is an anonymous class defined within an expression.


File: ceylon-spec.info,  Node: ifexpressions,  Next: switchexpressions,  Up: miscexpressions

6.7.1 if/then/else expressions
------------------------------

An 'if/then/else' expression has a condition list, as defined in *note
Conditions: controlstructureconditions, a 'then' expression, and an
'else' expression.  The 'else' expression is not optional.

IfElseExpression: "if" ConditionList ThenExpression ElseExpression
   The type of an 'if/then/else' expression with 'then' expression of
type 'X' and 'else' or 'else if' expression of type 'Y' is 'X|Y'.

ThenExpression: "then" Expression

ElseExpression: "else" Expression
   The expression following 'then' or 'else' is parsed with precedence
just higher than the '||' operator, and just lower than the 'then' and
'else' operators, that is, between the layers 3 and 4 defined in *note
Operator precedence: operatorprecedence.

   Alternatively, the expression following 'then' or 'else' may be an
'if/then/else' expression or a let expression.

     Note: the expression following 'then' or 'else' may not be a
     'switch/case/else' expression, since that would introduce an
     ambiguity related to the optional 'else' clause of the
     'switch/case/else' expression.

     if (exists lang) then lang.name else "Ceylon"


File: ceylon-spec.info,  Node: switchexpressions,  Next: letexpressions,  Prev: ifexpressions,  Up: miscexpressions

6.7.2 switch/case/else expressions
----------------------------------

A 'switch/case/else' expression has a 'switch' expression or inline
variable, a list of 'case' expressions, and, optionally, an 'else'
expression.

SwitchCaseElseExpression: Switch CaseExpression+ ElseExpression
   The type of a 'switch/case/else' expression with 'case' expressions
of type 'X1', 'X2', ..., 'Xn' and 'else' expression of type 'Y' is
'X1|X2|...|Xn|Y'.

CaseExpression: "case" CaseCondition Expression
   The expression following 'case' or 'else' is parsed with precedence
just higher than the '||' operator, and just lower than the 'then' and
'else' operators, that is, between the layers 3 and 4 defined in *note
Operator precedence: operatorprecedence.

   Alternatively, the expression following 'then' or 'else' may be an
'if/then/else' expression or a let expression.

   Each 'case' expression includes a value case or type case, as defined
in *note Case conditions: caseconditions.  Just like in a
'switch/case/else' conditional statement:

   * all cases must be disjoint, and

   * if there is no 'else' expression, the cases must be exhaustive.

     switch (seq) case (null) "null" case (is []) "empty" else "nonempty"


File: ceylon-spec.info,  Node: letexpressions,  Next: inlineanonymousclassexpressions,  Prev: switchexpressions,  Up: miscexpressions

6.7.3 Let expressions
---------------------

A let expression comprises a pattern list, followed by an expression
involving the pattern variables that occur in the listed patterns.

LetExpression: "let" PatternList Expression
   The expression is parsed with precedence just higher than the '||'
operator, and just lower than the 'then' and 'else' operators, that is,
between the layers 3 and 4 defined in *note Operator precedence:
operatorprecedence.

   Alternatively, the expression may be an 'if/then/else' expression or
another let expression.

   A pattern list is enclosed in parentheses.

PatternList: "(" PatternListElement ("," PatternListElement)* ")"
   Each element of the pattern list is a pattern, as defined in *note
Patterns: patterns, followed by a specified expression.  The patterned
type is the type of the specified expression.

PatternListElement: Pattern Specifier
   The pattern variables that occur in the pattern list are considered
in scope in the expression that follows the pattern list.  Furthermore,
a specified expression in the pattern list may refer to a pattern
variable declared by an earlier element in the pattern list.

     let ([x,y] = loc, d = sqrt(x^2+y^2)) [x/d, y/d]


File: ceylon-spec.info,  Node: inlineanonymousclassexpressions,  Prev: letexpressions,  Up: miscexpressions

6.7.4 Inline anonymous class expressions
----------------------------------------

An inline anonymous class expression resembles an anonymous class
declaration as defined in *note Anonymous classes: anonymousclasses.
The expression defines the schema, supertypes, and implementation of a
class.  It does not specify a type name.  Instead, the type has a name
assigned internally by the compiler that is not available at compilation
time.

ObjectExpression: "object" ObjectInheritance ClassBody
   The class:

   * is implicitly 'final', and

   * may not declare 'default' members.

   The type of an inline anonymous class expression is the intersection
of the class type it extends with all interface types it satisfies.  The
type of the inline anonymous class itself is not accessible outside the
body of the inline anonymous class expression.

     object
             satisfies {Integer+} {
         iterator() => object
                 satisfies Iterator<Integer> {
             variable value current = 0;
             next() => current++;
         };
     }


File: ceylon-spec.info,  Node: operators,  Next: metamodelexpressions,  Prev: miscexpressions,  Up: expressions

6.8 Operators
=============

* Menu:


* operatorprecedence:: Operator precedence
* operatordefinition:: Operator definition
* basic:: Basic invocation and assignment operators
* equalitycomparison:: Equality and comparison operators
* logical:: Logical operators
* nullvalues:: Operators for handling null values
* listmap:: Correspondence, subrange, and stream operators
* creation:: Operators for creating objects
* conditionals:: Conditional operators
* arithmetic:: Arithmetic operators
* sets:: Set operators

Operators are syntactic shorthand for more complex expressions involving
invocation, evaluation, or instantiation.  There is no support for
user-defined _operator overloading_:

   * new operator symbols may not be defined outside of the operators
     specified below, and

   * the definition of the operators specified below may not be changed
     or overloaded.

   However, many of the operators below are defined in terms of
'default' or 'formal' methods or attributes.  So, within well-defined
limits a concrete implementation may customize the behavior of an
operator.  This approach is called _operator polymorphism_.

   Some examples:

     Float z = x * y + 1.0;

     even = n % 2 == 0;

     ++count;

     Integer j = i++;

     if ( x > 100 || x < 0 ) { ... }

     User user = users[userId] else guest;

     List<Item> firstPage = results[0..20];

     for (n in 0:length) { ... }

     if (char in 'A'..'Z') { ... }

     String[] names = people*.name;

     this.total += item.price * item.quantity;

     Float vol = length^3;

     Vector scaled = scale ** vector;

     map.contains(person.name->person);

     if (!document.internal || user is Employee) { ... }


File: ceylon-spec.info,  Node: operatorprecedence,  Next: operatordefinition,  Up: operators

6.8.1 Operator precedence
-------------------------

There are 19 distinct operator precedence levels, but these levels are
arranged into layers in order to make them easier to predict.

   * Operators in layer 1 produce, transform, and combine values.

   * Operators in layer 2 compare or predicate values, producing a
     'Boolean' result.

   * Operators in layer 3 are logical operators that operate upon
     'Boolean' arguments to produce a 'Boolean' value.

   * Operators in layer 4 perform assignment and conditional evaluation.

   Within each layer, postfix operators have a higher precedence than
prefix operators, and prefix operators have a higher precedence than
binary operators.

   There is a single exception to this principle: the binary
exponentiation operator '^' has a higher precedence than the prefix
operators '+' and '-'.  The reason for this is that the following
expressions should be equivalent:

     -x^2       //means -(x^2)

     0 - x^2    //means 0 - (x^2)
   This table defines the relative precedence of the various operators,
from highest to lowest, along with associativity rules:

Operations                                             Operators                                                           Type                   Associativity
------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Layer 1_
Member invocation and selection, index, subrange:      '.', '*.', '?.', '()', '{}', '[]', '[:]', '[..]', '[...]'           Binary / N-ary         Left
Postfix increment and decrement:                       '++', '--'                                                          Unary postfix          Left
Prefix increment and decrement:                        '++', '--'                                                          Unary prefix           Right
Exponentiation:                                        '^'                                                                 Binary                 Right
Negation:                                              '+', '-'                                                            Unary prefix           Right
Set intersection:                                      '&'                                                                 Binary                 Left
Set union and complement:                              '|', '~'                                                            Binary                 Left
Multiplication, division, remainder:                   '*', '/', '%'                                                       Binary                 Left
Scale:                                                 '**'                                                                Binary                 Right
Addition, subtraction:                                 '+', '-'                                                            Binary                 Left
Range and entry construction:                          '..', ':', '->'                                                     Binary                 None
_Layer 2_
Existence, emptiness:                                  'exists', 'nonempty'                                                Unary postfix          None
Comparison, containment, assignability, inheritance:   '<=>', '<', '>', '<=', '>=', 'in', 'is', 'of'                       Binary (and ternary)   None
Equality, identity:                                    '==', '!=', '==='                                                   Binary                 None
_Layer 3_
Logical not:                                           '!'                                                                 Unary prefix           Right
Logical and:                                           '&&'                                                                Binary                 Left
Logical or:                                            '||'                                                                Binary                 Left
_Layer 4_
Conditionals:                                          'then', 'else'                                                      Binary                 Left
Assignment:                                            '=', '+=', '-=', '*=', '/=', '%=', '&=', '|=', '~=', '&&=', '||='   Binary                 Right
   It's important to be aware that in Ceylon, compared to other C-like
languages, the logical not operator '!' has a very low precedence.  The
following expressions are equivalent:

     !x.y == 0.0  //means !(x.y == 0.0)

     x.y != 0.0


File: ceylon-spec.info,  Node: operatordefinition,  Next: basic,  Prev: operatorprecedence,  Up: operators

6.8.2 Operator definition
-------------------------

The following tables define the semantics of the Ceylon operators. There
are six basic operators which do not have a definition in terms of other
operators or invocations:

   * the _member selection_ operator '.' separates the receiver
     expression and member name in a member expression, as defined above
     in *note Member expressions: memberexpressions,

   * the _argument specification_ operators '()' and '{}' specify the
     argument list of an invocation, as defined in *note Invocation
     expressions: invocationexpressions. and *note Invocation:
     invocation,

   * the _assignment_ operator '=' assigns a new value to a variable and
     returns the new value after assignment, as defined in *note
     Assignment: assignment,

   * the _identity_ operator '===' evaluates to 'true' if its argument
     expressions evaluate to references to the same object, as defined
     in *note Object instances: (identity)objectinstancesidentity, or to
     'false' otherwise,

   * the _assignability_ operator 'is' evaluates to 'true' if its
     argument expression evaluates to an instance of a class, as defined
     in *note Object instances: (identity)objectinstancesidentity, that
     is a subtype of the specified type, or to 'false' otherwise, and

   * the _coverage_ operator 'of' narrows or widens the type of an
     expression to any specified type that covers the expression type,
     as defined by *note Coverage: coverage, without affecting the value
     of the expression.

   All other operators are defined below in terms of other operators
and/or invocations.


File: ceylon-spec.info,  Node: basic,  Next: equalitycomparison,  Prev: operatordefinition,  Up: operators

6.8.3 Basic invocation and assignment operators
-----------------------------------------------

These operators support method invocation and attribute evaluation and
assignment.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Invocation_
'lhs.member'         member                                                                                'X'                                                                                             a member of 'X', of type 'T'                                      'T'
'lhs(x,y,z)' or      invoke                                                                                'T(*P)'                                                                                         argument list of type 'P'                                         'T'
'lhs{a=x;b=y;}'
_Assignment_
'lhs = rhs'          assign                   ''                                                           variable of type 'X'                                                                            'X'                                                               'X'
_Coverage_
'lhs of Type'        of                       ''                                                           'X'                                                                                             a literal type 'T' that covers 'X'                                'T'


File: ceylon-spec.info,  Node: equalitycomparison,  Next: logical,  Prev: basic,  Up: operators

6.8.4 Equality and comparison operators
---------------------------------------

These operators compare values for equality, order, magnitude, or
membership, producing boolean values.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Equality and
identity_
'lhs === rhs'        identical                ''                                                           'X given X satisfies Identifiable'                                                              'Y given Y satisfies Identifiable' where 'X&Y' is not 'Nothing'   'Boolean'
'lhs == rhs'         equal                    'lhs.equals(rhs)'                                            'Object'                                                                                        'Object'                                                          'Boolean'
'lhs != rhs'         not equal                '!lhs.equals(rhs)'                                           'Object'                                                                                        'Object'                                                          'Boolean'
_Comparison_
'lhs <=> rhs'        compare                  'lhs.compare(rhs)'                                           'Comparable <T>'                                                                                'T'                                                               'Comparison'
'lhs < rhs'          smaller                  'lhs.compare(rhs)==smaller'                                  'Comparable <T>'                                                                                'T'                                                               'Boolean'
'lhs > rhs'          larger                   'lhs.compare(rhs)==larger'                                   'Comparable <T>'                                                                                'T'                                                               'Boolean'
'lhs <= rhs'         small as                 'lhs.compare(rhs)!=larger'                                   'Comparable <T>'                                                                                'T'                                                               'Boolean'
'lhs >= rhs'         large as                 'lhs.compare(rhs)!=smaller'                                  'Comparable <T>'                                                                                'T'                                                               'Boolean'
_Containment_
'lhs in rhs'         in                       'let (x=lhs) rhs.contains(x)'                                'Object'                                                                                        'Category'                                                        'Boolean'
_Assignability_
'rhs is Type'        is                                                                                    any type which is not a subtype of 'T', whose intersection with 'T' is not 'Nothing'            any literal type 'T'                                              'Boolean'

     TODO: Should we have allow the operators '<=' and '>=' to handle
     partial orders?  A particular usecase is 'Set' comparison.

   A _bounded comparison_ is an abbreviation for two binary comparisons:

   * 'l<x<u' means 'let (t=x) l<t && t<u',

   * 'l<=x<u' means 'let (t=x) l<=t && t<u',

   * 'l<x<=u' means 'let (t=x) l<t && t<=u', and

   * 'l<=x<=u' means 'let (t=x) l<=t && t<=u'

   for expressions 'l', 'u', and 'x'.

   These abbreviations have the same precedence as the binary '<' and
'<=' operators, and, like the binary forms, are not associative.


File: ceylon-spec.info,  Node: logical,  Next: nullvalues,  Prev: equalitycomparison,  Up: operators

6.8.5 Logical operators
-----------------------

These are the usual logical operations for boolean values.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Logical
operators_
'!rhs'               not                      'if (rhs) then false else true'                                                                                                                              'Boolean'                                                         'Boolean'
'lhs || rhs'         conditional or           'if (lhs) then true else rhs'                                'Boolean'                                                                                       'Boolean'                                                         'Boolean'
'lhs && rhs'         conditional and          'if (lhs) then rhs else false'                               'Boolean'                                                                                       'Boolean'                                                         'Boolean'
_Logical
assignment_
'lhs ||= rhs'        conditional or           'if (lhs) then true else lhs=rhs'                            variable of type 'Boolean'                                                                      'Boolean'                                                         'Boolean'
'lhs &&= rhs'        conditional and          'if (lhs) then lhs=rhs else false'                           variable of type 'Boolean'                                                                      'Boolean'                                                         'Boolean'


File: ceylon-spec.info,  Node: nullvalues,  Next: listmap,  Prev: logical,  Up: operators

6.8.6 Operators for handling null values
----------------------------------------

These operators make it easy to work with optional expressions.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Existence_
'lhs exists'         exists                   'if (exists lhs) then true else false'                       any type whose intersections with 'Object' and 'Null' are not 'Nothing'                                                                                           'Boolean'
'lhs nonempty'       nonempty                 'if (nonempty lhs) then true else false'                     any subtype of 'Anything[]?' whose intersections with '[]' and '[Nothing+]' are not 'Nothing'                                                                     'Boolean'
_Nullsafe
invocation_
'lhs?.member'        nullsafe attribute       'if (exists lhs) then lhs.member else null'                  'X?'                                                                                            an attribute of type 'T' of 'X'                                   'T?'
'lhs?.member'        nullsafe method                                                                       'X?'                                                                                            a method of callable type 'T(*P)' of 'X' with exactly one         'T?(*P)'
                                                                                                                                                                                                           parameter list


File: ceylon-spec.info,  Node: listmap,  Next: creation,  Prev: nullvalues,  Up: operators

6.8.7 Correspondence, subrange, and stream operators
----------------------------------------------------

These operators provide a simplified syntax for accessing values of a
'Correspondence', for obtaining subranges of 'Ranged' objects, and for
spreading member access over a stream.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Keyed item
access_
'lhs[index]'         lookup                   'lhs.get(index)'                                             'Correspondence<X,Y>'                                                                           'X'                                                               'Y?'
_Subranges_
'lhs[from:length]'   measured subrange        'lhs.measure(from,length)'                                   'Ranged<X,Y,Z>'                                                                                 'X', 'Integer'                                                    'Z'
'lhs[from..to]'      spanned subrange         'lhs.span(from,to)'                                          'Ranged<X,Y,Z>'                                                                                 'X', 'X'                                                          'Z'
'lhs[from...]'       upper spanned subrange   'lhs.spanFrom(from)'                                         'Ranged<X,Y,Z>'                                                                                 'X'                                                               'Z'
'lhs[...to]'         lower spanned subrange   'lhs.spanTo(to)'                                             'Ranged<X,Y,Z>'                                                                                 'X'                                                               'Z'
_Spread
invocation_
'lhs*.attribute'     spread attribute         '[*lhs.map(X.attribute)]'                                    'Iterable<X,N>'                                                                                 attribute of 'X' of type 'T'                                      '[T*]' or '[T+]'
'lhs*.method'        spread method            'compose((Iterable<T,N> ts)=>[*ts], lhs.spread(X.method))'   'Iterable<X,N>'                                                                                 method of 'X' of callable type 'T(*P)' with exactly one           '[T*](*P)' or '[T+](*P)'
                                                                                                                                                                                                           parameter list
_Spread
multiplication_
'lhs ** rhs'         scale                    'rhs.scale(lhs)'                                             'X'                                                                                             'Scalable<X,Y>'                                                   'Y'
   There are two special cases related to sequences.  A type 'X' is a
_sequence type_ if 'X' is a subtype of 'Sequential<Anything>'.

   For any sequence type 'X' with principal instantiation '[E*]' and
integer 'n', we can form the _nth tail type, Xn, of X_ as follows:

   * for every 'i<=0', 'Xi' is 'X',

   * for every 'i>0', if 'Xi' has the principal instantiation
     'Tuple<Ui,Fi,Ti>' then 'X(i+1)' is 'Ti', or, if 'Xi' has principal
     instantiation '[Fi*]' then 'X(i+1)' is '[Fi*]', or, otherwise, if
     'Xi' is '[]', then 'X(i+1)' is also '[]'.

   For any sequence type 'X' and integer 'n', we can form the _nth
element type, En, of X_ as follows:

   * if 'n>=0' and 'Xn' has the principal instantiation '[Fn+]' then
     'En' is 'Fn', or,

   * otherwise, 'Xn' has the principal instantiation '[Fn*]' and 'En' is
     'Fn?'.

   Then the two special cases are:

   * The type of an expression of form 'x[i]' where 'x' is of the
     sequence type 'X' and 'n' is an integer literal is 'En'.

   * The type of an expression of form 'x[i...]' where 'x' is of the
     sequence type 'X' and 'n' is an integer literal is 'Xn' if 'Xn' is
     an instantiation of 'Tuple', '[Fn+]' if 'Xn' has the principal
     instantiation '[Fn+]', or '[Fn*]' if 'Xn' has the principal
     instantiation '[Fn*]'.


File: ceylon-spec.info,  Node: creation,  Next: conditionals,  Prev: listmap,  Up: operators

6.8.8 Operators for creating objects
------------------------------------

These operators simplify the syntax for instantiating certain commonly
used built-in types.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Range and entry
constructors_
'lhs..rhs'           spanned range            'span(lhs, rhs)'                                             'T given T satisfies Enumerable<T>'                                                             'T'                                                               'Range<T>'
'lhs:rhs'            measured range           'measure(lhs,rhs)'                                           'T given T satisfies Enumerable<T>'                                                             'Integer'                                                         'Range<T>|[]'
'lhs->rhs'           entry                    'Entry(lhs, rhs)'                                            'U given U satisfies Object'                                                                    'V'                                                               'Entry<U,V>'


File: ceylon-spec.info,  Node: conditionals,  Next: arithmetic,  Prev: creation,  Up: operators

6.8.9 Conditional operators
---------------------------

Two special operators allow emulation of the famous ternary operator of
C-like languages.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Conditionals_
'lhs then rhs'       then                     'if (lhs) then rhs else null'                                'Boolean'                                                                                       'T given T satisfies Object'                                      'T?'
'lhs else rhs'       else                     'if (exists lhs) then lhs else rhs'                          'U' such that 'null is U'                                                                       'V'                                                               'U&Object|V'


File: ceylon-spec.info,  Node: arithmetic,  Next: sets,  Prev: conditionals,  Up: operators

6.8.10 Arithmetic operators
---------------------------

These are the usual mathematical operations for all kinds of numeric
values.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Increment,
decrement_
'++rhs'              successor                'rhs=rhs.successor'                                                                                                                                          variable of type 'Ordinal<T>'                                     'T'
'--rhs'              predecessor              'rhs=rhs.predecessor'                                                                                                                                        variable of type 'Ordinal<T>'                                     'T'
'lhs++'              increment                                                                             variable of type 'Ordinal<T>'                                                                                                                                     'T'
'lhs--'              decrement                                                                             variable of type 'Ordinal<T>'                                                                                                                                     'T'
_Numeric
operators_
'+rhs'                                        'rhs'                                                                                                                                                        'Invertible <I>'                                                  'I'
'-rhs'               negation                 'rhs.negated'                                                                                                                                                'Invertible <I>'                                                  'I'
'lhs + rhs'          sum                      'lhs.plus(rhs)'                                              'Summable<X>'                                                                                   'X'                                                               'X'
'lhs - rhs'          difference               'lhs.minus(rhs)'                                             'Invertible <X>'                                                                                'X'                                                               'X'
'lhs * rhs'          product                  'lhs.times(rhs)'                                             'Numeric<X>'                                                                                    'X'                                                               'X'
'lhs / rhs'          quotient                 'lhs.divided(rhs)'                                           'Numeric<X>'                                                                                    'X'                                                               'X'
'lhs % rhs'          remainder                'lhs.remainder(rhs)'                                         'Integral<X>'                                                                                   'X'                                                               'X'
'lhs ^ rhs'          power                    'lhs.power(rhs)'                                             'Exponentiable <X,Y>'                                                                           'Y'                                                               'X'
_Numeric
assignment_
'lhs += rhs'         add                      'lhs=lhs.plus(rhs)'                                          variable of type 'Summable<N>'                                                                  'N'                                                               'N'
'lhs -= rhs'         subtract                 'lhs=lhs.minus(rhs)'                                         variable of type 'Invertible <N>'                                                               'N'                                                               'N'
'lhs *= rhs'         multiply                 'lhs=lhs.times(rhs)'                                         variable of type 'Numeric<N>'                                                                   'N'                                                               'N'
'lhs /= rhs'         divide                   'lhs=lhs.divided(rhs)'                                       variable of type 'Numeric<N>'                                                                   'N'                                                               'N'
'lhs %= rhs'         remainder                'lhs=lhs.remainder(rhs)'                                     variable of type 'Integral<N>'                                                                  'N'                                                               'N'
   The postfix increment and decrement operators are defined as follows:

   * 'x++' means the value of 'result' after executing 'X result=x;
     ++x;', and

   * 'x--' means the value of 'result' after executing 'X result=x;
     --x;'.

   Arithmetic operators automatically widen from 'Integer' to 'Float'
when necessary.  If one operand expression is of static type 'Integer',
and the other is of type 'Float', the operand of type 'Integer' is
widened to a 'Float' in order to make the operator expression
well-typed.  Widening is performed by evaluating the attribute 'float'
defined by 'Integer'.

     Note: this is the only circumstance in the language where implicit
     type conversion occurs.  In fact, it is more correct to view this
     behavior as an instance of operator overloading than as an implicit
     type conversion.  Implicit widening does not occur when an
     expression of type 'Integer' is merely assigned to the type
     'Float', since such behavior would result in ambiguities when
     generics come into play.


File: ceylon-spec.info,  Node: sets,  Prev: arithmetic,  Up: operators

6.8.11 Set operators
--------------------

These operators provide traditional mathematical operations for sets.

Example              Name                     Definition                                                   LHS type                                                                                        RHS type                                                          Return type
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_Set operators_
'lhs | rhs'          union                    'lhs.union(rhs)'                                             'Set<X>'                                                                                        'Set<Y>'                                                          'Set<X|Y>'
'lhs & rhs'          intersection             'lhs.intersection(rhs)'                                      'Set<X>'                                                                                        'Set<Y>'                                                          'Set<X&Y>'
'lhs ~ rhs'          complement               'lhs.complement(rhs)'                                        'Set<X>'                                                                                        'Set<Object>'                                                     'Set<X>'
_Set assignment_
'lhs |= rhs'         union                    'lhs=lhs|rhs'                                                variable of type 'Set<X>'                                                                       'Set<X>'                                                          'Set<X>'
'lhs &= rhs'         intersection             'lhs=lhs&rhs'                                                variable of type 'Set<X>'                                                                       'Set<Object>'                                                     'Set<X>'
'lhs ~= rhs'         complement               'lhs=lhs~rhs'                                                variable of type 'Set<X>'                                                                       'Set<Object>'                                                     'Set<X>'


File: ceylon-spec.info,  Node: metamodelexpressions,  Next: referenceexpressions,  Prev: operators,  Up: expressions

6.9 Metamodel expressions
=========================

* Menu:


* typeofametamodelexpression:: Type of a metamodel expression

A _metamodel expression_ is a reference to a type, a class, a function,
a value, or a constructor.  It evaluates to a metamodel object whose
static type captures, respectively:

   * the type itself,

   * the callable type of the class,

   * the callable type of the function,

   * the type of the value,

   * the type of the value constructor, or

   * the callable type of the callable constructor.

Meta: TypeMeta | BaseMeta | MemberMeta | ConstructorMeta
   A _type metamodel expression_ is a type, as defined by *note Types:
type, surrounded by backticks.

TypeMeta: "`" Type "`"
   The type may or may not be a reference to a class or interface.

     Class<Person,[Name]> personClass = `Person`;

     Interface<List<String>> stringListInterface = `List<String>`;

     UnionType<Integer|Float> numberType = `Number`;

     Type<Element> elementType = `Element`;
   A _base metamodel expression_ is a member name, with an optional list
of type arguments, surrounded by backticks.

BaseMeta: "`" PackageQualifier? MemberName TypeArguments? "`"
   A base metamodel expression is a reference to a value or function.
The referenced declaration is determined according to *note Unqualified
reference resolution: unqualifiedreferenceresolution.

   A _member metamodel expression_ is a qualifier, followed by a member
name, with an optional list of type arguments, surrounded by backticks.

MemberMeta: "`" PrimaryType "." MemberName TypeArguments? "`"
   The member metamodel expression is qualified by a type, as defined by
*note Types: type.

   A member metamodel expression is a reference to an attribute or
method of the type identified by the qualifier.  The member is resolved
as a member of the type according to *note Qualified reference
resolution: qualifiedreferenceresolution.

     Function<Float,[{Float+}]> sumFunction = `sum<Float>`;

     Attribute<Person,String> personNameAttribute = `Person.name`;

     Method<Person,Anything,[String]> personSayMethod = `Person.say`;

     Attribute<\Isystem,Integer> systemMillis = `\Isystem.milliseconds`;
   A _constructor metamodel expression_ is a qualifier, followed by a
constructor name, with an optional list of type arguments, surrounded by
backticks.

ConstructorMeta: "`" PrimaryType "." ()MemberName | TypeName) TypeArguments? "`"
   The constructor metamodel expression qualifier is a type that is an
instantiation of a class.

   A constructor metamodel expression is a reference to a constructor or
of the class identified by the qualifier.  The constructor is resolved
as a member of the class according to *note Qualified reference
resolution: qualifiedreferenceresolution.

   Type argument inference is impossible in a metamodel expression, so
type arguments must be explicitly provided for every generic
declaration.


File: ceylon-spec.info,  Node: typeofametamodelexpression,  Up: metamodelexpressions

6.9.1 Type of a metamodel expression
------------------------------------

The type of a metamodel expression depends upon the kind of declaration
referenced:

   * for a toplevel value of type 'R', the type is 'Value<R>',

   * for a toplevel function of callable type 'R(*P)', the type is
     'Function<R,P>',

   * for a toplevel class of callable type 'R(*P)', the type is
     'Class<R,P>',

   * for a callable constructor of a toplevel class of callable type
     'R(*P)', the type is 'CallableConstructor<R,P>',

   * for a value constructor of a toplevel class of type 'R', the type
     is 'ValueConstructor<R>',

   * for a class nested in a block of callable type 'R(*P)', the type is
     'Class<R,Nothing>', and

   * for a toplevel interface or interface nested in a block of type
     'R', the type is 'Interface<R>'.

     Note: members of anonymous classes are treated as toplevels here.

   Furthermore, given a member of a type 'T':

   * for an attribute of type 'R', the type is 'Attribute<T,R>',

   * for a method of callable type 'R(*P)', the type is 'Method<T,R,P>',

   * for a member class of callable type 'R(*P)', the type is
     'MemberClass<T,R,P>', and

   * for a callable constructor of a member class of callable type
     'R(*P)', the type is 'MemberClassCallableConstructor<T,R,P>', and

   * for a value constructor of a member class of type 'R', the type is
     'MemberClassValueConstructor<T,R>', and

   * for a value of a member class of type 'R', the type is
     'Attribute<T,R>', and

   * for a nested interface of type 'R', the type is
     'MemberInterface<T,R>'.

   Finally:

   * for a union type 'T', the type is 'UnionType<T>',

   * for an intersection type 'T', the type is 'IntersectionType<T>',

   * for the type 'Nothing', the type is 'Type<Nothing>', and

   * for a type parameter 'T', the type is 'Type<T>'.

   If a type alias occurs inside a typed metamodel expression, it is
replaced by its definition, after substituting type arguments, before
determining the type of the metamodel expression.


File: ceylon-spec.info,  Node: referenceexpressions,  Prev: metamodelexpressions,  Up: expressions

6.10 Reference expressions
==========================

* Menu:


* declarationreferences:: Declaration references
* packageandmodulereferences:: Package and module references
* typeofareferenceexpression:: Type of a reference expression

A _reference expression_ is a reference to a program element and
evaluates to a detyped metamodel of the program element.  Reference
expressions are used primarily in annotations, especially the
documentation annotations listed in *note Documentation: documentation.
A reference expression may refer to:

   * a class, interface, type alias, or type parameter,

   * a function or value,

   * a constructor, or

   * a package or module.

Dec: TypeDec | MemberDec | ConstructorDec | PackageDec | ModuleDec


File: ceylon-spec.info,  Node: declarationreferences,  Next: packageandmodulereferences,  Up: referenceexpressions

6.10.1 Declaration references
-----------------------------

Declaration reference expressions may be qualified by a _member
declaration qualifier_, a sequence of identifiers identifying a class or
interface declaration or an anonymous class declaration:

MemberDecQualifier: ( (TypeName | MemberName) "." )+
   Each identifier in the member declaration qualifier is the name of a
class, interface, or anonymous class.

   A _class reference expression_, _interface reference expression_,
_alias reference expression_, or _type parameter reference expression_
is an optional member declaration qualifier, followed by the name of a
class or anonymous class, interface, alias, or type parameter, with the
keyword 'class', 'interface', 'alias', or 'given', respectively,
surrounded by backticks.

TypeKeyword: "class" | "interface" | "alias" | "given"

TypeDec: "`" TypeKeyword ( PackageQualifier? MemberDecQualifier? (TypeName | MemberName) )? "`"
   For a class or interface reference expression, the name of the class
or interface is optional.  In this case, the class or interface
reference is to the immediately containing class or interface, if any,
as defined in *note Self references: selfreferences. For alias or type
parameter reference expressions, the name of the alias or type parameter
is required.

     ClassDeclaration thisClass = `class`;

     ClassDeclaration personClass = `class Person`;

     ClassDeclaration thisInterface = `interface`;

     InterfaceDeclaration stringListInterface = `interface List`;

     AliasDeclaration numberAlias = `alias Number`;

     TypeParameter elementTypeParameter = `given Element`;

     CallableConstructorDeclaration arrayOfSizeConstructor = `new Array.ofSize`;
   A _value reference expression_ or _function reference expression_ is
an optional member declaration qualifier, followed by the name of a
function, value, value constructor, or anonymous class, with the keyword
'value' or 'function', surrounded by backticks.

MemberKeyword: "value" | "function"

MemberDec: "`" MemberKeyword PackageQualifier? MemberDecQualifier? MemberName "`"
   A _constructor reference expression_ is a member declaration
qualifier, followed by the name of a callable constructor, with the
keyword 'new', surrounded by backticks.

ConstructorKeyword: "new"

ConstructorDec: "`" ConstructorKeyword PackageQualifier? MemberDecQualifier TypeName "`"
   A reference expression is a reference to a declaration.  The
referenced declaration is determined according to *note Unqualified
reference resolution: unqualifiedreferenceresolution. and *note
Qualified reference resolution: qualifiedreferenceresolution.  The kind
of the referenced declaration must match the kind of reference indicated
by the keyword.

     ValueDeclaration personNameAttribute = `value Person.name`;

     FunctionDeclaration personSayMethod = `function Person.say`;

     FunctionDeclaration processWriteMethod = `function process.write`;

     ClassDeclaration processClass = `class process`;


File: ceylon-spec.info,  Node: packageandmodulereferences,  Next: typeofareferenceexpression,  Prev: declarationreferences,  Up: referenceexpressions

6.10.2 Package and module references
------------------------------------

A _package reference expression_ is a package name, as defined by *note
Packages: packages, with the keyword 'package', surrounded by backticks.

PackageDec: "`" "package" FullPackageName? "`"
   The package name must refer to a package from which an 'import'
statement in the same compilation unit may import declarations, as
defined by *note Imports: imports.

   If there is no explicit package name, the package reference is to the
package in which the package reference expression occurs.

     Package currentPackage = `package`;
     Package modelPackage = `package ceylon.language.meta.model`;
   A _module reference expression_ is a module name, as defined by *note
Module names and version identifiers: modulenamesandversionidentifiers,
with the keyword 'module', surrounded by backticks.

ModuleDec: "`" "module" FullPackageName? "`"
   The module name must refer to the module to which the compilation
unit belongs, as specified by *note Source layout: sourcelayout, or to a
module imported by the module to which the compilation unit belongs, as
defined by *note Module descriptors: moduledescriptors.

   If there is no explicit module name, the module reference is to the
package in which the module reference expression occurs.

     Module currentModule = `module`;
     Module languageModule = `module ceylon.language`;


File: ceylon-spec.info,  Node: typeofareferenceexpression,  Prev: packageandmodulereferences,  Up: referenceexpressions

6.10.3 Type of a reference expression
-------------------------------------

The type of a reference expression depends upon the kind of program
element referenced:

   * for a module, the type is 'Module',

   * for a package, the type is 'Package',

   * for a reference, the type is 'ReferenceDeclaration',

   * for any other value, the type is 'ValueDeclaration',

   * for a function, the type is 'FunctionDeclaration',

   * for a callable constructor, the type is
     'CallableConstructorDeclaration',

   * for a value constructor, the type is 'ValueConstructorDeclaration',

   * for a type parameter, the type is 'TypeParameter',

   * for a type alias declared using the keyword 'alias', the type is
     'AliasDeclaration',

   * for a class with an initializer parameter list, or for any class
     alias, the type is 'ClassWithInitializerDeclaration',

   * for a class with constructors, the type is
     'ClassWithConstructorsDeclaration', and

   * for an interface or interface alias, the type is
     'InterfaceDeclaration'.

   For a reference to an anonymous class, the type depends upon the
keyword, 'class', or 'value', specified in the reference expression:

   * for a class reference expression, the type is 'ClassDeclaration',
     but

   * for a value reference expression, the type is 'ValueDeclaration'.


File: ceylon-spec.info,  Node: annotations,  Next: execution,  Prev: expressions,  Up: Top

7 Annotations
*************

* Menu:


* programelementannotations:: Annotations of program elements
* annotationdefinition:: Annotation definition
* annotationvalues:: Annotation values
* languageannotations:: Language annotations
* serialization:: Serialization

_Annotations_ allow information to be attached to a declaration or
assertion, and recovered at runtime via the use of the Ceylon metamodel.
Annotations are used to specify:

   * information used by the compiler while typechecking the program,

   * API documentation for the documentation compiler,

   * serialization of a class, and

   * information needed by generic frameworks and libraries.


File: ceylon-spec.info,  Node: programelementannotations,  Next: annotationdefinition,  Up: annotations

7.1 Annotations of program elements
===================================

* Menu:


* annotationlists:: Annotation lists
* annotationargments:: Annotation arguments

Annotations occur at the very beginning of a declaration or assertion,
in an _annotation list_.

     "The user login action"
     by ("Gavin King",
         "Andrew Haley")
     throws (`class DatabaseException`,
             "if database access fails")
     see (`function LogoutAction.logout`)
     scope (session)
     action { description="Log In"; url="/login"; }
     shared deprecated


File: ceylon-spec.info,  Node: annotationlists,  Next: annotationargments,  Up: programelementannotations

7.1.1 Annotation lists
----------------------

An annotation is an initial lowercase identifier, optionally followed by
an argument list.

Annotation: MemberName Arguments?
   The annotation name is a reference to an annotation constructor,
resolved according to *note Unqualified reference resolution:
unqualifiedreferenceresolution.

   A list of annotations does not require punctuation between the
individual annotations in the list.  An annotation list may begin with a
string literal, in which case it is interpreted as the argument of a
'doc' annotation.

Annotations: StringLiteral? Annotation*
   Every annotation is an invocation expression, as defined by *note
Invocation expressions: invocationexpressions, of an annotation
constructor.  The annotation name is interpreted as a base expression,
as defined in *note Base expressions: baseexpressions.


File: ceylon-spec.info,  Node: annotationargments,  Prev: annotationlists,  Up: programelementannotations

7.1.2 Annotation arguments
--------------------------

For an annotation with no arguments, the argument list may be omitted,
in which case the annotation is interpreted as having an empty
positional argument list.  Otherwise, the annotation argument list may
be specified using one of two forms:

   * Using a positional argument list, as defined in *note Positional
     argument lists: positionalarguments.:

          doc ("the name") String name;

   * Using a named argument list, as defined in *note Named argument
     lists: namedarguments.:

          doc { description="the name"; } String name;

   As a special case, the name of the 'doc' annotation and the
parenthesis around its argument may be ommitted if it is the first
annotation in an annotation list.

     "the name" String name;
   Operator expressions, member expressions, self references, anonymous
functions, comprehensions, and string templates are not permitted in an
annotation argument.  Every base expression in an annotation argument
must be a value reference to an anonyous class instance of an enumerated
type, or must occur in a direct instantiation expression for an
annotation type.

   A named argument to an annotation may not be an inline function,
value, or anonymous class.


File: ceylon-spec.info,  Node: annotationdefinition,  Next: annotationvalues,  Prev: programelementannotations,  Up: annotations

7.2 Annotation definition
=========================

* Menu:


* annotationconstructors:: Annotation constructors
* annotationtypes:: Annotation types
* constrainedannotationtypes:: Constrained annotation types

Annotations are typesafe.

   * An _annotation constructor_ defines the schema of an annotation as
     it appears at a program element.

   * An _annotation type_ defines constraints upon which program
     elements can bear the annotation, and an API for accessing the
     information carried by an annotation.


File: ceylon-spec.info,  Node: annotationconstructors,  Next: annotationtypes,  Up: annotationdefinition

7.2.1 Annotation constructors
-----------------------------

An _annotation constructor_ is a toplevel function that defines an
annotation schema.  An annotation constructor must be annotated
'annotation'.  An annotation constructor may not declare type
parameters.

   Each parameter of an annotation constructor must have one of the
following types:

   * 'Integer', 'Float', 'Character', or 'String',

   * an enumerated type whose cases are all anonymous classes, such as
     'Boolean',

   * a subtype of 'Declaration' in 'ceylon.language.meta.declaration',

   * an annotation type,

   * 'T?' where 'T' is a legal annotation constructor parameter type,

   * '{T*}', '{T+}', '[T*]', or '[T+]' where 'T' is a legal annotation
     constructor parameter type, or

   * any tuple type whose element types are legal annotation constructor
     parameter types.

   A parameter of an annotation constructor may be variadic.

   An annotation constructor must simply instantiate and return an
instance of an annotation type.  The body of an annotation constructor
may not contain multiple statements.  Operator expressions, member
expressions, self references, anonymous functions, comprehensions, and
string templates are not permitted in the definition of an annotation
constructor.  Every base expression in the body of an annotation
constructor must be a reference to a parameter of the annotation
constructor or to an anonyous class instance of an enumerated type, or
must occur in a direct instantiation expression for an annotation type.

   A named argument appearing in the definition of an annotation
constructor may not be an inline function, value, or anonymous class.

     shared annotation Scope scope(ScopeType s) => Scope(s);

     shared annotation Todo todo(String text) => Todo(text);
   An annotation constructor parameter may have a default argument,
which must be a legal annotation argument.

   The return type of an annotation constructor must be a constrained
annotation type, as defined below in *note Constrained annotation types:
constrainedannotationtypes.

   A user-defined annotation constructor may not return the same
annotation type as one of the modifiers listed below in *note
Declaration modifiers: declarationmodifiers.

     Note: in future releases of the language we will let an annotation
     constructor return a sequence or tuple of annotation type
     instances.


File: ceylon-spec.info,  Node: annotationtypes,  Next: constrainedannotationtypes,  Prev: annotationconstructors,  Up: annotationdefinition

7.2.2 Annotation types
----------------------

Annotation constructors produce instances of _annotation types_.  An
annotation type is a class annotated 'annotation'. An annotation type
may not be a generic type with type parameters.  An annotation type must
have an empty initializer section.

     Note: currently every annotation type must be a 'final' class which
     directly extends 'Basic' in 'ceylon.language'.

   Each initializer parameter of an annotation type must have one of the
following types:

   * 'Integer', 'Float', 'Character', or 'String',

   * an enumerated type whose cases are all anonymous classes, such as
     'Boolean',

   * a subtype of 'Declaration' in 'ceylon.language.meta.declaration',

   * an annotation type,

   * 'T?' where 'T' is a legal annotation parameter type,

   * '{T*}', '{T+}', '[T*]', or '[T+]' where 'T' is a legal annotation
     parameter type, or

   * any tuple type whose element types are legal annotation parameter
     types.

   An initializer parameter of an annotation type may be variadic.

   An initializer parameter of an annotation type may have a default
argument, which must be a legal annotation argument.


File: ceylon-spec.info,  Node: constrainedannotationtypes,  Prev: annotationtypes,  Up: annotationdefinition

7.2.3 Constrained annotation types
----------------------------------

A _constrained annotation type_ is an annotation type that is a subtype
of 'OptionalAnnotation' or 'SequencedAnnotation' defined in the package
'ceylon.language'.

   * If 'A' is a subtype of 'OptionalAnnotation', at most one annotation
     of annotation type 'A' may occur at a given program element.

   * If 'A' is a subtype of 'SequencedAnnotation', multiple annotations
     of annotation type 'A' may occur at a given program element.

   * If 'A' is a subtype of 'ConstrainedAnnotation<A,B,P,T>', then an
     annotation of annotation type 'A' may not occur at a program
     element whose reference expression type, as defined in *note Type
     of a reference expression: typeofareferenceexpression, is not
     assignable to 'P'.

   * If 'A' is a subtype of 'ConstrainedAnnotation<A,B,P,T>' where 'T'
     is not exactly 'Anything', then an annotation of annotation type
     'A' may not occur at a program element whose metamodel type, as
     defined in *note Type of a metamodel expression:
     typeofametamodelexpression, is not assignable to 'T'.

     shared final annotation class Scope(shared ScopeType scope)
             satisfies OptionalAnnotation<Scope,ClassOrInterfaceDeclaration> {
         string => (scope==request then "request")
              else (scope==session then "session")
              else (scope==application then "application")
              else nothing;
     }

     shared final annotation class Todo(String text)
             satisfies SequencedAnnotation<Todo> {
         string => text;
     }

     Note: it is perfectly acceptable for multiple annotation
     constructors to return the same annotation type.


File: ceylon-spec.info,  Node: annotationvalues,  Next: languageannotations,  Prev: annotationdefinition,  Up: annotations

7.3 Annotation values
=====================

An _annotation value_ is the value returned when an annotation
constructor is invoked.  We may obtain the annotation values of all
annotations of a given annotation type that occur at a given program
element by passing the annotation type metamodel, as defined in *note
Metamodel expressions: metamodelexpressions, and program element
reference, as defined in *note Reference expressions:
referenceexpressions, to the method 'annotations()' defined in the
package 'ceylon.language.meta.model'.

     Scope scope = annotations(`Scope`, `class Person`) else Scope(request);

     Todo[] todos = annotations(`Todo`, `function method`);


File: ceylon-spec.info,  Node: languageannotations,  Next: serialization,  Prev: annotationvalues,  Up: annotations

7.4 Language annotations
========================

* Menu:


* declarationmodifiers:: Declaration modifiers
* documentation:: Documentation

Certain important annotations are predefined in the module
'ceylon.language'.


File: ceylon-spec.info,  Node: declarationmodifiers,  Next: documentation,  Up: languageannotations

7.4.1 Declaration modifiers
---------------------------

The following annotations, called _modifiers_, are compiler instructions
that affect the compilation process:

   * 'shared' specifies that a declaration is visible outside of the
     package or body in which it occurs, or that a package is visible
     outside the module it belongs to.

   * 'abstract' specifies that a class cannot be instantiated, or that a
     constructor is a partial constructor.

   * 'formal' specifies that a member does not specify an implementation
     and must therefore be refined by every concrete subclass.

   * 'default' specifies that a method, attribute, or member class may
     be refined by subtypes.

   * 'actual' indicates that a method, attribute, or member type refines
     a method, attribute, or member type defined by a supertype.

   * 'variable' specifies that a value may be assigned multiple times.

   * 'late' disables definite initialization checking for a reference,
     allowing the reference to be initialized after the initializer of
     the class to which it belongs has already completed.

   * 'native' specifies that a program element is implementation is
     specific to a certain platform, and should be ignored by the
     compiler backend when compiling for any other platform, or that it
     is actually implemented in a different language, and that the
     program element should be completely ignored by the Ceylon compiler
     backend, or that a module or module 'import' statement, as defined
     in *note Module descriptors: moduledescriptors, is specific to a
     certain platform.

   * 'deprecated' indicates that a value, function or type is
     deprecated.  It accepts an optional 'String' argument.  The
     compiler produces a warning when compiling code that depends upon a
     deprecated program element.

   * 'final' specifies that a class may not be extended, and may not
     declare 'default' members.

   * 'sealed' specifies that a class may not be extended or instantiated
     outside the module in which it is defined, that an interface may
     not be satisfied by a class or interface outside the module in
     which it is defined, or that a constructor may not be invoked
     outside the module in which it is defined.

   * 'annotation' specifies that a class is an annotation type, or that
     a toplevel function is an annotation constructor.

   * 'suppressWarnings' hides compilation warnings occurring at the
     annotated program element.

     Note: annotation constraints ensure that these annotations do not
     occur at program elements to which they do not apply.

   The following annotation is a hint to the compiler that lets the
compiler optimize compiled bytecode for non-64 bit architectures:

   * 'small' specifies that a value of type 'Integer', 'Integer' or
     'Float' contains 32-bit values.

   By default, 'Integer' and 'Float' are assumed to represent 64-bit
values, as specified in *note Numeric operations: numericoperations.

     Note that 'small' is not yet supported in Ceylon 1.1.


File: ceylon-spec.info,  Node: documentation,  Prev: declarationmodifiers,  Up: languageannotations

7.4.2 Documentation
-------------------

The following annotations are instructions to the documentation
compiler:

   * 'doc' specifies the description of a program element, in Markdown
     format text.

   * 'by' specifies the authors of a program element.

   * 'license' specifies the URL of the license under which a module or
     package is distributed.

   * 'see' specifies a related member or type.

   * 'throws' specifies a thrown exception type.

   * 'tagged' specifies classifying named tags.

   The 'String' arguments to the 'deprecated', 'doc', 'throws' and 'by'
annotations are parsed by the documentation compiler as Markdown-format
content.

   These annotations are all defined in the package 'ceylon.language'.


File: ceylon-spec.info,  Node: serialization,  Prev: languageannotations,  Up: annotations

7.5 Serialization
=================

     TODO: Define how serialization works.


File: ceylon-spec.info,  Node: execution,  Next: modulesystem,  Prev: annotations,  Up: Top

8 Execution
***********

* Menu:


* objectinstancesidentity:: Object instances, identity, and reference passing
* sequentialexecutionandclosure:: Sequential execution and closure
* executionofcontrolstructures:: Execution of control structures and assertions
* evaluationinvocationandassignment:: Evaluation, invocation, and assignment
* operatorexpressions:: Operator expressions
* comprehensionevaluation:: Evaluation of comprehensions
* concurrency:: Concurrency

A Ceylon program executes in a virtual machine environment, either:

   * a Java Virtual Machine (JVM), or

   * a JavaScript virtual machine.

   In future, other virtual machine architectures may be supported.

   Despite the obvious differences between the respective languages that
these virtual machines were designed for, they share very much in common
in terms of runtime semantics, including common notions such as object
identity, primitive value types, exceptions, garbage collection, dynamic
dispatch, and pass by reference.

   Ceylon abstracts away many of the differences between these
platforms, and reuses what is common between them.  Inevitably there are
some differences that can't reasonably be hidden from the Ceylon
program, and the programmer must take these differences into
consideration.

   In Ceylon, every value is a reference to an instance of a class,
except within a 'dynamic' block, where a value with no type may be a
reference to an object which is not an instance of a class.

     Note: the semantics of objects without classes is
     platform-dependent and outside the scope of this specification.


File: ceylon-spec.info,  Node: objectinstancesidentity,  Next: sequentialexecutionandclosure,  Up: execution

8.1 Object instances, identity, and reference passing
=====================================================

* Menu:


* valuetypeoptimizations:: Value type optimizations
* reification:: Type argument reification

An _object_ is a unique identifier, together with a reference to a
class, its type arguments, and a persistent value for each reference
declared by the class (including inherited references).  The object is
said to be an _instance_ of the class.

   A _value_ is a reference to an object (a copy of its unique
identifier).  At a particular point in the execution of the program,
every reference of every object that exists, and every initialized
reference of every function, getter, setter, or initializer that is
currently executing has a value.  Furthermore, every time an expression
is executed, it produces a value.

   Two values are said to be _identical_ if they are references to the
same object--if they hold the same unique identifier. The program may
determine if two values of type 'Identifiable' are identical using the
'===' operator defined in *note Operator definition: operatordefinition.
It may not directly obtain the unique identifier (which is a purely
abstract construct).  The program has no way of determining the identity
of a value which is not of type 'Identifiable'.

   Given a value, the program may determine if the referenced object is
_assignable to a certain type_ using the 'is' operator.  The object is
assignable to the given type if the applied type formed by its class and
type arguments is a subtype of the given type according to the type
system defined in *note Type system: typesystem.  (Therefore, the Ceylon
runtime must be capable of reasoning about subtyping.)

   Invocation of a function or instantiation of a class results in
execution of the function body or class initializer with parameter
values that are copies of the value produced by executing the argument
expressions of the invocation, and a reference to the receiving instance
that is a copy of the value produced by executing the receiver
expression.  The value produced by the invocation expression is a copy
of the value produced by execution of the 'return' directive expression.

     Person myself(Person me) { return me; }
     Person p = ...;
     assert (myself(p)===p); //assertion never fails

     Semaphore s = Semaphore();
     this.semaphore = s;
     assert (semaphore===s); //assertion never fails
   A new object is produced by execution of a class instantiation
expression.  The Ceylon compiler guarantees that if execution of a class
initializer terminates with no uncaught exception, then every reference
of the object has been initialized with a well-defined persistent value.
The value of a reference is initialized for the first time by execution
of a specifier or assignment expression.  Every class instantiation
expression results in an object with a new unique identifier shared by
no other existing object.  The object exists from the point at which
execution of its initializer terminates.  _Conceptually_, the object
exists until execution of the program terminates.

   In practice, the object exists at least until the point at which it
is not reachable by recursively following references from any function,
getter, setter, or initializer currently being executed, or from an
expression in a statement currently being executed.  At this point, its
persistent values are no longer accessible to expressions which
subsequently execute and the object may be destroyed by the virtual
machine.  There is no way for the program to determine that an object
has been destroyed by the virtual machine (Ceylon does not support
finalizers).


File: ceylon-spec.info,  Node: valuetypeoptimizations,  Next: reification,  Up: objectinstancesidentity

8.1.1 Value type optimizations
------------------------------

As a special exception to the rules defined above, the compiler is
permitted to emit bytecode or compiled JavaScript that produces a new
instance of certain types in the module 'ceylon.language' without
execution of the initializer of the class, whenever any expression is
evaluated.  These types are: 'Integer', 'Float', 'Character', 'Range',
'Entry', 'String', 'Array', and 'Tuple'.  Furthermore, it is permitted
to use such a newly-produced instance as the value of the expression, as
long as the newly-produced instance is equal to the value expected
according to the rules above, as determined using the '==' operator.

   Therefore, the types listed above directly extend 'Object' instead of
'Basic', and are not 'Identifiable'.

     Note: this does no justice at all to our compiler.  Actually the
     compiler infrastructure already supports value type optimization
     for user-defined types, though we have not yet exposed this
     functionality as part of the language.


File: ceylon-spec.info,  Node: reification,  Prev: valuetypeoptimizations,  Up: objectinstancesidentity

8.1.2 Type argument reification
-------------------------------

Type arguments, as defined in *note Generic type arguments:
generictypearguments, are _reified_ in Ceylon.  An instance of a generic
type holds a reference to each of its type arguments.  Therefore, the
following are possible in Ceylon:

   * testing the runtime value of a type argument of an instance, for
     example, 'objectList is List<Person>' or 'case (is List<Person>)',

   * filtering exceptions based on type arguments, for example, 'catch
     (NotFoundException<Person> pnfe)', and

   * testing the runtime value of an instance against a type parameter,
     for example 'x is Key', or against a type with a type parameter as
     an argument, for example, 'objectList is List<Element>'.

   * obtaining a 'Type' object representing a type with type arguments,
     for example, '`List<Person>`',

   * obtaining a 'Type' object representing the runtime value of a type
     parameter, for example, '`Element`', or of a type with a type
     parameter as an argument, for example, '`List<Element>`', and

   * obtaining a 'Type' object representing the runtime value of a type
     argument of an instance using reflection, for example,
     'type(objectList).typeArguments.first'.

   At runtime, all types are _concrete types_ formed by:

   * recursively replacing all type aliases, class aliases, and
     interface aliases with their definitions, which is always possible
     according to *note Type alias elimination: typealiaselimination,
     and

   * recursively replacing all type parameters with their type arguments

   in any type that appears in an expression or condition.

   Therefore, every type parameter refers, at runtime, to a concrete
type that involves no type aliases or type parameters.  In particular,
the type arguments held by an instance of a generic class are concrete
types.

   This program prints 'String[]'.

     class Generic<out T>(T t) { string=>`T`.string; }
     Generic<{S*}> gen<S>(S* ss) => Generic(ss);
     void run() {
         print(gen("hello", "world"));
     }
   The runtime is generally permitted, as an optimization, to return a
more precise type in place of a less precise type when a type parameter
is evaluated.  This program may print 'String' instead of 'Object', even
though 'Object' is the type argument inferred at compile time.

     class Generic<out T>(T t) { string=>`T`.string; }
     Generic<Object> gen(Object o) => Generic(o);
     void run() {
         print(gen("hello"));
     }


File: ceylon-spec.info,  Node: sequentialexecutionandclosure,  Next: executionofcontrolstructures,  Prev: objectinstancesidentity,  Up: execution

8.2 Sequential execution and closure
====================================

* Menu:


* frames:: Frames
* currentinstancesandcurrentframes:: Current instances and current frames
* currentinstanceofaclassorinterface:: Current instance of a class or interface
* currentframeofablock:: Current frame of a block
* initialization:: Initialization
* classinstanceoptimization:: Class instance optimization
* executionofexpressionandspecificationstatements:: Execution of expression and specification statements
* executionofcontroldirectives:: Execution of control directives
* exceptionpropagation:: Exception propagation
* toplevelinitialization:: Initialization of toplevel references
* lateinitialization:: Initialization of late references

Ceylon programs are organized into bodies, as defined in *note Block
structure and references: blockstructure, containing statements which
are executed sequentially and have access to declarations which occur in
the surrounding lexical context and to persistent values held by
references, as defined in *note References: references, declared in the
surrounding lexical context.

     Note: for the purposes of this section, an interface body is,
     strictly speaking, a trivial case of a body which contains no
     statements or persistent values, but we're primarily concerned with
     blocks and class bodies.

   The statements and non-lazy specifiers that directly occur in a body
are executed sequentially in the lexical order in which they occcur.
Execution of a body begins at the first statement or non-lazy specifier.
Execution of a block terminates when the last statement or non-lazy
specifier of the body finishes executing, or when a control directive
that terminates the block is executed, or when an exception is thrown by
an evaluation, assignment, invocation, or instantiation.


File: ceylon-spec.info,  Node: frames,  Next: currentinstancesandcurrentframes,  Up: sequentialexecutionandclosure

8.2.1 Frames
------------

When execution of a body begins, a _frame_ is created.  For each
reference whose declaration directly occurs in the body, the frame has a
value, which may or may not be initialized.  The value may be
initialized or assigned during execution of the body.

   We can visualize a frame as a list of reference declarations with
optional values.  For example, a frame with an initialized reference
named 'language' and an uninitialized reference named 'count' would be
written like this:

     { String language = "ceylon"; Integer count; }
   While a body is executing, all values held in the frame are
considered accessible.  An evaluation, assignment, invocation, or
instantiation may result in a pause in execution of the body while the
called getter, setter, function, or class is executed or instantiated.
However, the frame associated with the calling body is retained and
values held in the frame are still considered accessible.  When
execution of the body resumes, the frame is restored.

   When execution of a body terminates, the frame may or may not become
inaccessible.  In the case of a class body, if the initializer
terminates with no thrown exception, the frame and its values become a
new instance of the class, are associated with the newly created unique
identifier, and remain accessible while this object is itself
accessible.  In the case of any other kind of body, or in the case that
an initializer throws an exception, the frame and its values may remain
accessible if:

   * a reference to a function or class declared within the body is
     accessible,

   * an instance of a class declared within the body is accessible, or

   * an instance of a comprehension declared within the body is
     accessible.

   Otherwise, the frame becomes inaccessible and may be destroyed.

   The principle of _closure_ states that a nested body always has
access to a frame for every containing body.  The set of _current
instances_ of containing classes and _current frames_ of containing
blocks forms the closure of a nested declaration.


File: ceylon-spec.info,  Node: currentinstancesandcurrentframes,  Next: currentinstanceofaclassorinterface,  Prev: frames,  Up: sequentialexecutionandclosure

8.2.2 Current instances and current frames
------------------------------------------

A frame may be the _current frame_ for a body.  When the body is
executing, the created frame is the current frame.  When execution of
the body terminates, the created frame is no longer the current frame.
Invocation or evaluation of a member of a class or interface, invocation
of a callable reference or anonymous function, or evaluation of the
values produced by a comprehension may result in the frame being
restored as the current frame.

   A class instance, callable reference, anonymous function reference,
or comprehension instance packages a reference to a frame for each body
containing the program element, as specified below.  When a member of
the class instance is invoked or evaluated, when the callable reference
or anonymous function is invoked, or when the comprehension instance
produces a value, these frames are restored as the current frames of the
associated bodies.  When the invocation or evaluation terminates, or
when the comprehension value has been produced, these frames are no
longer current frames.

   The value associated with a value reference in the current frame of
the body to which the value reference belongs is called the _current
value_ of the value reference.

   If a frame is the current frame for a class or interface body, we
call it the _current instance_ of the class or interface.

     TODO: in the following two sections, account for callable
     references, anonymous function references, and comprehension
     instances.


File: ceylon-spec.info,  Node: currentinstanceofaclassorinterface,  Next: currentframeofablock,  Prev: currentinstancesandcurrentframes,  Up: sequentialexecutionandclosure

8.2.3 Current instance of a class or interface
----------------------------------------------

If a statement is occurs directly or indirectly inside a class or
interface body, then there is always a current instance of the class or
interface when the statement is executed.  The current instance is
determined as follows:

   * For a statement that occurs sequentially, as defined by *note Block
     structure and references: blockstructure, in the body of the class
     or of a constructor of the class, the current instance is the new
     instance being initialized.

   * For a statement that occurs sequentially in the body of a member of
     the class or interface, the current instance is the receiving
     instance of the base or member expression that resulted in a
     reference to the member.

   * For a statement that occurs sequentially in the body of a nested
     class or interface that occurs in the body of the class or
     interface, the current instance is the same object that was the
     current instance when the initializer of the current instance of
     the nested class or interface was executed.

   * Otherwise, for any other statement that occurs sequentially in the
     body of a declaration that occurs in the body of the class or
     interface, the current instance is the same object that was the
     current instance when the base member expression that resulted in a
     reference to the declaration was executed.

   Here, 'innerObject' is the current instance of 'Inner' when
'member()' is executed, and 'outerObject' is the current instance of
'Outer':

     Outer outerObject = Outer();
     Inner innerObject = outerObject.Inner();
     innerObject.member();


File: ceylon-spec.info,  Node: currentframeofablock,  Next: initialization,  Prev: currentinstanceofaclassorinterface,  Up: sequentialexecutionandclosure

8.2.4 Current frame of a block
------------------------------

If a statement occurs directly or indirectly inside a block, then there
is always a current frame of the block when the statement is executed.
The current frame is determined as follows:

   * If the statement occurs sequentially, as defined by *note Block
     structure and references: blockstructure, in the block, the current
     frame is the frame associated with the current execution of the
     block.

   * For a statement that occurs sequentially in the body of a nested
     class or interface that occurs in the block, the current frame is
     the same frame that was the current frame when the initializer of
     the current instance of the nested class or interface was executed.

   * Otherwise, for any other statement that occurs sequentially inside
     the body of a declaration that occurs in the block, and the current
     frame is the frame that was the current frame when the base member
     expression that resulted in a reference to the declaration was
     executed.

   In each of the following code fragments, 'result' refers to the value
'"hello"':

     String()() outerMethod(String s) {
         String() middleMethod() {
             String innerMethod() => s;
             return innerMethod;
         }
         return middleMethod;
     }

     String middleMethod()() => outerMethod("hello");
     String innerMethod() => middleMethod();
     String result = innerMethod();

     Object outerMethod(String s) {
         object middleObject {
             shared actual String string => s;
         }
         return middleObject;
     }

     Object middleObject = outerMethod("hello");
     String result = middleObject.string;


File: ceylon-spec.info,  Node: initialization,  Next: classinstanceoptimization,  Prev: currentframeofablock,  Up: sequentialexecutionandclosure

8.2.5 Initialization
--------------------

When an instance is instantiated, its initializer is executed, and the
initializer for every class it inherits is executed.  If a class has
constructors, one of its constructors is also executed.  For a class
'C':

   * First, the initializer of 'Object' defined in 'ceylon.language' is
     executed.  (This initializer is empty and does no work.)

   * For each superclass 'X' of 'C', there is exactly one other
     superclass 'Y' of 'C' that directly extends 'X'.  When execution of
     the initializer of 'X' terminates without a thrown exception,
     execution of the initializer of 'Y' begins.  When sequential
     execution of the initializer reaches the declaration of the invoked
     or delegated constructor of 'Y', if any, the constructor itself is
     executed.  When execution of the constructor terminates without a
     thrown exception, execution of the initializer resumes at the next
     statement after the constructor declaration.

   * Finally, when execution of the initializer of 'C', terminates
     without a thrown exception, the new instance of 'C' is
     fully-initialized and made accessible to the calling code.

   If any initializer or constructor in the class hierarchy terminates
with a thrown exception, initialization terminates and the
incompletely-initialized instance never becomes accessible.

   Each initializer produces a frame containing initialized values for
each reference declared by the corresponding class.  These frames are
aggregated together to form the new instance of the class 'C'.

     Note: since interfaces don't have initializers, the issue of
     "linearization" of supertypes simply never arises in Ceylon.  There
     is a natural, well-defined initialization ordering.


File: ceylon-spec.info,  Node: classinstanceoptimization,  Next: executionofexpressionandspecificationstatements,  Prev: initialization,  Up: sequentialexecutionandclosure

8.2.6 Class instance optimization
---------------------------------

As an exception to the above, the compiler is permitted to destroy a
persistent value associated with a class instance when the class
initializer terminates, potentially rendering inaccessible the instance
identified by the value, if it can determine that the persistent value
will never be subsequently accessed by the program.

     This optimization is the only source of a distinction between a
     "field" of a class and a "local variable" of its initializer.
     There is no way for a program to observe this distinction.


File: ceylon-spec.info,  Node: executionofexpressionandspecificationstatements,  Next: executionofcontroldirectives,  Prev: classinstanceoptimization,  Up: sequentialexecutionandclosure

8.2.7 Execution of expression and specification statements
----------------------------------------------------------

When an expression statement is executed, the expression is evaluated.

   When a non-lazy specification statement is executed, the specified
expression is evaluated, and the resulting value assigned to the
specified reference within the current frame or current instance
associated with the body to which the specified reference belongs.

   When a lazy specification statement is executed, the specified
expression is associated with the specified reference within the current
frame or current instance associated with the body to which the
specified reference belongs.  Subsequent evaluation or invocation of the
reference for this current frame or current instance may result in
evaluation of the specified expression, in which case the expression is
evaluated within this current frame or current instance.


File: ceylon-spec.info,  Node: executionofcontroldirectives,  Next: exceptionpropagation,  Prev: executionofexpressionandspecificationstatements,  Up: sequentialexecutionandclosure

8.2.8 Execution of control directives
-------------------------------------

Execution of a control directive, as specified in *note Control
directives: controldirectives, terminates execution of the body in which
it occurs, and possibly of other containing bodies.

   * A 'return' directive that occurs sequentially in the body of a
     function, getter, setter, or class initializer terminates execution
     of the body of the function, getter, setter, or class initializer
     and of all intervening bodies.  Optionally, it determines the
     return value of the function or getter.

   * A 'break' directive terminates execution of the body of the most
     nested containing loop in which it occurs sequentially, and of all
     intervening bodies.  Additionally, it terminates execution of the
     loop.

   * A 'continue' directive terminates execution of the body of the most
     nested containing loop in which it occurs sequentially, and of all
     intervening bodies.  It does not terminate execution of the loop.

   * A 'throw' directive that occurs sequentially in the body of a
     function, getter, setter, or class initializer terminates execution
     of the body of the function, getter, setter, or class initializer
     and of all intervening bodies, and, furthermore, the exception
     propagates to the caller, as defined below, unless there is an
     intervening 'try' with a 'catch' clause matching the thrown
     exception, in which case it terminates execution of the body of the
     'try' statement and all intervening bodies, and execution continues
     from the body of the 'catch' clause.


File: ceylon-spec.info,  Node: exceptionpropagation,  Next: toplevelinitialization,  Prev: executionofcontroldirectives,  Up: sequentialexecutionandclosure

8.2.9 Exception propagation
---------------------------

If execution of an evaluation, assignment, invocation, or instantiation
terminates with an exception thrown, the exception propagates to the
calling code, and terminates execution of the body of the function,
getter, setter, or class initializer in which the expression involving
the evaluation, assignment, invocation, or instantiation sequentially
occurs, and of all intervening bodies, and, furthermore, the exception
propagates to the caller unless there is an intervening 'try' with a
'catch' clause matching the thrown exception, in which case it
terminates execution of the body of the 'try' statement and all
intervening bodies, and execution continues from the body of the 'catch'
clause.


File: ceylon-spec.info,  Node: toplevelinitialization,  Next: lateinitialization,  Prev: exceptionpropagation,  Up: sequentialexecutionandclosure

8.2.10 Initialization of toplevel references
--------------------------------------------

A toplevel reference has no associated frame.  Instead, the lifecycle of
its persistent value is associated with the loading and unloading of a
module by the module runtime.  The first time a toplevel reference is
accessed following the loading of its containing module, its initializer
expression is evaluated, and the resulting value is associated with the
reference.  This association survives until the toplevel reference is
reassigned, or until the module is unloaded by the module runtime.

   Initialization of a toplevel reference may result in recursive
initialization of other toplevel references.  Therefore, it is possible
that a cycle could occur where evaluation of a toplevel reference occurs
while evaluating its initializer expression.  When this occurs, an
'InitializationError' is thrown.


File: ceylon-spec.info,  Node: lateinitialization,  Prev: toplevelinitialization,  Up: sequentialexecutionandclosure

8.2.11 Initialization of late references
----------------------------------------

A reference annotated 'late' may be uninitialized in a given frame.  The
rules of the language do not guarantee that an uninitialized 'late'
reference is never evaluated at runtime.  If a 'late' reference which is
uninitialized in the current frame or current instance is evaluated, an
'InitializationError' is thrown.

   Likewise, if a non-'variable' 'late' reference which is already
initialized in the current frame or current instance is assigned, an
'InitializationError' is thrown.


File: ceylon-spec.info,  Node: executionofcontrolstructures,  Next: evaluationinvocationandassignment,  Prev: sequentialexecutionandclosure,  Up: execution

8.3 Execution of control structures and assertions
==================================================

* Menu:


* evaluationofconditions:: Evaluation of condition lists
* validationofassertions:: Validation of assertions
* executionofconditionals:: Execution of conditionals
* executionofloops:: Execution of loops
* exceptionhandling:: Exception handling
* dynamictypechecking:: Dynamic type checking

Control structures, as specified in *note Control structures and
assertions: controlstructures, are used to organize conditional and
repetitive code within a body.  Assertions are essentially a
sophisticated sort of control directive, but for convenience are
categorized together with control structures.


File: ceylon-spec.info,  Node: evaluationofconditions,  Next: validationofassertions,  Up: executionofcontrolstructures

8.3.1 Evaluation of condition lists
-----------------------------------

Execution of an 'if', 'while', or 'assert' requires evaluation of a
condition list, as defined in *note Conditions:
controlstructureconditions.

   To determine if a condition list is satisfied, its constituent
conditions are evaluated in the lexical order in which they occur in the
condition list. If any condition is not satisfied, none of the
subsequent conditions in the list are evaluated.

   * A boolean condition is satisfied if its expression evaluates to
     'true' when the condition is evaluated.

   For any other kind of condition, the condition is satisfied if its
value reference or expression evaluates to an instance of the required
type when the condition is evaluated:

   * for an assignability condition, the condition is satisfied if the
     expression evaluates to an instance of the specified type when the
     control structure is executed,

   * for an existence condition, the condition is satisfied unless the
     expression evaluates to 'null' when the control structure is
     executed, or

   * for a nonemptiness expression, the condition is satisfied unless
     the expression evaluates to an instance of '[]|Null' when the
     control structure is executed.

   A condition list is satisfied if and only if all of its constituent
conditions are satisfied.


File: ceylon-spec.info,  Node: validationofassertions,  Next: executionofconditionals,  Prev: evaluationofconditions,  Up: executionofcontrolstructures

8.3.2 Validation of assertions
------------------------------

When an assertion, as specified in *note Assertions: assertions, is
executed, its condition list is evaluated.  If the condition list is not
satisfied, an exception of type 'AssertionError' in 'ceylon.language' is
thrown.

   The information carried by the 'AssertionError' includes:

   * the text of the Ceylon code of the condition that failed,

   * the message specified by the 'doc' annotation of the assertion, if
     any.


File: ceylon-spec.info,  Node: executionofconditionals,  Next: executionofloops,  Prev: validationofassertions,  Up: executionofcontrolstructures

8.3.3 Execution of conditionals
-------------------------------

The 'if/else' and 'switch/case/else' constructs control conditional
execution.

   When the 'if/else' construct, specified in *note if/else: ifelse, is
executed, its condition list is evaluated.  If the condition list is
satisfied, the 'if' block is executed. Otherwise, the 'else' block, if
any, is executed, or, if the construct has an 'else if', the child 'if'
construct is executed.

   When a 'switch/case/else' construct, specified in *note
switch/case/else: switchcaseelse, is executed, its 'switch' expression
is evaluated to produce a value.  The value is guaranteed to _match_ at
most one 'case' of the 'switch'.  If it matches a certain case, then
that 'case' block is executed.  Otherwise, 'switch' is guaranteed to
have an 'else', and so the 'else' block is executed.

   The value produced by the 'switch' expression matches a case if
either:

   * the case is a list of literal values and value references the value
     is identical to one of the value references in the list or equal to
     one of the literal values in the list, or if

   * the case is an assignability condition of form 'case (is V)' and
     the value is an instance of 'V'.


File: ceylon-spec.info,  Node: executionofloops,  Next: exceptionhandling,  Prev: executionofconditionals,  Up: executionofcontrolstructures

8.3.4 Execution of loops
------------------------

The 'for/else' and 'while' loops control repeated execution.

   When a 'while' construct, specified in *note while: while, is
executed, the loop condition list is evaluated repeatedly until the
first time the condition list is not satisfied, or until a 'break',
'return', or 'throw' directive that terminates the loop is executed.
Each time the condition is satisfied, the 'while' block is executed.

   When a 'for/else' construct, specified in *note for/else: forelse, is
executed:

   * the iterated expression is evaluated to produce an an instance of
     'Iterable',

   * an 'Iterator' is obtained by calling 'iterator()' on the iterable
     object, and then

   * the 'for' block is executed once for each value of produced by
     repeatedly invoking the 'next()' method of the iterator, until the
     iterator produces the value 'finished', or until a 'break',
     'return', or 'throw' directive that terminates the loop is
     executed.

   Note that:

   * if the iterated expression is also of type 'X[]', the compiler is
     permitted to optimize away the use of 'Iterator', instead using
     indexed element access.

   * if the iterated expression is a range constructor expression, the
     compiler is permitted to optimize away creation of the 'Range', and
     generate the indices using the 'successor' operation.

   We say that the loop _exits early_ if it ends via execution of a
'break', 'return', or 'throw' directive.  Otherwise, we say that the
loop _completes_ normally.

   If the loop completes normally, the 'else' block is executed.
Otherwise, if the loop exits early, the 'else' block is not executed.


File: ceylon-spec.info,  Node: exceptionhandling,  Next: dynamictypechecking,  Prev: executionofloops,  Up: executionofcontrolstructures

8.3.5 Exception handling
------------------------

When a 'try/catch/finally' construct, specified in *note
try/catch/finally: trycatchfinally, is executed:

   * the resource expressions, if any, are evaluated in the order they
     occur, and then 'obtain()' is called on each resulting resource
     instance of type 'Obtainable', in the same order, then

   * the 'try' block is executed, then

   * 'destroy()' is called on each resource instance of type
     'Destroyable', and 'release()' is called on each resource instance
     of type 'Obtainable', if any, in the reverse order that the
     resource expressions occur, passing the exception that propagated
     out of the 'try' block, if any, then

   * if an exception did propagate out of the 'try' block, the first
     'catch' block with a variable to which the exception is assignable,
     if any, is executed, and then

   * the 'finally' block, if any, is executed, even in the case where an
     exception propagates out of the whole construct.

     TODO: Specify what happens if 'close()' throws an exception.  (Same
     semantics as Java with "suppressed" exceptions.)


File: ceylon-spec.info,  Node: dynamictypechecking,  Prev: exceptionhandling,  Up: executionofcontrolstructures

8.3.6 Dynamic type checking
---------------------------

Inside a 'dynamic' block, a situation might occur that requires dynamic
type checking, as specified in *note Dynamic blocks: dynamicblocks. It
is possible that:

   * the value to which an expression with no type evaluates at
     execution time might not be an instance of the type required where
     the expression occurs,

   * in particular, the value to which a 'switch' expression with no
     type evaluates at execution time might be an instance of a type not
     covered by the 'case's of a 'switch' with no 'else', or

   * a qualified or unqualified reference which does not refer to a
     statically typed declaration might not resolve to any declaration
     at all.

   Whenever such a condition is encountered at runtime, an
'AssertionError' is immediately thrown.

     Note: in Ceylon 1.0, dynamic type checking is only supported on
     JavaScript virtual machines.


File: ceylon-spec.info,  Node: evaluationinvocationandassignment,  Next: operatorexpressions,  Prev: executionofcontrolstructures,  Up: execution

8.4 Evaluation, invocation, and assignment
==========================================

* Menu:


* dynamicdispatch:: Dynamic dispatch
* evaluation:: Evaluation
* assignment:: Assignment
* invocation:: Invocation
* anonymousfunctionevaluation:: Evaluation of anonymous functions
* enumerationevaluation:: Evaluation of enumerations
* spreadevaluation:: Evaluation of spread arguments and comprehensions

Evaluation of an expression may result in:

   * invocation of a function or instantiation of a class,

   * evaluation of a value,

   * instantiation of an instance of 'Callable' that packages a callable
     reference, or

   * assignment to a variable value.


File: ceylon-spec.info,  Node: dynamicdispatch,  Next: evaluation,  Up: evaluationinvocationandassignment

8.4.1 Dynamic dispatch
----------------------

_Dynamic dispatch_ is the process of determing at runtime a member
declaration based upon the runtime type of an object, which, as a result
of subtype polymorphism, may be different to its static type known at
compile time.

   Any concrete class is guaranteed to have exactly one declaration of a
member, either declared or inherited by the class, which refines all
other declarations of the member declared or inherited by the class.  At
runtime, this member is selected.

   There is one exception to this rule: member expressions where the
receiver expression is of form 'super' or '(super of Type)', as defined
in *note super: super, are dispatched based on the static type of the
receiver expression:

   * Any invocation of a member of 'super' is processed by the member
     defined or inherited by the supertype, bypassing any member
     declaration that refines this member declaration.

   * Any invocation of a member of an expression of form '(super of
     Type)' is processed by the member defined or inherited by 'Type',
     bypassing any member declaration that refines this member
     declaration.


File: ceylon-spec.info,  Node: evaluation,  Next: assignment,  Prev: dynamicdispatch,  Up: evaluationinvocationandassignment

8.4.2 Evaluation
----------------

Evaluation of a value reference, as defined in *note Value references:
valuereferences, produces its current value.  Evaluation of a callable
reference, as defined in *note Callable references: callablereferences,
that does not occur as the primary of a direct invocation results in a
new instance of 'Callable' that packages the callable reference.

     person.name

     '/'.equals
   When a value reference expression is executed:

   * first, the receiver expression, if any, is evaluated to obtain a
     receiving instance for the evaluation, then

   * the actual declaration to be invoked is determined by considering
     the runtime type of the receiving instance, if any, and then

   * if the declaration is a reference, its persistent value is
     retrieved from the receiving instance, or

   * otherwise, execution of the calling body pauses while the body of
     its getter is executed by the receiving instance, then,

   * finally, when execution of the getter ends, execution of the
     calling body resumes.

   The resulting value is the persistent value retrieved, or the return
value of the getter, as specified by the 'return' directive.

   When a callable reference expression that does not occur as the
primary of a direct invocation expression is executed:

   * first, the receiver expression, if any, is evaluated to obtain a
     receiving instance for the evaluation, then

   * the receiving instance, a reference to the declaration to be
     invoked, or a reference to the current frame or instance of every
     body that contains the referenced declaration are packaged together
     into an instance of 'Callable'.

   The resulting value is the instance of 'Callable'.  The concrete
class of this instance is not specified here.


File: ceylon-spec.info,  Node: assignment,  Next: invocation,  Prev: evaluation,  Up: evaluationinvocationandassignment

8.4.3 Assignment
----------------

Given a value reference, as defined in *note Value references:
valuereferences, to a variable, the assignment operator '=' assigns it a
new value.

     person.name = "Gavin"
   When an assignment expression is executed:

   * first, the receiver expression of the value reference expression is
     executed to obtain the receiving instance, then

   * the actual declaration to be assigned is determined by considering
     the runtime type of the receiving instance, and then

   * if the member is a reference, its persistent value is updated in
     the receiving instance, or

   * otherwise, execution of the calling body pauses while the body of
     its setter is executed by the receiving instance with the assigned
     value, then,

   * finally, when execution of the setter ends, execution of the
     calling body resumes.


File: ceylon-spec.info,  Node: invocation,  Next: anonymousfunctionevaluation,  Prev: assignment,  Up: evaluationinvocationandassignment

8.4.4 Invocation
----------------

Evaluation of an invocation expression, as defined in *note Invocation
expressions: invocationexpressions, results in _invocation_ of a
function or callable constructor, or _instantiation_ of a class.  Every
invocation has a callable expression:

   * in a direct invocation, the callable expression is a callable
     reference, and

   * in an indirect invocation, the callable expression is an instance
     of 'Callable' that packages an underlying callable reference.

   In either case, the callable expression determines the instance and
member to be invoked.

     print("Hello world!")

     Entry(person.name, person)
   When an invocation expression is executed:

   * first, the callable expression is evaluated to obtain the receiving
     instance, then

   * each listed argument or spread argument is evaluated in turn in the
     calling body, and

   * if the argument list has a comprehension, a comprehension instance,
     as defined in *note Evaluation of comprehensions:
     comprehensionevaluation, is obtained, and then

   * the actual declaration to be invoked is determined by considering
     the runtime type of the receiving instance, if any, and then

   * execution of the calling body pauses while the body of the function
     or initializer is executed by the receiving instance with the
     argument values, then

   * finally, when execution of the function or initializer ends,
     execution of the calling body resumes.

   A function invocation evaluates to the return value of the function,
as specified by the 'return' directive.  The argument values are passed
to the parameters of the method, and the body of the method is executed.

   A class instantiation evaluates to a new instance of the class.  The
argument values are passed to the initializer parameters of the class,
and the initializer is executed.


File: ceylon-spec.info,  Node: anonymousfunctionevaluation,  Next: enumerationevaluation,  Prev: invocation,  Up: evaluationinvocationandassignment

8.4.5 Evaluation of anonymous functions
---------------------------------------

When an anonymous function expression, as defined in *note Anonymous
functions: anonymousfunctions, is evaluated, a reference to the function
and a reference to the current frame or instance of every containing
body are packaged into an instance of 'Callable'.  The instance of
'Callable' is the resulting value of the expression.  The concrete class
of this instance is not specified here.


File: ceylon-spec.info,  Node: enumerationevaluation,  Next: spreadevaluation,  Prev: anonymousfunctionevaluation,  Up: evaluationinvocationandassignment

8.4.6 Evaluation of enumerations
--------------------------------

Evaluation of an enumeration expression, as defined in *note Iterable
and tuple enumeration: enumeration, results in creation of an iterable
stream or tuple.

     { "hello", "world" }

     [ new, *elements ]
   When an iterable enumeration expression is executed, a reference to
the enumeration expression, together with a reference to the current
frame or instance of every containing body, together with a
comprehension instance, as defined in *note Evaluation of
comprehensions: comprehensionevaluation, in the case that the
enumeration expression has a comprehension, are packaged together into a
stream. Evaluation of an expression occurring in the enumeration
expression occurs in the context of the packaged framed associated with
the stream.  When the stream is iterated, it produces, in turn:

   * one value for each listed argument, by evaluating the listed
     argument expression, and then

   * if the argument list has a spread argument, each value produced by
     the spread argument, or

   * if the argument list has a comprehension, each value produced by
     the comprehension instance, or

   * if there are no arguments, and no comprehension, the stream is
     empty and produces no values.

   When a tuple enumeration expression is executed:

   * first, each listed argument or spread argument is evaluated in turn
     in the calling body, and

   * if the argument list has a comprehension, a comprehension instance,
     as defined in *note Evaluation of comprehensions:
     comprehensionevaluation, is obtained, and then

   * the resulting argument values are packaged into an instance of
     'Iterable' or 'Sequence', and this object is the resulting value of
     the enumeration expression, unless

   * there are no arguments, and no comprehension, in which case the
     resulting value of the enumeration expression is the object
     'empty'.

   In the case of an iterable enumeration, the concrete class of the
resulting value is not specified here.  In the case of a tuple
enumeration it is always 'Tuple', 'Empty', or 'Sequence'.


File: ceylon-spec.info,  Node: spreadevaluation,  Prev: enumerationevaluation,  Up: evaluationinvocationandassignment

8.4.7 Evaluation of spread arguments and comprehensions
-------------------------------------------------------

A spread argument, as defined in *note Spread arguments:
spreadarguments, produces multiple values by iterating the iterable
object to which the spread operator is applied.

   When a spread argument expression type is a subtype of 'Sequential',
the behavior does not depend upon where the spread argument occurs:

   * If it occurs as an argument, the sequence produced by evaluating
     the expression is passed directly to the parameter.

   * If it occurs in an enumeration expression, the sequence produced by
     evaluating the expression is appended directly to the resulting
     iterable object or tuple.

   On the other hand, when a spread argument expression type is not a
subtype of 'Sequential', the behavior depends upon where the spread
argument occurs:

   * If it occurs as an argument to a variadic parameter in a positional
     argument list, the values produced by a spread argument are
     evaluated immediately and packaged into an instance of 'Sequence'
     and passed to the variadic parameter, unless there are no values,
     in which case the object 'empty' is passed to the variadic
     parameter.

   * If it occurs as an argument to a parameter of type 'Iterable' at
     the end of a named argument list, the iterable object produced by
     evaluating the expression is passed directly to the parameter.

   * If it occurs in a tuple enumeration, the values produced by a
     spread argument are evaluated immediately and packaged into an
     instance of 'Sequence' and appended to the resulting tuple.

   * If it occurs in an iterable enumeration, the iterable object
     produced by evaluating the expression is chained directly to the
     resulting iterable object.

   Likewise, a comprehension, as defined in *note Comprehensions:
comprehensions, produces multiple values, as specified by *note
Evaluation of comprehensions: comprehensionevaluation. The behavior
depends upon where the comprehension occurs:

   * If it occurs as an argument to a variadic parameter in a positional
     argument list, the values produced by the comprehension instance
     are evaluated immediately, packaged into an instance of 'Sequence',
     and passed to the variadic parameter, unless there are no values,
     in which case the object 'empty' is passed to the variadic
     parameter.

   * If it occurs as an argument to a parameter of type 'Iterable' at
     the end of a named argument list, the comprehension instance is
     packaged into an iterable object that produces the values of the
     comprehension on demand, and this iterable object is passed
     directly to the parameter.  The concrete class of this object is
     not specified here.

   * If it occurs in a tuple enumeration, the values produced by the
     comprehension instance are evaluated immediately, packaged into an
     instance of 'Sequence', and appended to the resulting tuple.

   * If it occurs in an iterable enumeration, the comprehension instance
     is packaged into an iterable object that produces the values of the
     comprehension on demand, and this iterable object is chained
     directly to the resulting iterable object.  The concrete class of
     this object is not specified here.


File: ceylon-spec.info,  Node: operatorexpressions,  Next: comprehensionevaluation,  Prev: evaluationinvocationandassignment,  Up: execution

8.5 Operator expressions
========================

* Menu:


* operatorexpressionoptimization:: Operator expression optimization
* numericoperations:: Numeric operations

Most operator expression are defined in terms of function invocation,
value evaluation, or a combination of invocations and evaluations, as
specified in *note Operators: operators.  The semantics of evaluation of
an operator expression therefore follows from the above definitions of
evaluation and invocation and from its definition in terms of evaluation
and invocation.

   However, this specification allows the compiler to take advantage of
the optimized support for primitive value types provided by the virtual
machine environment.


File: ceylon-spec.info,  Node: operatorexpressionoptimization,  Next: numericoperations,  Up: operatorexpressions

8.5.1 Operator expression optimization
--------------------------------------

As a special exception to the rules, the compiler is permitted to
optimize certain operations upon certain types in the module
'ceylon.language'. These types are: 'Integer', 'Float', 'Character',
'Range', 'Entry', 'String', 'Array', and 'Tuple'.

   Thus, the tables in the previous chapter define semantics only.  The
compiler may emit bytecode or compiled JavaScript that produces the same
value at runtime as the pseudo-code that defines the operator, without
actually executing any invocation, for the following operators:

   * all arithmetic operators,

   * the comparison and equality operators '==', '!=', '<=>', '<', '>',
     '<=', '>=' when the argument expression types are built-in numeric
     types, and

   * the 'Range' and 'Entry' construction operators '..', ':', and '->'.

   In all operator expressions, the arguments of the operator must be
evaluated from left to right when the expression is executed.  In
certain cases, depending upon the definition of the operator, evaluation
of the leftmost argument expression results in a value that causes the
final value of the operator expression to be produced immediately
without evaluation of the remaining argument expressions.  Optimizations
performed by the Ceylon compiler must not alter these behaviours.

     Note: this restriction exists to ensure that any effects are not
     changed by the optimizations.


File: ceylon-spec.info,  Node: numericoperations,  Prev: operatorexpressionoptimization,  Up: operatorexpressions

8.5.2 Numeric operations
------------------------

The arithmetic operations defined in *note Arithmetic operators:
arithmetic. for values of type 'Integer' and 'Float' are defined in
terms of methods of the interface 'Numeric'. However, these methods
themselves make use of the native operations of the underlying virtual
machine.  Likewise, values of type 'Integer' and 'Float' are actually
represented in terms of a format native to the virtual machine.

   It follows that the precise behavior of numeric operations depends
upon the virtual machine upon which the program executes.  However,
certain behaviours are common to supported virtual machines:

   * Values of type 'Float' are represented according to the IEEE 754
     specification, _IEEE Standard for Binary Floating-Point
     Arithmetic_, and floating point numeric operations conform to this
     specification.  Where possible, a double-precision 64-bit
     representation is used.  It is possible on both Java and JavaScript
     virtual machines.

   * Where possible, values of type 'Integer' are represented in two's
     complement form using a fixed bit length.  Where possible, a 64-bit
     representation is used.  Overflow and underflow wrap silently.
     This is the case for the Java Virtual Machine.

   * Otherwise, values of type 'Integer' are represented according to
     the IEEE 754 specification.  This is the case for JavaScript
     virtual machines.

   Platform-dependent behavior of numeric operations is defined in the
Java Language Specification, and the ECMAScript Language Specification.

     It might be argued that having platform-dependent behavior for
     numeric operations opens up the same portability concerns that
     affected languages like C in the past.  However, the cross-platform
     virtual machines supported by Ceylon already provide a layer of
     indirection that substantially eases portability concerns.  Of
     course, numeric code is not guaranteed to be completely portable
     between the Java and JavaScript virtual machines, but it's
     difficult to imagine how such a level of portability could
     reasonably be achieved.


File: ceylon-spec.info,  Node: comprehensionevaluation,  Next: concurrency,  Prev: operatorexpressions,  Up: execution

8.6 Evaluation of comprehensions
================================

* Menu:


* forclause:: for clause
* ifclause:: if clause
* expressionclause:: Expression clause

When a comprehension, as specified in *note Comprehensions:
comprehensions, is evaluated, a reference to the comprehension, together
with a reference to the current frame or instance of every containing
body, are packaged together into a _comprehension instance_.  A
comprehension instance is not considered a value in the sense of *note
Object instances: (identity)objectinstancesidentity. Instead, it is a
stream of values, each produced by evaluating the expression clause of
the comprehension.

   A comprehension consists of a series of clauses.  Each clause of a
comprehension, except for the expression clause that terminates the list
of clauses, produces a stream of _frames_.  A frame is a set of values
for iteration variables and condition variables declared by the clause
and its parent clauses.

     Note: each child clause can be viewed as a body nested inside the
     parent clause.  The lifecycle of comprehension frames reflects this
     model.

   Evaluation of an expression occurring in a comprehension clause
occurs in the context of the packaged frames associated with the
comprehension instance together with a comprehension frame associated
with the clause.


File: ceylon-spec.info,  Node: forclause,  Next: ifclause,  Up: comprehensionevaluation

8.6.1 for clause
----------------

The expression which produces the source stream for a child 'for' clause
may refer to an iteration variable of a parent 'for' clause.  In this
case the child clause is considered _correlated_.  Otherwise it is
considered _uncorrelated_.

   In either case, the child clause produces a stream of frames. For
each frame produced by the parent clause, and for each value produced by
the source stream of the child clause, the child clause produces a frame
consisting of the parent clause frame extended by the iteration variable
value defined by the child clause.

   This comprehension has a correlated 'for' clause. For each character
'c' in each string 'w' in 'words', the child 'for' clause produces the
frame '{ String word=w; Character char=c; }'.

     for (word in words) for (char in word) char
   This comprehension has an uncorrelated 'for' clause. For each string
'n' in 'nouns', and each string 'a' in 'adjectives', the child 'for'
clause produces the frame '{ String noun=n; String adj=a; }'.

     for (noun in nouns) for (adj in adjectives) adj + " " + noun


File: ceylon-spec.info,  Node: ifclause,  Next: expressionclause,  Prev: forclause,  Up: comprehensionevaluation

8.6.2 if clause
---------------

A child 'if' clause filters its parent clause frames. For every frame
produced by the parent clause which satisfies the condition list of the
child clause, the child clause produces that frame, extended by any
condition variable defined by the child clause.

   This comprehension has an 'if' clause.  For each object 'o' in
'objects' that is a nonempty 'String', the 'if' clause produces the
frame '{ Object obj=o; String str=o; }'.

     for (obj in objects) if (is String str=obj, !str.empty) str


File: ceylon-spec.info,  Node: expressionclause,  Prev: ifclause,  Up: comprehensionevaluation

8.6.3 Expression clause
-----------------------

As specified in *note Comprehensions: comprehensions, every
comprehension ends in an expression clause.  An expression clause
produces a single value for each frame produced by its parent clause, by
evaluating the expression in the frame. These resulting values are the
values returned by the whole comprehension.


File: ceylon-spec.info,  Node: concurrency,  Prev: comprehensionevaluation,  Up: execution

8.7 Concurrency
===============

Neither this specification nor the module 'ceylon.language' provide any
facility to initiate or control concurrent execution of a program
written in Ceylon.  However, a Ceylon program executing on the Java
Virtual Machine may interact with Java libraries (and other Ceyon
modules) that make use of concurrency.

   In this scenario, the execution of a Ceylon program is governed by
the rules laid out by the Java programming language's execution model
(Chapter 17 of the Java Language Specification).  Ceylon references
belonging to a class or interface are considered _fields_ in the sense
of the JLS. Any such refence not explicitly declared 'variable' is
considered a _final field_.  Evaluation of a reference is considered a
_use_ operation, and assignment to or specification of a variable
reference is considered an _assign_ operation, again in terms of the
JLS.


File: ceylon-spec.info,  Node: modulesystem,  Next: index,  Prev: execution,  Up: Top

9 Module system
***************

* Menu:


* moduleruntime:: The module runtime and module isolation
* sourcelayout:: Source layout
* modules:: Module architecture

The Ceylon module architecture enables a toolset which relieves
developers of many mundane tasks.  The module system specifies:

   * the format of packaged deployable module archives (for the Java
     platform), module scripts (for the JavaScript platform), and source
     archives,

   * the layout of a module repository

   * the format of the package descriptor files which contain
     information about the packages contained in a module, including
     whether a package is visible to other modules, and

   * the format of the module descriptor file which contains information
     about a module, along with a list of its versioned dependencies.

   Thus, developers are never exposed to individual '.class' files, and
are not required to manually manage module archives using the operating
system file manager.  Instead, the toolset helps automate the management
of modules within module repositories.

   Circular dependencies between modules are not supported.  The Ceylon
compiler detects such dependencies and produces an error.


File: ceylon-spec.info,  Node: moduleruntime,  Next: sourcelayout,  Up: modulesystem

9.1 The module runtime and module isolation
===========================================

* Menu:


* classloaders:: Module isolation for the Java platform
* requirejs:: Module isolation for the JavaScript platform
* assemblies:: Assemblies

At any time, there may be multiple versions of a certain module
available in the virtual machine.  Modules execute under the control of
the _module runtime_.  The module runtime:

   * obtains modules from module repositories,

   * reads module metadata and recursively loads dependencies, and

   * isolates modules that belong to different assemblies.

   Execution of a module begins with a specified toplevel method or
class, or with an entry point specified in the module descriptor, and
imported modules are loaded lazily as classes they contain are needed.
The name and version id of the imported module containing the needed
class are determined from the imported package name specified by the
compilation unit and the imported module version specified by the module
descriptor.

   The mechanism behind this is platform-dependent.


File: ceylon-spec.info,  Node: classloaders,  Next: requirejs,  Up: moduleruntime

9.1.1 Module isolation for the Java platform
--------------------------------------------

In the JVM environment, each version of each module is loaded using a
different class loader.  Classes inside a module have access to other
classes in the same module and to classes belonging to modules that are
explicitly imported in the module descriptor. Classes in other modules
are not accessible.

   Ceylon supports a simplified class loader architecture:

   * The _bootstrap_ class loader owns classes required to bootstrap the
     module runtime.  It is the direct parent of all module class
     loaders, and its classes are visible to all module class loaders.

   * A _module_ class loader owns classes belonging to a given version
     of a certain module.  Its classes are visible only to classes
     belonging to the module class loader of a module which declares an
     explicit dependency on the given version of the first module.

     The Ceylon module runtime for the JVM is implemented using JBoss
     Modules.  It is included in the Ceylon SDK.


File: ceylon-spec.info,  Node: requirejs,  Next: assemblies,  Prev: classloaders,  Up: moduleruntime

9.1.2 Module isolation for the JavaScript platform
--------------------------------------------------

In the JavaScript environment, modules are loaded using the 'require()'
function defined by CommonJS Modules.

     There are various implementations of the CommonJS-style 'require()'
     function, and Ceylon module scripts should work with any of them.


File: ceylon-spec.info,  Node: assemblies,  Prev: requirejs,  Up: moduleruntime

9.1.3 Assemblies
----------------

     A future release of the language will add support for assemblies,
     that is, the ability to:

        * package together several interdependent versioned modules into
          a single archive for deployment as a single well-defined
          application or service,

        * specify the name and version of the application or service,
          and

        * override the versions of imported modules declared in
          'modules.ceylon', as defined in *note Module descriptors:
          moduledescriptors, with assembly-specific module versions.

     An assembly archive will probably just be an archived module
     repository with an assembly descriptor.


File: ceylon-spec.info,  Node: sourcelayout,  Next: modules,  Prev: moduleruntime,  Up: modulesystem

9.2 Source layout
=================

A _source directory_ contains Ceylon source code in files with the
extension '.ceylon' and Java source code in files with the extension
'.java'. The module and package to which a compilation unit belongs is
determined by the subdirectory in which the source file is found.

   The name of the package to which a compilation unit belongs is formed
by replacing every path directory separator character with a period in
the relative path from the root source directory to the subdirectory
containing the source file.  In the case of a Java source file, the
subdirectory must agree with the package specified by the Java 'package'
declaration.

   The name of the module to which a compilation unit belongs is
determined by searching all containing directories for a module
descriptor.  The name of the module is formed by replacing every path
directory separator character with a period in the relative path from
the source directory to the subdirectory containing the module
descriptor.  If no module descriptor is found, the code belongs to the
_default module_.

     Note: the default module is intended only as a convenience for
     experimental code.

   A package or compilation unit may belong to only one module.  No more
than one module descriptor may occur in the containing directories of a
compilation unit.

   Thus, the structure of the source directory containing the module
'org.hello' might be the following:

     source/ org/ hello/ module.ceylon //the module descriptor main/
     hello.ceylon default/ DefaultHello.ceylon personalized/
     PersonalizedHello.ceylon
   The source code for multiple modules may be contained in a single
source directory.


File: ceylon-spec.info,  Node: modules,  Prev: sourcelayout,  Up: modulesystem

9.3 Module architecture
=======================

* Menu:


* modulenamesandversionidentifiers:: Module names and version identifiers
* modulearchivenamesjava:: Module archive names for the Java platform
* modulescriptnamesjs:: Module script names for the JavaScript platform
* sourcearchivenames:: Source archive names
* modulearchives:: Module archives
* modulescripts:: Module scripts
* sourcearchives:: Source archives
* modulerepositories:: Module repositories
* packagedescriptors:: Package descriptors
* moduledescriptors:: Module descriptors

Compiled code is automatically packaged into _module archives_ and
_module scripts_ by the Ceylon compiler.  A _module repository_ is a
repository containing module archives, module scripts, and other
miscellaneous artifacts.  A module archive or module script is
automatically obtained from a module repository when code belonging to
the module is needed by the compiler or module runtime.

   Modules that form part of the Ceylon SDK are found in the module
repository in the 'modules' directory of the Ceylon distribution.

   Red Hat maintains a central module repository at
'http://modules.ceylon-lang.org'.  Read access to this site is free of
registration and free of charge.  Ceylon projects may apply for a user
account which provides write access to the central module repository.

   A module belonging to the central module repository must satisfy the
following regulations:

   * the first element of the module name must be a top-level internet
     domain name, and the second element of the module name must be a
     second-level domain of the given top-level domain owned by the
     organization distributing the module, and.

   * the module must be made available under a royalty-free license.

   For example, a module developed by Red Hat might be named
'org.jboss.server'.

     TODO: should we require that module archives be signed using the
     Java 'jarsigner' tool?


File: ceylon-spec.info,  Node: modulenamesandversionidentifiers,  Next: modulearchivenamesjava,  Up: modules

9.3.1 Module names and version identifiers
------------------------------------------

A module _name_ is a period-separated list of initial lowercase
identifiers, for example:

     ceylon.language

     org.hibernate
   It is recommended that module names follow the Java package naming
convention embedding the organization's domain name (in this case,
'hibernate.org').  The namespace 'ceylon' is reserved for Ceylon SDK
modules.  The namespace 'java' is reserved for modules belonging to the
Java SDK. The namespace 'default' is reserved for the default module.

   It is highly recommended, but not required, that every user-written
module have at least three identifiers in its name. Therefore,
'org.hibernate.orm' is strongly preferred to 'org.hibernate'.

   Modules may not be "nested".  That is, the list of identifiers
forming the name of a module may not be a prefix of the list of
identifiers forming the name of another module.

   A package belongs to a module if the list of identifiers forming the
name of the module is a prefix of the list of identifiers forming the
name of the package.  For example, the packages:

     ceylon.language

     ceylon.language.assertion

     ceylon.language.meta

     ceylon.language.meta.declaration
   belong to the module 'ceylon.language'.  The packages:

     org.hibernate

     org.hibernate.impl

     org.hibernate.cache
   belong to the module 'org.hibernate'.

     TODO: This might not work out all that well in practice, unless we
     introduce some additional convention for "extras" modules, for
     example, modules containing examples.  It could be 'org.hibernate'
     vs 'org.hibernate_example' or 'org.hibernate.core' vs
     'org.hibernate.example'.

   The name of the default module is 'default'.  The default module has
no version and cannot be published to a remote repository nor to the
local repository cache under '~/.ceylon/repo'.

   A module _version identifier_ is a character string containing no
whitespace, for example:

     1.0.1

     3.0.0.beta

     TODO: at some stage we will probably need to add a format for
     specifying version ranges.


File: ceylon-spec.info,  Node: modulearchivenamesjava,  Next: modulescriptnamesjs,  Prev: modulenamesandversionidentifiers,  Up: modules

9.3.2 Module archive names for the Java platform
------------------------------------------------

A _module archive name_ is constructed from the module name and version
identifier.  A module archive name is of the following standard form:

     _<module>_-_<version>_.car
   where '_<module>_' is the full name of the module, and '_<version>_'
is the module version identifier.  For example:

     ceylon.language-1.0.1.car

     org.hibernate-3.0.0.beta.car
   The default module has no version, its module archive name is
'default.car'


File: ceylon-spec.info,  Node: modulescriptnamesjs,  Next: sourcearchivenames,  Prev: modulearchivenamesjava,  Up: modules

9.3.3 Module script names for the JavaScript platform
-----------------------------------------------------

A _module script name_ is likewise constructed from the module name and
version identifier.  A module script name is of the following standard
form:

     _<module>_-_<version>_.js
   where '_<module>_' is the full name of the module, and '_<version>_'
is the module version identifier.  For example:

     ceylon.language-1.0.1.js

     org.hibernate-3.0.0.beta.js
   The default module has no version, its module archive name is
'default.js'


File: ceylon-spec.info,  Node: sourcearchivenames,  Next: modulearchives,  Prev: modulescriptnamesjs,  Up: modules

9.3.4 Source archive names
--------------------------

A _source archive name_ is of the following standard form:

     _<module>_-_<version>_.src
   For example:

     ceylon.language-1.0.1.src

     org.hibernate-3.0.0.beta.src
   The default module has no version, its source archive name is
'default.src'


File: ceylon-spec.info,  Node: modulearchives,  Next: modulescripts,  Prev: sourcearchivenames,  Up: modules

9.3.5 Module archives
---------------------

A Ceylon module archive is a Java 'jar' archive which:

   * contains a Ceylon module descriptor in the _module directory_,

   * contains the compiled '.class' files for all compilation units
     belonging to the module, and

   * has a filename which adheres to the standard for module archive
     names.

   The _module directory_ of the module archive is formed by replacing
each period in the fully qualified package name with the directory
separator character.  For example, the module directory for the module
'ceylon.language' is:

     /ceylon/language
   The module directory for the module 'org.hibernate' is:

     /org/hibernate
   The _package directory_ for a package belonging to the module archive
is formed by replacing each period in the fully qualified package name
with the directory separator character.  For example, the package
directory for the package 'org.hibernate.impl' is:

     /org/hibernate/impl
   Inside a module archive, a '.class' file is found in the package
directory of the package to which it belongs.

   Thus, the structure of the module archive for the module 'org.hello'
might be the following:

     org.hello-1.0.0.car META-INF/ MANIFEST.MF org/ hello/ module.class
     //the module descriptor main/ package.class //a package descriptor
     hello.class default/ DefaultHello.class personalized/
     PersonalizedHello.class
   A module archive may not contain multiple modules.


File: ceylon-spec.info,  Node: modulescripts,  Next: sourcearchives,  Prev: modulearchives,  Up: modules

9.3.6 Module scripts
--------------------

A Ceylon module script is a JavaScript source file which:

   * complies with the CommonJS Modules specification, and

   * has a filename which adheres to the standard for module script
     names.


File: ceylon-spec.info,  Node: sourcearchives,  Next: modulerepositories,  Prev: modulescripts,  Up: modules

9.3.7 Source archives
---------------------

A _source archive_ is a 'zip' archive which:

   * contains the source code ('.ceylon' and '.java' files) for all
     compilation units belonging to the module, and

   * has a filename which adheres to the standard for source archive
     names.

   Inside a source archive, a Ceylon or Java source file is located in
the _package directory_ of the package to which the compilation unit
belongs.  The package directory for a package belonging to the source
archive is formed by replacing each period in the fully qualified
package name with the directory separator character.

   Thus, the structure of the source archive for the module 'org.hello'
might be the following:

     org.hello-1.0.0.src org/ hello/ module.ceylon //the module
     descriptor main/ package.ceylon //a package descriptor hello.ceylon
     default/ DefaultHello.ceylon personalized/ PersonalizedHello.ceylon
   A source archive may not contain the source of multiple modules.


File: ceylon-spec.info,  Node: modulerepositories,  Next: packagedescriptors,  Prev: sourcearchives,  Up: modules

9.3.8 Module repositories
-------------------------

A module repository is a directory structure on the local filesystem or
a remote HTTP server.

   * A _local_ module repository is identified by a filesystem path.

   * A _remote_ module repository is identified by a URL with protocol
     'http:' or 'https:'.

   A _publishable_ module repository is a local module repository, or a
WebDAV-enabled remote module repository.

   For example:

     modules

     /usr/bin/ceylon/modules

     http://jboss.org/ceylon/modules

     https://gavin:secret@modules.ceylon-lang.org
   A module repository contains module archives, module scripts, source
archives, and documentation.  The address of an artifact belonging to
the repository adheres to the following standard form:

     _<repository>_/_<module-path>_/_<version>_/_<artifact>_
   where '_<repository>_' is the filesystem path or URL of the
repository, '_<artifact>_' is the name of the artifact, '_<version>_' is
the module version, and '_<module-path>_' is formed by replacing every
period with a slash in the module name.

   The default module having no version, its access path does not
contain the version.

     _<repository>_/default/_<archive>_
   For example, the module archive 'ceylon.language-1.0.1.car', module
script, 'ceylon.language-1.0.1.js', and source archive
'ceylon.language-1.0.1.src', belonging to the repository included in the
Ceylon SDK are obtained from the following addresses:

     modules/ceylon/language/1.0.1/ceylon.language-1.0.1.car

     modules/ceylon/language/1.0.1/ceylon.language-1.0.1.js

     modules/ceylon/language/1.0.1/ceylon.language-1.0.1.src
   The module archive 'org.hibernate-3.0.0.beta.car' and source archive
'org.hibernate-3.0.0.beta.src' belonging to the repository
'http://jboss.org/ceylon/modules' are obtained from the following
addresses:

     http://jboss.org/ceylon/modules/org/hibernate/3.0.0.beta/org.hibernate-3.0.0.beta.car

     http://jboss.org/ceylon/modules/org/hibernate/3.0.0.beta/org.hibernate-3.0.0.beta.src
   The legacy Java 'jar' archive 'org.h2-1.2.141.jar' belonging to the
repository '/usr/bin/ceylon/modules' is obtained from the following
address:

     /usr/bin/ceylon/modules/org/h2/1.2.141/org.h2-1.2.141.jar
   For each archive, the module repository may contain a SHA-1 checksum
file.  The checksum file is a plain text file containing just the SHA-1
checksum of the archive.  The address of a checksum file adheres to the
following standard form:

     _<repository>_/_<module-path>_/_<version>_/_<archive>_.sha1
   The compiler or module runtime verifies the checksum after
downloading the archive from the module repository.

   A module repository may contain documentation generated by the Ceylon
documentation compiler in exploded form.  A module's documentation
resides in the _module documentation directory_, a directory with
address adhering to the following standard form:

     _<repository>_/_<module-path>_/_<version>_/module-doc/
   For example, the home page for the documentation of the module
'org.hibernate' is:

     http://jboss.org/ceylon/modules/org/hibernate/module-doc/index.html


File: ceylon-spec.info,  Node: packagedescriptors,  Next: moduledescriptors,  Prev: modulerepositories,  Up: modules

9.3.9 Package descriptors
-------------------------

A _package descriptor_ is defined in a source file named
'package.ceylon' in the package it describes.

PackageDescriptor: Annotations "package" FullPackageName ";"
   A 'package' may be annotated 'shared'. A 'shared' package is visible
outside the containing module, that is, in any module which imports the
containing module.

   The package descriptor is optional for unshared packages.

     "The typesafe query API."
     license ("http://www.gnu.org/licenses/lgpl.html")
     shared package org.hibernate.query;


File: ceylon-spec.info,  Node: moduledescriptors,  Prev: packagedescriptors,  Up: modules

9.3.10 Module descriptors
-------------------------

A _module descriptor_ is defined in a source file named 'module.ceylon'
in the root package of the module it describes (the package with the
same name as the module).

ModuleDescriptor: Annotations "module" FullPackageName StringLiteral ModuleBody
   The literal string after the module name specifies the version of the
module.

   A module may import other modules.

ModuleBody: "{" ModuleImport* "}"

ModuleImport: Annotations "import" (FullPackageName|StringLiteral) StringLiteral ";"
   The name of the imported module may be specified using the usual
syntax for a module name, or as a literal string, to allow
interoperation with legacy module repositories existing outside the
Ceylon ecosystem.

     Note: this enables interoperation with Maven.

     Note: in Ceylon 1.0 it is illegal to explicitly import the module
     'ceylon.language'.  The language module is always implicitly
     imported.

   The string literal after the imported module name specifies the
version of the imported module.

   An imported module may be annotated 'optional' and/or 'shared'.

   * If module 'x' has a 'shared' import of module 'y', then any module
     that imports 'x' implicitly imports 'y'.

   * If module 'x' has an 'optional' import of module 'y', then 'x' may
     be executed even if 'y' is not available at runtime.

   If a declaration belonging to module 'x' is visible outside the
module and involves types imported from a different module 'y', then the
module import of 'y' in the module descriptor for 'x' must be 'shared'.

     "The best-ever ORM solution!"
     license ("http://www.gnu.org/licenses/lgpl.html")
     module org.hibernate "3.0.0.beta" {
         shared import ceylon.language "1.0.1";
         import javax.sql "4.0";
     }

     "The test suite for Hibernate"
     license ("http://www.gnu.org/licenses/lgpl.html")
     module org.hibernate.test "3.0.0.beta" {
         import org.hibernate "3.0.0.beta";
         TestSuite().run();
     }

     TODO: do we allow procedural code in the body of a 'module'?


File: ceylon-spec.info,  Node: index,  Prev: modulesystem,  Up: Top

Index
*****

 [index ]
* Menu:

* Abstract, final, sealed, formal, and default classes: abstractandformalclasses.
                                                                (line 6)
* Alias imports:                         aliasimports.          (line 6)
* Annotation arguments:                  annotationargments.    (line 6)
* Annotation constructors:               annotationconstructors.
                                                                (line 6)
* Annotation definition:                 annotationdefinition.  (line 6)
* Annotation lists:                      annotationlists.       (line 6)
* Annotation types:                      annotationtypes.       (line 6)
* Annotation values:                     annotationvalues.      (line 6)
* Annotations:                           annotations.           (line 6)
* Annotations of program elements:       programelementannotations.
                                                                (line 6)
* Anonymous arguments:                   anonymousarguments.    (line 6)
* Anonymous class imports:               anonymousclassimports. (line 6)
* Anonymous classes:                     anonymousclasses.      (line 6)
* Anonymous function parameter type inference: parametertypeinference.
                                                                (line 6)
* Anonymous functions:                   anonymousfunctions.    (line 6)
* Applied types and and variance:        producedtypes.         (line 6)
* Arithmetic operators:                  arithmetic.            (line 6)
* Assemblies:                            assemblies.            (line 6)
* Assertions:                            assertions.            (line 6)
* Assignability conditions:              assignabilityconditions.
                                                                (line 6)
* Assignment:                            assignment.            (line 6)
* Attribute refinement:                  attributerefinement.   (line 6)
* Base expressions:                      baseexpressions.       (line 6)
* Basic invocation and assignment operators: basic.             (line 6)
* Block structure and references:        blockstructure.        (line 6)
* Blocks and statements:                 blocksandstatements.   (line 6)
* Boolean conditions:                    booleanconditions.     (line 6)
* Callable parameters:                   callableparameters.    (line 6)
* Callable references:                   callablereferences.    (line 6)
* Callable type of a class:              callabletypeofclass.   (line 6)
* Callable type of a constructor:        callabletypeofaconstructor.
                                                                (line 6)
* Callable type of a function:           callabletypeoffunction.
                                                                (line 6)
* Case conditions:                       caseconditions.        (line 6)
* Case enumeration and coverage:         casesandcoverage.      (line 6)
* Cases:                                 cases.                 (line 6)
* Character literals:                    characterliterals.     (line 6)
* Character literals <1>:                character.             (line 6)
* Character string literals:             string.                (line 6)
* Class aliases:                         classaliases.          (line 6)
* Class inheritance:                     classinheritance.      (line 6)
* Class initialization and instantiation: initializationandinstantiation.
                                                                (line 6)
* Class instance optimization:           classinstanceoptimization.
                                                                (line 6)
* Classes:                               classes.               (line 6)
* Comments:                              comments.              (line 6)
* Compilation unit structure:            compilationunitstructure.
                                                                (line 6)
* Compile-time safety for null values and flow-sensitive typing: compiletimesafety.
                                                                (line 6)
* Compound expressions:                  compoundexpressions.   (line 6)
* Comprehensions:                        comprehensions.        (line 6)
* Concurrency:                           concurrency.           (line 6)
* Conditional expressions, let expressions, and anonymous class expressions: miscexpressions.
                                                                (line 6)
* Conditional operators:                 conditionals.          (line 6)
* Conditions:                            controlstructureconditions.
                                                                (line 6)
* Constrained annotation types:          constrainedannotationtypes.
                                                                (line 6)
* Constructor delegation:                constructordelegation. (line 6)
* Constructor expressions:               constructorexpressions.
                                                                (line 6)
* Constructors:                          constructors.          (line 6)
* Control directives:                    controldirectives.     (line 6)
* Control structures and assertions:     controlstructures.     (line 6)
* Correspondence, subrange, and stream operators: listmap.      (line 6)
* Coverage:                              coverage.              (line 6)
* Current frame of a block:              currentframeofablock.  (line 6)
* Current instance of a class or interface: currentinstanceofaclassorinterface.
                                                                (line 6)
* Current instances and current frames:  currentinstancesandcurrentframes.
                                                                (line 6)
* Declaration modifiers:                 declarationmodifiers.  (line 6)
* Declaration name uniqueness:           declarationnameuniqueness.
                                                                (line 6)
* Declaration references:                declarationreferences. (line 6)
* Declaration section:                   declarationsection.    (line 6)
* Declarations:                          declarations.          (line 6)
* Default arguments:                     defaultarguments.      (line 6)
* Defaulted parameters:                  defaultedparameters.   (line 6)
* Defaulted parameters and variadic parameters: defaultparameters.
                                                                (line 6)
* Definite initialization:               definiteinitialization.
                                                                (line 6)
* Definite return:                       definitereturn.        (line 6)
* Definite uninitialization:             definiteuninitialization.
                                                                (line 6)
* Destructuring statements:              destructuringstatements.
                                                                (line 6)
* Direct invocations:                    directinvocations.     (line 6)
* Disjoint types:                        disjointtypes.         (line 6)
* Documentation:                         documentation.         (line 6)
* Dynamic blocks:                        dynamicblocks.         (line 6)
* Dynamic dispatch:                      dynamicdispatch.       (line 6)
* Dynamic enumerations:                  dynamicenumerations.   (line 6)
* Dynamic interfaces:                    dynamicinterfaces.     (line 6)
* Dynamic type checking:                 dynamictypechecking.   (line 6)
* Entry patterns:                        entrypatterns.         (line 6)
* Enumerated classes:                    classeswithcases.      (line 6)
* Enumerated interfaces:                 interfaceswithcases.   (line 6)
* Equality and comparison operators:     equalitycomparison.    (line 6)
* Evaluation:                            evaluation.            (line 6)
* Evaluation of anonymous functions:     anonymousfunctionevaluation.
                                                                (line 6)
* Evaluation of comprehensions:          comprehensionevaluation.
                                                                (line 6)
* Evaluation of condition lists:         evaluationofconditions.
                                                                (line 6)
* Evaluation of enumerations:            enumerationevaluation. (line 6)
* Evaluation of spread arguments and comprehensions: spreadevaluation.
                                                                (line 6)
* Evaluation, invocation, and assignment: evaluationinvocationandassignment.
                                                                (line 6)
* Exception handling:                    exceptionhandling.     (line 6)
* Exception propagation:                 exceptionpropagation.  (line 6)
* Execution:                             execution.             (line 6)
* Execution of conditionals:             executionofconditionals.
                                                                (line 6)
* Execution of control directives:       executionofcontroldirectives.
                                                                (line 6)
* Execution of control structures and assertions: executionofcontrolstructures.
                                                                (line 6)
* Execution of expression and specification statements: executionofexpressionandspecificationstatements.
                                                                (line 6)
* Execution of loops:                    executionofloops.      (line 6)
* Existence and nonemptiness conditions: existencenonemptinessconditions.
                                                                (line 6)
* Expression clause:                     expressionclause.      (line 6)
* Expression statements:                 expressionstatements.  (line 6)
* Expressions:                           expressions.           (line 6)
* Extension:                             extendedclass.         (line 6)
* First-class functions and higher-order programming: firstclassfunctions.
                                                                (line 6)
* Floating point number literals:        floatnumber.           (line 6)
* for clause:                            forclause.             (line 6)
* for/else:                              forelse.               (line 6)
* Formal and default attributes:         formalattributes.      (line 6)
* Formal and default methods:            formalmethods.         (line 6)
* Forward declaration of functions:      functionforwarddeclaration.
                                                                (line 6)
* Forward declaration of values:         valueforwarddeclaration.
                                                                (line 6)
* Frames:                                frames.                (line 6)
* Function and value imports:            methodattributeimports.
                                                                (line 6)
* Function return type inference:        returntypeinference.   (line 6)
* Functions:                             functions.             (line 6)
* Functions with blocks:                 functionswithblocks.   (line 6)
* Functions with multiple parameter lists: multipleparameterlists.
                                                                (line 6)
* Functions with specifiers:             functionswithspecifiers.
                                                                (line 6)
* Functions, methods, values, and attributes: methodsandattributes.
                                                                (line 6)
* Generic enumerated types:              genericenumeratedtypes.
                                                                (line 6)
* Generic type arguments:                generictypearguments.  (line 6)
* Generic type constraints:              generictypeconstraints.
                                                                (line 6)
* Generic type parameters:               generictypeparameters. (line 6)
* Getters:                               getters.               (line 6)
* Hidden declarations:                   hiddendeclarations.    (line 6)
* Identifier naming:                     identifiernaming.      (line 6)
* Identifiers and keywords:              identifiersandkeywords.
                                                                (line 6)
* if clause:                             ifclause.              (line 6)
* if/else:                               ifelse.                (line 6)
* if/then/else expressions:              ifexpressions.         (line 6)
* Imported name:                         importedname.          (line 6)
* Imports:                               imports.               (line 6)
* Inheritance:                           inheritance.           (line 6)
* Inheritance and subtyping:             inheritanceandsubtyping.
                                                                (line 6)
* Inherited instantiations:              inheritedinstantiations.
                                                                (line 6)
* Initialization:                        initialization.        (line 6)
* Initialization of late references:     lateinitialization.    (line 6)
* Initialization of toplevel references: toplevelinitialization.
                                                                (line 6)
* Initializer section:                   initializersection.    (line 6)
* Inline anonymous class expressions:    inlineanonymousclassexpressions.
                                                                (line 6)
* Inline declaration arguments:          inlinedeclarationarguments.
                                                                (line 6)
* Integer number literals:               naturalnumber.         (line 6)
* Interface aliases:                     interfacealiases.      (line 6)
* Interface bodies:                      interfacebodies.       (line 6)
* Interface inheritance:                 interfaceinheritance.  (line 6)
* Interfaces:                            interfaces.            (line 6)
* Intersection types:                    intersectiontypes.     (line 6)
* Introduction:                          introduction.          (line 6)
* Invocation:                            invocation.            (line 6)
* Invocation expressions:                invocationexpressions. (line 6)
* Iterable and tuple enumeration:        enumeration.           (line 6)
* Language annotations:                  languageannotations.   (line 6)
* Language module:                       thelanguagemodule.     (line 6)
* Language overview:                     languageoverview.      (line 6)
* Let expressions:                       letexpressions.        (line 6)
* Lexical structure:                     lexical.               (line 6)
* Listed arguments:                      listedarguments.       (line 6)
* Literal values:                        literalvalues.         (line 6)
* Literals:                              literals.              (line 6)
* Logical operators:                     logical.               (line 6)
* Member class refinement:               classrefinement.       (line 6)
* Member distinctness:                   memberdistinctness.    (line 6)
* Member expressions:                    memberexpressions.     (line 6)
* Metamodel expressions:                 metamodelexpressions.  (line 6)
* Metaprogramming:                       metaprogramming.       (line 6)
* Method refinement:                     methodrefinement.      (line 6)
* Mixin inheritance:                     mixininheritance.      (line 6)
* Modularity:                            modularity.            (line 6)
* Module architecture:                   modules.               (line 6)
* Module archive names for the Java platform: modulearchivenamesjava.
                                                                (line 6)
* Module archives:                       modulearchives.        (line 6)
* Module descriptors:                    moduledescriptors.     (line 6)
* Module isolation for the Java platform: classloaders.         (line 6)
* Module isolation for the JavaScript platform: requirejs.      (line 6)
* Module names and version identifiers:  modulenamesandversionidentifiers.
                                                                (line 6)
* Module repositories:                   modulerepositories.    (line 6)
* Module script names for the JavaScript platform: modulescriptnamesjs.
                                                                (line 6)
* Module scripts:                        modulescripts.         (line 6)
* Module system:                         modulesystem.          (line 6)
* Named argument lists:                  namedarguments.        (line 6)
* Named arguments and tree-like structures: structureddata.     (line 6)
* Naming conventions, annotations, and inline documentation: namingconventionsandannotations.
                                                                (line 6)
* Numeric and character types:           numerictypes.          (line 6)
* Numeric literals:                      numericliterals.       (line 6)
* Numeric operations:                    numericoperations.     (line 6)
* Object instances, identity, and reference passing: objectinstancesidentity.
                                                                (line 6)
* Object-oriented programming:           objectorientedprogramming.
                                                                (line 6)
* Operator definition:                   operatordefinition.    (line 6)
* Operator expression optimization:      operatorexpressionoptimization.
                                                                (line 6)
* Operator expressions:                  operatorexpressions.   (line 6)
* Operator precedence:                   operatorprecedence.    (line 6)
* Operators:                             operators.             (line 6)
* Operators and delimiters:              operatorsanddelimiters.
                                                                (line 6)
* Operators and operator polymorphism:   operatorsandoperatorpolymorphism.
                                                                (line 6)
* Operators for creating objects:        creation.              (line 6)
* Operators for handling null values:    nullvalues.            (line 6)
* outer:                                 outer.                 (line 6)
* Package and module references:         packageandmodulereferences.
                                                                (line 6)
* Package descriptors:                   packagedescriptors.    (line 6)
* Packages:                              packages.              (line 6)
* Parameter lists:                       parameterlists.        (line 6)
* Parameters:                            parameters.            (line 6)
* Partial constructors:                  partialconstructors.   (line 6)
* Pattern variables:                     patternvariables.      (line 6)
* Patterns:                              patterns.              (line 6)
* Patterns and variables:                patternsandvariables.  (line 6)
* Positional argument lists:             positionalarguments.   (line 6)
* Preface:                               preface.               (line 6)
* Principal instantiation inheritance:   principalinstantiationinheritance.
                                                                (line 6)
* Principal instantiation of a supertype: principalinstantiationofasupertype.
                                                                (line 6)
* Principal instantiations and polymorphism: principalinstantiations.
                                                                (line 6)
* Principal typing:                      principaltyping.       (line 6)
* Qualified reference resolution:        qualifiedreferenceresolution.
                                                                (line 6)
* Qualified types:                       qualifiedtypes.        (line 6)
* Realizations:                          realizations.          (line 6)
* Reference expressions:                 referenceexpressions.  (line 6)
* References:                            references.            (line 6)
* References and block structure:        referenceabilityofdeclaration.
                                                                (line 6)
* Refinement:                            refinement.            (line 6)
* Required parameters:                   requiredparameters.    (line 6)
* Runtime and platform:                  runtimeandplatform.    (line 6)
* Satisfaction:                          satisfiedinterfaces.   (line 6)
* Scope of a declaration:                scopeofdeclaration.    (line 6)
* Sealed interfaces:                     sealedinterfaces.      (line 6)
* Self references:                       selfreferences.        (line 6)
* Sequences and tuples:                  sequencesandtuples.    (line 6)
* Sequential execution and closure:      sequentialexecutionandclosure.
                                                                (line 6)
* Serialization:                         serialization.         (line 6)
* Set operators:                         sets.                  (line 6)
* Setters:                               setters.               (line 6)
* Simplified generics:                   simplifiedgenerics.    (line 6)
* Source archive names:                  sourcearchivenames.    (line 6)
* Source archives:                       sourcearchives.        (line 6)
* Source layout:                         sourcelayout.          (line 6)
* Specification statements:              specificationstatements.
                                                                (line 6)
* Specified arguments:                   specifiedarguments.    (line 6)
* Spread arguments:                      spreadarguments.       (line 6)
* Statements, blocks, and control structures: statementblocks.  (line 6)
* Static callable references:            staticcallablereferences.
                                                                (line 6)
* Static expressions:                    staticexpressions.     (line 6)
* Static value references:               staticvaluereferences. (line 6)
* Streams and comprehensions:            iterableobjectsandcomprehensions.
                                                                (line 6)
* String literals:                       stringliterals.        (line 6)
* String templates:                      stringtemplates.       (line 6)
* Subtyping:                             subtyping.             (line 6)
* Sum types, self types, and type families: algrebraictypesselftypes.
                                                                (line 6)
* super:                                 super.                 (line 6)
* switch/case/else:                      switchcaseelse.        (line 6)
* switch/case/else expressions:          switchexpressions.     (line 6)
* The bottom type:                       bottomtype.            (line 6)
* The module runtime and module isolation: moduleruntime.       (line 6)
* The type of a list of arguments:       tupletypeofarglist.    (line 6)
* this:                                  this.                  (line 6)
* Toplevel and nested declarations:      topleveldeclarations.  (line 6)
* try/catch/finally:                     trycatchfinally.       (line 6)
* Tuple patterns:                        tuplepatterns.         (line 6)
* Type abbreviations:                    typenameabbreviations. (line 6)
* Type alias elimination:                typealiaselimination.  (line 6)
* Type aliases:                          typealiasedeclarations.
                                                                (line 6)
* Type aliases and type inference:       typealiasesandtypeinference.
                                                                (line 6)
* Type argument distinctness:            typeargumentdistinctness.
                                                                (line 6)
* Type argument inference:               typeargumentinference. (line 6)
* Type argument reification:             reification.           (line 6)
* Type argument substitution:            typeargumentsubstitution.
                                                                (line 6)
* Type arguments and type constraints:   typeargumentsandconstraints.
                                                                (line 6)
* Type arguments and variance:           typeargumentvariance.  (line 6)
* Type expressions:                      typeexpressions.       (line 6)
* Type imports:                          typeimports.           (line 6)
* Type inference:                        typeinference.         (line 6)
* Type inference and block structure:    typeinferenceandblockstructure.
                                                                (line 6)
* Type of a metamodel expression:        typeofametamodelexpression.
                                                                (line 6)
* Type of a reference expression:        typeofareferenceexpression.
                                                                (line 6)
* Type parameters and variance:          typeparametersandvariance.
                                                                (line 6)
* Type system:                           thetypesystem.         (line 6)
* Type system <1>:                       typesystem.            (line 6)
* Types:                                 type.                  (line 6)
* Union and intersection types:          unionandintersectiontypes.
                                                                (line 6)
* Union types:                           uniontypes.            (line 6)
* Unqualified reference resolution:      unqualifiedreferenceresolution.
                                                                (line 6)
* Validation of assertions:              validationofassertions.
                                                                (line 6)
* Value parameters:                      valueparameters.       (line 6)
* Value references:                      valuereferences.       (line 6)
* Value type inference:                  valuetypeinference.    (line 6)
* Value type optimizations:              valuetypeoptimizations.
                                                                (line 6)
* Values:                                values.                (line 6)
* Variables:                             controlstructurevariables.
                                                                (line 6)
* Variadic parameters:                   sequencedparameters.   (line 6)
* Variance validation:                   variancevalidation.    (line 6)
* Visibility:                            visibility.            (line 6)
* while:                                 while.                 (line 6)
* Whitespace:                            whitespace.            (line 6)
* Wildcard imports:                      wildcardimports.       (line 6)

