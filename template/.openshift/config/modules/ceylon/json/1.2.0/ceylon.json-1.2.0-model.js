(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"$mod-version":"1.2.0","$mod-deps":["ceylon.language\/1.2.0",{exp:1,path:"ceylon.collection\/1.2.0"}],"ceylon.json":{parseExponent:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",nm:"parseExponent"},StringPrinter:{super:{pk:".",nm:"Printer"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"pretty"}],mt:"c",$at:{pretty$3cghnj:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"},builder$4bb58c:{$t:{md:"$",pk:"$",nm:"StringBuilder"},mt:"a",nm:"builder"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:{doc:["Returns the printed JSON"]},nm:"string"}},$m:{print:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",an:{doc:["Appends the given value to our `String` representation"]},nm:"print"}},an:{by:["Stéphane Épardaud"],doc:["A JSON Printer that prints to a [[String]]."]},nm:"StringPrinter"},Emitter:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:".",nm:"Visitor"}],ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"pretty"}],mt:"c",$at:{level$4mlxvu:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"g",nm:"level"},pretty$8sysk4:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"},state$ilnlu7:{$t:{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",md:"$",pk:"$",nm:"Integer"}],nm:"ArrayList"},mt:"a",an:{doc:["A stack of states. The top of the stack corresponds to the \ncurrent thing we're emitting. If it's > 0 we're emitting an Object,\nif it's < 0 we're emitting an Array. The magnitude -1 is the number \nof elements of the Object or Array that have been emitted so far."]},nm:"state"}},$m:{onNumber:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"n"}]],$ff:1,mt:"m",nm:"onNumber"},onStartArray:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onStartArray"},onBoolean:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"v"}]],$ff:1,mt:"m",nm:"onBoolean"},onKey:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],$ff:1,mt:"m",nm:"onKey"},indent$dqjjny:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"indent"},onEndArray:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onEndArray"},print:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",an:{doc:["Override to implement the printing part"]},nm:"print"},onString:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"s"}]],$ff:1,mt:"m",nm:"onString"},printString$38as7o:{$t:{md:"$",pk:"$",nm:"Anything"},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"s"}]],$ff:1,mt:"m",an:{doc:["Prints a `String`"]},nm:"printString"},onEndObject:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onEndObject"},onNull:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onNull"},emitValue$jk96z8:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",an:{doc:["Updates the top element on the stack, and \nadds comma separators if emitting an array."]},nm:"emitValue"},onStartObject:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",an:{doc:["Prints an `Object`"]},nm:"onStartObject"}},an:{by:["Tom Bentley"],doc:["A [[Visitor]] which emits formatted \nJSON to the [[print]] method."]},nm:"Emitter"},StringParser:{super:{pk:".",nm:"Parser"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",an:{doc:["The string of JSON data to be parsed."]},nm:"str"},{$t:{pk:".",nm:"Visitor"},mt:"prm",nm:"visitor"}],mt:"c",$at:{str$puzo67:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",an:{doc:["The string of JSON data to be parsed."]},nm:"str"},visitor$qsoxsm:{$t:{pk:".",nm:"Visitor"},mt:"a",nm:"visitor"}},an:{by:["Stéphane Épardaud"],doc:["A parser for JSON data presented as a String which calls  \nthe given visitor for each matched rule. \n\nTo construct a JSON model the visitor would be a [[Builder]]."]},nm:"StringParser"},StringEmitter:{super:{pk:".",nm:"Emitter"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"pretty"}],mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:{doc:["Returns the printed JSON"]},nm:"string"},pretty$c2sib1:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"},builder$b3xuq8:{$t:{md:"$",pk:"$",nm:"StringBuilder"},mt:"a",nm:"builder"}},$m:{print:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",an:{doc:["Appends the given value to our `String` representation"]},nm:"print"}},an:{by:["Tom Bentley"],doc:["A JSON Emitter that prints to a [[String]]."]},nm:"StringEmitter"},Visitor:{pa:1,mt:"i",$m:{onEndArray:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,$ff:1,mt:"m",an:{doc:["Called at the end of an array."]},nm:"onEndArray"},onNumber:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"number"}]],$ff:1,mt:"m",an:{doc:["Called when encountering a number."]},nm:"onNumber"},onStartArray:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,$ff:1,mt:"m",an:{doc:["Called at the start of a new array. \nFurther calls pertain to this new object until \na corresponding call to [[onEndArray]]."]},nm:"onStartArray"},onBoolean:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"boolean"}]],$ff:1,mt:"m",an:{doc:["Called when encountering true or false."]},nm:"onBoolean"},onString:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",an:{doc:["Called when encountering a string."]},nm:"onString"},onEndObject:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,$ff:1,mt:"m",an:{doc:["Called at the end of an object."]},nm:"onEndObject"},onNull:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,$ff:1,mt:"m",an:{doc:["Called when encountering a null."]},nm:"onNull"},onStartObject:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,$ff:1,mt:"m",an:{doc:["Called at the start of a new object.\nFurther calls pertain to this new object until \na corresponding call to [[onEndObject]]."]},nm:"onStartObject"},onKey:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],$ff:1,mt:"m",an:{doc:["Called when encountering a key within a the current object."]},nm:"onKey"}},an:{by:["Tom Bentley"],doc:["Callable interface used when traversing JSON data. \n\nIt is the callers responsiblity to ensure the \nmethods of this interface are called in a sequence \nthat corresponds to well-formed JSON. \nFor example, callers should never generate the calling\nsequence `onKey()`, `onKey()`."]},nm:"Visitor"},Builder:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"Visitor"}],mt:"c",$at:{result:{$t:{pk:".",nm:"Value"},pa:1,mt:"g",an:{doc:["The constructed [[Value]]."],throws:["AssertionError","The builder has not yet seen enough input to return a fully formed JSON value."]},nm:"result"},currentKey$xesi29:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},pa:1027,mt:"a",nm:"currentKey"},stack$utn8fx:{$t:{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",pk:".",nm:"Value"}],nm:"ArrayList"},mt:"a",nm:"stack"}},$m:{push$ml0ud7:{$t:{md:"$",pk:"$",nm:"Anything"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"v"}]],$ff:1,mt:"m",nm:"push"},onEndArray:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onEndArray"},onNumber:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"num"}]],$ff:1,mt:"m",nm:"onNumber"},onStartArray:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onStartArray"},onBoolean:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"bool"}]],$ff:1,mt:"m",nm:"onBoolean"},addToCurrent$lxw5io:{$t:{md:"$",pk:"$",nm:"Anything"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"v"}]],$ff:1,mt:"m",nm:"addToCurrent"},onString:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",nm:"onString"},onEndObject:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onEndObject"},onNull:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onNull"},onStartObject:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"onStartObject"},pop$r7gvbw:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"pop"},onKey:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],$ff:1,mt:"m",nm:"onKey"}},an:{by:["Tom Bentley"],doc:["A [[Visitor]] that constructs a [[Value]].\n\nThis would usually be used in conjunction with \na [[StringParser]]."]},nm:"Builder"},parseStringEscape:{$t:{md:"$",pk:"$",nm:"Character"},ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",nm:"parseStringEscape"},parseNumber:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},pa:1,ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",an:{doc:["Parse a number, consuming any initial whitepsace."]},nm:"parseNumber"},Positioned:{pa:1,mt:"i",$at:{line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The line number within the input."]},nm:"line"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The column number within the current line."]},nm:"column"},location:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"g",an:{doc:["A string descriptor of the current position."]},nm:"location"},position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The position (in characters) within the input."]},nm:"position"}},an:{doc:["Contract for stateful iterators, tokenizers etc which have the concept of a 'current position'."]},nm:"Positioned"},Printer:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,ps:[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"pretty"}],mt:"c",$at:{level$k1uxue:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"level"},pretty$6ma7eg:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",nm:"pretty"}},$m:{printNumber:{$t:{md:"$",pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"}]},mt:"prm",nm:"n"}]],$ff:1,mt:"m",an:{doc:["Prints an `Integer|Float`"]},nm:"printNumber"},printObject:{$t:{md:"$",pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"o"}]],$ff:1,mt:"m",an:{doc:["Prints an `Object`"]},nm:"printObject"},print:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",an:{doc:["Override to implement the printing part"]},nm:"print"},printArray:{$t:{md:"$",pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{pk:".",nm:"Array"},mt:"prm",nm:"o"}]],$ff:1,mt:"m",an:{doc:["Prints an `Array`"]},nm:"printArray"},enter$lrxp1m:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"enter"},leave$jlu1e9:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"leave"},printNull:{$t:{md:"$",pk:"$",nm:"Anything"},pa:9,$ff:1,mt:"m",an:{doc:["Prints `null`"]},nm:"printNull"},printBoolean:{$t:{md:"$",pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",nm:"v"}]],$ff:1,mt:"m",an:{doc:["Prints a `Boolean`"]},nm:"printBoolean"},indent$1opgam:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"indent"},printValue:{$t:{md:"$",pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],$ff:1,mt:"m",an:{doc:["Prints a JSON value"]},nm:"printValue"},printString:{$t:{md:"$",pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"s"}]],$ff:1,mt:"m",an:{doc:["Prints a `String`"]},nm:"printString"}},an:{by:["Stéphane Épardaud"],doc:["A JSON Printer"]},nm:"Printer"},parseFalse:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",an:{doc:["Parse false, consuming any initial whitespace"]},nm:"parseFalse"},ObjectValue:{pa:1,$alias:{comp:"u",l:[{md:"$",pk:"$",nm:"String"},{md:"$",pk:"$",nm:"Boolean"},{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Float"},{pk:".",nm:"Object"},{pk:".",nm:"Array"}]},mt:"als",an:{doc:["A JSON value, a [[String]], [[Boolean]], [[Integer]],\n[[Float]], JSON [[Object]], or JSON [[Array]].\n\nThis means [[Value]] except [[Null]]."]},nm:"ObjectValue"},parseKeyOrString:{$t:{md:"$",pk:"$",nm:"String"},pa:1,ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",an:{doc:["Parse a String literal, consuming any initial whitespace"]},nm:"parseKeyOrString"},parseTrue:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",an:{doc:["Parse true, consuming any initial whitespace"]},nm:"parseTrue"},parseStringUnicode:{$t:{md:"$",pk:"$",nm:"Character"},ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",nm:"parseStringUnicode"},Tokenizer:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:".",nm:"Positioned"}],mt:"c",$at:{line_$j1cqe:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"line_"},unexpectedEnd:{$t:{pk:".",nm:"ParseException"},pa:1,mt:"g",nm:"unexpectedEnd"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"line"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"column"},hasMore:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Whether there is another character"]},nm:"hasMore"},index$axh4m1:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"index"},column_$7ybrm0:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1027,mt:"a",nm:"column_"},position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"position"}},$m:{eatChar:{$t:{md:"$",pk:"$",nm:"Character"},pa:1,mt:"m",an:{doc:["The character at the current index, and move one"]},nm:"eatChar"},exception:{$t:{pk:".",nm:"ParseException"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"message"}]],mt:"m",nm:"exception"},character:{$t:{md:"$",pk:"$",nm:"Character"},pa:5,mt:"m",an:{doc:["The character at the current index, or throw"]},nm:"character"},isDigit:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],mt:"m",an:{doc:["true if the given character is \n`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8` or `9`."]},nm:"isDigit"},eat:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],$ff:1,mt:"m",an:{doc:["If the current character is not the given character then throw, \notherwise [[moveOne]]"]},nm:"eat"},moveOne:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,$ff:1,mt:"m",an:{doc:["Move to the next character"]},nm:"moveOne"},eatSpacesUntil:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],$ff:1,mt:"m",an:{doc:["Consume characters until the given character occurs"]},nm:"eatSpacesUntil"},eatSpaces:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,$ff:1,mt:"m",an:{doc:["Consume characters until the first non-whitespace"]},nm:"eatSpaces"},check:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],mt:"m",an:{doc:["If the current [[character]] is not the given character then return false. \nOtherwise [[moveOne]] and return true."]},nm:"check"},unexpectedCharacter:{$t:{pk:".",nm:"ParseException"},pa:1,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Character"},{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]}]},mt:"prm",nm:"expected"}]],mt:"m",nm:"unexpectedCharacter"},isSpace:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],mt:"m",an:{doc:["true if the given character is a space, \nnewline (`\\n`), carriage return (`\\r`) or a horizontal tab (`\\t`).\n"]},nm:"isSpace"}},an:{doc:["Contract for a tokenizer"]},nm:"Tokenizer"},compareKeys:{$t:{md:"$",pk:"$",nm:"Comparison"},ps:[[{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"Entry"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"Entry"},mt:"prm",nm:"y"}]],mt:"m",nm:"compareKeys"},parseNull:{$t:{md:"$",pk:"$",nm:"Null"},pa:1,ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",an:{doc:["Parse null, consuming any initial whitespace"]},nm:"parseNull"},parseDigits:{$t:{md:"$",pk:"$",nm:"Integer"},ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",nm:"parseDigits"},"$pkg-pa":1,parseHex:{$t:{md:"$",pk:"$",nm:"Integer"},ps:[[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",nm:"tokenizer"}]],mt:"m",nm:"parseHex"},parse:{$t:{pk:".",nm:"Value"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"str"}]],mt:"m",an:{by:["Stéphane Épardaud"],doc:["Parses a JSON string into a JSON value"],throws:["Exception","If the JSON string is invalid"]},nm:"parse"},Parser:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,ps:[{$t:{pk:".",nm:"Tokenizer"},mt:"prm",an:{doc:["The data to be parsed."]},nm:"tokenizer",$hdn:1},{$t:{pk:".",nm:"Visitor"},pa:1,mt:"prm",an:{doc:["The visitor to called for each matched rule."]},nm:"visitor",$hdn:1}],mt:"c",$at:{visitor:{$t:{pk:".",nm:"Visitor"},pa:1,mt:"a",an:{doc:["The visitor to called for each matched rule."]},nm:"visitor"},tokenizer$6turdq:{$t:{pk:".",nm:"Tokenizer"},mt:"a",an:{doc:["The data to be parsed."]},nm:"tokenizer"}},$m:{parseObject$jwd68v:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"parseObject"},parseArray$qjniqd:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"parseArray"},parseValue:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,$ff:1,mt:"m",an:{throws:["ParseException","If the specified string cannot be parsed"]},nm:"parseValue"},parse:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,$ff:1,mt:"m",nm:"parse"},parseString$sljd25:{$t:{md:"$",pk:"$",nm:"Anything"},$ff:1,mt:"m",nm:"parseString"}},an:{by:["Stéphane Épardaud"],doc:["A parser for JSON data presented as a Tokenizer which calls  \nthe given visitor for each matched rule. \n\nTo construct a JSON model the visitor would be a [[Builder]]."]},nm:"Parser"},Array:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",pk:".",nm:"Value"}],nm:"MutableList"}],ps:[{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},def:1,mt:"prm",nm:"values"}],mt:"c",$at:{values$vcoj45:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},mt:"a",nm:"values"},rest:{$t:{pk:".",nm:"Array"},pa:3,mt:"g",nm:"rest"},list$eh7yhj:{$t:{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",pk:".",nm:"Value"}],nm:"LinkedList"},mt:"a",nm:"list"},pretty:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"g",an:{doc:["Returns a pretty-printed serialised JSON representation"]},nm:"pretty"},floats:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Float"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",an:{doc:["Returns this array as a sequence of [[Float]] elements."],throws:["InvalidTypeException","If one element in this array is not a [[Float]]."]},nm:"floats"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns a serialised JSON representation"]},nm:"string"},objects:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",an:{doc:["Returns this array as a sequence of [[Object]] elements."],throws:["InvalidTypeException","If one element in this array is not an [[Object]]."]},nm:"objects"},integers:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",an:{doc:["Returns this array as a sequence of [[Integer]] elements."],throws:["InvalidTypeException","If one element in this array is not a [[Integer]]."]},nm:"integers"},size:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns the number of elements in this array"]},nm:"size"},strings:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",an:{doc:["Returns this array as a sequence of [[String]] elements."],throws:["InvalidTypeException","If one element in this array is not a [[String]]."]},nm:"strings"},booleans:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Boolean"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",an:{doc:["Returns this array as a sequence of [[Boolean]] elements."],throws:["InvalidTypeException","If one element in this array is not a [[Boolean]]."]},nm:"booleans"},lastIndex:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},arrays:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Array"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",an:{doc:["Returns this array as a sequence of [[Array]] elements."],throws:["InvalidTypeException","If one element in this array is not an [[Array]]."]},nm:"arrays"},reversed:{$t:{pk:".",nm:"Array"},pa:3,mt:"g",nm:"reversed"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"}},$m:{spanFrom:{$t:{pk:".",nm:"Array"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},infill:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],$ff:1,mt:"m",nm:"infill"},replace:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"val"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"newVal"}]],$ff:1,mt:"m",nm:"replace"},insert:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],$ff:1,mt:"m",nm:"insert"},checkString$9ziptm:{$t:{md:"$",pk:"$",nm:"String"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",an:{throws:["InvalidTypeException"]},nm:"checkString"},deleteMeasure:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"length"}]],$ff:1,mt:"m",nm:"deleteMeasure"},replaceFirst:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],mt:"m",nm:"replaceFirst"},replaceLast:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"replacement"}]],mt:"m",nm:"replaceLast"},delete:{$t:{pk:".",nm:"Value"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"delete"},removeLast:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"}]],mt:"m",nm:"removeLast"},remove:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"val"}]],mt:"m",nm:"remove"},checkInteger$4waw35:{$t:{md:"$",pk:"$",nm:"Integer"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",an:{throws:["InvalidTypeException"]},nm:"checkInteger"},iterator:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Value"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},removeAll:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"ObjectValue"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",nm:"removeAll"},truncate:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"size"}]],$ff:1,mt:"m",nm:"truncate"},removeFirst:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"ObjectValue"},mt:"prm",nm:"element"}]],mt:"m",nm:"removeFirst"},add:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],$ff:1,mt:"m",an:{doc:["Adds a new value at the end of this array"]},nm:"add"},set:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],$ff:1,mt:"m",nm:"set"},getFromFirst:{$t:{pk:".",nm:"Value"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clear:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"clear"},checkObject$ioowmw:{$t:{pk:".",nm:"Object"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",an:{throws:["InvalidTypeException"]},nm:"checkObject"},spanTo:{$t:{pk:".",nm:"Array"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},measure:{$t:{pk:".",nm:"Array"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},addAll:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"values"}]],$ff:1,mt:"m",nm:"addAll"},prune:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"prune"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",nm:"equals"},clone:{$t:{pk:".",nm:"Array"},pa:3,mt:"m",nm:"clone"},deleteSpan:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"to"}]],$ff:1,mt:"m",nm:"deleteSpan"},checkArray$61ubg2:{$t:{pk:".",nm:"Array"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",an:{throws:["InvalidTypeException"]},nm:"checkArray"},checkBoolean$v3xsa1:{$t:{md:"$",pk:"$",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",an:{throws:["InvalidTypeException"]},nm:"checkBoolean"},checkFloat$zgce4d:{$t:{md:"$",pk:"$",nm:"Float"},ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",an:{throws:["InvalidTypeException"]},nm:"checkFloat"},insertAll:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],$ff:1,mt:"m",nm:"insertAll"},span:{$t:{pk:".",nm:"Array"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"from"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},an:{by:["Stéphane Épardaud"],doc:["Represents a JSON Array"]},nm:"Array"},parseDigit:{$t:{md:"$",pk:"$",nm:"Integer"},ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"c"}]],mt:"m",nm:"parseDigit"},StringTokenizer:{super:{pk:".",nm:"Tokenizer"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"chars"}],mt:"c",$at:{hasMore:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Whether there is another character"]},nm:"hasMore"},chars$3ibitv:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"chars"},array$v7foi9:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Character"}],nm:"Array"},mt:"a",nm:"array"}},$m:{character:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"m",an:{doc:["The character at the current index, or throw"]},nm:"character"}},an:{doc:["An implementation of Tokenizer using a String"]},nm:"StringTokenizer"},Value:{pa:1,$alias:{comp:"u",l:[{pk:".",nm:"ObjectValue"},{md:"$",pk:"$",nm:"Null"}]},mt:"als",an:{doc:["A JSON value, a [[String]], [[Boolean]], [[Integer]],\n[[Float]], JSON [[Object]], JSON [[Array]], or \n[[Null]]."]},nm:"Value"},Object:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"MutableMap"}],ps:[{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"Entry"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},def:1,mt:"prm",nm:"values"}],mt:"c",$at:{pretty:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"g",an:{doc:["Returns a pretty-printed serialised JSON representation"]},nm:"pretty"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns a serialised JSON representation"]},nm:"string"},size:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"size"},contents$adyvg7:{$t:{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"HashMap"},mt:"a",nm:"contents"},values$6zuosx:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"Entry"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},mt:"a",nm:"values"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"}},$m:{getObject:{$t:{pk:".",nm:"Object"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Object]] value."],throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Object]]."]},nm:"getObject"},getArrayOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Array"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Array]] value, unless the key does not \nexist, or the value is null."],throws:["InvalidTypeException","If the key points to a type that is neither \n[[Array]] nor [[Null]]."]},nm:"getArrayOrNull"},clear:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,$ff:1,mt:"m",nm:"clear"},getArray:{$t:{pk:".",nm:"Array"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Array]] value."],throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Array]]."]},nm:"getArray"},getInteger:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Integer]] value."],throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Integer]]."]},nm:"getInteger"},getFloat:{$t:{md:"$",pk:"$",nm:"Float"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Float]] value."],throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Float]]."]},nm:"getFloat"},getString:{$t:{md:"$",pk:"$",nm:"String"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[String]] value."],throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[String]]."]},nm:"getString"},getFloatOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Float"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Float]] value, unless the key does not \nexist, or the value is null."],throws:["InvalidTypeException","If the key points to a type that is neither \n[[Float]] nor [[Null]]."]},nm:"getFloatOrNull"},put:{$t:{pk:".",nm:"Value"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"},{$t:{pk:".",nm:"Value"},mt:"prm",nm:"item"}]],mt:"m",nm:"put"},remove:{$t:{pk:".",nm:"Value"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",nm:"remove"},defines:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",nm:"defines"},getObjectOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Object"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Object]] value, unless the key does not \nexist, or the value is null."],throws:["InvalidTypeException","If the key points to a type that is neither \n[[Object]] nor [[Null]]."]},nm:"getObjectOrNull"},getBooleanOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Boolean"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Boolean]] value, unless the key does not \nexist, or the value is null."],throws:["InvalidTypeException","If the key points to a type that is neither \n[[Boolean]] nor [[Null]]."]},nm:"getBooleanOrNull"},iterator:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"Entry"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getStringOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"String"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[String]] value, unless the key does not \nexist, or the value is null."],throws:["InvalidTypeException","If the key points to a type that is neither \n[[String]] nor [[Null]]."]},nm:"getStringOrNull"},get:{$t:{pk:".",nm:"Value"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",nm:"get"},putAll:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:".",nm:"Value"}],nm:"Entry"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"entries"}]],$ff:1,mt:"m",nm:"putAll"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",nm:"equals"},clone:{$t:{pk:".",nm:"Object"},pa:3,mt:"m",nm:"clone"},getBoolean:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Boolean]] value."],throws:["InvalidTypeException","If the key dot not exist or points to a type that \nis not [[Boolean]]."]},nm:"getBoolean"},getIntegerOrNull:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"key"}]],mt:"m",an:{doc:["Returns an [[Integer]] value, unless the key does not \nexist, or the value is null."],throws:["InvalidTypeException","If the key points to a type that is neither \n[[Integer]] nor [[Null]]."]},nm:"getIntegerOrNull"}},an:{by:["Stéphane Épardaud"],doc:["Represents a JSON Object"]},nm:"Object"},ParseException:{super:{md:"$",pk:"$",nm:"Exception"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"message"},{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:{doc:["The error line (1-based)"]},nm:"line"},{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:{doc:["The error column (1-based)"]},nm:"column"}],mt:"c",$at:{line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["The error line (1-based)"]},nm:"line"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["The error column (1-based)"]},nm:"column"},message$55bchf:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["An Exception throw during parse errors"]},nm:"ParseException"},visit:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{pk:".",nm:"Value"},mt:"prm",an:{doc:["The value to visit."]},nm:"subject",$hdn:1},{$t:{pk:".",nm:"Visitor"},mt:"prm",an:{doc:["The visitor to apply."]},nm:"visitor",$hdn:1},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",an:{doc:["Whether keys should be visited in alphabetical order, when visiting objects."]},nm:"sortedKeys",$hdn:1}]],$ff:1,mt:"m",an:{by:["Tom Bentley"],doc:["Recursively visit the given subject using the given visitor. If \n[[sortedKeys]] is true then the keys of Objects will be visited \nin alphabetical order"]},nm:"visit"},"$pkg-anns":{by:["Stéphane Épardaud"],doc:["A JSON parser \/ serialiser"]},InvalidTypeException:{super:{md:"$",pk:"$",nm:"Exception"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"message"}],mt:"c",$at:{message$jqbjmt:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Represents the failure of a type conversion.  \nAn instance is typically thrown as a result of trying to \nget and convert an [[Object]] member or [[Array]] element \nwhich cannot be converted to the requested or implied type."]},nm:"InvalidTypeException"}},"ceylon.json.stream":{buildArray:{$t:{pk:"ceylon.json",nm:"Array"},ps:[[{$t:{comp:"i",l:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Event"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"events"}]],mt:"m",nm:"buildArray"},StreamParser:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Event"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}],ps:[{$t:{pk:"ceylon.json",nm:"Tokenizer"},mt:"prm",an:{doc:["The tokenizer to read input from"]},nm:"input",$hdn:1},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",an:{doc:["Whether to validate the uniqueness of keys"]},nm:"trackKeys",$hdn:1}],mt:"c",$at:{state$r6yb4i:{$t:{pk:".",nm:"StreamState"},pa:1027,mt:"a",an:{doc:["A stack (singly linked list) of states for all objects and arrays which \nhave been started, but not finished."]},nm:"state"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"line"},trackKeys$4hlw5s:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"a",an:{doc:["Whether to validate the uniqueness of keys"]},nm:"trackKeys"},input$rh2j6r:{$t:{pk:"ceylon.json",nm:"Tokenizer"},mt:"a",an:{doc:["The tokenizer to read input from"]},nm:"input"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"column"},position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"position"}},$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",an:{doc:["Return the next event from the stream, or finished"],throws:["ParseException"]},nm:"next"},parseValue$abikp:{$t:{pk:".",nm:"Event"},mt:"m",an:{doc:["Parse any JSON value and return an event"]},nm:"parseValue"},yield$38y73i:{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},mt:"prm",nm:"yielding"}]],mt:"m",nm:"yield"},pushState$9cmfiw:{$t:{pk:".",nm:"StreamState"},ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"StreamState"}]},mt:"prm",nm:"parent"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Event"}]},mt:"prm",nm:"last"}]],mt:"m",nm:"pushState"},checkNext$rguf2k:{$t:{md:"$",pk:"$",nm:"Anything"},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"expectedIdent"}]],$ff:1,mt:"m",nm:"checkNext"}},an:{doc:["A parser for JSON data as specified by \n[RFC 7159] [1] which produces a stream of [[events|Event]] \nto be handled by the caller. The parser produces events as it reads the \nsource [[input]], so it's possible to start parsing JSON while it's \nstill being received.\n\nThis parser does not enforce uniqueness of keys within \nJSON objects. It is usually not onerous for the caller to do so if \nthey require such enforcement.\n\nBy default [[ParseException]]s will propagate out of calls to [[next]] \nwhen a error is detected. You can use [[errorReporting]] \nto report errors as [[Exception]]s within the stream.\n\n## Example\n\nSuppose we have the domain model:\n\n    class Order(address, items) {\n        shared String address;\n        shared Item[] items;\n    }\n    class Item(sku, quantity) {\n        shared String sku;\n        shared Integer quantity;\n    }\n    \n And we want to parse JSON that looks like this:\n \n ```javascript\n    {\n      \"address\":\"\",\n      \"items\":[\n        {\n          \"sku\":\"123-456-789\",\n          \"quantity\":4\n        },\n        {\n          \"sku\":\"456-789\",\n          \"quantity\":20\n        }\n      ]\n    }\n ```\n \n Then we might write a parser like this:\n \n     class OrderParser() {\n         \n         late variable Peek<Event> stream;\n        \n         String missingKey(String container, String key) {\n             return \"``container``: '``key``' missing at line ``stream.line``'\";\n         }\n         String duplicateKey(String container, String key) {\n             return \"``container``: '``key``' occurs more than once at line ``stream.line``'\";\n         }\n         String keyType(String container, String key, String expectedType) {\n             return \"``container``: '``key``' key is supposed to be of ``expectedType`` type at line ``stream.line``\";\n         }\n         String unexpectedKey(String container, String key) {\n             return \"``container``: '``key``' key not supported at line ``stream.line``\";\n         }\n         String unexpectedEvent(String container, Event|Finished event) {\n             return \"``container``: unexpected event ``event else \"null\"`` at line ``stream.line``\";\n         }\n         \n         \"Parses an item from events read from the given parser.\n          Returns the item or an error explanation.\"\n         Item|String parseItem() {\n             if (!(stream.next() is ObjectStartEvent)) {\n                 return \"Item: should be a JSON object\";\n             }\n             variable String? sku = null;\n             variable Integer? quantity = null;\n             while(true) {\n                 switch(event=stream.next())\n                 case (is KeyEvent) {\n                     switch(key=event.key) \n                     case (\"sku\") {\n                         if (is String s = stream.next()) {\n                             if (sku exists) {\n                                 return duplicateKey(\"Item\", \"sku\");\n                             }\n                             sku = s;\n                         } else {\n                             return keyType(\"Item\", \"sku\", \"String\");\n                         }\n                     }\n                     case (\"quantity\") {\n                         if (is Integer s = stream.next()) {\n                             if (quantity exists) {\n                                 return duplicateKey(\"Item\", \"quantity\");\n                             }\n                             quantity = s;\n                         } else {\n                             return keyType(\"Item\", \"sku\", \"Integer\");\n                         }\n                     }\n                     else {\n                         return unexpectedKey(\"Item\", key);\n                     }\n                 }\n                 case (is ObjectEndEvent) {\n                     if (exists s=sku) {\n                         if (exists q=quantity) {\n                             return Item(s, q);\n                         }\n                         return missingKey(\"Item\", \"quantity\");\n                     }\n                     return missingKey(\"Item\", \"sku\");\n                 }\n                 else {\n                     return unexpectedEvent(\"Item\", event);\n                 }\n             }\n         }\n         \n         \"Parses an order from events read from the given parser.\n          Returns the order or an error explanation.\"\n         Order|String parseOrder() {\n             if (!(stream.next() is ObjectStartEvent)) {\n                 return \"Order: should be a JSON object\";\n             }\n             variable String? address = null;\n             value items = ArrayList<Item>();\n             while(true) {\n                 switch(event=stream.next())\n                 case (is KeyEvent) {\n                     switch(key=event.key) \n                     case (\"address\") {\n                         if (is String s = stream.next()) {\n                             if (address exists) {\n                                 return duplicateKey(\"Order\", \"address\");\n                             }\n                             address = s;\n                         } else {\n                             return keyType(\"Order\", \"address\", \"String\");\n                         }\n                     }\n                     case (\"items\") {\n                         if (!items.empty) {\n                             return duplicateKey(\"Order\", \"items\");\n                         }\n                         if (!stream.next() is ArrayStartEvent) {\n                             return keyType(\"Order\", \"items\", \"Array\");\n                         }\n                         while (stream.peek() is ObjectStartEvent) {\n                             switch (item=parseItem())\n                             case (is String) {\n                                 return item;\n                             }\n                             case (is Item) {\n                                 items.add(item);\n                             }\n                         }\n                         assert(stream.next() is ArrayEndEvent);\n                     }\n                     else {\n                         return unexpectedKey(\"Order\", key);\n                     }\n                 }\n                 case (is ObjectEndEvent) {\n                     if (exists a=address) {\n                         return Order(a, items.sequence());\n                     }\n                     return missingKey(\"Order\", \"address\");\n                 }\n                 else {\n                     return unexpectedEvent(\"Item\", event);\n                 }\n             }\n         }\n         \n         shared Order|String parse(String json) {\n             stream = Peek(StreamParser(StringTokenizer(json)));\n             return parseOrder();\n         }\n     }\n\nWhile this is certainly verbose it's extremely readable and regular.\n\n[1]: https:\/\/tools.ietf.org\/html\/rfc7159\n"]},nm:"StreamParser"},none:{super:{pk:".",nm:"None"},mt:"o",nm:"none"},StreamingVisitor:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Event"}],nm:"Iterator"}],ps:[{$t:{pk:"ceylon.json",nm:"Value"},mt:"prm",nm:"root"}],mt:"c",$at:{stack$vozhl2:{$t:{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:"ceylon.json",nm:"Value"},{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:"ceylon.json",nm:"Value"}],nm:"Entry"}]}],nm:"PushIterator"}],nm:"ArrayList"},mt:"a",nm:"stack"},pi$wvgdfz:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:"ceylon.json",nm:"Value"},{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"},{mt:"tp",pk:"ceylon.json",nm:"Value"}],nm:"Entry"}]}],nm:"PushIterator"},mt:"a",nm:"pi"},root$tvqdbk:{$t:{pk:"ceylon.json",nm:"Value"},mt:"a",nm:"root"}},$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Event"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},an:{doc:["Produces a stream of events from the descendents of the given root value."]},nm:"StreamingVisitor"},buildValue:{$t:{pk:"ceylon.json",nm:"Value"},ps:[[{$t:{comp:"i",l:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Event"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"events"}]],mt:"m",an:{doc:["Recursively builds a [[model|Value]] from events produced from the given iterator."]},nm:"buildValue"},buildObject:{$t:{pk:"ceylon.json",nm:"Object"},ps:[[{$t:{comp:"i",l:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Event"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"events"}]],mt:"m",nm:"buildObject"},KeyEvent:{super:{md:"$",pk:"$",nm:"Basic"},pa:17,ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"key",$hdn:1}],mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},key:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"key"}},an:{doc:["A key encountered when processing JSON data"]},nm:"KeyEvent"},StreamState:{super:{md:"$",pk:"$",nm:"Basic"},ps:[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"StreamState"}]},pa:1,mt:"prm",nm:"parent",$hdn:1},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Event"}]},pa:1025,mt:"prm",nm:"last",$hdn:1},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"}],nm:"HashSet"}]},pa:1,mt:"prm",nm:"keys",$hdn:1}],mt:"c",$at:{parent:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"StreamState"}]},pa:1,mt:"a",nm:"parent"},last:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Event"}]},pa:1025,mt:"a",nm:"last"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},keys:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"ceylon.collection",pk:"ceylon.collection",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"}],nm:"HashSet"}]},pa:1,mt:"a",nm:"keys"},num:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1025,mt:"a",an:{doc:["The number of events yielded so far"]},nm:"num"}},an:{doc:["Package-private class used by [[StreamParser]] to track state."]},nm:"StreamState"},objectStart:{super:{pk:".",nm:"ObjectStartEvent"},pa:1,mt:"o",$at:{other:{$t:{pk:".",nm:"ObjectEndEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["The start of an object encountered when processing JSON data"]},nm:"objectStart"},arrayStart:{super:{pk:".",nm:"ArrayStartEvent"},pa:1,mt:"o",$at:{other:{$t:{pk:".",nm:"ArrayEndEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["The start of an array encountered when processing JSON data"]},nm:"arrayStart"},streamToVisitor:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Event"}],nm:"Iterator"},mt:"prm",nm:"stream"},{$t:{pk:"ceylon.json",nm:"Visitor"},mt:"prm",nm:"visitor"}]],$ff:1,mt:"m",an:{doc:["Calls a visitor according to the events obtained from a stream."]},nm:"streamToVisitor"},LookAhead:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"T"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}],ps:[{$t:{comp:"i",l:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"T"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"stream"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},def:1,mt:"prm",an:{doc:["The maximum number of elements we can look ahead, or null for unbounded lookahead."]},nm:"lookAhead",$hdn:1}],mt:"c",$at:{stream$4v9nbw:{$t:{comp:"i",l:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"T"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"a",nm:"stream"},lookAhead$xft3nu:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Integer"}]},mt:"a",an:{doc:["The maximum number of elements we can look ahead, or null for unbounded lookahead."]},nm:"lookAhead"},pos$k7bql4:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1155,mt:"a",an:{doc:["The position of the last element returned from next()"]},nm:"pos"},lin$k41cb1:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1155,mt:"a",an:{doc:["The line number of the last element returned from next()"]},nm:"lin"},line:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"line"},peeked$1afwi6:{$t:{md:"ceylon.collection",pk:"ceylon.collection",tp:[{comp:"u",mt:"tp",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]}],nm:"ArrayList"},mt:"a",an:{doc:["The buffer"]},nm:"peeked"},column:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"column"},position:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"position"},col$jx4yhw:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1155,mt:"a",an:{doc:["The column number of the last element returned from next()"]},nm:"col"}},$m:{next:{$t:{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"},peek:{$t:{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"n"}]],mt:"m",an:{doc:["Get the *n*th element ahead"]},nm:"peek"}},tp:[{nm:"T"}],an:{doc:["A look-ahead buffer wrapping a stream"]},nm:"LookAhead"},PushIterator:{super:{md:"$",pk:"$",nm:"Basic"},sts:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"T"}],nm:"Iterator"}],ps:[{$t:{md:"$",pk:"$",tp:[{mt:"tp",nm:"T"}],nm:"Iterator"},mt:"prm",nm:"it"}],mt:"c",$at:{it$vje6a5:{$t:{md:"$",pk:"$",tp:[{mt:"tp",nm:"T"}],nm:"Iterator"},mt:"a",nm:"it"},pushed$3u4iln:{$t:{comp:"u",l:[{nm:"T"},{pk:".",nm:"None"}]},pa:1027,mt:"a",nm:"pushed"}},$m:{next:{$t:{comp:"u",l:[{nm:"T"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"},push:{$t:{md:"$",pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Anything"},mt:"prm",nm:"pushed"}]],$ff:1,mt:"m",nm:"push"}},tp:[{dv:"out",nm:"T"}],nm:"PushIterator"},"$pkg-pa":1,ObjectStartEvent:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"ObjectStartEvent"},{mt:"tp",pk:".",nm:"ObjectEndEvent"}],nm:"NestingEvent"}],mt:"c",of:[{pk:".",nm:"objectStart"}],an:{doc:["The start of a JSON object\/hash, emitted when `{` is parsed."]},nm:"ObjectStartEvent"},objectEnd:{super:{pk:".",nm:"ObjectEndEvent"},pa:1,mt:"o",$at:{other:{$t:{pk:".",nm:"ObjectStartEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["The end of the current object encountered when processing JSON data"]},nm:"objectEnd"},parse:{$t:{pk:"ceylon.json",nm:"Value"},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"json"}]],mt:"m",an:{doc:["Parse the given string of JSON \nformatted data into an in-memory model, \nreturning the model."]},nm:"parse"},ArrayStartEvent:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"ArrayStartEvent"},{mt:"tp",pk:".",nm:"ArrayEndEvent"}],nm:"NestingEvent"}],mt:"c",of:[{pk:".",nm:"arrayStart"}],an:{doc:["The start of a JSON array, emitted when `[` is parsed."]},nm:"ArrayStartEvent"},ObjectEndEvent:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"ObjectEndEvent"},{mt:"tp",pk:".",nm:"ObjectStartEvent"}],nm:"NestingEvent"}],mt:"c",of:[{pk:".",nm:"objectEnd"}],an:{doc:["The end of a JSON object\/hash, emitted when `}` is parsed."]},nm:"ObjectEndEvent"},arrayEnd:{super:{pk:".",nm:"ArrayEndEvent"},pa:1,mt:"o",$at:{other:{$t:{pk:".",nm:"ArrayStartEvent"},pa:3,mt:"g",nm:"other"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["The end of the current array encountered when processing JSON data"]},nm:"arrayEnd"},ArrayEndEvent:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"ArrayEndEvent"},{mt:"tp",pk:".",nm:"ArrayStartEvent"}],nm:"NestingEvent"}],mt:"c",of:[{pk:".",nm:"arrayEnd"}],an:{doc:["The end of a JSON array, emitted when `]` is parsed."]},nm:"ArrayEndEvent"},errorReporting:{$t:{comp:"i",l:[{md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"T"},{md:"$",pk:"$",nm:"Exception"}]}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},ps:[[{$t:{comp:"i",l:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"T"}],nm:"Iterator"},{pk:"ceylon.json",nm:"Positioned"}]},mt:"prm",nm:"stream"}]],mt:"m",tp:[{nm:"T"}],an:{doc:["Adapts the given stream so that exceptions thrown while evaluating `next()` get \nreturned from the iterator, rather than propagating."]},nm:"errorReporting"},Event:{pa:1,$alias:{comp:"u",l:[{pk:".",nm:"ObjectStartEvent"},{pk:".",nm:"ObjectEndEvent"},{pk:".",nm:"ArrayStartEvent"},{pk:".",nm:"ArrayEndEvent"},{pk:".",nm:"KeyEvent"},{md:"$",pk:"$",nm:"String"},{md:"$",pk:"$",nm:"Float"},{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Boolean"},{md:"$",pk:"$",nm:"Null"}]},mt:"als",an:{doc:["An event encountered when processing JSON data"]},nm:"Event"},NestingEvent:{pa:17,mt:"i",$at:{other:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The value associated with this event"]},nm:"other"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Self"},{mt:"tp",nm:"Other"}],nm:"NestingEvent"}],nm:"Self"},{dv:"out",sts:[{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"Self"}],nm:"NestingEvent"}],nm:"Other"}],an:{doc:["An [[Event]] that has a corresponding other event"]},nm:"NestingEvent"},None:{super:{md:"$",pk:"$",nm:"Basic"},pa:256,mt:"c",of:[{pk:".",nm:"none"}],an:{doc:["A unit type used internally because we can't use null"]},nm:"None"},"$pkg-anns":{doc:["Representation of JSON data as [[events|Event]] pulled from an [[Iterator]].\n\n[[StreamParser]] produces events according to JSON data read from \na [[ceylon.json::Tokenizer]].\n\n[[errorReporting]] adapts an Iterator so that exceptions thrown \nwhile iterating are *returned from* the iterator, rather \nthan *propagating from* it.\n\n[[streamToVisitor]] provides a bridge between producers of events \n(in the form of `Iterator`s) and consumers of those events (in the form \nof a [[ceylon.json::Visitor]].\n\n[[StreamingVisitor]] provides a bridge in the reverse direction. \nIt can be used to produce events by \n[[visiting|ceylon.json::visit]] a [[ceylon.json::Value]]."]}},"$mod-bin":"8.0","$mod-anns":{license:["Apache Software License"],by:["Stéphane Épardaud","Tom Bentley"],doc:["Contains everything required to parse and serialise JSON \ndata.\n\nSample usage for parsing and accessing JSON:\n\n    import ceylon.json {\n        parse, Object = Object\n    }\n\n    String getAuthor(String json){\n        value parsedJson = parse(json);\n        \"author must be a string\"\n        assert(is Object parsedJson, is String author = parsedJson[\"author\"]);\n        return author;\n    }\n\nAlternatively, this variation will result in an \n[[InvalidTypeException]] instead of an [[AssertionError]]\nif the input JSON data doesn't have the expected format:\n\n    import ceylon.json {\n        parse, Object\n    }\n\n    String getAuthor(String json){\n        assert(is Object parsedJson = parse(json));\n        return parsedJson.getString(\"author\");\n    }\n\nYou can iterate JSON objects too:\n\n    import ceylon.json {\n        parse, Array, Object\n    }\n\n    {String*} getModules(String json){\n        assert(is Object parsedJson = parse(json));\n        if(is Array modules = parsedJson.get(\"modules\")){\n            return { for (mod in modules) \n                       if(is Object mod, \n                          is String name = mod.get(\"name\")) \n                         name \n                   };\n        }\n        throw Exception(\"Invalid JSON data\");\n    }\n\nSample usage for generating JSON data:\n\n    import ceylon.json {\n        Object, Array\n    }\n\n    String getJSON(){\n        value json = Object {\n            \"name\" -> \"Introduction to Ceylon\",\n            \"authors\" -> Array {\n                \"Stef Epardaud\",\n                \"Emmanuel Bernard\"\n            }\n        };\n        return json.string;\n    }\n"]},"$mod-name":"ceylon.json"};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
