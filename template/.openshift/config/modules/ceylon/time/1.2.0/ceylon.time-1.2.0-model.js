(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"$mod-bin":"8.0","ceylon.time.internal":{TimeOfDay:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time",nm:"Time"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:{doc:["Number of milliseconds since last midnight."]},nm:"millisecondsOfDay",$hdn:1}],mt:"c",$at:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of milliseconds since last full second."]},nm:"milliseconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of full hours elapsed since last midnight."]},nm:"hours"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of seconds since last minute."]},nm:"seconds"},successor:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"g",an:{doc:["For successor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the successor is the current value plus 1 millisecond."]},nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Times"]},nm:"string"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of minutes since last full hour."]},nm:"minutes"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of seconds since last midnight."]},nm:"secondsOfDay"},millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["Number of milliseconds since last midnight."]},nm:"millisecondsOfDay"},predecessor:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"g",an:{doc:["For predecessor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the predecessor is the current value minus 1 millisecond."]},nm:"predecessor"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of minutes since last midnight."]},nm:"minutesOfDay"}},$m:{minus:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Subtracts specified time period from this time of day\nand returns the result as new time of day."]},nm:"minus"},periodTo:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"end"}]],mt:"m",an:{doc:["Returns the period between this and the given time.\n\nIf this time is after the given time then return zero period."]},nm:"periodTo"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Compare two instances of _time of day_."]},nm:"compare"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},plusHours:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Adds specified number of hours to this time of day\nand returns the result as new time of day."]},nm:"plusHours"},minusMilliseconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Subtracts specified number of milliseconds from this time of day\nand returns the result as new time of day."]},nm:"minusMilliseconds"},withMinutes:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this Time replacing the _minutes_ value.\n\n**Note:** It should be a valid _minute_."]},nm:"withMinutes"},minusHours:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Subtracts specified number of hours from this time of day \nand returns the result as new time of day."]},nm:"minusHours"},withHours:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this Time replacing the _hours_ value.\n\n**Note:** It should be a valid _hour_."]},nm:"withHours"},withSeconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this Time replacing the _seconds_ value.\n\n**Note:** It should be a valid _second_."]},nm:"withSeconds"},periodFrom:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"start"}]],mt:"m",an:{doc:["Returns the period between this and the given time.\n\nIf this time is before the given time then return zero period."]},nm:"periodFrom"},neighbour:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},plusMinutes:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Adds specified number of minutes to this time of day \nand returns the result as new  time of day."]},nm:"plusMinutes"},plus:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Adds specified time period to this time of day\nand returns the result as new time of day."]},nm:"plus"},minusMinutes:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Subtracts specified number of minutes from this time of day \nand returns the result as new  time of day."]},nm:"minusMinutes"},rangeTo:{$t:{pk:"ceylon.time",nm:"TimeRange"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the [[TimeRange]] between this and given Time."]},nm:"rangeTo"},plusMilliseconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Adds specified number of milliseconds to this time of day\nand returns the result as new time of day."]},nm:"plusMilliseconds"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Return _true_ if it have same type and milliseconds of day."]},nm:"equals"},plusSeconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Adds specified number of seconds to this time of day\nand returns the result as new time of day."]},nm:"plusSeconds"},minusSeconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Subtracts specified number of seconds from this time of day\nand returns the result as new time of day."]},nm:"minusSeconds"},withMilliseconds:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this Time replacing the _milliseconds_ value.\n\n**Note:** It should be a valid _millisecond_."]},nm:"withMilliseconds"}},an:{doc:["Basic implementation of [[Time]] interface, representing an abstract \n_time of day_ such as _10am_ or _3.20pm_ with a precision of milliseconds."]},nm:"TimeOfDay"},overlap:{$t:{comp:"u",l:[{md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},{md:"$",pk:"$",nm:"Empty"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},mt:"prm",nm:"first"},{$t:{md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},mt:"prm",nm:"second"}]],mt:"m",tp:[{sts:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"Value"}],nm:"Enumerable"},{md:"$",pk:"$",tp:[{mt:"tp",nm:"Value"}],nm:"Comparable"}],nm:"Value"}],an:{doc:["Returns the inclusive overlap between two ordinal ranges.\n\nThe range of the overlap will be returned in the natural order of the values regardless of their original order in input tuples.\n\nExamples:\n\n    assert(overlap([1, 3], [2, 4]) == [2, 3]);\n    assert(overlap([4, 2], [1, 3]) == [2, 3]);\n    assert(is Empty o = overlap([1, 2], [3, 4]));\n"]},nm:"overlap"},"$pkg-pa":1,intersect:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{nm:"Value"},mt:"prm",nm:"start"},{$t:{nm:"Value"},mt:"prm",nm:"end"},{$t:{nm:"Value"},mt:"prm",nm:"otherStart"},{$t:{nm:"Value"},mt:"prm",nm:"otherEnd"}]],mt:"m",tp:[{sts:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"Value"}],nm:"Comparable"}],nm:"Value"}],an:{doc:["Returns if two ranges has intersection."]},nm:"intersect"},GregorianZonedDateTime:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time.timezone",nm:"ZoneDateTime"}],ps:[{$t:{pk:"ceylon.time",nm:"Instant"},pa:3,mt:"prm",an:{doc:["All operations of this implementations is based in this Instant."]},nm:"instant",$hdn:1},{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},pa:3,def:1,mt:"prm",an:{doc:["TimeZone to be applied in this implementation."]},nm:"timeZone",$hdn:1}],mt:"c",$at:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"g",an:{doc:["Returns [[ceylon.time::Date]] representation of current zoned _date and time_."]},nm:"date"},dateTime:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"g",an:{doc:["Returns [[ceylon.time::DateTime]] representation of this zoned _date and time_."]},nm:"dateTime"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of milliseconds since last full second."]},nm:"milliseconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of full hours elapsed since last midnight."]},nm:"hours"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns week of year according to ISO-8601 week number calculation rules."]},nm:"weekOfYear"},successor:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"g",an:{doc:["For successor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the successor is the current value plus 1 millisecond.\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC"]},nm:"string"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of year_ value of this gregorian date."]},nm:"dayOfYear"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns year of this gregorian date."]},nm:"year"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of minutes since last full hour."]},nm:"minutes"},timeZone:{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},pa:3,mt:"a",an:{doc:["TimeZone to be applied in this implementation."]},nm:"timeZone"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Returns `true`, if this is a leap year according to gregorian calendar leap year rules."]},nm:"leapYear"},millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of milliseconds since last midnight."]},nm:"millisecondsOfDay"},predecessor:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,mt:"g",an:{doc:["For predecessor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the predecessor is the current value minus 1 millisecond.\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"predecessor"},instant:{$t:{pk:"ceylon.time",nm:"Instant"},pa:3,mt:"a",an:{doc:["All operations of this implementations is based in this Instant."]},nm:"instant"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of minutes since last midnight."]},nm:"minutesOfDay"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of seconds since last minute."]},nm:"seconds"},dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:3,mt:"g",an:{doc:["Returns current day of the week."]},nm:"dayOfWeek"},dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of year_ value of this gregorian date."]},nm:"dayOfEra"},month:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"g",an:{doc:["Returns month of this gregorian date."]},nm:"month"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of seconds since last midnight."]},nm:"secondsOfDay"},time:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"g",an:{doc:["Returns [[ceylon.time::Time]] representation of current zoned _date and time_."]},nm:"time"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of month_ value of this gregorian date."]},nm:"day"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Comparing [[ZoneDateTime]] is based on [[Instant]] and should not be\ncompared as it´s human representation as they are adjusted based on geographic and regional (DST)\nlocations and do not represent a comparison correct."]},nm:"compare"},plusHours:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Adds number of hours from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"plusHours"},minusHours:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Subtracts number of hours from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"minusHours"},withHours:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _hour_ value set to the specified value.\n\n**Note 01:** It should be a valid _hour_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"withHours"},withSeconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _second_ value set to the specified value.\n\n**Note 01:** It should be a valid _second_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"withSeconds"},neighbour:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},plusMinutes:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Adds number of minutes from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"plusMinutes"},withYear:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _year_ value set to the specified value.\n\n**Note 01:** It should result in a valid gregorian date.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"withYear"},adjust$npr8ju:{$t:{pk:".",nm:"GregorianZonedDateTime"},ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"resolved"}]],mt:"m",an:{doc:["Fix [[DateTime]] zone absence."]},nm:"adjust"},minusMinutes:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Subtracts number of minutes from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"minusMinutes"},plusDays:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Adds number of days from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"plusDays"},plusSeconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Adds number of seconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"plusSeconds"},plusWeeks:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Adds number of weeks from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"plusWeeks"},withMilliseconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _milliseconds_ value set to the specified value.\n\n**Note 01:** It should be a valid _millisecond_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"withMilliseconds"},withDayOfWeek:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _day of week_ value set to the specified value."]},nm:"withDayOfWeek"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},minusMilliseconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Subtracts number of milliseconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"minusMilliseconds"},minusYears:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Subtracts number of years from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note 01:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).minusYears(1)` will return\n`2011-02-28`, since _February 2011_ has only 28 days.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"minusYears"},withMinutes:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _minute_ value set to the specified value.\n\n**Note 01:** It should be a valid _minute_.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"withMinutes"},plusMonths:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Adds number of months to this _zoned date and time_ and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the\nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 1, 31).plusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]},nm:"plusMonths"},plusYears:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Adds number of years to this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note 01:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).plusYears(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"plusYears"},minusWeeks:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Subtracts number of weeks from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"minusWeeks"},withDayOfYear:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _day of year_ value set to the specified value."]},nm:"withDayOfYear"},minusDays:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Subtracts number of days from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"minusDays"},minusMonths:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Subtracts number of months from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note 01:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 3, 30).minusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"minusMonths"},withDay:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfMonth"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _day of month_ value set to the specified value.\n\n**Note 01:** It should result in a valid gregorian date.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"withDay"},withWeekOfYear:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekNumber"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _week of year_ value set to the specified value."]},nm:"withWeekOfYear"},plusMilliseconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Adds number of milliseconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"plusMilliseconds"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns _true_ if given value is same type, date and time."]},nm:"equals"},minusSeconds:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Subtracts number of seconds from this _zoned date and time_ and returns the resulting [[ZoneDateTime]].\n\n**Note:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time."]},nm:"minusSeconds"},withMonth:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",an:{doc:["Returns new [[ZoneDateTime]] with the _month_ value set to the specified value.\n\n**Note 01:** It should result in a valid gregorian date.\n\n**Note 02:** The resulting  [[ZoneDateTime]] can be affected by Daylight Saving Time.\n"]},nm:"withMonth"}},an:{doc:["Default implementation of gregorian calendar thats makes use of a [[TimeZone]] for it´s operations.\n\nThis means that making some operations like _plusDays_ takes into \naccount the result Instant generated to reapply all the rules of the current TimeZone."]},nm:"GregorianZonedDateTime"},gap:{$t:{comp:"u",l:[{md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},{md:"$",pk:"$",nm:"Empty"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},mt:"prm",nm:"first"},{$t:{md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},mt:"prm",nm:"second"}]],mt:"m",tp:[{sts:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"Value"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",nm:"Value"}],nm:"Enumerable"}],nm:"Value"}],an:{doc:["Returns a tuple representing an exclusive gap between two disjoint ranges of ordinal values.\n\nValues in the tuple are returned always in their natural order regardless of their original ordering in the input tuples. \nIf input ranges are overlapping, this function will return an empty value.\n\nExamples:\n\n    assert(gap([1, 2], [5, 6]) == [3, 4]);\n    assert(gap([6, 5], [1, 2]) == [3, 4]);\n    assert(is Empty g = gap([1, 3], [2, 4]));\n"]},nm:"gap"},GregorianDateTime:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time",nm:"DateTime"}],ps:[{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"prm",an:{doc:["Returns [[Date]] representation of current _date and time_."]},nm:"date",$hdn:1},{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"prm",an:{doc:["Returns [[Time]] representation of current _date and time_."]},nm:"time",$hdn:1}],mt:"c",$at:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"a",an:{doc:["Returns [[Date]] representation of current _date and time_."]},nm:"date"},milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of milliseconds since last full second."]},nm:"milliseconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of full hours elapsed since last midnight."]},nm:"hours"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns week of year according to ISO-8601 week number calculation rules."]},nm:"weekOfYear"},successor:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"g",an:{doc:["For successor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the successor is the current value minus 1 millisecond.\n"]},nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns ISO-8601 formatted String representation of this _Date and Time of day_.\n\nhttps:\/\/en.wikipedia.org\/wiki\/ISO_8601#Combined_date_and_time_representations"]},nm:"string"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of year_ value of this gregorian date."]},nm:"dayOfYear"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns year of this gregorian date."]},nm:"year"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of minutes since last full hour."]},nm:"minutes"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Returns `true` if this is a leap year according to gregorian calendar leap year rules."]},nm:"leapYear"},millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of milliseconds since last midnight."]},nm:"millisecondsOfDay"},predecessor:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,mt:"g",an:{doc:["For predecessor its used the lowest unit of time, this way we can benefit\nfrom maximum precision. In this case the predecessor is the current value minus 1 millisecond.\n"]},nm:"predecessor"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of minutes since last midnight."]},nm:"minutesOfDay"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of seconds since last minute."]},nm:"seconds"},dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:3,mt:"g",an:{doc:["Returns current day of the week."]},nm:"dayOfWeek"},dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of year_ value of this gregorian date."]},nm:"dayOfEra"},month:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"g",an:{doc:["Returns month of this gregorian date."]},nm:"month"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Number of seconds since last midnight."]},nm:"secondsOfDay"},time:{$t:{pk:"ceylon.time",nm:"Time"},pa:3,mt:"a",an:{doc:["Returns [[Time]] representation of current _date and time_."]},nm:"time"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of month_ value of this gregorian date."]},nm:"day"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{minus:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"amount"}]],mt:"m",an:{doc:["Subtracts specified date period from this date and returns the new [[DateTime]]."]},nm:"minus"},periodTo:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"end"}]],mt:"m",an:{doc:["Returns the period between this and the given [[DateTime]].\n\nIf this [[DateTime]] is after the given [[DateTime]] then return negative period."]},nm:"periodTo"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Comparing [[DateTime]] is based on [[Date]] and [[Time]] comparison."]},nm:"compare"},plusHours:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Adds number of hours from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"plusHours"},minusHours:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Subtracts number of hours from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"minusHours"},withHours:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _hours_ value set to the specified value.\n\n**Note:** It should be a valid _hour_.\n"]},nm:"withHours"},withSeconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _seconds_ value set to the specified value.\n\n**Note:** It should be a valid _second_.\n"]},nm:"withSeconds"},neighbour:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},plusMinutes:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Adds number of minutes from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"plusMinutes"},withYear:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _year_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withYear"},instant:{$t:{pk:"ceylon.time",nm:"Instant"},pa:3,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],mt:"m",an:{doc:["[[DateTime]] does not know anything about [[TimeZone]] and it should be supplied to\ncreate a [[Instant]]."]},nm:"instant"},plusDays:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Adds number of days to this date and returns the resulting [[DateTime]]."]},nm:"plusDays"},minusMinutes:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Subtracts number of minutes from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"minusMinutes"},rangeTo:{$t:{pk:"ceylon.time",nm:"DateTimeRange"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the [[DateTimeRange]] between this and given DateTime."]},nm:"rangeTo"},addPeriod$g15ssb:{$t:{pk:"ceylon.time",nm:"DateTime"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["This method add the specified fields doing first the subtraction and last the additions.\n\nThe mix between positive and negative fields does not guarantee any expected behavior."]},nm:"addPeriod"},plusSeconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Adds number of seconds from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"plusSeconds"},plusWeeks:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Adds number of weeks to this date and returns the resulting [[DateTime]]."]},nm:"plusWeeks"},withMilliseconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _milliseconds_ value set to the specified value.\n\n**Note:** It should be a valid _millisecond_.\n"]},nm:"withMilliseconds"},withDayOfWeek:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _day of week_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withDayOfWeek"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},minusYears:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Subtracts number of years from this date returning the resulting the new gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).minusYears(1)` will return\n`2011-02-28`, since _February 2011_ has only 28 days.\n"]},nm:"minusYears"},minusMilliseconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Subtracts number of milliseconds from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"minusMilliseconds"},withMinutes:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _minutes_ value set to the specified value.\n\n**Note:** It should be a valid _minute_.\n"]},nm:"withMinutes"},plusMonths:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Adds number of months to this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 1, 31).plusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]},nm:"plusMonths"},plusYears:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Adds number of years to this date returning the resulting gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).plusYears(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]},nm:"plusYears"},minusWeeks:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Subtracts number of weeks from this date and returns the resulting [[DateTime]]."]},nm:"minusWeeks"},withDayOfYear:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _day of week_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withDayOfYear"},periodFrom:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"DateTime"},mt:"prm",nm:"start"}]],mt:"m",an:{doc:["Returns the period between this and the given [[DateTime]].\n\nIf this [[DateTime]] is before the given [[DateTime]] then return negative period."]},nm:"periodFrom"},plus:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"amount"}]],mt:"m",an:{doc:["Adds specified date period to this date and returns the new [[DateTime]]."]},nm:"plus"},minusDays:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Subtracts number of days from this date and returns the resulting [[DateTime]]."]},nm:"minusDays"},minusMonths:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Subtracts number of months from this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 3, 30).minusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]},nm:"minusMonths"},withDay:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfMonth"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _day of month_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withDay"},withWeekOfYear:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekNumber"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _week of year_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withWeekOfYear"},fromTime$uyune6:{$t:{pk:"ceylon.time",nm:"DateTime"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"millis"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"signal"}]],mt:"m",an:{doc:["Calculates the based in given time, consuming it for each day if necessary."]},nm:"fromTime"},plusMilliseconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Adds number of milliseconds from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"plusMilliseconds"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns _true_ if given value is same type, date and time."]},nm:"equals"},minusSeconds:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Subtracts number of seconds from this _date and time_ and returns the resulting [[DateTime]]."]},nm:"minusSeconds"},withMonth:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",an:{doc:["Returns new [[DateTime]] with the _month_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withMonth"}},an:{doc:["Default implementation of a gregorian calendar"]},nm:"GregorianDateTime"},GregorianDate:{super:{pk:".",nm:"AbstractDate"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfEra"}],mt:"c",$at:{dayOfEra$launx3:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"a",nm:"dayOfEra"},successor:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"g",an:{doc:["Returns gregorian date immediately succeeding this date.\n\nFor successor its used the lowest unit of date, this way we can benefit\nfrom maximum precision. In this case the successor is the current value plus 1 day."]},nm:"successor"},dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:3,mt:"g",an:{doc:["Returns current day of the week."]},nm:"dayOfWeek"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",$m:{normalizeFirstWeek$7b8vj7:{$t:{pk:"ceylon.time",nm:"Date"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"yearNumber"}]],mt:"m",nm:"normalizeFirstWeek"},normalizeLastWeek$ekrdod:{$t:{pk:"ceylon.time",nm:"Date"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"yearNumber"}]],mt:"m",nm:"normalizeLastWeek"}},an:{doc:["Returns week of year according to ISO-8601 week number calculation rules."]},nm:"weekOfYear"},month:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:3,mt:"g",an:{doc:["Returns month of this gregorian date."]},nm:"month"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns ISO-8601 formatted String representation of this date.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Dates"]},nm:"string"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns year of this gregorian date."]},nm:"year"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of year_ value of this gregorian date."]},nm:"dayOfYear"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Returns `true`, if this is a leap year according to gregorian calendar leap year rules."]},nm:"leapYear"},predecessor:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,mt:"g",an:{doc:["Returns gregorian date immediately preceding this date.\n\nFor successor its used the lowest unit of date, this way we can benefit\nfrom maximum precision. In this case the successor is the current value minus 1 day."]},nm:"predecessor"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns _day of month_ value of this gregorian date."]},nm:"day"}},$m:{minus:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"amount"}]],mt:"m",an:{doc:["Subtracts specified date period from this date and returns the new [[Date]]."]},nm:"minus"},periodTo:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"end"}]],mt:"m",an:{doc:["Returns the period between this and the given date.\n\nIf this date is after the given date then return negative period."]},nm:"periodTo"},withDayOfWeek:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],mt:"m",nm:"withDayOfWeek"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},minusYears:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Subtracts number of years from this date returning the resulting the new gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).minusYears(1)` will return\n`2011-02-28`, since _February 2011_ has only 28 days.\n"]},nm:"minusYears"},plusMonths:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Adds number of months to this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 1, 31).plusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]},nm:"plusMonths"},plusYears:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Adds number of years to this date returning the resulting gregorian date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2012, 2, 29).plusYears(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]},nm:"plusYears"},minusWeeks:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Subtracts number of weeks from this date and returns the resulting [[Date]]."]},nm:"minusWeeks"},withDayOfYear:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],mt:"m",nm:"withDayOfYear"},periodFrom:{$t:{pk:"ceylon.time",nm:"Period"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"start"}]],mt:"m",an:{doc:["Returns the period between this and the given date.\n\nIf this date is before the given date then return negative period."]},nm:"periodFrom"},neighbour:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},withYear:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Returns new date with the specified year value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withYear"},plus:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"amount"}]],mt:"m",an:{doc:["Adds specified date period to this date and returns the new [[Date]]."]},nm:"plus"},minusDays:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Subtracts number of days from this date and returns the resulting [[Date]]."]},nm:"minusDays"},plusDays:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Adds number of days to this date and returns the resulting [[Date]]."]},nm:"plusDays"},minusMonths:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Subtracts number of months from this date and returns the resulting date.\n\n**Note:** Day of month value of the resulting date will be truncated to the \nvalid range of the target date if necessary.\n\nThis means for example, that `date(2013, 3, 30).minusMonths(1)` will return\n`2013-02-28`, since _February 2013_ has only 28 days.\n"]},nm:"minusMonths"},rangeTo:{$t:{pk:"ceylon.time",nm:"DateRange"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the [[DateRange]] between this and given Date."]},nm:"rangeTo"},withDay:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"}]],mt:"m",an:{doc:["Returns new date with the _day of month_ value set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withDay"},at:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}]],mt:"m",an:{doc:["Returns new [[DateTime]] value."]},nm:"at"},withWeekOfYear:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekOfYear"}]],mt:"m",an:{doc:["Returns new date with the specified weekOfYear value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withWeekOfYear"},plusWeeks:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Adds number of weeks to this date and returns the resulting [[Date]]."]},nm:"plusWeeks"},withMonth:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",an:{doc:["Returns new date with the month set to the specified value.\n\n**Note:** It should result in a valid gregorian date.\n"]},nm:"withMonth"},addPeriod$2sk1dc:{$t:{pk:"ceylon.time",nm:"Date"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["This method add the specified fields doing first the subtraction and last the additions.\n\nThe mix between positive and negative fields does not guarantee any expected behavior."]},nm:"addPeriod"}},an:{doc:["Default implementation of a gregorian calendar"]},nm:"GregorianDate"},gregorianDate:{$t:{pk:"ceylon.time",nm:"Date"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:{doc:["Year number of the date"]},nm:"year",$hdn:1},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",an:{doc:["Month of the year"]},nm:"month",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:{doc:["Day of month"]},nm:"day",$hdn:1}]],mt:"m",an:{doc:["Returns a gregorian calendar date according to the specified year, month and date values."]},nm:"gregorianDate"},AbstractDate:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:"ceylon.time",nm:"Date"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:{doc:["Every [[Date]] implementation should indicate it´s own _day of era_ based in it´s own chronology."]},nm:"dayOfEra",$hdn:1}],mt:"c",$at:{dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["Every [[Date]] implementation should indicate it´s own _day of era_ based in it´s own chronology."]},nm:"dayOfEra"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Dates from same chronology can be compared if they have same _day of era_."]},nm:"compare"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Dates from same chronology can be considered equal if they have same _day of era_."]},nm:"equals"}},an:{doc:["Common behaviors for _Date_ types."]},nm:"AbstractDate"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"]}},"ceylon.time.internal.math":{adjustedMod:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"y"}]],mt:"m",an:{doc:["Returns an _adjusted remainder_ of the two integers.\n\n   value moduli = [for (x in 4..-4) amod(x, 4)];\n   assert( moduli == [4, 3, 2, 1, 4, 3, 2, 1, 4] );\n"]},nm:"adjustedMod"},"$pkg-pa":1,round:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Float"},mt:"prm",nm:"f"}]],mt:"m",an:{doc:["Returns nearest integer to x"]},nm:"round"},floorMod:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"y"}]],mt:"m",an:{doc:["Returns the floor remainder (modulus) of the two integers.\n\n    value moduli = [for (x in 4..-4) mod(x, 4)] \n    assert( moduli == [0, 3, 2, 1, 0, 3, 2, 1, 0] );\n"]},nm:"floorMod"},floorDiv:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"x"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"y"}]],mt:"m",an:{doc:["Returns floored division of the two integers."]},nm:"floorDiv"},floor:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Float"},mt:"prm",nm:"x"}]],mt:"m",an:{doc:["Returns the largest integer less than or equal to _x_."]},nm:"floor"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"]}},"ceylon.time.timezone":{zoneDateTime:{$t:{pk:".",nm:"ZoneDateTime"},pa:1,ps:[[{$t:{pk:".",nm:"TimeZone"},mt:"prm",nm:"timeZone"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"hour"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"millis"}]],mt:"m",an:{doc:["Returns a [[ZoneDateTime]] based on the specified [[TimeZone]], year, month, day of month, hour, minute, second and millisecond values."]},nm:"zoneDateTime"},TimeZone:{pa:1,mt:"i",of:[{pk:".",nm:"OffsetTimeZone"},{pk:".",nm:"RuleBasedTimezone"}],$m:{offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,ps:[[{$t:{pk:"ceylon.time",nm:"Instant"},mt:"prm",nm:"instant"}]],mt:"m",an:{doc:["Returns offset in milliseconds of the specified instant according to this time zone."]},nm:"offset"}},an:{doc:["The interface representing a timezone."]},nm:"TimeZone"},"$pkg-pa":1,ZoneDateTime:{pa:1,sts:[{pk:".",nm:"ReadableZoneDateTime"},{pk:"ceylon.time.base",nm:"ReadableDateTime"},{pk:".",nm:"ReadableTimeZone"},{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"ZoneDateTime"},{mt:"tp",pk:"ceylon.time",nm:"Date"},{mt:"tp",pk:"ceylon.time",nm:"Time"}],nm:"DateTimeBehavior"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"ZoneDateTime"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"ZoneDateTime"}],nm:"Ordinal"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"ZoneDateTime"}],nm:"Enumerable"}],mt:"i",$at:{dateTime:{$t:{pk:"ceylon.time",nm:"DateTime"},pa:5,mt:"a",an:{doc:["Local date and time according to the current time zone of this instance.\n\n**Note:** The resulting [[DateTime]], is a local representation of \nthis date and time stripped of any time zone information."]},nm:"dateTime"},currentOffsetMilliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:9,mt:"g",an:{doc:["Returns current time zone offset from UTC in milliseconds"]},nm:"currentOffsetMilliseconds"},instant:{$t:{pk:"ceylon.time",nm:"Instant"},pa:5,mt:"a",an:{doc:["Instant used as base."]},nm:"instant"}},an:{doc:["Instant of time in a specific time zone."]},nm:"ZoneDateTime"},RuleBasedTimezone:{pa:1,sts:[{pk:".",nm:"TimeZone"}],mt:"i",an:{doc:["This represents offsets based on daylight saving time."]},nm:"RuleBasedTimezone"},timeZone:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",$m:{offset:{$t:{pk:".",nm:"OffsetTimeZone"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Represents fixed timeZone created based on given values."]},nm:"offset"},parse:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"TimeZone"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"zone"}]],mt:"m",an:{doc:["Parses input string and returns appropriate time zone.\nCurrently it accepts only ISO-8601 time zone offset patterns:\n&plusmn;`[hh]:[mm]`, &plusmn;`[hh][mm]`, and &plusmn;`[hh]`.\n\nIn addition, the special code `Z` is recognized as a shorthand for `+00:00`."]},nm:"parse"}},$o:{system:{super:{pk:".",nm:"OffsetTimeZone"},pa:1,mt:"o",an:{doc:["Current system time zone."]},nm:"system"},utc:{super:{pk:".",nm:"OffsetTimeZone"},pa:1,mt:"o",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nhttps:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC"]},nm:"string"}},an:{doc:["Coordinated Universal Time (UTC) time zone."]},nm:"utc"}},an:{doc:["Common utility methods for getting time zone instances."]},nm:"timeZone"},ReadableTimeZone:{pa:1,mt:"i",$at:{timeZone:{$t:{pk:".",nm:"TimeZone"},pa:5,mt:"a",an:{doc:["Time zone value."]},nm:"timeZone"}},an:{doc:["Common interface that can hold a reference to a specific time zone."]},nm:"ReadableTimeZone"},OffsetTimeZone:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"TimeZone"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:{doc:["The value that represents this constant offset in milliseconds."]},nm:"offsetMilliseconds",$hdn:1}],mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:{doc:["Returns ISO-8601 formatted String representation of this _time of day_.\n\nhttps:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC"]},nm:"string"},offsetMilliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["The value that represents this constant offset in milliseconds."]},nm:"offsetMilliseconds"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{pk:"ceylon.time",nm:"Instant"},mt:"prm",nm:"instant"}]],mt:"m",an:{doc:["Returns offset in milliseconds of the specified instant according to this time zone.\n\nThis implementation always returns a constant offset."]},nm:"offset"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns _true_ if given value is same type and offset milliseconds."]},nm:"equals"}},an:{doc:["A simple time zone with a constant offset from UTC."]},nm:"OffsetTimeZone"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"]},ReadableZoneDateTime:{pa:1,sts:[{pk:"ceylon.time.base",nm:"ReadableDate"},{pk:"ceylon.time.base",nm:"ReadableTime"},{pk:".",nm:"ReadableTimeZone"}],mt:"i",an:{doc:["Common interface that can represent particular time of day on a specific date in a specific time zone."]},nm:"ReadableZoneDateTime"}},"ceylon.time.chronology":{rd:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"t"}]],mt:"m",an:{doc:["Converts _Rata Die_ day number to a fixed date value.\n\n_Rata Die_ is fixed at Monday, January 1st, 1. (Gregorian)."]},nm:"rd"},unixTime:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"o",$at:{epoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Fixed date value of the _Unix time_ epoch (1970-01-01)."]},nm:"epoch"}},$m:{timeFromFixed:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],mt:"m",an:{doc:["Return milliseconds elapsed from 1970-01-01 00:00:00."]},nm:"timeFromFixed"},fixedFromTime:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"time"}]],mt:"m",an:{doc:["Returns a _fixed date_ from the _unix time_ value."]},nm:"fixedFromTime"},timeOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"time"}]],mt:"m",an:{doc:["Returns _time of day_ in milliseconds for the specified _unix time_ value."]},nm:"timeOfDay"}},an:{doc:["Common properties of _Unix time_."]},nm:"unixTime"},"$pkg-pa":1,GregorianCalendar:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{pk:".",tp:[{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{md:"$",pk:"$",nm:"Integer"},{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Nothing"}]}]}]},{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{md:"$",pk:"$",nm:"Integer"},{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Nothing"}]},{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"}],nm:"Tuple"}],nm:"Chronology"},{pk:".",tp:[{mt:"tp",pk:".",nm:"GregorianCalendar"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{md:"$",pk:"$",nm:"Integer"},{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Nothing"}]}]}]},{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{md:"$",pk:"$",nm:"Integer"},{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",md:"$",pk:"$",tp:[{comp:"u",mt:"tp",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Nothing"}]},{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",md:"$",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"}],nm:"Tuple"}],nm:"LeapYear"}],mt:"c",of:[{pk:".",nm:"gregorian"}],an:{doc:["Base class for a gregorian calendar chronology."]},nm:"GregorianCalendar"},Chronology:{pa:1,mt:"i",$at:{epoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Epoch is the offset of the _fixed date_ day number that defines \nthe beginning of the calendar."]},nm:"epoch"}},$m:{fixedFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,ps:[[{$t:{nm:"Fields"},mt:"prm",nm:"date"}]],mt:"m",an:{doc:["Converts date tuple of this calendar system to an equivalent _fixed date_\nrepresentation of the day of era."]},nm:"fixedFrom"},dateFrom:{$t:{nm:"Fields"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"fixed"}]],mt:"m",an:{doc:["Converts a _fixed day_ number to a calendar date tuple."]},nm:"dateFrom"},checkDate:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{nm:"Fields"},mt:"prm",nm:"date"}]],$ff:1,mt:"m",an:{doc:["Validate the given date."]},nm:"checkDate"}},tp:[{sts:[{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Anything"}],nm:"Sequential"}],nm:"Fields"}],an:{doc:["Generic base interface of a _calendar system_.\nChronology serves as a computational backend to \na Date representation of the same calendar system."]},nm:"Chronology"},LeapYear:{st:"Self",pa:1,mt:"i",of:[{nm:"Self"}],$m:{leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"leapYear"}]],mt:"m",an:{doc:["Returns true if the specified year is a leap year according to the leap year rules of the given chronology."]},nm:"leapYear"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Fields"}],nm:"Chronology"}],nm:"Self"},{sts:[{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Anything"}],nm:"Sequential"}],nm:"Fields"}],an:{doc:["An interface for calendar system that defines leap year rules.\n\n*Note:* This interface is meant to convey a Calendar that has some sort of leap year syntax."]},nm:"LeapYear"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"],doc:["Package containing supported chronologies in ceylon.time library.\n\nA _Chronology_ is a set of functions and methods that define the calendar system. \nA Chronology is tightly coupled to the actual date implementation of that chronology.\n\nGenerally speaking, a chronology is an implementation detail of a calendar system that \nshould not be overly visible to the users of the library unless they wish to implement \ntheir own calendrical systems.\n\nInitial implementation contains only implementation for gregorian (and julian) chronologies. \nThis API is considered experimental and can change significantly between releases, so dependency \non this package is not advisable for general use.\n"]},gregorian:{super:{pk:".",nm:"GregorianCalendar"},pa:1,mt:"o",$at:{november:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"november"},may:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"may"},august:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"august"},february:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"february"},july:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"july"},epoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["Epoch of the gregorian calendar."]},nm:"epoch"},april:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"april"},march:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"march"},june:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"june"},september:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"september"},january:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"january"},december:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"december"},october:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",nm:"october"}},$m:{newYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Returns fixed date value of the first day of the gregorian year."]},nm:"newYear"},fixed$jr0536:{$t:{md:"$",pk:"$",nm:"Integer"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"}]],mt:"m",an:{doc:["Return the _day of era_ from a given date."]},nm:"fixed"},yearFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"fixed"}]],mt:"m",an:{doc:["Returns a gregorian year number of the fixed date value."]},nm:"yearFrom"},fixedFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{$t:{md:"$",pk:"$",nm:"Integer"},count:3,pk:"$",nm:"Tuple"},mt:"prm",nm:"date"}]],mt:"m",an:{doc:["Return the _day of era_ from a given date."]},nm:"fixedFrom"},yearEnd:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Returns fixed date value of the last day of the gregorian year."]},nm:"yearEnd"},dayFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],mt:"m",an:{doc:["Returns day of month value of the fixed date value."]},nm:"dayFrom"},monthFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],mt:"m",an:{doc:["Returns the month number of the gregorian calendar from the fixed date value."]},nm:"monthFrom"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Gregorian leap year rule states that every fourth year\nis a leap year except century years not divisible by 400."]},nm:"leapYear"},checkDate:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{$t:{md:"$",pk:"$",nm:"Integer"},count:3,pk:"$",nm:"Tuple"},mt:"prm",nm:"date"}]],$ff:1,mt:"m",an:{doc:["Assert that specified date has it conjunction of year, month and day as valid gregorian values."]},nm:"checkDate"},dateFrom:{$t:{$t:{md:"$",pk:"$",nm:"Integer"},count:3,pk:"$",nm:"Tuple"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],mt:"m",an:{doc:["Converts the fixed date value to an equivalent gregorian date."]},nm:"dateFrom"},dayOfWeekFrom:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"date"}]],mt:"m",an:{doc:["Returns _day of week_ value for the specified fixed date value."]},nm:"dayOfWeekFrom"}},an:{doc:["Represents the implementation of all calculations for\nthe rules based on Gregorian Calendar."]},nm:"gregorian"}},"ceylon.time":{date:{$t:{pk:".",nm:"Date"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"}]],mt:"m",an:{doc:["Returns a date based on the specified year, month and day of month values."]},nm:"date"},dateTime:{$t:{pk:".",nm:"DateTime"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:"ceylon.time.base",nm:"Month"}]},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"day"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"minutes"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"seconds"},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a date based on the specified year, month and day of month values."]},nm:"dateTime"},"$pkg-pa":1,FixedInstant:{super:{md:"$",pk:"$",nm:"Basic"},sts:[{pk:".",nm:"Clock"}],ps:[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"fixedInstant"}],mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:{doc:["Returns the fixed [[Instant]] that this [[Clock]] represents."]},nm:"string"},fixedInstant$dw5xdz:{$t:{pk:".",nm:"Instant"},mt:"a",nm:"fixedInstant"}},$m:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:{doc:["Returns milliseconds from the fixed instant."]},nm:"milliseconds"},instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",an:{doc:["Returns the fixed instant."]},nm:"instant"}},an:{doc:["Implementation of a clock that always returns the same instant.\n\nThis is typically used for testing."]},nm:"FixedInstant"},offsetTime:{$t:{pk:".",nm:"Clock"},pa:1,ps:[[{$t:{pk:".",nm:"Clock"},mt:"prm",nm:"baseClock"},{$t:{pk:".",nm:"Duration"},mt:"prm",nm:"offset"}]],mt:"m",an:{doc:["Returns an implementation of a clock that always returns a \nconstant offset from the value of the provided clock."]},nm:"offsetTime"},Instant:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time.base",nm:"ReadableInstant"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Instant"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Instant"}],nm:"Enumerable"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:{doc:["Internal value of an instant as a number of milliseconds since\n1970-01-01T00:00:00.000Z."]},nm:"millisecondsOfEpoch",$hdn:1}],mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns ISO-8601 formatted String representation of this _time of day_ in UTC.\n\nReference: [ISO-8601 Time Offsets from UTC](https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_offsets_from_UTC)"]},nm:"string"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"},millisecondsOfEpoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["Internal value of an instant as a number of milliseconds since\n1970-01-01T00:00:00.000Z."]},nm:"millisecondsOfEpoch"}},$m:{dateTime:{$t:{pk:".",nm:"DateTime"},pa:1,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],mt:"m",an:{doc:["Returns this instant as a [[DateTime]] value."]},nm:"dateTime"},date:{$t:{pk:".",nm:"Date"},pa:1,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],mt:"m",an:{doc:["Returns this instant as a [[Date]] value."]},nm:"date"},minus:{$t:{pk:".",nm:"Instant"},pa:1,ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Duration"},{pk:".",nm:"Period"}]},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Subtracts a period to this instant."]},nm:"minus"},zoneDateTime:{$t:{pk:"ceylon.time.timezone",nm:"ZoneDateTime"},pa:1,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],mt:"m",an:{doc:["Returns ZoneDateTime value for this instant."]},nm:"zoneDateTime"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Compares this instant to the _other_ instant."]},nm:"compare"},durationFrom:{$t:{pk:".",nm:"Duration"},pa:1,ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns duration in milliseconds from other instant to this instant."]},nm:"durationFrom"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns _true_ if given value is same type and milliseconds of epoch."]},nm:"equals"},durationTo:{$t:{pk:".",nm:"Duration"},pa:1,ps:[[{$t:{pk:".",nm:"Instant"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns duration in milliseconds from this instant to the other instant."]},nm:"durationTo"},neighbour:{$t:{pk:".",nm:"Instant"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},time:{$t:{pk:".",nm:"Time"},pa:1,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],mt:"m",an:{doc:["Returns _time of day_ for this instant."]},nm:"time"},plus:{$t:{pk:".",nm:"Instant"},pa:1,ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Duration"},{pk:".",nm:"Period"}]},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Adds a period to this instant."]},nm:"plus"}},an:{doc:["A specific instant of time on a continuous time-scale.\n\nAn instant represents a single point in time irrespective of \nany time-zone offsets or geographical locations."]},nm:"Instant"},FixedMilliseconds:{super:{md:"$",pk:"$",nm:"Basic"},sts:[{pk:".",nm:"Clock"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"fixedMilliseconds"}],mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:{doc:["Returns the fixed [[Instant]] that this [[Clock]] represents."]},nm:"string"},fixedMilliseconds$ip85yf:{$t:{md:"$",pk:"$",nm:"Integer"},mt:"a",nm:"fixedMilliseconds"}},$m:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:{doc:["Returns the fixed milliseconds."]},nm:"milliseconds"},instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",an:{doc:["Returns the instant from the fixed milliseconds."]},nm:"instant"}},an:{doc:["Implementation of a clock that always returns the same instant.\n\nThis is typically used for testing."]},nm:"FixedMilliseconds"},Period:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time.base",nm:"ReadablePeriod"},{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Period"}],nm:"PeriodBehavior"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Period"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Period"}],nm:"Summable"},{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",pk:".",nm:"Period"}],nm:"Scalable"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,def:1,mt:"prm",an:{doc:["The number of years."]},nm:"years",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,def:1,mt:"prm",an:{doc:["The number of months."]},nm:"months",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,def:1,mt:"prm",an:{doc:["The number of days."]},nm:"days",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,def:1,mt:"prm",an:{doc:["The number of hours."]},nm:"hours",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,def:1,mt:"prm",an:{doc:["The number of minutes."]},nm:"minutes",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,def:1,mt:"prm",an:{doc:["The number of seconds."]},nm:"seconds",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,def:1,mt:"prm",an:{doc:["The number of milliseconds."]},nm:"milliseconds",$hdn:1}],mt:"c",$at:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["The number of milliseconds."]},nm:"milliseconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["The number of hours."]},nm:"hours"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["The number of seconds."]},nm:"seconds"},dateOnly:{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},pa:3,mt:"g",an:{doc:["Returns a date only view of this period."]},nm:"dateOnly"},timeOnly:{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},pa:3,mt:"g",an:{doc:["Returns a time only view of this period."]},nm:"timeOnly"},months:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["The number of months."]},nm:"months"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns the ISO-8601 formatted string for this period."]},nm:"string"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["The number of minutes."]},nm:"minutes"},days:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["The number of days."]},nm:"days"},years:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["The number of years."]},nm:"years"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:".",nm:"Period"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Return the result of comparing this period to the _other_ period."]},nm:"compare"},plusHours:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of hours added."]},nm:"plusHours"},minusHours:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of hours subtracted."]},nm:"minusHours"},normalized:{$t:{pk:".",nm:"Period"},pa:3,mt:"m",an:{doc:["Returns a copy of this period with all amounts normalized to the\nstandard ranges for date\/time fields.\n\nTwo normalizations occur, one for years and months, and one for\nhours, minutes, seconds and milliseconds.\n\nDays are not normalized, as a day may vary in length at daylight savings cutover.\nNeither is days normalized into months, as number of days per month varies from\nmonth to another and depending on the leap year."]},nm:"normalized"},withHours:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of hours."]},nm:"withHours"},withSeconds:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of seconds."]},nm:"withSeconds"},scale:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"scale"}]],mt:"m",an:{doc:["Each field will be scalable independently, and the result will _not_ be normalized"]},nm:"scale"},plusMinutes:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of minutes added."]},nm:"plusMinutes"},plusDays:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of days added."]},nm:"plusDays"},minusMinutes:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of minutes subtracted."]},nm:"minusMinutes"},plusSeconds:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of seconds added."]},nm:"plusSeconds"},isZero:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,mt:"m",an:{doc:["Checks if this period is zero-length."]},nm:"isZero"},withDays:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of days."]},nm:"withDays"},withMilliseconds:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of milliseconds."]},nm:"withMilliseconds"},withMonths:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of months."]},nm:"withMonths"},withMinutes:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of minutes."]},nm:"withMinutes"},minusYears:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of years subtracted."]},nm:"minusYears"},minusMilliseconds:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of milliseconds subtracted."]},nm:"minusMilliseconds"},plusMonths:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of months added."]},nm:"plusMonths"},plusYears:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of years added."]},nm:"plusYears"},plus:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{pk:".",nm:"Period"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns a new period that is a sum of the two periods."]},nm:"plus"},minusDays:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of days subtracted."]},nm:"minusDays"},minusMonths:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of months subtracted."]},nm:"minusMonths"},plusMilliseconds:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of milliseconds added."]},nm:"plusMilliseconds"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Checks if this period is equal to another period."]},nm:"equals"},withYears:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of years."]},nm:"withYears"},minusSeconds:{$t:{pk:".",nm:"Period"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of seconds subtracted."]},nm:"minusSeconds"}},an:{doc:["An immutable period consisting of the ISO-8601 _years_, _months_, _days_, _hours_,\n_minutes_, _seconds_ and _milliseconds_, such as '3 Months, 4 Days and 7 Hours'.\n\nA period is a human-scale description of an amount of time.\n"]},nm:"Period"},Duration:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time.base",nm:"ReadableDuration"},{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Integer"},{mt:"tp",pk:".",nm:"Duration"}],nm:"Scalable"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"prm",an:{doc:["Number of milliseconds of this duration."]},nm:"milliseconds",$hdn:1}],mt:"c",$at:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",an:{doc:["Number of milliseconds of this duration."]},nm:"milliseconds"},period:{$t:{pk:".",nm:"Period"},pa:1,mt:"g",an:{doc:["Returns this duration as a period of milliseconds."]},nm:"period"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",an:{doc:["Returns the string representation of this duration."]},nm:"string"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Duration is considered equal when type and milliseconds are the same."]},nm:"equals"},scale:{$t:{pk:".",nm:"Duration"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"scale"}]],mt:"m",an:{doc:["Returns a new [[Duration]] with it´s milliseconds scaled."]},nm:"scale"}},an:{doc:["Duration specifies a discreet amount of milliseconds between two instances of time."]},nm:"Duration"},Time:{pa:1,sts:[{pk:"ceylon.time.base",nm:"ReadableTime"},{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Time"}],nm:"TimeBehavior"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Time"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Time"}],nm:"Ordinal"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Time"}],nm:"Enumerable"}],mt:"i",$m:{minus:{$t:{pk:".",nm:"Time"},pa:5,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Subtracts a period of time to this time of day value.\n\nResult of this operation is another time of day,\nwrapping around 12 a.m. (midnight) if necessary.\n"]},nm:"minus"},periodTo:{$t:{pk:".",nm:"Period"},pa:5,ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"end"}]],mt:"m",an:{doc:["Returns the period between this and the given time.\nIf this time is after the given time then return zero period."]},nm:"periodTo"},rangeTo:{$t:{pk:".",nm:"TimeRange"},pa:5,ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the [[TimeRange]] between this and given Time."]},nm:"rangeTo"},periodFrom:{$t:{pk:".",nm:"Period"},pa:5,ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"start"}]],mt:"m",an:{doc:["Returns the period between this and the given time.\nIf this time is before the given time then return zero period."]},nm:"periodFrom"},plus:{$t:{pk:".",nm:"Time"},pa:5,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableTimePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Adds a period of time to this time of day value.\n\nResult of this operation is another time of day,\nwrapping around 12 a.m. (midnight) if necessary.\n"]},nm:"plus"}},an:{doc:["Time of day like _6pm_ or _8.30am_.\n\nThis type contains only information about an abstract _time of day_ without \nreferencing any date or timezone.\n\nYou use Time to specify something that has to occur on a specific time of day\nlike _\"lunch hour starts at 1pm\"_ or _\"shop opens at 10am\"_.\n"]},nm:"Time"},Clock:{pa:1,mt:"i",$m:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"m",an:{doc:["Gets the current millisecond instant of the clock."]},nm:"milliseconds"},instant:{$t:{pk:".",nm:"Instant"},pa:5,mt:"m",an:{doc:["Gets the current instant of the clock."]},nm:"instant"}},an:{doc:["A clock providing access to the current instant, date and time using a time-zone.\n\nInstances of this class are used to find the current instant, which can be\ninterpreted using the stored time-zone to find the current date and time.\nAs such, a clock can be used instead of `system.milliseconds`.\n\nThe primary purpose of this abstraction is to allow alternate clocks to be\nplugged in as and when required. Applications use an object to obtain the\ncurrent time rather than a static method. This can simplify testing.\n\nApplications should _avoid_ using the top level objects directly.\nInstead, they should pass a [[Clock]] into any method that requires it.\nA dependency injection framework is one way to achieve this.\n\nThis approach allows an alternate clock, such as [[fixedTime]] to be used during testing.\n\nThe [[systemTime]] top level factory method offers clocks based on the best available \nsystem clock, such as `system.milliseconds`."]},nm:"Clock"},fixedTime:{$t:{pk:".",nm:"Clock"},pa:1,ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Instant"},{md:"$",pk:"$",nm:"Integer"}]},mt:"prm",nm:"instant"}]],mt:"m",an:{doc:["Gets a clock that always returns the same instant in the UTC time-zone."]},nm:"fixedTime"},systemTime:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"Clock"}],mt:"o",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:{doc:["Returns only the kind of this implementation as time can change to every call."]},nm:"string"}},$m:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",an:{doc:["Return number of milliseconds from system time."]},nm:"milliseconds"},instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",an:{doc:["Return current instant from system time."]},nm:"instant"}},an:{doc:["Gets a clock that obtains the current instant using the best available system clock."]},nm:"systemTime"},Date:{pa:1,sts:[{pk:"ceylon.time.base",nm:"ReadableDate"},{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Date"}],nm:"DateBehavior"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Date"}],nm:"Ordinal"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Date"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Date"}],nm:"Enumerable"}],mt:"i",$m:{minus:{$t:{pk:".",nm:"Date"},pa:5,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Subtracts a specified period to this date."]},nm:"minus"},periodTo:{$t:{pk:".",nm:"Period"},pa:5,ps:[[{$t:{pk:".",nm:"Date"},mt:"prm",nm:"end"}]],mt:"m",an:{doc:["Returns the period between this and the given date.\n\nIf this date is after the given date then return zero period."]},nm:"periodTo"},rangeTo:{$t:{pk:".",nm:"DateRange"},pa:5,ps:[[{$t:{pk:".",nm:"Date"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the [[DateRange]] between this and given [[Date]]."]},nm:"rangeTo"},at:{$t:{pk:".",nm:"DateTime"},pa:5,ps:[[{$t:{pk:".",nm:"Time"},mt:"prm",nm:"time"}]],mt:"m",an:{doc:["Returns new DateTime value based on this date and a specified time."]},nm:"at"},periodFrom:{$t:{pk:".",nm:"Period"},pa:5,ps:[[{$t:{pk:".",nm:"Date"},mt:"prm",nm:"start"}]],mt:"m",an:{doc:["Returns the period between this and the given date.\n\nIf this date is before the given date then return zero period."]},nm:"periodFrom"},plus:{$t:{pk:".",nm:"Date"},pa:5,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadableDatePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Adds a specified period to this date."]},nm:"plus"}},an:{doc:["An interface for date objects in the ISO-8601 calendar system.\n\nA date is often viewed as triple of year-month-day values. \nThis interface also defines access to other date fields such as \nday-of-year, day-of-week and week-of-year."]},nm:"Date"},DateTime:{pa:1,sts:[{pk:"ceylon.time.base",nm:"ReadableDateTime"},{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"DateTime"},{mt:"tp",pk:".",nm:"Date"},{mt:"tp",pk:".",nm:"Time"}],nm:"DateTimeBehavior"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DateTime"}],nm:"Ordinal"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DateTime"}],nm:"Enumerable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DateTime"}],nm:"Comparable"}],mt:"i",$m:{minus:{$t:{pk:".",nm:"DateTime"},pa:5,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Subtracts a specified period to this date and time."]},nm:"minus"},periodTo:{$t:{pk:".",nm:"Period"},pa:5,ps:[[{$t:{pk:".",nm:"DateTime"},mt:"prm",nm:"end"}]],mt:"m",an:{doc:["Returns the period between this and the given DateTime.\n\nIf this DateTime is after the given DateTime then return zero period."]},nm:"periodTo"},rangeTo:{$t:{pk:".",nm:"DateTimeRange"},pa:5,ps:[[{$t:{pk:".",nm:"DateTime"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the [[DateTimeRange]] between this and given [[DateTime]]."]},nm:"rangeTo"},periodFrom:{$t:{pk:".",nm:"Period"},pa:5,ps:[[{$t:{pk:".",nm:"DateTime"},mt:"prm",nm:"start"}]],mt:"m",an:{doc:["Returns the period between this and the given DateTime.\n\nIf this date is before the given date then return zero period."]},nm:"periodFrom"},plus:{$t:{pk:".",nm:"DateTime"},pa:5,ps:[[{$t:{pk:"ceylon.time.base",nm:"ReadablePeriod"},mt:"prm",nm:"period"}]],mt:"m",an:{doc:["Adds a specified period to this date and time."]},nm:"plus"},instant:{$t:{pk:".",nm:"Instant"},pa:5,ps:[[{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],mt:"m",an:{doc:["Returns an instant from this [[DateTime]]."]},nm:"instant"}},an:{doc:["An abstract moment in time (like _4pm, October 21. 2012_).\n\nDateTime does not contain a time zone information, so You can not use it to record or \nschedule events."]},nm:"DateTime"},zero:{$t:{pk:".",nm:"Period"},pa:1,mt:"a",an:{doc:["A period of zero length."]},nm:"zero"},TimeRange:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Time"},{mt:"tp",pk:"ceylon.time.base",nm:"UnitOfTime"}],nm:"Range"}],ps:[{$t:{pk:".",nm:"Time"},pa:3,mt:"prm",an:{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]},nm:"from",$hdn:1},{$t:{pk:".",nm:"Time"},pa:3,mt:"prm",an:{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]},nm:"to",$hdn:1},{$t:{pk:"ceylon.time.base",nm:"UnitOfTime"},pa:3,def:1,mt:"prm",an:{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]},nm:"step",$hdn:1}],mt:"c",$at:{duration:{$t:{pk:".",nm:"Duration"},pa:3,mt:"g",an:{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]},nm:"duration"},period:{$t:{pk:".",nm:"Period"},pa:3,mt:"g",an:{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]},nm:"period"},from:{$t:{pk:".",nm:"Time"},pa:3,mt:"a",an:{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]},nm:"from"},step:{$t:{pk:"ceylon.time.base",nm:"UnitOfTime"},pa:3,mt:"a",an:{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]},nm:"step"},to:{$t:{pk:".",nm:"Time"},pa:3,mt:"a",an:{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]},nm:"to"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{nextByStep$9cla77:{$t:{pk:".",nm:"Time"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],mt:"m",an:{doc:["The iteration for each element should always start from same point."]},nm:"nextByStep"},iterator:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Time"}],nm:"Iterator"},pa:3,mt:"m",$o:{listIterator$itbwha:{super:{md:"$",pk:"$",nm:"Basic"},sts:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Time"}],nm:"Iterator"}],mt:"o",$at:{count$dw3q34:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"count"}},$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Time"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"listIterator"}},an:{doc:["An iterator for the elements belonging to this \ncontainer. where each jump is based on actual step of this Range."]},nm:"iterator"},previousByStep$1wvr21:{$t:{pk:".",nm:"Time"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],mt:"m",an:{doc:["The iteration for each element should always start from same point."]},nm:"previousByStep"},overlap:{$t:{comp:"u",l:[{pk:".",nm:"TimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Time"},{mt:"tp",pk:"ceylon.time.base",nm:"UnitOfTime"}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A]\n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]},nm:"overlap"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]},nm:"equals"},gap:{$t:{comp:"u",l:[{pk:".",nm:"TimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Time"},{mt:"tp",pk:"ceylon.time.base",nm:"UnitOfTime"}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A]\n- The precision is based on the lowest unit\n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n\nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]},nm:"gap"},stepBy:{$t:{pk:".",nm:"TimeRange"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"UnitOfTime"},mt:"prm",nm:"step"}]],mt:"m",an:{doc:["Define how this Range will get next or previous element while iterating."]},nm:"stepBy"}},an:{see:["Range"],doc:["Implementation of [[Range]] and allows easy iteration between [[Time]] types.\n\nProvides all power of [[Iterable]] features and complements with:\n* Easy way to recover [[Period]]\n* Easy way to recover [[Duration]]\n* Recover the overlap between [[TimeRange]] types\n* Recover the gap between [[TimeRange]] types\n* Allows customized way to iterate as navigate between values by [[UnitOfTime]] cases\n"]},nm:"TimeRange"},DateRange:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Date"},{mt:"tp",pk:"ceylon.time.base",nm:"UnitOfDate"}],nm:"Range"}],ps:[{$t:{pk:".",nm:"Date"},pa:3,mt:"prm",an:{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]},nm:"from",$hdn:1},{$t:{pk:".",nm:"Date"},pa:3,mt:"prm",an:{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]},nm:"to",$hdn:1},{$t:{pk:"ceylon.time.base",nm:"UnitOfDate"},pa:3,def:1,mt:"prm",an:{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]},nm:"step",$hdn:1}],mt:"c",$at:{duration:{$t:{pk:".",nm:"Duration"},pa:3,mt:"g",an:{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]},nm:"duration"},period:{$t:{pk:".",nm:"Period"},pa:3,mt:"g",an:{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]},nm:"period"},from:{$t:{pk:".",nm:"Date"},pa:3,mt:"a",an:{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]},nm:"from"},step:{$t:{pk:"ceylon.time.base",nm:"UnitOfDate"},pa:3,mt:"a",an:{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]},nm:"step"},to:{$t:{pk:".",nm:"Date"},pa:3,mt:"a",an:{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]},nm:"to"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{iterator:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Date"}],nm:"Iterator"},pa:3,mt:"m",$o:{listIterator$bgdwol:{super:{md:"$",pk:"$",nm:"Basic"},sts:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Date"}],nm:"Iterator"}],mt:"o",$at:{count$1fh4vb:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"count"}},$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Date"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"listIterator"}},an:{doc:["An iterator for the elements belonging to this \ncontainer. where each jump is based on actual step of this Range."]},nm:"iterator"},nextByStep$x6l2vu:{$t:{pk:".",nm:"Date"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],mt:"m",an:{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]},nm:"nextByStep"},overlap:{$t:{comp:"u",l:[{pk:".",nm:"DateRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Date"},{mt:"tp",pk:"ceylon.time.base",nm:"UnitOfDate"}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]},nm:"overlap"},previousByStep$lx41mm:{$t:{pk:".",nm:"Date"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],mt:"m",an:{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]},nm:"previousByStep"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]},nm:"equals"},gap:{$t:{comp:"u",l:[{pk:".",nm:"DateRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"Date"},{mt:"tp",pk:"ceylon.time.base",nm:"UnitOfDate"}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]},nm:"gap"},stepBy:{$t:{pk:".",nm:"DateRange"},pa:3,ps:[[{$t:{pk:"ceylon.time.base",nm:"UnitOfDate"},mt:"prm",nm:"step"}]],mt:"m",an:{doc:["Define how this Range will get next or previous element while iterating."]},nm:"stepBy"}},an:{see:["Range"],doc:["Implementation of [[Range]] and allows easy iteration between [[Date]] types.\n\nProvides all power of [[Iterable]] features and complements with:\n* Easy way to recover [[Period]]\n* Easy way to recover [[Duration]]\n* Recover the overlap between [[DateRange]] types\n* Recover the gap between [[DateRange]] types\n* Allows customized way to iterate as navigate between values by [[UnitOfDate]] cases\n"]},nm:"DateRange"},OffsetClock:{super:{md:"$",pk:"$",nm:"Basic"},sts:[{pk:".",nm:"Clock"}],ps:[{$t:{pk:".",nm:"Clock"},mt:"prm",nm:"baseClock"},{$t:{pk:".",nm:"Duration"},mt:"prm",nm:"offset"}],mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",an:{doc:["Returns the [[offsetTime]] period from given [[Clock]]."]},nm:"string"},baseClock$wp0y7f:{$t:{pk:".",nm:"Clock"},mt:"a",nm:"baseClock"},offset$fimsw5:{$t:{pk:".",nm:"Duration"},mt:"a",nm:"offset"}},$m:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"m",nm:"milliseconds"},instant:{$t:{pk:".",nm:"Instant"},pa:3,mt:"m",nm:"instant"}},an:{doc:["An implementation of a [[Clock]] that returns time with a constant \noffset from the provided clock."]},nm:"OffsetClock"},today:{$t:{pk:".",nm:"Date"},pa:1,ps:[[{$t:{pk:".",nm:"Clock"},def:1,mt:"prm",nm:"clock"},{$t:{pk:"ceylon.time.timezone",nm:"TimeZone"},def:1,mt:"prm",nm:"timeZone"}]],mt:"m",an:{doc:["Returns current date according to the provided system clock and time zone."]},nm:"today"},now:{$t:{pk:".",nm:"Instant"},pa:1,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Clock"}]},def:1,mt:"prm",nm:"clock"}]],mt:"m",an:{doc:["Obtains the current instant from the system clock."]},nm:"now"},DateTimeRange:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"DateTime"},{comp:"u",mt:"tp",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]}],nm:"Range"}],ps:[{$t:{pk:".",nm:"DateTime"},pa:3,mt:"prm",an:{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]},nm:"from",$hdn:1},{$t:{pk:".",nm:"DateTime"},pa:3,mt:"prm",an:{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]},nm:"to",$hdn:1},{$t:{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]},pa:3,def:1,mt:"prm",an:{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]},nm:"step",$hdn:1}],mt:"c",$at:{duration:{$t:{pk:".",nm:"Duration"},pa:3,mt:"g",an:{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]},nm:"duration"},period:{$t:{pk:".",nm:"Period"},pa:3,mt:"g",an:{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]},nm:"period"},from:{$t:{pk:".",nm:"DateTime"},pa:3,mt:"a",an:{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]},nm:"from"},step:{$t:{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]},pa:3,mt:"a",an:{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]},nm:"step"},to:{$t:{pk:".",nm:"DateTime"},pa:3,mt:"a",an:{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]},nm:"to"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{iterator:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DateTime"}],nm:"Iterator"},pa:3,mt:"m",$o:{listIterator$tg8jkg:{super:{md:"$",pk:"$",nm:"Basic"},sts:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DateTime"}],nm:"Iterator"}],mt:"o",$at:{count$xwt382:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"count"}},$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"DateTime"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"listIterator"}},an:{doc:["An iterator for the elements belonging to this \ncontainer. where each jump is based on actual step of this Range."]},nm:"iterator"},overlap:{$t:{comp:"u",l:[{pk:".",nm:"DateTimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"DateTime"},{comp:"u",mt:"tp",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]},nm:"overlap"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]},nm:"equals"},gap:{$t:{comp:"u",l:[{pk:".",nm:"DateTimeRange"},{md:"$",pk:"$",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:"ceylon.time.base",tp:[{mt:"tp",pk:".",nm:"DateTime"},{comp:"u",mt:"tp",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]},nm:"gap"},nextByStep$cusa3f:{$t:{pk:".",nm:"DateTime"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],mt:"m",an:{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]},nm:"nextByStep"},previousByStep$o49bcn:{$t:{pk:".",nm:"DateTime"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"jump"}]],mt:"m",an:{doc:["The iteration for each element should always start from same point,\nthis way is possible to not suffer with different number of days in months."]},nm:"previousByStep"},stepBy:{$t:{pk:".",nm:"DateTimeRange"},pa:3,ps:[[{$t:{comp:"u",l:[{pk:"ceylon.time.base",nm:"UnitOfDate"},{pk:"ceylon.time.base",nm:"UnitOfTime"}]},mt:"prm",nm:"step"}]],mt:"m",an:{doc:["Define how this Range will get next or previous element while iterating."]},nm:"stepBy"}},an:{doc:["Implementation of [[Range]] and allows easy iteration between [[DateTime]] types.\n\nProvides all power of [[Iterable]] features and complements with:\n* Easy way to recover [[Period]]\n* Easy way to recover [[Duration]]\n* Recover the overlap between [[DateTimeRange]] types\n* Recover the gap between [[DateTimeRange]] types\n* Allows customized way to iterate as navigate between values by [[UnitOfDate]] or [[UnitOfTime]] cases\n"]},nm:"DateTimeRange"},time:{$t:{pk:".",nm:"Time"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:{doc:["Hours of the day (0..23)."]},nm:"hours",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",an:{doc:["Minutes of the hour (0..59)."]},nm:"minutes",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",an:{doc:["Seconds of the minute (0..59)."]},nm:"seconds",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",an:{doc:["Milliseconds of the second (0..999)."]},nm:"milliseconds",$hdn:1}]],mt:"m",an:{doc:["Creates new instance of [[Time]]."]},nm:"time"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"],doc:["Main package for the Ceylon's Date and Time library.\n\nLike in [JodaTime] and [JSR-310], there is a _machine timeline_ and a _human timeline_.\n\n[JodaTime]: http:\/\/joda-time.sourceforge.net\n[JSR-310]: http:\/\/sourceforge.net\/apps\/mediawiki\/threeten\/index.php?title=ThreeTen\n\n## Machine timeline\n\nMachine timeline is represented by an [[Instant]] that is basically just an object\nwrapper around an [[Integer]] representing _[Unix time]_ value. A value of an Instant\nuniquely identifies a particular instant of time without needing to take into account\ntimezone information and contain no ambiguities associated with [DST] changeover times.\n\n[Unix time]: http:\/\/en.wikipedia.org\/wiki\/Unix_time\n[DST]: http:\/\/en.wikipedia.org\/wiki\/Daylight_saving_time\n\n## Human timeline\n\nHuman timeline is based mostly on Gregorian and ISO-8601 calendar systems and consists of\nthe following principal data types:\n\n* [[Date]] -- A date value without time component.\n* [[Time]] -- A time of day vallue without date component.\n* [[DateTime]] -- A particular time of a particular date.\n* [[ceylon.time.timezone::ZoneDateTime]] -- A particular moment of time identified by date, time of day and\n  a time zone.\n\n**Note:** At the moment, timezone is not fully supported, therefore current\nconversions can uses offsets provided by VMs  and provides some features like [[ceylon.time.timezone::timeZone]]\nobject that allows parser and creation of fixed offsets.\n"]}},"ceylon.time.timezone.model":{ZoneRule:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",of:[{pk:".",nm:"standardZoneRule"},{pk:".",nm:"PeriodZoneRule"},{pk:".",nm:"BasedZoneRule"}],an:{doc:["Whether daylight saving time is being observed:\n\n* [[standardZoneRule]]: A hyphen, a kind of `null` value, \n  means that we have not set our clocks ahead of standard time.\n* [[PeriodZoneRule]]: An amount of time (usually but not necessarily `1:00` meaning one hour)\n  means that we have set our clocks ahead by that amount.\n* [[BasedZoneRule]]: Some alphabetic string means that we might have set our clocks ahead;\n  and we need to check the rule the name of which is the given alphabetic string."]},nm:"ZoneRule"},standardZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,mt:"o",nm:"standardZoneFormat"},AtWallClockTime:{super:{pk:".",nm:"AtTime"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],mt:"c",$at:{time$h07jro:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},an:{doc:["Wall clock time rule.\n\nOffset from GMT varies depending wether the DST is in effect at the moment or not."]},nm:"AtWallClockTime"},standardZoneRule:{super:{pk:".",nm:"ZoneRule"},pa:1,mt:"o",nm:"standardZoneRule"},BasedZoneRule:{super:{pk:".",nm:"ZoneRule"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"ruleName",$hdn:1}],mt:"c",$at:{ruleName:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"ruleName"}},nm:"BasedZoneRule"},OnDay:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",of:[{pk:".",nm:"OnFixedDay"},{pk:".",nm:"OnFirstOfMonth"},{pk:".",nm:"OnLastOfMonth"}],$m:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:5,ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",nm:"date"}},an:{doc:["Rule describing the day a rule applieds to."]},nm:"OnDay"},ZoneTimeline:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"prm",nm:"offset",$hdn:1},{$t:{pk:".",nm:"ZoneRule"},pa:1,mt:"prm",nm:"rule",$hdn:1},{$t:{pk:".",nm:"ZoneFormat"},pa:1,mt:"prm",nm:"format",$hdn:1},{$t:{pk:".",nm:"ZoneUntil"},pa:1,mt:"prm",nm:"until",$hdn:1}],mt:"c",$at:{offset:{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"a",nm:"offset"},format:{$t:{pk:".",nm:"ZoneFormat"},pa:1,mt:"a",nm:"format"},rule:{$t:{pk:".",nm:"ZoneRule"},pa:1,mt:"a",nm:"rule"},until:{$t:{pk:".",nm:"ZoneUntil"},pa:1,mt:"a",nm:"until"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},nm:"ZoneTimeline"},AliasName:{pa:1,$alias:{md:"$",pk:"$",nm:"String"},mt:"als",an:{doc:["Alternative name (i.e. _alias_) of the time zone"]},nm:"AliasName"},AbbreviationZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"abbreviation",$hdn:1}],mt:"c",$at:{abbreviation:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"abbreviation"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},nm:"AbbreviationZoneFormat"},AtUtcTime:{super:{pk:".",nm:"AtTime"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],mt:"c",$at:{time$cqe33g:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},an:{doc:["UTC time rule."]},nm:"AtUtcTime"},OnFirstOfMonth:{super:{pk:".",nm:"OnDay"},pa:1,ps:[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"prm",nm:"dayOfWeek",$hdn:1},{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"prm",nm:"onDateOrAfter",$hdn:1}],mt:"c",$at:{dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"a",nm:"dayOfWeek"},onDateOrAfter:{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"a",nm:"onDateOrAfter"}},$m:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",nm:"date"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"},matchesDayOfWeekAndDay$42vt2u:{$t:{md:"$",pk:"$",nm:"Boolean"},ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"dateTime"}]],mt:"m",nm:"matchesDayOfWeekAndDay"}},an:{doc:["Represents a day equal to or higher than a day of week.\n\nFor example, given the rule `Sun>=1` it can mean one of the following:\neither _June 1. 2014_ or _June 7. 2015_ (or anything in between) \ndepending on the year and month of the overall rule.\n"]},nm:"OnFirstOfMonth"},"$pkg-pa":1,AtGmtTime:{super:{pk:".",nm:"AtTime"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],mt:"c",$at:{time$oxfz9q:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},an:{doc:["GMT time rule."]},nm:"AtGmtTime"},DayOfMonth:{pa:1,$alias:{md:"$",pk:"$",nm:"Integer"},mt:"als",an:{doc:["Alias to represent a specific day."]},nm:"DayOfMonth"},ReplacedZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"format",$hdn:1}],mt:"c",$at:{format:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"format"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},nm:"ReplacedZoneFormat"},ZoneUntil:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Date"},pa:1,mt:"prm",nm:"date",$hdn:1},{$t:{pk:".",nm:"AtTime"},pa:1,mt:"prm",nm:"ruleDefinition",$hdn:1}],mt:"c",$at:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:1,mt:"a",nm:"date"},ruleDefinition:{$t:{pk:".",nm:"AtTime"},pa:1,mt:"a",nm:"ruleDefinition"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},an:{doc:["To represent a [[ZoneTimeline]] that continues until the present you should \nuse [[untilPresent]]"]},nm:"ZoneUntil"},PeriodZoneRule:{super:{pk:".",nm:"ZoneRule"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"prm",nm:"period",$hdn:1}],mt:"c",$at:{period:{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"a",nm:"period"}},nm:"PeriodZoneRule"},untilPresent:{$t:{pk:".",nm:"ZoneUntil"},pa:1,mt:"a",nm:"untilPresent"},PairAbbreviationZoneFormat:{super:{pk:".",nm:"ZoneFormat"},pa:1,ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"standardAbbreviation",$hdn:1},{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"daylightAbbreviation",$hdn:1}],mt:"c",$at:{standardAbbreviation:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"standardAbbreviation"},daylightAbbreviation:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"daylightAbbreviation"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},nm:"PairAbbreviationZoneFormat"},OnFixedDay:{super:{pk:".",nm:"OnDay"},pa:1,ps:[{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"prm",nm:"fixedDate",$hdn:1}],mt:"c",$at:{fixedDate:{$t:{pk:".",nm:"DayOfMonth"},pa:1,mt:"a",nm:"fixedDate"}},$m:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",nm:"date"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},an:{doc:["Represents a fixed day of month.\n\nFor example, a value `3` on February, 2004, means exactly _February 3. 2004_.\n"]},nm:"OnFixedDay"},Year:{pa:1,$alias:{md:"$",pk:"$",nm:"Integer"},mt:"als",an:{doc:["Alias to represent a specific year."]},nm:"Year"},AtTime:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,ps:[{$t:{pk:"ceylon.time",nm:"Time"},pa:1,mt:"prm",nm:"time",$hdn:1},{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"letter",$hdn:1}],mt:"c",of:[{pk:".",nm:"AtWallClockTime"},{pk:".",nm:"AtLocalMeanTime"},{pk:".",nm:"AtGmtTime"},{pk:".",nm:"AtUtcTime"},{pk:".",nm:"AtNauticalTime"}],$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},letter:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"letter"},time:{$t:{pk:"ceylon.time",nm:"Time"},pa:1,mt:"a",nm:"time"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},an:{doc:["First, the time that something happens (in the AT column) is not necessarily the local wall clock time. \n\nThe time can be suffixed with \u2018s\u2019 (for \u201Cstandard\u201D) to mean local standard time (different from wall clock time when observing daylight saving time); \nor it can be suffixed with \u2018g\u2019, \u2018u\u2019, or \u2018z\u2019, all three of which mean the standard time at the prime meridan. \n\u2018g\u2019 stands for \u201CGMT\u201D; \n\u2018u\u2019 stands for \u201CUT\u201D or \u201CUTC\u201D (whichever was official at the time); \n\u2018z\u2019 stands for the nautical time zone Z (a.k.a. \u201CZulu\u201D which, in turn, stands for \u2018Z\u2019). \nThe time can also be suffixed with \u2018w\u2019 meaning \u201Cwall clock time;\u201D \nbut it usually isn\u2019t because that\u2019s the default."]},nm:"AtTime"},AtNauticalTime:{super:{pk:".",nm:"AtTime"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],mt:"c",$at:{time$5xyi0b:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},an:{doc:["Nautical time rule."]},nm:"AtNauticalTime"},OnLastOfMonth:{super:{pk:".",nm:"OnDay"},pa:1,ps:[{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"prm",nm:"dayOfWeek",$hdn:1}],mt:"c",$at:{dayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},pa:1,mt:"a",nm:"dayOfWeek"}},$m:{date:{$t:{pk:"ceylon.time",nm:"Date"},pa:3,ps:[[{$t:{pk:".",nm:"Year"},mt:"prm",nm:"year"},{$t:{pk:"ceylon.time.base",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",nm:"date"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},an:{doc:["Represents the last day of week, for example:\n* `lastSun`\n* `lastSat`\n\nFor example, `lastSun` of February 2015 is _February 22, 2015_"]},nm:"OnLastOfMonth"},ZoneFormat:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,mt:"c",of:[{pk:".",nm:"standardZoneFormat"},{pk:".",nm:"AbbreviationZoneFormat"},{pk:".",nm:"PairAbbreviationZoneFormat"},{pk:".",nm:"ReplacedZoneFormat"}],an:{doc:["It can have one of four forms:\n* [[standardZoneFormat]]: the string, \u201Czzz,\u201D which is a kind of null value\n* [[AbbreviationZoneFormat]]: a single alphabetic string other than \u201Czzz,\u201D in which case that\u2019s the abbreviation\n* [[PairAbbreviationZoneFormat]]: a pair of strings separated by a slash (\u2018\/\u2019), in which case the first string is the abbreviation for the standard time name and the second string is the abbreviation for the daylight saving time name\n* [[ReplacedZoneFormat]]: a string containing \u201C%s,\u201D in which case the \u201C%s\u201D will be replaced by the text in the appropriate Rule\u2019s LETTER column"]},nm:"ZoneFormat"},AtLocalMeanTime:{super:{pk:".",nm:"AtTime"},pa:1,ps:[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}],mt:"c",$at:{time$2ab90g:{$t:{pk:"ceylon.time",nm:"Time"},mt:"a",nm:"time"}},an:{doc:["Local mean time rule.\n\nThis has always a fixed offset from the UTC."]},nm:"AtLocalMeanTime"},RealName:{pa:1,$alias:{md:"$",pk:"$",nm:"String"},mt:"als",an:{doc:["Canonical name of the timezone link expression"]},nm:"RealName"},Rule:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,ps:[{$t:{pk:".",nm:"Year"},pa:1,mt:"prm",nm:"fromYear"},{$t:{pk:".",nm:"Year"},pa:1,mt:"prm",nm:"toYear"},{$t:{pk:"ceylon.time.base",nm:"Month"},pa:1,mt:"prm",nm:"inMonth"},{$t:{pk:".",nm:"OnDay"},pa:1,mt:"prm",nm:"onDay"},{$t:{pk:".",nm:"AtTime"},pa:1,mt:"prm",nm:"atTime"},{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"prm",nm:"save"},{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",nm:"letter"}],mt:"c",$at:{toYear:{$t:{pk:".",nm:"Year"},pa:1,mt:"a",nm:"toYear"},atTime:{$t:{pk:".",nm:"AtTime"},pa:1,mt:"a",nm:"atTime"},onDay:{$t:{pk:".",nm:"OnDay"},pa:1,mt:"a",nm:"onDay"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},fromYear:{$t:{pk:".",nm:"Year"},pa:1,mt:"a",nm:"fromYear"},letter:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"letter"},save:{$t:{pk:"ceylon.time",nm:"Period"},pa:1,mt:"a",nm:"save"},inMonth:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:1,mt:"a",nm:"inMonth"}},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"}},an:{doc:["Timezone transition rule."]},nm:"Rule"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"],doc:[" All the models are intended to be unrelated of the database origin.\n\nP.S.: Its not intended to be used outside of ceylon.time and currently\nits as shared because we need to test it."]},Link:{pa:1,$alias:{$t:{pk:".",nm:"RealName"},count:2,pk:"$",nm:"Tuple"},mt:"als",an:{doc:["Tuple representing the Timezone aliasing rules."]},nm:"Link"}},"ceylon.time.timezone.parser.iana":{parseMonth:{$t:{pk:"ceylon.time.base",nm:"Month"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"month"}]],mt:"m",nm:"parseMonth"},findDayOfWeek:{$t:{pk:"ceylon.time.base",nm:"DayOfWeek"},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"dayOfWeek"}]],mt:"m",nm:"findDayOfWeek"},"$pkg-pa":1,parseRuleLine:{$t:{pk:"$",l:[{pk:".",nm:"RuleName"},{pk:"ceylon.time.timezone.model",nm:"Rule"}],nm:"Tuple"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"line"}]],mt:"m",nm:"parseRuleLine"},adjustToEndOfDayIfNecessary:{$t:{pk:"ceylon.time",nm:"Time"},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["The rules represent the end of day as 24:00 and our ceylon.time.Time \ndoes have another semantic for this."]},nm:"adjustToEndOfDayIfNecessary"},parseOnDay:{$t:{pk:"ceylon.time.timezone.model",nm:"OnDay"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],mt:"m",nm:"parseOnDay"},parseZoneLine:{$t:{pk:"$",l:[{pk:".",nm:"ZoneName"},{pk:"ceylon.time.timezone.model",nm:"ZoneTimeline"}],nm:"Tuple"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"line"},{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"ZoneName"}]},def:1,mt:"prm",nm:"zoneName"}]],mt:"m",nm:"parseZoneLine"},parseYear:{$t:{md:"$",pk:"$",nm:"Integer"},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"year"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"defaultYear"}]],mt:"m",nm:"parseYear"},ZoneName:{pa:1,$alias:{md:"$",pk:"$",nm:"String"},mt:"als",nm:"ZoneName"},Signal:{pa:1,$alias:{md:"$",pk:"$",nm:"Integer"},mt:"als",an:{doc:["Alias to represent a specific signal:\n* Positive = 1\n* Negative = -1"]},nm:"Signal"},parseZoneFormat:{$t:{pk:"ceylon.time.timezone.model",nm:"ZoneFormat"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],mt:"m",nm:"parseZoneFormat"},tokenDelimiter:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"char"}]],mt:"m",nm:"tokenDelimiter"},parseUntil:{$t:{pk:"ceylon.time.timezone.model",nm:"ZoneUntil"},pa:1,ps:[[{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"String"}],nm:"Sequential"},mt:"prm",nm:"token"}]],mt:"m",nm:"parseUntil"},toPeriod:{$t:{pk:"ceylon.time",nm:"Period"},ps:[[{$t:{pk:"$",l:[{pk:"ceylon.time.timezone.model",nm:"AtTime"},{pk:".",nm:"Signal"}],nm:"Tuple"},mt:"prm",nm:"signedTime"}]],mt:"m",an:{doc:["Transform time in Period \n\nP.S.: This is a good case to add this feature to Time. something like:\n      time(1,0).period"]},nm:"toPeriod"},parseOnDayToken:{$t:{pk:"$",l:[{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone.model",nm:"DayOfMonth"}]},{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.base",nm:"DayOfWeek"}]},{md:"$",pk:"$",nm:"Comparison"}],nm:"Tuple"},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],mt:"m",nm:"parseOnDayToken"},parseZoneRule:{$t:{pk:"ceylon.time.timezone.model",nm:"ZoneRule"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],mt:"m",nm:"parseZoneRule"},parseLinkLine:{$t:{pk:"ceylon.time.timezone.model",nm:"Link"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"line"}]],mt:"m",nm:"parseLinkLine"},parseTime:{$t:{pk:"$",l:[{pk:"ceylon.time.timezone.model",nm:"AtTime"},{pk:".",nm:"Signal"}],nm:"Tuple"},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"atTime"}]],mt:"m",nm:"parseTime"},atTimeDefinition:{$t:{pk:"ceylon.time.timezone.model",nm:"AtTime"},ps:[[{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"},{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"token"}]],mt:"m",nm:"atTimeDefinition"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"]},RuleName:{pa:1,$alias:{md:"$",pk:"$",nm:"String"},mt:"als",an:{doc:["Parse current token using http:\/\/www.cstdbill.com\/tzdb\/tz-how-to.html \ncolumns as reference"]},nm:"RuleName"}},"$mod-version":"1.2.0","$mod-deps":["ceylon.language\/1.2.0","ceylon.collection\/1.2.0"],"ceylon.time.iso8601":{parseTimeComponents:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{$t:{md:"$",pk:"$",nm:"Integer"},count:4,pk:"$",nm:"Tuple"}]},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],mt:"m",$m:{calculateFraction$k42vha:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Null"}]},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"magnitude"},{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"fractionPart"}]],mt:"m",nm:"calculateFraction"},parseMilliseconds$4qjv03:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{md:"$",pk:"$",nm:"Null"}]},ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"fractionPart"}]],mt:"m",nm:"parseMilliseconds"}},nm:"parseTimeComponents"},parseDateTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"DateTime"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],mt:"m",an:{see:["parseDate","parseTime"],doc:["The [[DateTime]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) datetime format \nor `null` if the string does not contain valid ISO 8601 formatted \ndatetime value or the datetime is not formatted according to ISO standard."]},nm:"parseDateTime"},"$pkg-pa":1,parseDate:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Date"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],mt:"m",an:{doc:["The [[Date]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) date format \nor `null` if the string does not contain valid ISO 8601 formatted \ndate value or the date is not formatted according to ISO standard.\n\nMore specifically, this method parses any input that conforms to any of the \nfollowing date formats:\n\n- `YYYY-MM-DD` or `YYYYMMDD`\n- `YYYY-Www-D` or `YYYYWwwD`\n- `YYYY-DDD`   or `YYYYDDD`\n \n \nWhere: `YYYY` stands for a full (four digit) year number,\n`MM` is a number of a month of year (ranging from `01` for January to `12` for December),\n`DD` is a number of a day of month (ranging from `01` to `31`),\n`Www` stands for a single uppercase character `'W'` followed by two digit number of a week (ranging from `01` to `53`)\nand `D` stands for a single digit day of week.\n\n**Note:** This function accepts only four digit full year date formats. \nThere is no support for abbreviated 2 digit format or year values larger than 4 digits.\n"]},nm:"parseDate"},parsePeriod:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Period"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",nm:"parsePeriod"},parseZoneDateTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone",nm:"ZoneDateTime"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],mt:"m",an:{see:["parseDate","parseTime","parseTimeZone"],doc:["The [[ZoneDateTime]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) zoned datetime \nformat or `null` if the string does not contain valid ISO 8601 formatted \nzoned datetime value or the datetime is not formatted according to ISO \nstandard."]},nm:"parseZoneDateTime"},parseTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Time"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"input"}]],mt:"m",an:{doc:["The [[Time]] value of the given [[string representation|String]] \nof a [ISO 8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) date format \nor `null` if the string does not contain valid ISO 8601 formatted \ndate value or the date is not formatted according to ISO standard.\n\nMore specifically, this method parses any input that conforms to any \nof the following date formats:\n\n- `hh:mm:ss.sss` (or `hhmmss.sss`),\n- `hh:mm:ss` (or `hhmmss`),\n- `hh:mm` (or `hhmm`)\n- and `hh`\n\nWhere `hh` stands for 2 digit 24 hour clock hour value between \n`00` and `24` (where `24` is only used to denote midnight at the \nend of a calendar day)\n\n"]},nm:"parseTime"},"$pkg-anns":{by:["Roland Tepp"],doc:["This package contains parsers implementations for reading [[ceylon.time::Date]], \n[[ceylon.time::Time]], [[ceylon.time::DateTime]], [[ceylon.time.timezone::TimeZone]], and\n[[ceylon.time.timezone::ZoneDateTime]] values from their [ISO 8601][1] formatted string \nrepresentations.\n\nThe parser functions are [[parseDate]], [[parseTime]], [[parseDateTime]], [[parseTimeZone]],\nand [[parseZoneDateTime]].\n\nThis package only contains parsers for reading `Date`, `Time`, `DateTime` and `Period` values from their \n[[string representation|String]] forms. There are no formatters in this package, as all relevant types return \nISO 8601 formatted values as their `string` attribute.\n\nIf you need more flexible, locale aware parsing and formatting facilities, look into `ceylon.locale` package.\n\n[1]: https:\/\/en.wikipedia.org\/wiki\/ISO_8601"]},parseTimeZone:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone",nm:"TimeZone"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"offset"}]],mt:"m",$m:{offsetTimeZone$mf7brt:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time.timezone",nm:"OffsetTimeZone"}]},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hh"},{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"mm"}]],mt:"m",nm:"offsetTimeZone"}},an:{doc:["Timezone offset parser based on ISO-8601, currently it accepts the following \ntime zone offset patterns:\n\n- &plusmn;`[hh]:[mm]`,\n- &plusmn;`[hh][mm]`, and \n- &plusmn;`[hh]`.\n\nIn addition, the special code `Z` is recognized as a shorthand for `+00:00`"]},nm:"parseTimeZone"},createDateTime:{$t:{pk:"ceylon.time",nm:"DateTime"},ps:[[{$t:{pk:"ceylon.time",nm:"Date"},mt:"prm",nm:"date"},{$t:{pk:"ceylon.time",nm:"Time"},mt:"prm",nm:"time"}]],mt:"m",nm:"createDateTime"},convertToTime:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:"ceylon.time",nm:"Time"}]},pa:1,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{$t:{md:"$",pk:"$",nm:"Integer"},count:4,pk:"$",nm:"Tuple"}]},mt:"prm",nm:"timeComponents"}]],mt:"m",nm:"convertToTime"}},"$mod-anns":{by:["Diego Coronel","Roland Tepp"],doc:["Date and Time library for Ceylon language SDK.\n\nThis library is loosely modeled\/inspired by the JodaTime\/JSR-310 date\/time library.\n"]},"$mod-name":"ceylon.time","ceylon.time.base":{milliseconds:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"UnitOfMillisecond"}],mt:"o",$at:{perSecond:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of milliseconds per second."]},nm:"perSecond"},perHour:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Number of milliseconds per hour."]},nm:"perHour"},perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Number of milliseconds per day."]},nm:"perDay"},perMinute:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Milliseconds per minute."]},nm:"perMinute"}},an:{doc:["Common properties of _millisecond_ time unit."]},nm:"milliseconds"},november:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["November. The eleventh month of a gregorian calendar system."]},nm:"november"},ReadableInstant:{pa:1,mt:"i",$at:{millisecondsOfEpoch:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Internal value of an instant as a number of milliseconds \nsince beginning of an _epoch_ (january 1st 1970 UTC)"]},nm:"millisecondsOfEpoch"}},an:{see:["Instant"],doc:["An abstraction for data that can represent an instant of time."]},nm:"ReadableInstant"},UnitOfTime:{pa:1,mt:"i",of:[{pk:".",nm:"UnitOfHour"},{pk:".",nm:"UnitOfMinute"},{pk:".",nm:"UnitOfSecond"},{pk:".",nm:"UnitOfMillisecond"}],an:{doc:["Represents units of Time"]},nm:"UnitOfTime"},UnitOfMonth:{pa:1,sts:[{pk:".",nm:"UnitOfDate"}],mt:"i",nm:"UnitOfMonth"},april:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["April. The fourth month of a gregorian calendar system."]},nm:"april"},years:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"UnitOfYear"}],mt:"o",$at:{maximum:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["The maximum supported year for instances of `Date`, 999,999,999."]},nm:"maximum"},minimum:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["The minimum supported year for instances of `Date`, -283_457."]},nm:"minimum"}},an:{doc:["Common properties and constraints of _year_ unit."]},nm:"years"},Month:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Month"}],nm:"Ordinal"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Month"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Month"}],nm:"Enumerable"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:{doc:["Ordinal number of the month of year.\nWhere:\n\n   january  = 1\n\n   february = 2\n\n   ...\n\n   december = 12"]},nm:"integer",$hdn:1}],mt:"c",of:[{pk:".",nm:"january"},{pk:".",nm:"february"},{pk:".",nm:"march"},{pk:".",nm:"april"},{pk:".",nm:"may"},{pk:".",nm:"june"},{pk:".",nm:"july"},{pk:".",nm:"august"},{pk:".",nm:"september"},{pk:".",nm:"october"},{pk:".",nm:"november"},{pk:".",nm:"december"}],$at:{integer:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Ordinal number of the month of year.\nWhere:\n\n   january  = 1\n\n   february = 2\n\n   ...\n\n   december = 12"]},nm:"integer"}},$m:{add:{$t:{pk:".",nm:"Month.Overflow"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"numberOfMonths"}]],mt:"m",an:{doc:["Adds number of months to this month and returns the result of \nas new month value and number of times the operation overflowed."]},nm:"add"},minusMonths:{$t:{pk:".",nm:"Month"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],mt:"m",an:{doc:["Returns month of year that comes specified number of months before this month."]},nm:"minusMonths"},firstDayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:9,ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],mt:"m",an:{doc:["Returns the _day of year_ value for first of this month."]},nm:"firstDayOfYear"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Compares ordinal numbers of two instances of `Month`."]},nm:"compare"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the offset of the other _month_ compared to this.\n\nThis will always return positive integer such that given any\ntwo months `a` and `b`, the following is always true:\n\n   assert(0 <= a.offset(b) <= 11);\n"]},nm:"offset"},plusMonths:{$t:{pk:".",nm:"Month"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],mt:"m",an:{doc:["Returns month of year that comes specified number of months after this month."]},nm:"plusMonths"},neighbour:{$t:{pk:".",nm:"Month"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",an:{doc:["returns `n`-th neighbour of this _day of week_.\n\nFor example:\n\n    assert(january.neighbour(0)  == january);\n    assert(january.neighbour(1)  == february);\n    assert(january.neighbour(-1) == december);\n"]},nm:"neighbour"},numberOfDays:{$t:{md:"$",pk:"$",nm:"Integer"},pa:9,ps:[[{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],mt:"m",an:{doc:["Returns number of days in this month."]},nm:"numberOfDays"}},an:{doc:["A month in a Gregorian or Julian calendar system."]},nm:"Month",$c:{Overflow:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,ps:[{$t:{pk:".",nm:"Month"},pa:1,mt:"prm",an:{doc:["New month value."]},nm:"month",$hdn:1},{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:{doc:["Number of years overflowed by calculation."]},nm:"years",$hdn:1}],mt:"c",$at:{month:{$t:{pk:".",nm:"Month"},pa:1,mt:"a",an:{doc:["New month value."]},nm:"month"},years:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of years overflowed by calculation."]},nm:"years"}},an:{doc:["A result of adding or subtracting a month to another amount."]},nm:"Overflow"}}},seconds:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"UnitOfSecond"}],mt:"o",$at:{perHour:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Number of seconds per hour."]},nm:"perHour"},perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Number of seconds per day."]},nm:"perDay"},perMinute:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of seconds per minute."]},nm:"perMinute"}},an:{doc:["Common properties of _second_ time unit."]},nm:"seconds"},ReadableDatePeriod:{pa:1,mt:"i",$at:{months:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The number of months."]},nm:"months"},days:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The number of days."]},nm:"days"},years:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The number of years."]},nm:"years"}},an:{doc:["A period of _days_, _months_ and _years_."]},nm:"ReadableDatePeriod"},UnitOfSecond:{pa:1,sts:[{pk:".",nm:"UnitOfTime"}],mt:"i",nm:"UnitOfSecond"},UnitOfHour:{pa:1,sts:[{pk:".",nm:"UnitOfTime"}],mt:"i",nm:"UnitOfHour"},TimeBehavior:{st:"Element",pa:1,mt:"i",of:[{nm:"Element"}],$m:{minusMinutes:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of minutes subtracted."]},nm:"minusMinutes"},withMinutes:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of minutes."]},nm:"withMinutes"},plusHours:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of hours added."]},nm:"plusHours"},minusMilliseconds:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of milliseconds subtracted."]},nm:"minusMilliseconds"},plusMilliseconds:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of milliseconds added."]},nm:"plusMilliseconds"},minusHours:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of hours subtracted."]},nm:"minusHours"},plusSeconds:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of seconds added."]},nm:"plusSeconds"},withHours:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of hours.\n\nResult must be a valid time of day."]},nm:"withHours"},withSeconds:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of seconds."]},nm:"withSeconds"},plusMinutes:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of minutes added."]},nm:"plusMinutes"},minusSeconds:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of seconds subtracted."]},nm:"minusSeconds"},withMilliseconds:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of milliseconds."]},nm:"withMilliseconds"}},tp:[{sts:[{pk:".",nm:"ReadableTime"}],nm:"Element"}],an:{doc:["Common behavior for the types that represent time."]},nm:"TimeBehavior"},UnitOfMillisecond:{pa:1,sts:[{pk:".",nm:"UnitOfTime"}],mt:"i",nm:"UnitOfMillisecond"},months:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"UnitOfMonth"}],mt:"o",$at:{all:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"Month"}],nm:"Sequential"},pa:1,mt:"a",an:{doc:["Ordered list of all months of Gregorian and Julian calendar system from January to December."]},nm:"all"},perYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of months per year."]},nm:"perYear"}},an:{doc:["Common properties and constraints of months."]},nm:"months"},"$pkg-pa":1,august:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["August. The eighth month of a gregorian calendar system."]},nm:"august"},minutes:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"UnitOfMinute"}],mt:"o",$at:{perHour:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of minutes per hour."]},nm:"perHour"},perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Number of minutes per day."]},nm:"perDay"}},an:{doc:["Common properties of _minute_ time unit."]},nm:"minutes"},weekdays:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DayOfWeek"}],nm:"Sequential"},pa:1,mt:"a",an:{doc:["List of all available weekdays."]},nm:"weekdays"},july:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["July. The seventh month of a gregorian calendar system."]},nm:"july"},Range:{pa:1,sts:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"Element"},{mt:"tp",md:"$",pk:"$",nm:"Null"}],nm:"Iterable"}],mt:"i",$at:{duration:{$t:{pk:"ceylon.time",nm:"Duration"},pa:5,mt:"a",an:{doc:["Returns the Duration between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 86400000 milliseconds.\n\nGiven: tomorrow().to(today).duration then duration is -86400000 milliseconds."]},nm:"duration"},period:{$t:{pk:"ceylon.time",nm:"Period"},pa:5,mt:"a",an:{doc:["Returns the Period between _from_ and _to_ fields.\n\nExample: \n\nGiven: today().to(tomorrow).duration then duration is 1 day.\n\nGiven: tomorrow().to(today).duration then duration is -1 day."]},nm:"period"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:11,mt:"g",an:{doc:["Returns ISO-8601 formatted String representation of this Range.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/ISO_8601#Time_intervals"]},nm:"string"},from:{$t:{nm:"Element"},pa:5,mt:"a",an:{doc:["The first Element returned by the iterator, if any.\nThis should always produce the same value as\n`iterable.iterator().head`.\nIt also represents the _caller_ that created the Range:\n\nExample: today().to(tomorrow) -> in this case today() is the caller\/creator of the range."]},nm:"from"},step:{$t:{comp:"u",l:[{pk:".",nm:"UnitOfDate"},{pk:".",nm:"UnitOfTime"}]},pa:5,mt:"a",an:{doc:["Customized way to iterate over each element, it does not interfer in _from_\nand _to_ fields, but it does not guarantee that _to_ will be included in iterator."]},nm:"step"},to:{$t:{nm:"Element"},pa:5,mt:"a",an:{doc:["The limit of the Range where. \n\nExample:\n\nGiven: today().to(tomorrow) then tomorrow is the _to_ element.\n\nGiven: tomorrow.to(today()) then today() is the _to_ element."]},nm:"to"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,mt:"g",an:{doc:["This implementation respect the constraint that if `x==y` then `x.hash==y.hash`."]},nm:"hash"}},$m:{overlap:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"StepBy"}],nm:"Range"},{md:"$",pk:"$",nm:"Empty"}]},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"StepBy"}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A]\n- The precision is based on the lowest unit\n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB < CD\n\n    [1..6] overlap [3..9] = [3,6]\n\n    [1..6] overlap [9..3] = [3,6]\n\n    [6..1] overlap [3..9] = [3,6]\n\n    [6..1] overlap [9..3] = [3,6]\n\n\n\nGiven: [A..B] overlap [C..D]\n \nWhen: AB > CD\n\n    [3..9] overlap [1..6] = [3,6]\n\n    [3..9] overlap [6..1] = [3,6]\n\n    [9..3] overlap [1..6] = [3,6]\n\n    [9..3] overlap [6..1] = [3,6]"]},nm:"overlap"},gap:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"StepBy"}],nm:"Range"},{md:"$",pk:"$",nm:"Empty"}]},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"StepBy"}],nm:"Range"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns empty or a new Range:\n- Each Range is considered a _set_ then [A..B] is equivalent to [B..A] \n- The precision is based on the lowest unit \n- When the new Range exists it will follow these rules:\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB < CD\n\n    [1..2] gap [5..6] = (2,5)\n\n    [1..2] gap [6..5] = (2,5)\n\n    [2..1] gap [5..6] = (2,5)\n\n    [2..1] gap [6..5] = (2,5)\n\n\n\nGiven: [A..B] gap [C..D]\n \nWhen: AB > CD\n\n    [5..6] gap [1..2] = (2,5)\n\n    [5..6] gap [2..1] = (2,5)\n\n    [6..5] gap [1..2] = (2,5)\n\n    [6..5] gap [2..1] = (2,5)"]},nm:"gap"},equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:11,ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns true if both: this and other are same type and have equal fields _from_ and _to_."]},nm:"equals"},stepBy:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"StepBy"}],nm:"Range"},pa:5,ps:[[{$t:{nm:"StepBy"},mt:"prm",nm:"step"}]],mt:"m",an:{doc:["Define how this Range will get next or previous element while iterating."]},nm:"stepBy"}},tp:[{sts:[{md:"$",pk:"$",tp:[{mt:"tp",nm:"Element"}],nm:"Enumerable"}],nm:"Element"},{nm:"StepBy"}],an:{doc:["An interface to represent a Range between same kinds of _Date_ or _DateTime_ or _Time_."]},nm:"Range"},sunday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["_Sunday_ is the day of the week that follows Saturday and precedes Monday."]},nm:"sunday"},PeriodBehavior:{st:"Self",pa:1,mt:"i",of:[{nm:"Self"}],$m:{withMonths:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"month"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of months."]},nm:"withMonths"},minusYears:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of years subtracted."]},nm:"minusYears"},withMinutes:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of minutes."]},nm:"withMinutes"},plusHours:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of hours added."]},nm:"plusHours"},minusMilliseconds:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of milliseconds subtracted."]},nm:"minusMilliseconds"},plusMonths:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of months added."]},nm:"plusMonths"},minusHours:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of hours subtracted."]},nm:"minusHours"},normalized:{$t:{pk:".",tp:[{mt:"tp",nm:"Self"}],nm:"PeriodBehavior"},pa:5,mt:"m",an:{doc:["Returns a copy of this period with all amounts normalized to the \nstandard ranges for date-time fields.\n\nTwo normalizations occur, one for years and months, and one for\nhours, minutes, seconds and nanoseconds.\n\nDays are not normalized, as a day may vary in length at daylight savings cutover.\n\nNeither is days normalized into months, as number of days per month varies from \nmonth to another and depending on the leap year."]},nm:"normalized"},plusYears:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of years added."]},nm:"plusYears"},withHours:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"hours"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of hours."]},nm:"withHours"},withSeconds:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of seconds."]},nm:"withSeconds"},plusMinutes:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of minutes added."]},nm:"plusMinutes"},minusDays:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of days subtracted."]},nm:"minusDays"},plusDays:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of days added."]},nm:"plusDays"},minusMonths:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of months subtracted."]},nm:"minusMonths"},minusMinutes:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"minutes"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of minutes subtracted."]},nm:"minusMinutes"},plusMilliseconds:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of milliseconds added."]},nm:"plusMilliseconds"},plusSeconds:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of seconds added."]},nm:"plusSeconds"},withYears:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of years."]},nm:"withYears"},withDays:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"daysOfMonth"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of days."]},nm:"withDays"},minusSeconds:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"seconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of seconds subtracted."]},nm:"minusSeconds"},withMilliseconds:{$t:{nm:"Self"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"milliseconds"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified amount of milliseconds."]},nm:"withMilliseconds"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Self"}],nm:"PeriodBehavior"},{pk:".",nm:"ReadablePeriod"}],nm:"Self"}],an:{doc:["Common behavior of objects representing a period."]},nm:"PeriodBehavior"},october:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["October. The tenth month of a gregorian calendar system."]},nm:"october"},ReadableDuration:{pa:1,mt:"i",$at:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of milliseconds."]},nm:"milliseconds"}},an:{see:["Duration"],doc:["An abstraction of data representing a specific duration of time.\n\nA duration is a fixed delta of time between two instants \nmeasured in number of milliseconds."]},nm:"ReadableDuration"},saturday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["_Saturday_ is the day of the week that follows Friday and precedes Sunday."]},nm:"saturday"},monthOf:{$t:{pk:".",nm:"Month"},pa:1,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"Month"}]},mt:"prm",nm:"month"}]],mt:"m",an:{doc:["Returns month of year specified by the input argument.\n\nIf input is an Integer, this method returns a month according to the integer \nvalue of the [[Month]] (i.e. 1=[[january]], 2=[[february]], ... 12=[[december]])\nAny invalid values will throw an [[AssertionError]].\n\nIf the input value is a [[Month]], the input value is returned as is."]},nm:"monthOf"},ReadableDateTime:{pa:1,sts:[{pk:".",nm:"ReadableDate"},{pk:".",nm:"ReadableTime"}],mt:"i",an:{doc:["Common interface that can represent particular time of day on a specific date."]},nm:"ReadableDateTime"},DateBehavior:{st:"Element",pa:1,mt:"i",of:[{nm:"Element"}],$m:{withDayOfWeek:{$t:{nm:"Element"},pa:5,ps:[[{$t:{pk:".",nm:"DayOfWeek"},mt:"prm",nm:"dayOfWeek"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified day of week."]},nm:"withDayOfWeek"},minusYears:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of years subtracted."]},nm:"minusYears"},plusMonths:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of months added."]},nm:"plusMonths"},plusYears:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"years"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of years added."]},nm:"plusYears"},minusWeeks:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of weeks subtracted."]},nm:"minusWeeks"},withDayOfYear:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfYear"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified day of year."]},nm:"withDayOfYear"},withYear:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"year"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified year."]},nm:"withYear"},minusDays:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of days subtracted."]},nm:"minusDays"},plusDays:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"days"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of days added."]},nm:"plusDays"},minusMonths:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"months"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of months subtracted."]},nm:"minusMonths"},withDay:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"dayOfMonth"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified day of month."]},nm:"withDay"},withWeekOfYear:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weekNumber"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified week of year."]},nm:"withWeekOfYear"},plusWeeks:{$t:{nm:"Element"},pa:5,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"weeks"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified number of weeks added."]},nm:"plusWeeks"},withMonth:{$t:{nm:"Element"},pa:5,ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"month"}]],mt:"m",an:{doc:["Returns a copy of this period with the specified month of year."]},nm:"withMonth"}},tp:[{sts:[{pk:".",nm:"ReadableDate"}],nm:"Element"}],an:{doc:["Common behavior for date types."]},nm:"DateBehavior"},parseDayOfWeek:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"DayOfWeek"}]},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"dayOfWeek"}]],mt:"m",an:{doc:["Parses a string into a DayOfWeek.\n\nExpected inputs and outputs are:\n* \"sunday\"    results in [[sunday]]\n* \"monday\"    results in [[monday]]\n* \"tuesday\"   results in [[tuesday]]\n* \"wednesday\" results in [[wednesday]]\n* \"thursday\"  results in [[thursday]]\n* \"friday\"    results in [[friday]]\n* \"saturday\"  results in [[saturday]]"]},nm:"parseDayOfWeek"},dayOfWeek:{$t:{pk:".",nm:"DayOfWeek"},pa:1,ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Integer"},{pk:".",nm:"DayOfWeek"}]},mt:"prm",nm:"dayOfWeek"}]],mt:"m",an:{doc:["Returns [[DayOfWeek]] from the input."]},nm:"dayOfWeek"},september:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["September. The ninth month of a gregorian calendar system."]},nm:"september"},wednesday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["_Wednesday_ is the day of the week that follows Tuesday and precedes Thursday."]},nm:"wednesday"},friday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["_Friday_ is the day of the week that follows Thursday and precedes Saturday."]},nm:"friday"},december:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["December. The twelfth (last) month of a gregorian calendar system."]},nm:"december"},ReadableTime:{pa:1,mt:"i",$at:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of milliseconds since last second."]},nm:"milliseconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Hour of day."]},nm:"hours"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of seconds since last minute."]},nm:"seconds"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of minutes since last full hour."]},nm:"minutes"},secondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of seconds since the beginning of the day."]},nm:"secondsOfDay"},millisecondsOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of milliseconds since the beginning of the day."]},nm:"millisecondsOfDay"},minutesOfDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of minutes since the beginning of the day."]},nm:"minutesOfDay"}},an:{see:["Time","DateTime","ZoneDateTime"],doc:["Common interface capable of representing _time of day_."]},nm:"ReadableTime"},ReadableTimePeriod:{pa:1,mt:"i",$at:{milliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The number of milliseconds"]},nm:"milliseconds"},hours:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The number of hours"]},nm:"hours"},seconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The number of seconds"]},nm:"seconds"},minutes:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The number of minutes"]},nm:"minutes"}},an:{doc:["A period of _hours_, _minutes_, _seconds_ and _milliseconds_."]},nm:"ReadableTimePeriod"},monday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["_Monday_ is the day of the week that follows Sunday and precedes Tuesday."]},nm:"monday"},DayOfWeek:{super:{md:"$",pk:"$",nm:"Basic"},pa:257,sts:[{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DayOfWeek"}],nm:"Ordinal"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DayOfWeek"}],nm:"Comparable"},{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DayOfWeek"}],nm:"Enumerable"}],ps:[{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"prm",an:{doc:["Numeric value of the DayOfWeek."]},nm:"integer",$hdn:1}],mt:"c",of:[{pk:".",nm:"monday"},{pk:".",nm:"tuesday"},{pk:".",nm:"wednesday"},{pk:".",nm:"thursday"},{pk:".",nm:"friday"},{pk:".",nm:"saturday"},{pk:".",nm:"sunday"}],$at:{integer:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Numeric value of the DayOfWeek."]},nm:"integer"}},$m:{plusDays:{$t:{pk:".",nm:"DayOfWeek"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],mt:"m",an:{doc:["Returns a day of week that comes specified number of days after this DayOfWeek."]},nm:"plusDays"},compare:{$t:{md:"$",pk:"$",nm:"Comparison"},pa:3,ps:[[{$t:{pk:".",nm:"DayOfWeek"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Compare days of week."]},nm:"compare"},offset:{$t:{md:"$",pk:"$",nm:"Integer"},pa:11,ps:[[{$t:{pk:".",nm:"DayOfWeek"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the offset of the other _day of week_ compared to this.\n\nThis will always return positive integer such that given any\ntwo days of week `a` and `b`, the following is always true:\n\n    assert(0 <= a.offset(b) <= 6);\n"]},nm:"offset"},neighbour:{$t:{pk:".",nm:"DayOfWeek"},pa:3,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",an:{doc:["returns `n`-th neighbour of this _day of week_.\n\nFor example:\n\n    assert(sunday.neighbour(0)  == sunday);\n    assert(sunday.neighbour(1)  == monday);\n    assert(sunday.neighbour(-1) == saturday);\n"]},nm:"neighbour"},minusDays:{$t:{pk:".",nm:"DayOfWeek"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"number"}]],mt:"m",an:{doc:["Returns a day of week that comes number of days before this DayOfWeek."]},nm:"minusDays"}},an:{doc:["A day of week, such as 'tuesday'.\n\nThis class satisfies `Enumerable<DayOfWeek>`, which means that you can\ncreate ranges of days of week:\n\nE.g:\n    value week = monday..sunday;\n    value weekend = saturday..sunday;\n\nNote that ranges created this way are always in _increasing_ order, wrapping\nonce last day of week is reached. This means that when you create a range of `tuesday..monday`,\nthis is equivalent to the following sequence: `[tuesday, wednesday, thursday, friday, saturday, sunday, monday]`\n\nIn order to get the reverse order range, you can use either span operator:\n    value reverseDaysOfWeek = tuesday:-1;\n\nor explicitly reverse the order of the range like this:\n    calue reverseDaysOfWeek = (monday..tuesday).reverse();\n\n"]},nm:"DayOfWeek"},UnitOfDay:{pa:1,sts:[{pk:".",nm:"UnitOfDate"}],mt:"i",nm:"UnitOfDay"},hours:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"UnitOfHour"}],mt:"o",$at:{perDay:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of hours per day."]},nm:"perDay"}},an:{doc:["Common properties of _hour_ time unit."]},nm:"hours"},may:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["May. The fifth month of a gregorian calendar system."]},nm:"may"},february:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["February. The second month of a gregorian calendar system."]},nm:"february"},firstDayOfMonth:{$t:{md:"$",pk:"$",tp:[{mt:"tp",md:"$",pk:"$",nm:"Integer"}],nm:"Sequential"},mt:"a",an:{doc:["Table of _day of year_ values for the first day of each month."]},nm:"firstDayOfMonth"},thursday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["_Thursday_ is the day of the week that follows Wednesday and precedes Friday."]},nm:"thursday"},UnitOfDate:{pa:1,mt:"i",of:[{pk:".",nm:"UnitOfYear"},{pk:".",nm:"UnitOfMonth"},{pk:".",nm:"UnitOfDay"}],an:{doc:["Represents units of Date"]},nm:"UnitOfDate"},march:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["March. The third month of a gregorian calendar system."]},nm:"march"},tuesday:{super:{pk:".",nm:"DayOfWeek"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"DayOfWeek"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["_Tuesday_ is the day of the week that follows Monday and precedes Wednesday."]},nm:"tuesday"},june:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["June. The sixth month of a gregorian calendar system."]},nm:"june"},UnitOfMinute:{pa:1,sts:[{pk:".",nm:"UnitOfTime"}],mt:"i",nm:"UnitOfMinute"},DateTimeBehavior:{st:"Element",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"DateBehavior"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"TimeBehavior"}],mt:"i",of:[{nm:"Element"}],$at:{date:{$t:{nm:"DateType"},pa:5,mt:"a",an:{doc:["Returns Date portion of this [[DateTime]] value."]},nm:"date"},time:{$t:{nm:"TimeType"},pa:5,mt:"a",an:{doc:["Returns Time portion of this [[DateTime]] value."]},nm:"time"}},tp:[{sts:[{pk:".",nm:"ReadableDateTime"}],nm:"Element"},{dv:"out",sts:[{pk:".",nm:"ReadableDate"}],nm:"DateType"},{dv:"out",sts:[{pk:".",nm:"ReadableTime"}],nm:"TimeType"}],an:{see:["DateTime","ReadableDateTime","ReadableDate","ReadableTime"],doc:["Common behavior of the [[DateTime]] types."]},nm:"DateTimeBehavior"},january:{super:{pk:".",nm:"Month"},pa:1,mt:"o",$at:{successor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"successor"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},predecessor:{$t:{pk:".",nm:"Month"},pa:3,mt:"g",nm:"predecessor"}},an:{doc:["January. The first month of a gregorian calendar system."]},nm:"january"},ReadablePeriod:{pa:1,sts:[{pk:".",nm:"ReadableDatePeriod"},{pk:".",nm:"ReadableTimePeriod"}],mt:"i",$at:{dateOnly:{$t:{pk:".",nm:"ReadableDatePeriod"},pa:5,mt:"a",an:{doc:["Returns a truncated view of this period that only contains number of \n_years_, _months_ and _days_."]},nm:"dateOnly"},timeOnly:{$t:{pk:".",nm:"ReadableTimePeriod"},pa:5,mt:"a",an:{doc:["Returns a truncated view of this period that only contains number of \n_hours_, _minutes_, _seconds_ and _milliseconds_."]},nm:"timeOnly"}},an:{doc:["A Period of time represented as number of _years_, _months_, _days_, \n_hours_, _minutes_, _seconds_ and\/or _milliseconds_."]},nm:"ReadablePeriod"},UnitOfYear:{pa:1,sts:[{pk:".",nm:"UnitOfDate"}],mt:"i",nm:"UnitOfYear"},days:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"UnitOfDay"}],mt:"o",$at:{perFourCenturies:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["The number of days in a 400 year cycle."]},nm:"perFourCenturies"},inFourYears:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of days in four years."]},nm:"inFourYears"},perCentury:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of of per century (100 years)."]},nm:"perCentury"},perWeek:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["Number of days per week (7)."]},nm:"perWeek"},perCycle:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"a",an:{doc:["The number of days in a 400 year cycle."]},nm:"perCycle"},perLeapYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Number of days per leap year."]},nm:"perLeapYear"},perYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,mt:"g",an:{doc:["Number of days per normal year."]},nm:"perYear"},ofWeek:{$t:{md:"$",pk:"$",tp:[{mt:"tp",pk:".",nm:"DayOfWeek"}],nm:"Sequential"},pa:1,mt:"a",nm:"ofWeek"}},$m:{perMonth:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],mt:"m",an:{doc:["Returns the number of days per month."]},nm:"perMonth"},toMonth:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{pk:".",nm:"Month"},mt:"prm",nm:"month"},{$t:{md:"$",pk:"$",nm:"Boolean"},def:1,mt:"prm",nm:"leapYear"}]],mt:"m",an:{doc:["Returns the number of days from the start of the year to the first of the month."]},nm:"toMonth"},fromMilliseconds:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1,ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"millisecondsIn"}]],mt:"m",an:{doc:["Returns number of days from the number of milliseconds."]},nm:"fromMilliseconds"}},an:{doc:["Common properties and constraints of _day_ unit."]},nm:"days"},"$pkg-anns":{by:["Diego Coronel","Roland Tepp"],doc:["Base classes and interfaces of the Date\/Time library."]},ReadableDate:{pa:1,mt:"i",$at:{dayOfWeek:{$t:{pk:".",nm:"DayOfWeek"},pa:5,mt:"a",an:{doc:["Day of the week."]},nm:"dayOfWeek"},weekOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of the week of the date."]},nm:"weekOfYear"},month:{$t:{pk:".",nm:"Month"},pa:5,mt:"a",an:{doc:["Month of the year value of the date."]},nm:"month"},dayOfEra:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of calendar days since ERA."]},nm:"dayOfEra"},year:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The year of the date."]},nm:"year"},dayOfYear:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Number of the day in year."]},nm:"dayOfYear"},leapYear:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the year of the date is a leap year."]},nm:"leapYear"},day:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["Day of month value of the date."]},nm:"day"}},an:{see:["Date","Time","DateTime","ZoneDateTime"],doc:["A common interface of all date like objects.\n\nThis interface is common to all data types that\neither partially or fully represent information \nthat can be interpreted as _date_."]},nm:"ReadableDate"}}};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
